<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>11ty-solid-base</title>
  <link rel="stylesheet" href="/11ty-solid-base/app/style-UUXDUJOW.min.css">
  <style></style>
  <script type="module" defer="" src="/11ty-solid-base/app/is-land-CMWCL4WF.min.js"></script>
</head>
<body>
  <header>
    <h1>11ty-solid-base</h1>
  </header>
  <main>
  <h2>Menu</h2>
<ul>
<li><a href="/11ty-solid-base/webc/">WebC</a></li>
</ul>
<menu></menu>
<h2>The counter</h2>
<p>To test if the island partial hydration is working; on a mobile phone, turn the phone to landscape view. This should swap the html for javascript to start the counter.</p>
<is-land on:media="(min-width: 30em)">
  <counter-component>
    <p>Count value is 0</p>
  </counter-component>
  <template data-island="replace">
    <p id="app"></p>
    <script type="module" src="/11ty-solid-base/app/undefined"></script>
  </template>
</is-land>
<h2>The shortcode</h2>
<p>The shortcode adds the js inline. Need to add import maps for this.</p>
<is-land on:media="(min-width: 30em)">
  <shortcode-component>
    <p>The solidify shortcode is inactive :)</p>
  </shortcode-component>
  <template data-island="replace">
    <p id="shorty"></p>
<script type="module">// node_modules/solid-js/dist/solid.js
var taskIdCounter = 1, isCallbackScheduled = false, isPerformingWork = false, taskQueue = [], currentTask = null, shouldYieldToHost = null, yieldInterval = 5, deadline = 0, maxYieldInterval = 300, scheduleCallback = null, scheduledCallback = null;
var maxSigned31BitInt = 1073741823;
function setupScheduler() {
  const channel = new MessageChannel(), port = channel.port2;
  scheduleCallback = () => port.postMessage(null);
  channel.port1.onmessage = () => {
    if (scheduledCallback !== null) {
      const currentTime = performance.now();
      deadline = currentTime + yieldInterval;
      const hasTimeRemaining = true;
      try {
        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);
        if (!hasMoreWork) {
          scheduledCallback = null;
        } else
          port.postMessage(null);
      } catch (error) {
        port.postMessage(null);
        throw error;
      }
    }
  };
  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {
    const scheduling = navigator.scheduling;
    shouldYieldToHost = () => {
      const currentTime = performance.now();
      if (currentTime >= deadline) {
        if (scheduling.isInputPending()) {
          return true;
        }
        return currentTime >= maxYieldInterval;
      } else {
        return false;
      }
    };
  } else {
    shouldYieldToHost = () => performance.now() >= deadline;
  }
}
function enqueue(taskQueue2, task) {
  function findIndex() {
    let m = 0;
    let n = taskQueue2.length - 1;
    while (m <= n) {
      const k2 = n + m >> 1;
      const cmp = task.expirationTime - taskQueue2[k2].expirationTime;
      if (cmp > 0)
        m = k2 + 1;
      else if (cmp < 0)
        n = k2 - 1;
      else
        return k2;
    }
    return m;
  }
  taskQueue2.splice(findIndex(), 0, task);
}
function requestCallback(fn, options) {
  if (!scheduleCallback)
    setupScheduler();
  let startTime = performance.now(), timeout = maxSigned31BitInt;
  if (options && options.timeout)
    timeout = options.timeout;
  const newTask = {
    id: taskIdCounter++,
    fn,
    startTime,
    expirationTime: startTime + timeout
  };
  enqueue(taskQueue, newTask);
  if (!isCallbackScheduled && !isPerformingWork) {
    isCallbackScheduled = true;
    scheduledCallback = flushWork;
    scheduleCallback();
  }
  return newTask;
}
function cancelCallback(task) {
  task.fn = null;
}
function flushWork(hasTimeRemaining, initialTime) {
  isCallbackScheduled = false;
  isPerformingWork = true;
  try {
    return workLoop(hasTimeRemaining, initialTime);
  } finally {
    currentTask = null;
    isPerformingWork = false;
  }
}
function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;
  currentTask = taskQueue[0] || null;
  while (currentTask !== null) {
    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
      break;
    }
    const callback = currentTask.fn;
    if (callback !== null) {
      currentTask.fn = null;
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      callback(didUserCallbackTimeout);
      currentTime = performance.now();
      if (currentTask === taskQueue[0]) {
        taskQueue.shift();
      }
    } else
      taskQueue.shift();
    currentTask = taskQueue[0] || null;
  }
  return currentTask !== null;
}
var sharedConfig = {
  context: void 0,
  registry: void 0
};
function setHydrateContext(context) {
  sharedConfig.context = context;
}
function nextHydrateContext() {
  return {
    ...sharedConfig.context,
    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,
    count: 0
  };
}
var equalFn = (a, b2) => a === b2;
var $PROXY = Symbol("solid-proxy");
var $TRACK = Symbol("solid-track");
var $DEVCOMP = Symbol("solid-dev-component");
var signalOptions = {
  equals: equalFn
};
var ERROR = null;
var runEffects = runQueue;
var STALE = 1;
var PENDING = 2;
var UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var NO_INIT = {};
var Owner = null;
var Transition = null;
var Scheduler = null;
var ExternalSourceFactory = null;
var Listener = null;
var Updates = null;
var Effects = null;
var ExecCount = 0;
var [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
function createRoot(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, root = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: null,
    owner: detachedOwner === void 0 ? owner : detachedOwner
  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  const setter = (value2) => {
    if (typeof value2 === "function") {
      if (Transition && Transition.running && Transition.sources.has(s))
        value2 = value2(s.tValue);
      else
        value2 = value2(s.value);
    }
    return writeSignal(s, value2);
  };
  return [readSignal.bind(s), setter];
}
function createComputed(fn, value, options) {
  const c = createComputation(fn, value, true, STALE);
  if (Scheduler && Transition && Transition.running)
    Updates.push(c);
  else
    updateComputation(c);
}
function createRenderEffect(fn, value, options) {
  const c = createComputation(fn, value, false, STALE);
  if (Scheduler && Transition && Transition.running)
    Updates.push(c);
  else
    updateComputation(c);
}
function createEffect(fn, value, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value, false, STALE), s = SuspenseContext && lookup(Owner, SuspenseContext.id);
  if (s)
    c.suspense = s;
  if (!options || !options.render)
    c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createReaction(onInvalidate, options) {
  let fn;
  const c = createComputation(() => {
    fn ? fn() : untrack(onInvalidate);
    fn = void 0;
  }, void 0, false, 0), s = SuspenseContext && lookup(Owner, SuspenseContext.id);
  if (s)
    c.suspense = s;
  c.user = true;
  return (tracking) => {
    fn = tracking;
    updateComputation(c);
  };
}
function createMemo(fn, value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn, value, true, 0);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || void 0;
  if (Scheduler && Transition && Transition.running) {
    c.tState = STALE;
    Updates.push(c);
  } else
    updateComputation(c);
  return readSignal.bind(c);
}
function createResource(pSource, pFetcher, pOptions) {
  let source;
  let fetcher;
  let options;
  if (arguments.length === 2 && typeof pFetcher === "object" || arguments.length === 1) {
    source = true;
    fetcher = pSource;
    options = pFetcher || {};
  } else {
    source = pSource;
    fetcher = pFetcher;
    options = pOptions || {};
  }
  let pr = null, initP = NO_INIT, id = null, loadedUnderTransition = false, scheduled = false, resolved = "initialValue" in options, dynamic = typeof source === "function" && createMemo(source);
  const contexts = /* @__PURE__ */ new Set(), [value, setValue] = (options.storage || createSignal)(options.initialValue), [error, setError] = createSignal(void 0), [track, trigger] = createSignal(void 0, {
    equals: false
  }), [state, setState] = createSignal(resolved ? "ready" : "unresolved");
  if (sharedConfig.context) {
    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;
    let v2;
    if (options.ssrLoadFrom === "initial")
      initP = options.initialValue;
    else if (sharedConfig.load && (v2 = sharedConfig.load(id)))
      initP = v2[0];
  }
  function loadEnd(p, v2, error2, key) {
    if (pr === p) {
      pr = null;
      key !== void 0 && (resolved = true);
      if ((p === initP || v2 === initP) && options.onHydrated)
        queueMicrotask(() => options.onHydrated(key, {
          value: v2
        }));
      initP = NO_INIT;
      if (Transition && p && loadedUnderTransition) {
        Transition.promises.delete(p);
        loadedUnderTransition = false;
        runUpdates(() => {
          Transition.running = true;
          completeLoad(v2, error2);
        }, false);
      } else
        completeLoad(v2, error2);
    }
    return v2;
  }
  function completeLoad(v2, err) {
    runUpdates(() => {
      if (err === void 0)
        setValue(() => v2);
      setState(err !== void 0 ? "errored" : resolved ? "ready" : "unresolved");
      setError(err);
      for (const c of contexts.keys())
        c.decrement();
      contexts.clear();
    }, false);
  }
  function read() {
    const c = SuspenseContext && lookup(Owner, SuspenseContext.id), v2 = value(), err = error();
    if (err !== void 0 && !pr)
      throw err;
    if (Listener && !Listener.user && c) {
      createComputed(() => {
        track();
        if (pr) {
          if (c.resolved && Transition && loadedUnderTransition)
            Transition.promises.add(pr);
          else if (!contexts.has(c)) {
            c.increment();
            contexts.add(c);
          }
        }
      });
    }
    return v2;
  }
  function load(refetching = true) {
    if (refetching !== false && scheduled)
      return;
    scheduled = false;
    const lookup2 = dynamic ? dynamic() : source;
    loadedUnderTransition = Transition && Transition.running;
    if (lookup2 == null || lookup2 === false) {
      loadEnd(pr, untrack(value));
      return;
    }
    if (Transition && pr)
      Transition.promises.delete(pr);
    const p = initP !== NO_INIT ? initP : untrack(() => fetcher(lookup2, {
      value: value(),
      refetching
    }));
    if (typeof p !== "object" || !(p && "then" in p)) {
      loadEnd(pr, p, void 0, lookup2);
      return p;
    }
    pr = p;
    scheduled = true;
    queueMicrotask(() => scheduled = false);
    runUpdates(() => {
      setState(resolved ? "refreshing" : "pending");
      trigger();
    }, false);
    return p.then((v2) => loadEnd(p, v2, void 0, lookup2), (e) => loadEnd(p, void 0, castError(e), lookup2));
  }
  Object.defineProperties(read, {
    state: {
      get: () => state()
    },
    error: {
      get: () => error()
    },
    loading: {
      get() {
        const s = state();
        return s === "pending" || s === "refreshing";
      }
    },
    latest: {
      get() {
        if (!resolved)
          return read();
        const err = error();
        if (err && !pr)
          throw err;
        return value();
      }
    }
  });
  if (dynamic)
    createComputed(() => load(false));
  else
    load(false);
  return [read, {
    refetch: load,
    mutate: setValue
  }];
}
function createDeferred(source, options) {
  let t, timeout = options ? options.timeoutMs : void 0;
  const node = createComputation(() => {
    if (!t || !t.fn)
      t = requestCallback(() => setDeferred(() => node.value), timeout !== void 0 ? {
        timeout
      } : void 0);
    return source();
  }, void 0, true);
  const [deferred, setDeferred] = createSignal(node.value, options);
  updateComputation(node);
  setDeferred(() => node.value);
  return deferred;
}
function createSelector(source, fn = equalFn, options) {
  const subs = /* @__PURE__ */ new Map();
  const node = createComputation((p) => {
    const v2 = source();
    for (const [key, val] of subs.entries())
      if (fn(key, v2) !== fn(key, p)) {
        for (const c of val.values()) {
          c.state = STALE;
          if (c.pure)
            Updates.push(c);
          else
            Effects.push(c);
        }
      }
    return v2;
  }, void 0, true, STALE);
  updateComputation(node);
  return (key) => {
    const listener = Listener;
    if (listener) {
      let l;
      if (l = subs.get(key))
        l.add(listener);
      else
        subs.set(key, l = /* @__PURE__ */ new Set([listener]));
      onCleanup(() => {
        l.delete(listener);
        !l.size && subs.delete(key);
      });
    }
    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
  };
}
function batch(fn) {
  return runUpdates(fn, false);
}
function untrack(fn) {
  if (Listener === null)
    return fn();
  const listener = Listener;
  Listener = null;
  try {
    return fn();
  } finally {
    Listener = listener;
  }
}
function on(deps, fn, options) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let defer = options && options.defer;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++)
        input[i] = deps[i]();
    } else
      input = deps();
    if (defer) {
      defer = false;
      return void 0;
    }
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null)
    ;
  else if (Owner.cleanups === null)
    Owner.cleanups = [fn];
  else
    Owner.cleanups.push(fn);
  return fn;
}
function catchError(fn, handler) {
  ERROR || (ERROR = Symbol("error"));
  Owner = createComputation(void 0, void 0, true);
  Owner.context = {
    [ERROR]: [handler]
  };
  if (Transition && Transition.running)
    Transition.sources.add(Owner);
  try {
    return fn();
  } catch (err) {
    handleError(err);
  } finally {
    Owner = Owner.owner;
  }
}
function onError(fn) {
  ERROR || (ERROR = Symbol("error"));
  if (Owner === null)
    ;
  else if (Owner.context === null)
    Owner.context = {
      [ERROR]: [fn]
    };
  else if (!Owner.context[ERROR])
    Owner.context[ERROR] = [fn];
  else
    Owner.context[ERROR].push(fn);
}
function getListener() {
  return Listener;
}
function getOwner() {
  return Owner;
}
function runWithOwner(o, fn) {
  const prev = Owner;
  const prevListener = Listener;
  Owner = o;
  Listener = null;
  try {
    return runUpdates(fn, true);
  } catch (err) {
    handleError(err);
  } finally {
    Owner = prev;
    Listener = prevListener;
  }
}
function enableScheduling(scheduler = requestCallback) {
  Scheduler = scheduler;
}
function startTransition(fn) {
  if (Transition && Transition.running) {
    fn();
    return Transition.done;
  }
  const l = Listener;
  const o = Owner;
  return Promise.resolve().then(() => {
    Listener = l;
    Owner = o;
    let t;
    if (Scheduler || SuspenseContext) {
      t = Transition || (Transition = {
        sources: /* @__PURE__ */ new Set(),
        effects: [],
        promises: /* @__PURE__ */ new Set(),
        disposed: /* @__PURE__ */ new Set(),
        queue: /* @__PURE__ */ new Set(),
        running: true
      });
      t.done || (t.done = new Promise((res) => t.resolve = res));
      t.running = true;
    }
    runUpdates(fn, false);
    Listener = Owner = null;
    return t ? t.done : void 0;
  });
}
function useTransition() {
  return [transPending, startTransition];
}
function resumeEffects(e) {
  Effects.push.apply(Effects, e);
  e.length = 0;
}
function createContext(defaultValue, options) {
  const id = Symbol("context");
  return {
    id,
    Provider: createProvider(id),
    defaultValue
  };
}
function useContext(context) {
  let ctx;
  return (ctx = lookup(Owner, context.id)) !== void 0 ? ctx : context.defaultValue;
}
function children(fn) {
  const children2 = createMemo(fn);
  const memo = createMemo(() => resolveChildren(children2()));
  memo.toArray = () => {
    const c = memo();
    return Array.isArray(c) ? c : c != null ? [c] : [];
  };
  return memo;
}
var SuspenseContext;
function getSuspenseContext() {
  return SuspenseContext || (SuspenseContext = createContext({}));
}
function enableExternalSource(factory) {
  if (ExternalSourceFactory) {
    const oldFactory = ExternalSourceFactory;
    ExternalSourceFactory = (fn, trigger) => {
      const oldSource = oldFactory(fn, trigger);
      const source = factory((x3) => oldSource.track(x3), trigger);
      return {
        track: (x3) => source.track(x3),
        dispose() {
          source.dispose();
          oldSource.dispose();
        }
      };
    };
  } else {
    ExternalSourceFactory = factory;
  }
}
function readSignal() {
  const runningTransition = Transition && Transition.running;
  if (this.sources && (runningTransition ? this.tState : this.state)) {
    if ((runningTransition ? this.tState : this.state) === STALE)
      updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  if (runningTransition && Transition.sources.has(this))
    return this.tValue;
  return this.value;
}
function writeSignal(node, value, isComp) {
  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
  if (!node.comparator || !node.comparator(current, value)) {
    if (Transition) {
      const TransitionRunning = Transition.running;
      if (TransitionRunning || !isComp && Transition.sources.has(node)) {
        Transition.sources.add(node);
        node.tValue = value;
      }
      if (!TransitionRunning)
        node.value = value;
    } else
      node.value = value;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node.observers.length; i += 1) {
          const o = node.observers[i];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o))
            continue;
          if (TransitionRunning ? !o.tState : !o.state) {
            if (o.pure)
              Updates.push(o);
            else
              Effects.push(o);
            if (o.observers)
              markDownstream(o);
          }
          if (!TransitionRunning)
            o.state = STALE;
          else
            o.tState = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (false)
            ;
          throw new Error();
        }
      }, false);
    }
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn)
    return;
  cleanNode(node);
  const owner = Owner, listener = Listener, time = ExecCount;
  Listener = Owner = node;
  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
  if (Transition && !Transition.running && Transition.sources.has(node)) {
    queueMicrotask(() => {
      runUpdates(() => {
        Transition && (Transition.running = true);
        Listener = Owner = node;
        runComputation(node, node.tValue, time);
        Listener = Owner = null;
      }, false);
    });
  }
  Listener = listener;
  Owner = owner;
}
function runComputation(node, value, time) {
  let nextValue;
  try {
    nextValue = node.fn(value);
  } catch (err) {
    if (node.pure) {
      if (Transition && Transition.running) {
        node.tState = STALE;
        node.tOwned && node.tOwned.forEach(cleanNode);
        node.tOwned = void 0;
      } else {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time + 1;
    return handleError(err);
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue, true);
    } else if (Transition && Transition.running && node.pure) {
      Transition.sources.add(node);
      node.tValue = nextValue;
    } else
      node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state = STALE, options) {
  const c = {
    fn,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: null,
    pure
  };
  if (Transition && Transition.running) {
    c.state = 0;
    c.tState = state;
  }
  if (Owner === null)
    ;
  else if (Owner !== UNOWNED) {
    if (Transition && Transition.running && Owner.pure) {
      if (!Owner.tOwned)
        Owner.tOwned = [c];
      else
        Owner.tOwned.push(c);
    } else {
      if (!Owner.owned)
        Owner.owned = [c];
      else
        Owner.owned.push(c);
    }
  }
  if (ExternalSourceFactory) {
    const [track, trigger] = createSignal(void 0, {
      equals: false
    });
    const ordinary = ExternalSourceFactory(c.fn, trigger);
    onCleanup(() => ordinary.dispose());
    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);
    c.fn = (x3) => {
      track();
      return Transition && Transition.running ? inTransition.track(x3) : ordinary.track(x3);
    };
  }
  return c;
}
function runTop(node) {
  const runningTransition = Transition && Transition.running;
  if ((runningTransition ? node.tState : node.state) === 0)
    return;
  if ((runningTransition ? node.tState : node.state) === PENDING)
    return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback))
    return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (runningTransition && Transition.disposed.has(node))
      return;
    if (runningTransition ? node.tState : node.state)
      ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node = ancestors[i];
    if (runningTransition) {
      let top = node, prev = ancestors[i + 1];
      while ((top = top.owner) && top !== prev) {
        if (Transition.disposed.has(top))
          return;
      }
    }
    if ((runningTransition ? node.tState : node.state) === STALE) {
      updateComputation(node);
    } else if ((runningTransition ? node.tState : node.state) === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates)
    return fn();
  let wait = false;
  if (!init)
    Updates = [];
  if (Effects)
    wait = true;
  else
    Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait)
      Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    if (Scheduler && Transition && Transition.running)
      scheduleQueue(Updates);
    else
      runQueue(Updates);
    Updates = null;
  }
  if (wait)
    return;
  let res;
  if (Transition) {
    if (!Transition.promises.size && !Transition.queue.size) {
      const sources = Transition.sources;
      const disposed = Transition.disposed;
      Effects.push.apply(Effects, Transition.effects);
      res = Transition.resolve;
      for (const e2 of Effects) {
        "tState" in e2 && (e2.state = e2.tState);
        delete e2.tState;
      }
      Transition = null;
      runUpdates(() => {
        for (const d2 of disposed)
          cleanNode(d2);
        for (const v2 of sources) {
          v2.value = v2.tValue;
          if (v2.owned) {
            for (let i = 0, len = v2.owned.length; i < len; i++)
              cleanNode(v2.owned[i]);
          }
          if (v2.tOwned)
            v2.owned = v2.tOwned;
          delete v2.tValue;
          delete v2.tOwned;
          v2.tState = 0;
        }
        setTransPending(false);
      }, false);
    } else if (Transition.running) {
      Transition.running = false;
      Transition.effects.push.apply(Transition.effects, Effects);
      Effects = null;
      setTransPending(true);
      return;
    }
  }
  const e = Effects;
  Effects = null;
  if (e.length)
    runUpdates(() => runEffects(e), false);
  if (res)
    res();
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++)
    runTop(queue[i]);
}
function scheduleQueue(queue) {
  for (let i = 0; i < queue.length; i++) {
    const item = queue[i];
    const tasks = Transition.queue;
    if (!tasks.has(item)) {
      tasks.add(item);
      Scheduler(() => {
        tasks.delete(item);
        runUpdates(() => {
          Transition.running = true;
          runTop(item);
        }, false);
        Transition && (Transition.running = false);
      });
    }
  }
}
function runUserEffects(queue) {
  let i, userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user)
      runTop(e);
    else
      queue[userLength++] = e;
  }
  if (sharedConfig.context)
    setHydrateContext();
  for (i = 0; i < userLength; i++)
    runTop(queue[i]);
}
function lookUpstream(node, ignore) {
  const runningTransition = Transition && Transition.running;
  if (runningTransition)
    node.tState = 0;
  else
    node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      const state = runningTransition ? source.tState : source.state;
      if (state === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
          runTop(source);
      } else if (state === PENDING)
        lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  const runningTransition = Transition && Transition.running;
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (runningTransition ? !o.tState : !o.state) {
      if (runningTransition)
        o.tState = PENDING;
      else
        o.state = PENDING;
      if (o.pure)
        Updates.push(o);
      else
        Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (Transition && Transition.running && node.pure) {
    if (node.tOwned) {
      for (i = node.tOwned.length - 1; i >= 0; i--)
        cleanNode(node.tOwned[i]);
      delete node.tOwned;
    }
    reset(node, true);
  } else if (node.owned) {
    for (i = node.owned.length - 1; i >= 0; i--)
      cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = node.cleanups.length - 1; i >= 0; i--)
      node.cleanups[i]();
    node.cleanups = null;
  }
  if (Transition && Transition.running)
    node.tState = 0;
  else
    node.state = 0;
  node.context = null;
}
function reset(node, top) {
  if (!top) {
    node.tState = 0;
    Transition.disposed.add(node);
  }
  if (node.owned) {
    for (let i = 0; i < node.owned.length; i++)
      reset(node.owned[i]);
  }
}
function castError(err) {
  if (err instanceof Error)
    return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function handleError(err, owner = Owner) {
  const fns = ERROR && lookup(owner, ERROR);
  const error = castError(err);
  if (!fns)
    throw error;
  if (Effects)
    Effects.push({
      fn() {
        try {
          for (const f of fns)
            f(error);
        } catch (e) {
          handleError(e, owner?.owner || null);
        }
      },
      state: STALE
    });
  else {
    try {
      for (const f of fns)
        f(error);
    } catch (e) {
      handleError(e, owner?.owner || null);
    }
  }
}
function lookup(owner, key) {
  return owner ? owner.context && owner.context[key] !== void 0 ? owner.context[key] : lookup(owner.owner, key) : void 0;
}
function resolveChildren(children2) {
  if (typeof children2 === "function" && !children2.length)
    return resolveChildren(children2());
  if (Array.isArray(children2)) {
    const results = [];
    for (let i = 0; i < children2.length; i++) {
      const result = resolveChildren(children2[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children2;
}
function createProvider(id, options) {
  return function provider(props) {
    let res;
    createRenderEffect(() => res = untrack(() => {
      Owner.context = {
        [id]: props.value
      };
      return children(() => props.children);
    }), void 0);
    return res;
  };
}
function observable(input) {
  return {
    subscribe(observer) {
      if (!(observer instanceof Object) || observer == null) {
        throw new TypeError("Expected the observer to be an object.");
      }
      const handler = typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
      if (!handler) {
        return {
          unsubscribe() {
          }
        };
      }
      const dispose2 = createRoot((disposer) => {
        createEffect(() => {
          const v2 = input();
          untrack(() => handler(v2));
        });
        return disposer;
      });
      if (getOwner())
        onCleanup(dispose2);
      return {
        unsubscribe() {
          dispose2();
        }
      };
    },
    [Symbol.observable || "@@observable"]() {
      return this;
    }
  };
}
function from(producer) {
  const [s, set] = createSignal(void 0, {
    equals: false
  });
  if ("subscribe" in producer) {
    const unsub = producer.subscribe((v2) => set(() => v2));
    onCleanup(() => "unsubscribe" in unsub ? unsub.unsubscribe() : unsub());
  } else {
    const clean = producer(set);
    onCleanup(clean);
  }
  return s;
}
var FALLBACK = Symbol("fallback");
function dispose(d2) {
  for (let i = 0; i < d2.length; i++)
    d2[i]();
}
function mapArray(list, mapFn, options = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [], i, j;
    newItems[$TRACK];
    return untrack(() => {
      let newLen = newItems.length, newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j = 0; j < newLen; j++) {
          items[j] = newItems[j];
          mapped[j] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++)
          ;
        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j = newEnd; j >= start; j--) {
          item = newItems[j];
          i = newIndices.get(item);
          newIndicesNext[j] = i === void 0 ? -1 : i;
          newIndices.set(item, j);
        }
        for (i = start; i <= end; i++) {
          item = items[i];
          j = newIndices.get(item);
          if (j !== void 0 && j !== -1) {
            temp[j] = mapped[i];
            tempdisposers[j] = disposers[i];
            indexes && (tempIndexes[j] = indexes[i]);
            j = newIndicesNext[j];
            newIndices.set(item, j);
          } else
            disposers[i]();
        }
        for (j = start; j < newLen; j++) {
          if (j in temp) {
            mapped[j] = temp[j];
            disposers[j] = tempdisposers[j];
            if (indexes) {
              indexes[j] = tempIndexes[j];
              indexes[j](j);
            }
          } else
            mapped[j] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set] = createSignal(j);
        indexes[j] = set;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
function indexArray(list, mapFn, options = {}) {
  let items = [], mapped = [], disposers = [], signals = [], len = 0, i;
  onCleanup(() => dispose(disposers));
  return () => {
    const newItems = list() || [];
    newItems[$TRACK];
    return untrack(() => {
      if (newItems.length === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          signals = [];
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
        return mapped;
      }
      if (items[0] === FALLBACK) {
        disposers[0]();
        disposers = [];
        items = [];
        mapped = [];
        len = 0;
      }
      for (i = 0; i < newItems.length; i++) {
        if (i < items.length && items[i] !== newItems[i]) {
          signals[i](() => newItems[i]);
        } else if (i >= items.length) {
          mapped[i] = createRoot(mapper);
        }
      }
      for (; i < items.length; i++) {
        disposers[i]();
      }
      len = signals.length = disposers.length = newItems.length;
      items = newItems.slice(0);
      return mapped = mapped.slice(0, len);
    });
    function mapper(disposer) {
      disposers[i] = disposer;
      const [s, set] = createSignal(newItems[i]);
      signals[i] = set;
      return mapFn(s, i);
    }
  };
}
var hydrationEnabled = false;
function enableHydration() {
  hydrationEnabled = true;
}
function createComponent(Comp, props) {
  if (hydrationEnabled) {
    if (sharedConfig.context) {
      const c = sharedConfig.context;
      setHydrateContext(nextHydrateContext());
      const r = untrack(() => Comp(props || {}));
      setHydrateContext(c);
      return r;
    }
  }
  return untrack(() => Comp(props || {}));
}
function trueFn() {
  return true;
}
var propTraps = {
  get(_3, property, receiver) {
    if (property === $PROXY)
      return receiver;
    return _3.get(property);
  },
  has(_3, property) {
    if (property === $PROXY)
      return true;
    return _3.has(property);
  },
  set: trueFn,
  deleteProperty: trueFn,
  getOwnPropertyDescriptor(_3, property) {
    return {
      configurable: true,
      enumerable: true,
      get() {
        return _3.get(property);
      },
      set: trueFn,
      deleteProperty: trueFn
    };
  },
  ownKeys(_3) {
    return _3.keys();
  }
};
function resolveSource(s) {
  return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
  for (let i = 0, length = this.length; i < length; ++i) {
    const v2 = this[i]();
    if (v2 !== void 0)
      return v2;
  }
}
function mergeProps(...sources) {
  let proxy = false;
  for (let i = 0; i < sources.length; i++) {
    const s = sources[i];
    proxy = proxy || !!s && $PROXY in s;
    sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
  }
  if (proxy) {
    return new Proxy({
      get(property) {
        for (let i = sources.length - 1; i >= 0; i--) {
          const v2 = resolveSource(sources[i])[property];
          if (v2 !== void 0)
            return v2;
        }
      },
      has(property) {
        for (let i = sources.length - 1; i >= 0; i--) {
          if (property in resolveSource(sources[i]))
            return true;
        }
        return false;
      },
      keys() {
        const keys = [];
        for (let i = 0; i < sources.length; i++)
          keys.push(...Object.keys(resolveSource(sources[i])));
        return [...new Set(keys)];
      }
    }, propTraps);
  }
  const target = {};
  const sourcesMap = {};
  const defined = /* @__PURE__ */ new Set();
  for (let i = sources.length - 1; i >= 0; i--) {
    const source = sources[i];
    if (!source)
      continue;
    const sourceKeys = Object.getOwnPropertyNames(source);
    for (let i2 = 0, length = sourceKeys.length; i2 < length; i2++) {
      const key = sourceKeys[i2];
      if (key === "__proto__" || key === "constructor")
        continue;
      const desc = Object.getOwnPropertyDescriptor(source, key);
      if (!defined.has(key)) {
        if (desc.get) {
          defined.add(key);
          Object.defineProperty(target, key, {
            enumerable: true,
            configurable: true,
            get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
          });
        } else {
          if (desc.value !== void 0)
            defined.add(key);
          target[key] = desc.value;
        }
      } else {
        const sources2 = sourcesMap[key];
        if (sources2) {
          if (desc.get) {
            sources2.push(desc.get.bind(source));
          } else if (desc.value !== void 0) {
            sources2.push(() => desc.value);
          }
        } else if (target[key] === void 0)
          target[key] = desc.value;
      }
    }
  }
  return target;
}
function splitProps(props, ...keys) {
  if ($PROXY in props) {
    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
    const res = keys.map((k2) => {
      return new Proxy({
        get(property) {
          return k2.includes(property) ? props[property] : void 0;
        },
        has(property) {
          return k2.includes(property) && property in props;
        },
        keys() {
          return k2.filter((property) => property in props);
        }
      }, propTraps);
    });
    res.push(new Proxy({
      get(property) {
        return blocked.has(property) ? void 0 : props[property];
      },
      has(property) {
        return blocked.has(property) ? false : property in props;
      },
      keys() {
        return Object.keys(props).filter((k2) => !blocked.has(k2));
      }
    }, propTraps));
    return res;
  }
  const otherObject = {};
  const objects = keys.map(() => ({}));
  for (const propName of Object.getOwnPropertyNames(props)) {
    const desc = Object.getOwnPropertyDescriptor(props, propName);
    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
    let blocked = false;
    let objectIndex = 0;
    for (const k2 of keys) {
      if (k2.includes(propName)) {
        blocked = true;
        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
      }
      ++objectIndex;
    }
    if (!blocked) {
      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
    }
  }
  return [...objects, otherObject];
}
function lazy(fn) {
  let comp;
  let p;
  const wrap = (props) => {
    const ctx = sharedConfig.context;
    if (ctx) {
      const [s, set] = createSignal();
      (p || (p = fn())).then((mod) => {
        setHydrateContext(ctx);
        set(() => mod.default);
        setHydrateContext();
      });
      comp = s;
    } else if (!comp) {
      const [s] = createResource(() => (p || (p = fn())).then((mod) => mod.default));
      comp = s;
    }
    let Comp;
    return createMemo(() => (Comp = comp()) && untrack(() => {
      if (false)
        ;
      if (!ctx)
        return Comp(props);
      const c = sharedConfig.context;
      setHydrateContext(ctx);
      const r = Comp(props);
      setHydrateContext(c);
      return r;
    }));
  };
  wrap.preload = () => p || ((p = fn()).then((mod) => comp = () => mod.default), p);
  return wrap;
}
var counter = 0;
function createUniqueId() {
  const ctx = sharedConfig.context;
  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;
}
var narrowedError = (name) => `Stale read from <${name}>.`;
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));
}
function Index(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(indexArray(() => props.each, props.children, fallback || void 0));
}
function Show(props) {
  const keyed = props.keyed;
  const condition = createMemo(() => props.when, void 0, {
    equals: (a, b2) => keyed ? a === b2 : !a === !b2
  });
  return createMemo(() => {
    const c = condition();
    if (c) {
      const child = props.children;
      const fn = typeof child === "function" && child.length > 0;
      return fn ? untrack(() => child(keyed ? c : () => {
        if (!untrack(condition))
          throw narrowedError("Show");
        return props.when;
      })) : child;
    }
    return props.fallback;
  }, void 0, void 0);
}
function Switch(props) {
  let keyed = false;
  const equals = (a, b2) => a[0] === b2[0] && (keyed ? a[1] === b2[1] : !a[1] === !b2[1]) && a[2] === b2[2];
  const conditions = children(() => props.children), evalConditions = createMemo(() => {
    let conds = conditions();
    if (!Array.isArray(conds))
      conds = [conds];
    for (let i = 0; i < conds.length; i++) {
      const c = conds[i].when;
      if (c) {
        keyed = !!conds[i].keyed;
        return [i, c, conds[i]];
      }
    }
    return [-1];
  }, void 0, {
    equals
  });
  return createMemo(() => {
    const [index, when, cond] = evalConditions();
    if (index < 0)
      return props.fallback;
    const c = cond.children;
    const fn = typeof c === "function" && c.length > 0;
    return fn ? untrack(() => c(keyed ? when : () => {
      if (untrack(evalConditions)[0] !== index)
        throw narrowedError("Match");
      return cond.when;
    })) : c;
  }, void 0, void 0);
}
function Match(props) {
  return props;
}
var Errors;
function resetErrorBoundaries() {
  Errors && [...Errors].forEach((fn) => fn());
}
function ErrorBoundary(props) {
  let err;
  let v2;
  if (sharedConfig.context && sharedConfig.load && (v2 = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count)))
    err = v2[0];
  const [errored, setErrored] = createSignal(err, void 0);
  Errors || (Errors = /* @__PURE__ */ new Set());
  Errors.add(setErrored);
  onCleanup(() => Errors.delete(setErrored));
  return createMemo(() => {
    let e;
    if (e = errored()) {
      const f = props.fallback;
      return typeof f === "function" && f.length ? untrack(() => f(e, () => setErrored())) : f;
    }
    return catchError(() => props.children, setErrored);
  }, void 0, void 0);
}
var suspenseListEquals = (a, b2) => a.showContent === b2.showContent && a.showFallback === b2.showFallback;
var SuspenseListContext = createContext();
function SuspenseList(props) {
  let [wrapper, setWrapper] = createSignal(() => ({
    inFallback: false
  })), show;
  const listContext = useContext(SuspenseListContext);
  const [registry, setRegistry] = createSignal([]);
  if (listContext) {
    show = listContext.register(createMemo(() => wrapper()().inFallback));
  }
  const resolved = createMemo((prev) => {
    const reveal = props.revealOrder, tail = props.tail, {
      showContent = true,
      showFallback = true
    } = show ? show() : {}, reg = registry(), reverse = reveal === "backwards";
    if (reveal === "together") {
      const all = reg.every((inFallback2) => !inFallback2());
      const res2 = reg.map(() => ({
        showContent: all && showContent,
        showFallback
      }));
      res2.inFallback = !all;
      return res2;
    }
    let stop = false;
    let inFallback = prev.inFallback;
    const res = [];
    for (let i = 0, len = reg.length; i < len; i++) {
      const n = reverse ? len - i - 1 : i, s = reg[n]();
      if (!stop && !s) {
        res[n] = {
          showContent,
          showFallback
        };
      } else {
        const next = !stop;
        if (next)
          inFallback = true;
        res[n] = {
          showContent: next,
          showFallback: !tail || next && tail === "collapsed" ? showFallback : false
        };
        stop = true;
      }
    }
    if (!stop)
      inFallback = false;
    res.inFallback = inFallback;
    return res;
  }, {
    inFallback: false
  });
  setWrapper(() => resolved);
  return createComponent(SuspenseListContext.Provider, {
    value: {
      register: (inFallback) => {
        let index;
        setRegistry((registry2) => {
          index = registry2.length;
          return [...registry2, inFallback];
        });
        return createMemo(() => resolved()[index], void 0, {
          equals: suspenseListEquals
        });
      }
    },
    get children() {
      return props.children;
    }
  });
}
function Suspense(props) {
  let counter2 = 0, show, ctx, p, flicker, error;
  const [inFallback, setFallback] = createSignal(false), SuspenseContext2 = getSuspenseContext(), store = {
    increment: () => {
      if (++counter2 === 1)
        setFallback(true);
    },
    decrement: () => {
      if (--counter2 === 0)
        setFallback(false);
    },
    inFallback,
    effects: [],
    resolved: false
  }, owner = getOwner();
  if (sharedConfig.context && sharedConfig.load) {
    const key = sharedConfig.context.id + sharedConfig.context.count;
    let ref = sharedConfig.load(key);
    if (ref && (p = ref[0]) && p !== "$$f") {
      if (typeof p !== "object" || !("then" in p))
        p = Promise.resolve(p);
      const [s, set] = createSignal(void 0, {
        equals: false
      });
      flicker = s;
      p.then((err) => {
        if (err || sharedConfig.done) {
          err && (error = err);
          return set();
        }
        sharedConfig.gather(key);
        setHydrateContext(ctx);
        set();
        setHydrateContext();
      });
    }
  }
  const listContext = useContext(SuspenseListContext);
  if (listContext)
    show = listContext.register(store.inFallback);
  let dispose2;
  onCleanup(() => dispose2 && dispose2());
  return createComponent(SuspenseContext2.Provider, {
    value: store,
    get children() {
      return createMemo(() => {
        if (error)
          throw error;
        ctx = sharedConfig.context;
        if (flicker) {
          flicker();
          return flicker = void 0;
        }
        if (ctx && p === "$$f")
          setHydrateContext();
        const rendered = createMemo(() => props.children);
        return createMemo((prev) => {
          const inFallback2 = store.inFallback(), {
            showContent = true,
            showFallback = true
          } = show ? show() : {};
          if ((!inFallback2 || p && p !== "$$f") && showContent) {
            store.resolved = true;
            dispose2 && dispose2();
            dispose2 = ctx = p = void 0;
            resumeEffects(store.effects);
            return rendered();
          }
          if (!showFallback)
            return;
          if (dispose2)
            return prev;
          return createRoot((disposer) => {
            dispose2 = disposer;
            if (ctx) {
              setHydrateContext({
                id: ctx.id + "f",
                count: 0
              });
              ctx = void 0;
            }
            return props.fallback;
          }, owner);
        });
      });
    }
  });
}
var DEV = void 0;

// node_modules/solid-js/web/dist/web.js
var booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
var Properties = /* @__PURE__ */ new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
var ChildProperties = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]);
var Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
});
var PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function getPropAlias(prop, tagName) {
  const a = PropAliases[prop];
  return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
var DelegatedEvents = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]);
var SVGElements = /* @__PURE__ */ new Set([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "use",
  "view",
  "vkern"
]);
var SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};
var DOMElements = /* @__PURE__ */ new Set(["html", "base", "head", "link", "meta", "style", "title", "body", "address", "article", "aside", "footer", "header", "main", "nav", "section", "body", "blockquote", "dd", "div", "dl", "dt", "figcaption", "figure", "hr", "li", "ol", "p", "pre", "ul", "a", "abbr", "b", "bdi", "bdo", "br", "cite", "code", "data", "dfn", "em", "i", "kbd", "mark", "q", "rp", "rt", "ruby", "s", "samp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr", "area", "audio", "img", "map", "track", "video", "embed", "iframe", "object", "param", "picture", "portal", "source", "svg", "math", "canvas", "noscript", "script", "del", "ins", "caption", "col", "colgroup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "button", "datalist", "fieldset", "form", "input", "label", "legend", "meter", "optgroup", "option", "output", "progress", "select", "textarea", "details", "dialog", "menu", "summary", "details", "slot", "template", "acronym", "applet", "basefont", "bgsound", "big", "blink", "center", "content", "dir", "font", "frame", "frameset", "hgroup", "image", "keygen", "marquee", "menuitem", "nobr", "noembed", "noframes", "plaintext", "rb", "rtc", "shadow", "spacer", "strike", "tt", "xmp", "a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "portal", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp", "input", "h1", "h2", "h3", "h4", "h5", "h6"]);
function reconcileArrays(parentNode, a, b2) {
  let bLength = b2.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a[aStart] === b2[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a[aEnd - 1] === b2[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b2[bStart - 1].nextSibling : b2[bEnd - bStart] : after;
      while (bStart < bEnd)
        parentNode.insertBefore(b2[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart]))
          a[aStart].remove();
        aStart++;
      }
    } else if (a[aStart] === b2[bEnd - 1] && b2[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b2[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b2[--bEnd], node);
      a[aEnd] = b2[bEnd];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = bStart;
        while (i < bEnd)
          map.set(b2[i], i++);
      }
      const index = map.get(a[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i = aStart, sequence = 1, t;
          while (++i < aEnd && i < bEnd) {
            if ((t = map.get(a[i])) == null || t !== index + sequence)
              break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index)
              parentNode.insertBefore(b2[bStart++], node);
          } else
            parentNode.replaceChild(b2[bStart++], a[aStart++]);
        } else
          aStart++;
      } else
        a[aStart++].remove();
    }
  }
}
var $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
  let disposer;
  createRoot((dispose2) => {
    disposer = dispose2;
    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
  }, options.owner);
  return () => {
    disposer();
    element.textContent = "";
  };
}
function template(html, isCE, isSVG) {
  let node;
  const create = () => {
    const t = document.createElement("template");
    t.innerHTML = html;
    return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;
  };
  const fn = isCE ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function delegateEvents(eventNames, document2 = window.document) {
  const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
  for (let i = 0, l = eventNames.length; i < l; i++) {
    const name = eventNames[i];
    if (!e.has(name)) {
      e.add(name);
      document2.addEventListener(name, eventHandler);
    }
  }
}
function clearDelegatedEvents(document2 = window.document) {
  if (document2[$$EVENTS]) {
    for (let name of document2[$$EVENTS].keys())
      document2.removeEventListener(name, eventHandler);
    delete document2[$$EVENTS];
  }
}
function setAttribute(node, name, value) {
  if (value == null)
    node.removeAttribute(name);
  else
    node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
  if (value == null)
    node.removeAttributeNS(namespace, name);
  else
    node.setAttributeNS(namespace, name, value);
}
function className(node, value) {
  if (value == null)
    node.removeAttribute("class");
  else
    node.className = value;
}
function addEventListener(node, name, handler, delegate) {
  if (delegate) {
    if (Array.isArray(handler)) {
      node[`$$${name}`] = handler[0];
      node[`$$${name}Data`] = handler[1];
    } else
      node[`$$${name}`] = handler;
  } else if (Array.isArray(handler)) {
    const handlerFn = handler[0];
    node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
  } else
    node.addEventListener(name, handler);
}
function classList(node, value, prev = {}) {
  const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
  let i, len;
  for (i = 0, len = prevKeys.length; i < len; i++) {
    const key = prevKeys[i];
    if (!key || key === "undefined" || value[key])
      continue;
    toggleClassKey(node, key, false);
    delete prev[key];
  }
  for (i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i], classValue = !!value[key];
    if (!key || key === "undefined" || prev[key] === classValue || !classValue)
      continue;
    toggleClassKey(node, key, true);
    prev[key] = classValue;
  }
  return prev;
}
function style(node, value, prev) {
  if (!value)
    return prev ? setAttribute(node, "style") : value;
  const nodeStyle = node.style;
  if (typeof value === "string")
    return nodeStyle.cssText = value;
  typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
  prev || (prev = {});
  value || (value = {});
  let v2, s;
  for (s in prev) {
    value[s] == null && nodeStyle.removeProperty(s);
    delete prev[s];
  }
  for (s in value) {
    v2 = value[s];
    if (v2 !== prev[s]) {
      nodeStyle.setProperty(s, v2);
      prev[s] = v2;
    }
  }
  return prev;
}
function spread(node, props = {}, isSVG, skipChildren) {
  const prevProps = {};
  if (!skipChildren) {
    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
  }
  createRenderEffect(() => props.ref && props.ref(node));
  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
  return prevProps;
}
function dynamicProperty(props, key) {
  const src = props[key];
  Object.defineProperty(props, key, {
    get() {
      return src();
    },
    enumerable: true
  });
  return props;
}
function innerHTML(parent, content) {
  !sharedConfig.context && (parent.innerHTML = content);
}
function use(fn, element, arg) {
  return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
  if (marker !== void 0 && !initial)
    initial = [];
  if (typeof accessor !== "function")
    return insertExpression(parent, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
  props || (props = {});
  for (const prop in prevProps) {
    if (!(prop in props)) {
      if (prop === "children")
        continue;
      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);
    }
  }
  for (const prop in props) {
    if (prop === "children") {
      if (!skipChildren)
        insertExpression(node, props.children);
      continue;
    }
    const value = props[prop];
    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);
  }
}
function hydrate$1(code, element, options = {}) {
  sharedConfig.completed = globalThis._$HY.completed;
  sharedConfig.events = globalThis._$HY.events;
  sharedConfig.load = globalThis._$HY.load;
  sharedConfig.gather = (root) => gatherHydratable(element, root);
  sharedConfig.registry = /* @__PURE__ */ new Map();
  sharedConfig.context = {
    id: options.renderId || "",
    count: 0
  };
  gatherHydratable(element, options.renderId);
  const dispose2 = render(code, element, [...element.childNodes], options);
  sharedConfig.context = null;
  return dispose2;
}
function getNextElement(template2) {
  let node, key;
  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {
    if (sharedConfig.context)
      console.warn("Unable to find DOM nodes for hydration key:", key);
    if (!template2)
      throw new Error("Unrecoverable Hydration Mismatch. No template for key: " + key);
    return template2();
  }
  if (sharedConfig.completed)
    sharedConfig.completed.add(node);
  sharedConfig.registry.delete(key);
  return node;
}
function getNextMatch(el, nodeName) {
  while (el && el.localName !== nodeName)
    el = el.nextSibling;
  return el;
}
function getNextMarker(start) {
  let end = start, count = 0, current = [];
  if (sharedConfig.context) {
    while (end) {
      if (end.nodeType === 8) {
        const v2 = end.nodeValue;
        if (v2 === "#")
          count++;
        else if (v2 === "/") {
          if (count === 0)
            return [end, current];
          count--;
        }
      }
      current.push(end);
      end = end.nextSibling;
    }
  }
  return [end, current];
}
function runHydrationEvents() {
  if (sharedConfig.events && !sharedConfig.events.queued) {
    queueMicrotask(() => {
      const {
        completed,
        events
      } = sharedConfig;
      events.queued = false;
      while (events.length) {
        const [el, e] = events[0];
        if (!completed.has(el))
          return;
        eventHandler(e);
        events.shift();
      }
    });
    sharedConfig.events.queued = true;
  }
}
function toPropertyName(name) {
  return name.toLowerCase().replace(/-([a-z])/g, (_3, w2) => w2.toUpperCase());
}
function toggleClassKey(node, key, value) {
  const classNames = key.trim().split(/\s+/);
  for (let i = 0, nameLen = classNames.length; i < nameLen; i++)
    node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef) {
  let isCE, isProp, isChildProp, propAlias, forceProp;
  if (prop === "style")
    return style(node, value, prev);
  if (prop === "classList")
    return classList(node, value, prev);
  if (value === prev)
    return prev;
  if (prop === "ref") {
    if (!skipRef)
      value(node);
  } else if (prop.slice(0, 3) === "on:") {
    const e = prop.slice(3);
    prev && node.removeEventListener(e, prev);
    value && node.addEventListener(e, value);
  } else if (prop.slice(0, 10) === "oncapture:") {
    const e = prop.slice(10);
    prev && node.removeEventListener(e, prev, true);
    value && node.addEventListener(e, value, true);
  } else if (prop.slice(0, 2) === "on") {
    const name = prop.slice(2).toLowerCase();
    const delegate = DelegatedEvents.has(name);
    if (!delegate && prev) {
      const h3 = Array.isArray(prev) ? prev[0] : prev;
      node.removeEventListener(name, h3);
    }
    if (delegate || value) {
      addEventListener(node, name, value, delegate);
      delegate && delegateEvents([name]);
    }
  } else if (prop.slice(0, 5) === "attr:") {
    setAttribute(node, prop.slice(5), value);
  } else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-"))) {
    if (forceProp) {
      prop = prop.slice(5);
      isProp = true;
    }
    if (prop === "class" || prop === "className")
      className(node, value);
    else if (isCE && !isProp && !isChildProp)
      node[toPropertyName(prop)] = value;
    else
      node[propAlias || prop] = value;
  } else {
    const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
    if (ns)
      setAttributeNS(node, ns, prop, value);
    else
      setAttribute(node, Aliases[prop] || prop, value);
  }
  return value;
}
function eventHandler(e) {
  const key = `$$${e.type}`;
  let node = e.composedPath && e.composedPath()[0] || e.target;
  if (e.target !== node) {
    Object.defineProperty(e, "target", {
      configurable: true,
      value: node
    });
  }
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  if (sharedConfig.registry && !sharedConfig.done)
    sharedConfig.done = _$HY.done = true;
  while (node) {
    const handler = node[key];
    if (handler && !node.disabled) {
      const data = node[`${key}Data`];
      data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
      if (e.cancelBubble)
        return;
    }
    node = node._$host || node.parentNode || node.host;
  }
}
function insertExpression(parent, value, current, marker, unwrapArray) {
  if (sharedConfig.context) {
    !current && (current = [...parent.childNodes]);
    let cleaned = [];
    for (let i = 0; i < current.length; i++) {
      const node = current[i];
      if (node.nodeType === 8 && node.data.slice(0, 2) === "!$")
        node.remove();
      else
        cleaned.push(node);
    }
    current = cleaned;
  }
  while (typeof current === "function")
    current = current();
  if (value === current)
    return current;
  const t = typeof value, multi = marker !== void 0;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t === "string" || t === "number") {
    if (sharedConfig.context)
      return current;
    if (t === "number")
      value = value.toString();
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data = value;
      } else
        node = document.createTextNode(value);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value;
      } else
        current = parent.textContent = value;
    }
  } else if (value == null || t === "boolean") {
    if (sharedConfig.context)
      return current;
    current = cleanChildren(parent, current, marker);
  } else if (t === "function") {
    createRenderEffect(() => {
      let v2 = value();
      while (typeof v2 === "function")
        v2 = v2();
      current = insertExpression(parent, v2, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
      return () => current;
    }
    if (sharedConfig.context) {
      if (!array.length)
        return current;
      for (let i = 0; i < array.length; i++) {
        if (array[i].parentNode)
          return current = array;
      }
    }
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi)
        return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array, marker);
      } else
        reconcileArrays(parent, current, array);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array);
    }
    current = array;
  } else if (value.nodeType) {
    if (sharedConfig.context && value.parentNode)
      return current = multi ? [value] : value;
    if (Array.isArray(current)) {
      if (multi)
        return current = cleanChildren(parent, current, marker, value);
      cleanChildren(parent, current, null, value);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value);
    } else
      parent.replaceChild(value, parent.firstChild);
    current = value;
  } else
    console.warn(`Unrecognized value. Skipped inserting`, value);
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
  let dynamic = false;
  for (let i = 0, len = array.length; i < len; i++) {
    let item = array[i], prev = current && current[i], t;
    if (item == null || item === true || item === false)
      ;
    else if ((t = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
    } else if (t === "function") {
      if (unwrap) {
        while (typeof item === "function")
          item = item();
        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value = String(item);
      if (prev && prev.nodeType === 3 && prev.data === value)
        normalized.push(prev);
      else
        normalized.push(document.createTextNode(value));
    }
  }
  return dynamic;
}
function appendNodes(parent, array, marker = null) {
  for (let i = 0, len = array.length; i < len; i++)
    parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === void 0)
    return parent.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i)
          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else
          isParent && el.remove();
      } else
        inserted = true;
    }
  } else
    parent.insertBefore(node, marker);
  return [node];
}
function gatherHydratable(element, root) {
  const templates = element.querySelectorAll(`*[data-hk]`);
  for (let i = 0; i < templates.length; i++) {
    const node = templates[i];
    const key = node.getAttribute("data-hk");
    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key))
      sharedConfig.registry.set(key, node);
  }
}
function getHydrationKey() {
  const hydrate2 = sharedConfig.context;
  return `${hydrate2.id}${hydrate2.count++}`;
}
function NoHydration(props) {
  return sharedConfig.context ? void 0 : props.children;
}
function Hydration(props) {
  return props.children;
}
function voidFn() {
}
function throwInBrowser(func) {
  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);
  console.error(err);
}
function renderToString(fn, options) {
  throwInBrowser(renderToString);
}
function renderToStringAsync(fn, options) {
  throwInBrowser(renderToStringAsync);
}
function renderToStream(fn, options) {
  throwInBrowser(renderToStream);
}
function ssr(template2, ...nodes) {
}
function ssrElement(name, props, children2, needsId) {
}
function ssrClassList(value) {
}
function ssrStyle(value) {
}
function ssrAttribute(key, value) {
}
function ssrHydrationKey() {
}
function resolveSSRNode(node) {
}
function escape(html) {
}
function ssrSpread(props, isSVG, skipChildren) {
}
var isServer = false;
var isDev = false;
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(tagName, isSVG = false) {
  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
}
var hydrate = (...args) => {
  enableHydration();
  return hydrate$1(...args);
};
function Portal(props) {
  const {
    useShadow
  } = props, marker = document.createTextNode(""), mount = () => props.mount || document.body, owner = getOwner();
  let content;
  let hydrating = !!sharedConfig.context;
  createEffect(() => {
    if (hydrating)
      getOwner().user = hydrating = false;
    content || (content = runWithOwner(owner, () => createMemo(() => props.children)));
    const el = mount();
    if (el instanceof HTMLHeadElement) {
      const [clean, setClean] = createSignal(false);
      const cleanup = () => setClean(true);
      createRoot((dispose2) => insert(el, () => !clean() ? content() : dispose2(), null));
      onCleanup(cleanup);
    } else {
      const container = createElement(props.isSVG ? "g" : "div", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({
        mode: "open"
      }) : container;
      Object.defineProperty(container, "_$host", {
        get() {
          return marker.parentNode;
        },
        configurable: true
      });
      insert(renderRoot, content);
      el.appendChild(container);
      props.ref && props.ref(container);
      onCleanup(() => el.removeChild(container));
    }
  }, void 0, {
    render: !hydrating
  });
  return marker;
}
function Dynamic(props) {
  const [p, others] = splitProps(props, ["component"]);
  const cached = createMemo(() => p.component);
  return createMemo(() => {
    const component = cached();
    switch (typeof component) {
      case "function":
        Object.assign(component, {
          [$DEVCOMP]: true
        });
        return untrack(() => component(others));
      case "string":
        const isSvg = SVGElements.has(component);
        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);
        spread(el, others, isSvg);
        return el;
    }
  });
}

// http-url:https://esm.sh/stable/solid-js@1.7.7/esnext/solid-js.mjs
var ze = 1, he = false, ge = false, G = [], D = null, pe = null, Be = 5, fe = 0, Ke = 300, we = null, ne = null, Ye = 1073741823;
function Ge() {
  let e = new MessageChannel(), t = e.port2;
  if (we = () => t.postMessage(null), e.port1.onmessage = () => {
    if (ne !== null) {
      let s = performance.now();
      fe = s + Be;
      let n = true;
      try {
        ne(n, s) ? t.postMessage(null) : ne = null;
      } catch (r) {
        throw t.postMessage(null), r;
      }
    }
  }, navigator && navigator.scheduling && navigator.scheduling.isInputPending) {
    let s = navigator.scheduling;
    pe = () => {
      let n = performance.now();
      return n >= fe ? s.isInputPending() ? true : n >= Ke : false;
    };
  } else
    pe = () => performance.now() >= fe;
}
function Qe(e, t) {
  function s() {
    let n = 0, r = e.length - 1;
    for (; n <= r; ) {
      let i = r + n >> 1, l = t.expirationTime - e[i].expirationTime;
      if (l > 0)
        n = i + 1;
      else if (l < 0)
        r = i - 1;
      else
        return i;
    }
    return n;
  }
  e.splice(s(), 0, t);
}
function Ce(e, t) {
  we || Ge();
  let s = performance.now(), n = Ye;
  t && t.timeout && (n = t.timeout);
  let r = { id: ze++, fn: e, startTime: s, expirationTime: s + n };
  return Qe(G, r), !he && !ge && (he = true, ne = Xe, we()), r;
}
function pt(e) {
  e.fn = null;
}
function Xe(e, t) {
  he = false, ge = true;
  try {
    return Je(e, t);
  } finally {
    D = null, ge = false;
  }
}
function Je(e, t) {
  let s = t;
  for (D = G[0] || null; D !== null && !(D.expirationTime > s && (!e || pe())); ) {
    let n = D.fn;
    if (n !== null) {
      D.fn = null;
      let r = D.expirationTime <= s;
      n(r), s = performance.now(), D === G[0] && G.shift();
    } else
      G.shift();
    D = G[0] || null;
  }
  return D !== null;
}
var w = { context: void 0, registry: void 0 };
function L(e) {
  w.context = e;
}
function Ze() {
  return { ...w.context, id: `${w.context.id}${w.context.count++}-`, count: 0 };
}
var Ee = (e, t) => e === t, re = Symbol("solid-proxy"), Ae = Symbol("solid-track"), wt = Symbol("solid-dev-component"), se = { equals: Ee }, q = null, Te = Re, M = 1, Z = 2, Pe = { owned: null, cleanups: null, context: null, owner: null }, ae = {}, d = null, u = null, K = null, z = null, h = null, x = null, S = null, ue = 0, [et, Se] = I(false);
function B(e, t) {
  let s = h, n = d, r = e.length === 0, i = r ? Pe : { owned: null, cleanups: null, context: null, owner: t === void 0 ? n : t }, l = r ? e : () => e(() => k(() => H(i)));
  d = i, h = null;
  try {
    return V(l, true);
  } finally {
    h = s, d = n;
  }
}
function I(e, t) {
  t = t ? Object.assign({}, se, t) : se;
  let s = { value: e, observers: null, observerSlots: null, comparator: t.equals || void 0 }, n = (r) => (typeof r == "function" && (u && u.running && u.sources.has(s) ? r = r(s.tValue) : r = r(s.value)), Le(s, r));
  return [qe.bind(s), n];
}
function ke(e, t, s) {
  let n = _(e, t, true, M);
  K && u && u.running ? x.push(n) : W(n);
}
function tt(e, t, s) {
  let n = _(e, t, false, M);
  K && u && u.running ? x.push(n) : W(n);
}
function Fe(e, t, s) {
  Te = ot;
  let n = _(e, t, false, M), r = U && J(d, U.id);
  r && (n.suspense = r), (!s || !s.render) && (n.user = true), S ? S.push(n) : W(n);
}
function bt(e, t) {
  let s, n = _(() => {
    s ? s() : k(e), s = void 0;
  }, void 0, false, 0), r = U && J(d, U.id);
  return r && (n.suspense = r), n.user = true, (i) => {
    s = i, W(n);
  };
}
function A(e, t, s) {
  s = s ? Object.assign({}, se, s) : se;
  let n = _(e, t, true, 0);
  return n.observers = null, n.observerSlots = null, n.comparator = s.equals || void 0, K && u && u.running ? (n.tState = M, x.push(n)) : W(n), qe.bind(n);
}
function nt(e, t, s) {
  let n, r, i;
  arguments.length === 2 && typeof t == "object" || arguments.length === 1 ? (n = true, r = e, i = t || {}) : (n = e, r = t, i = s || {});
  let l = null, o = ae, f = null, a = false, c = false, g = "initialValue" in i, p = typeof n == "function" && A(n), b2 = /* @__PURE__ */ new Set(), [T, O] = (i.storage || I)(i.initialValue), [F2, j] = I(void 0), [m, v2] = I(void 0, { equals: false }), [C2, $2] = I(g ? "ready" : "unresolved");
  if (w.context) {
    f = `${w.context.id}${w.context.count++}`;
    let y2;
    i.ssrLoadFrom === "initial" ? o = i.initialValue : w.load && (y2 = w.load(f)) && (o = y2[0]);
  }
  function R2(y2, E, P2, Y2) {
    return l === y2 && (l = null, Y2 !== void 0 && (g = true), (y2 === o || E === o) && i.onHydrated && queueMicrotask(() => i.onHydrated(Y2, { value: E })), o = ae, u && y2 && a ? (u.promises.delete(y2), a = false, V(() => {
      u.running = true, ve(E, P2);
    }, false)) : ve(E, P2)), E;
  }
  function ve(y2, E) {
    V(() => {
      E === void 0 && O(() => y2), $2(E !== void 0 ? "errored" : g ? "ready" : "unresolved"), j(E);
      for (let P2 of b2.keys())
        P2.decrement();
      b2.clear();
    }, false);
  }
  function oe2() {
    let y2 = U && J(d, U.id), E = T(), P2 = F2();
    if (P2 !== void 0 && !l)
      throw P2;
    return h && !h.user && y2 && ke(() => {
      m(), l && (y2.resolved && u && a ? u.promises.add(l) : b2.has(y2) || (y2.increment(), b2.add(y2)));
    }), E;
  }
  function ce2(y2 = true) {
    if (y2 !== false && c)
      return;
    c = false;
    let E = p ? p() : n;
    if (a = u && u.running, E == null || E === false) {
      R2(l, k(T));
      return;
    }
    u && l && u.promises.delete(l);
    let P2 = o !== ae ? o : k(() => r(E, { value: T(), refetching: y2 }));
    return typeof P2 != "object" || !(P2 && "then" in P2) ? (R2(l, P2, void 0, E), P2) : (l = P2, c = true, queueMicrotask(() => c = false), V(() => {
      $2(g ? "refreshing" : "pending"), v2();
    }, false), P2.then((Y2) => R2(P2, Y2, void 0, E), (Y2) => R2(P2, void 0, Ue(Y2), E)));
  }
  return Object.defineProperties(oe2, { state: { get: () => C2() }, error: { get: () => F2() }, loading: { get() {
    let y2 = C2();
    return y2 === "pending" || y2 === "refreshing";
  } }, latest: { get() {
    if (!g)
      return oe2();
    let y2 = F2();
    if (y2 && !l)
      throw y2;
    return T();
  } } }), p ? ke(() => ce2(false)) : ce2(false), [oe2, { refetch: ce2, mutate: O }];
}
function mt(e, t) {
  let s, n = t ? t.timeoutMs : void 0, r = _(() => ((!s || !s.fn) && (s = Ce(() => l(() => r.value), n !== void 0 ? { timeout: n } : void 0)), e()), void 0, true), [i, l] = I(r.value, t);
  return W(r), l(() => r.value), i;
}
function yt(e, t = Ee, s) {
  let n = /* @__PURE__ */ new Map(), r = _((i) => {
    let l = e();
    for (let [o, f] of n.entries())
      if (t(o, l) !== t(o, i))
        for (let a of f.values())
          a.state = M, a.pure ? x.push(a) : S.push(a);
    return l;
  }, void 0, true, M);
  return W(r), (i) => {
    let l = h;
    if (l) {
      let o;
      (o = n.get(i)) ? o.add(l) : n.set(i, o = /* @__PURE__ */ new Set([l])), N(() => {
        o.delete(l), !o.size && n.delete(i);
      });
    }
    return t(i, u && u.running && u.sources.has(r) ? r.tValue : r.value);
  };
}
function xt(e) {
  return V(e, false);
}
function k(e) {
  if (h === null)
    return e();
  let t = h;
  h = null;
  try {
    return e();
  } finally {
    h = t;
  }
}
function vt(e, t, s) {
  let n = Array.isArray(e), r, i = s && s.defer;
  return (l) => {
    let o;
    if (n) {
      o = Array(e.length);
      for (let a = 0; a < e.length; a++)
        o[a] = e[a]();
    } else
      o = e();
    if (i) {
      i = false;
      return;
    }
    let f = k(() => t(o, r, l));
    return r = o, f;
  };
}
function St(e) {
  Fe(() => k(e));
}
function N(e) {
  return d === null || (d.cleanups === null ? d.cleanups = [e] : d.cleanups.push(e)), e;
}
function rt(e, t) {
  q || (q = Symbol("error")), d = _(void 0, void 0, true), d.context = { [q]: [t] }, u && u.running && u.sources.add(d);
  try {
    return e();
  } catch (s) {
    X(s);
  } finally {
    d = d.owner;
  }
}
function kt(e) {
  q || (q = Symbol("error")), d === null || (d.context === null ? d.context = { [q]: [e] } : d.context[q] ? d.context[q].push(e) : d.context[q] = [e]);
}
function Ot() {
  return h;
}
function je() {
  return d;
}
function Ct(e, t) {
  let s = d, n = h;
  d = e, h = null;
  try {
    return V(t, true);
  } catch (r) {
    X(r);
  } finally {
    d = s, h = n;
  }
}
function Et(e = Ce) {
  K = e;
}
function Ie(e) {
  if (u && u.running)
    return e(), u.done;
  let t = h, s = d;
  return Promise.resolve().then(() => {
    h = t, d = s;
    let n;
    return (K || U) && (n = u || (u = { sources: /* @__PURE__ */ new Set(), effects: [], promises: /* @__PURE__ */ new Set(), disposed: /* @__PURE__ */ new Set(), queue: /* @__PURE__ */ new Set(), running: true }), n.done || (n.done = new Promise((r) => n.resolve = r)), n.running = true), V(e, false), h = d = null, n ? n.done : void 0;
  });
}
function At() {
  return [et, Ie];
}
function st(e) {
  S.push.apply(S, e), e.length = 0;
}
function Me(e, t) {
  let s = Symbol("context");
  return { id: s, Provider: ct(s), defaultValue: e };
}
function Ve(e) {
  let t;
  return (t = J(d, e.id)) !== void 0 ? t : e.defaultValue;
}
function $e(e) {
  let t = A(e), s = A(() => be(t()));
  return s.toArray = () => {
    let n = s();
    return Array.isArray(n) ? n : n != null ? [n] : [];
  }, s;
}
var U;
function it() {
  return U || (U = Me({}));
}
function Tt(e) {
  if (z) {
    let t = z;
    z = (s, n) => {
      let r = t(s, n), i = e((l) => r.track(l), n);
      return { track: (l) => i.track(l), dispose() {
        i.dispose(), r.dispose();
      } };
    };
  } else
    z = e;
}
function qe() {
  let e = u && u.running;
  if (this.sources && (e ? this.tState : this.state))
    if ((e ? this.tState : this.state) === M)
      W(this);
    else {
      let t = x;
      x = null, V(() => ie(this), false), x = t;
    }
  if (h) {
    let t = this.observers ? this.observers.length : 0;
    h.sources ? (h.sources.push(this), h.sourceSlots.push(t)) : (h.sources = [this], h.sourceSlots = [t]), this.observers ? (this.observers.push(h), this.observerSlots.push(h.sources.length - 1)) : (this.observers = [h], this.observerSlots = [h.sources.length - 1]);
  }
  return e && u.sources.has(this) ? this.tValue : this.value;
}
function Le(e, t, s) {
  let n = u && u.running && u.sources.has(e) ? e.tValue : e.value;
  if (!e.comparator || !e.comparator(n, t)) {
    if (u) {
      let r = u.running;
      (r || !s && u.sources.has(e)) && (u.sources.add(e), e.tValue = t), r || (e.value = t);
    } else
      e.value = t;
    e.observers && e.observers.length && V(() => {
      for (let r = 0; r < e.observers.length; r += 1) {
        let i = e.observers[r], l = u && u.running;
        l && u.disposed.has(i) || ((l ? !i.tState : !i.state) && (i.pure ? x.push(i) : S.push(i), i.observers && De(i)), l ? i.tState = M : i.state = M);
      }
      if (x.length > 1e6)
        throw x = [], new Error();
    }, false);
  }
  return t;
}
function W(e) {
  if (!e.fn)
    return;
  H(e);
  let t = d, s = h, n = ue;
  h = d = e, Oe(e, u && u.running && u.sources.has(e) ? e.tValue : e.value, n), u && !u.running && u.sources.has(e) && queueMicrotask(() => {
    V(() => {
      u && (u.running = true), h = d = e, Oe(e, e.tValue, n), h = d = null;
    }, false);
  }), h = s, d = t;
}
function Oe(e, t, s) {
  let n;
  try {
    n = e.fn(t);
  } catch (r) {
    return e.pure && (u && u.running ? (e.tState = M, e.tOwned && e.tOwned.forEach(H), e.tOwned = void 0) : (e.state = M, e.owned && e.owned.forEach(H), e.owned = null)), e.updatedAt = s + 1, X(r);
  }
  (!e.updatedAt || e.updatedAt <= s) && (e.updatedAt != null && "observers" in e ? Le(e, n, true) : u && u.running && e.pure ? (u.sources.add(e), e.tValue = n) : e.value = n, e.updatedAt = s);
}
function _(e, t, s, n = M, r) {
  let i = { fn: e, state: n, updatedAt: null, owned: null, sources: null, sourceSlots: null, cleanups: null, value: t, owner: d, context: null, pure: s };
  if (u && u.running && (i.state = 0, i.tState = n), d === null || d !== Pe && (u && u.running && d.pure ? d.tOwned ? d.tOwned.push(i) : d.tOwned = [i] : d.owned ? d.owned.push(i) : d.owned = [i]), z) {
    let [l, o] = I(void 0, { equals: false }), f = z(i.fn, o);
    N(() => f.dispose());
    let a = () => Ie(o).then(() => c.dispose()), c = z(i.fn, a);
    i.fn = (g) => (l(), u && u.running ? c.track(g) : f.track(g));
  }
  return i;
}
function ee(e) {
  let t = u && u.running;
  if ((t ? e.tState : e.state) === 0)
    return;
  if ((t ? e.tState : e.state) === Z)
    return ie(e);
  if (e.suspense && k(e.suspense.inFallback))
    return e.suspense.effects.push(e);
  let s = [e];
  for (; (e = e.owner) && (!e.updatedAt || e.updatedAt < ue); ) {
    if (t && u.disposed.has(e))
      return;
    (t ? e.tState : e.state) && s.push(e);
  }
  for (let n = s.length - 1; n >= 0; n--) {
    if (e = s[n], t) {
      let r = e, i = s[n + 1];
      for (; (r = r.owner) && r !== i; )
        if (u.disposed.has(r))
          return;
    }
    if ((t ? e.tState : e.state) === M)
      W(e);
    else if ((t ? e.tState : e.state) === Z) {
      let r = x;
      x = null, V(() => ie(e, s[0]), false), x = r;
    }
  }
}
function V(e, t) {
  if (x)
    return e();
  let s = false;
  t || (x = []), S ? s = true : S = [], ue++;
  try {
    let n = e();
    return lt(s), n;
  } catch (n) {
    s || (S = null), x = null, X(n);
  }
}
function lt(e) {
  if (x && (K && u && u.running ? ut(x) : Re(x), x = null), e)
    return;
  let t;
  if (u) {
    if (!u.promises.size && !u.queue.size) {
      let n = u.sources, r = u.disposed;
      S.push.apply(S, u.effects), t = u.resolve;
      for (let i of S)
        "tState" in i && (i.state = i.tState), delete i.tState;
      u = null, V(() => {
        for (let i of r)
          H(i);
        for (let i of n) {
          if (i.value = i.tValue, i.owned)
            for (let l = 0, o = i.owned.length; l < o; l++)
              H(i.owned[l]);
          i.tOwned && (i.owned = i.tOwned), delete i.tValue, delete i.tOwned, i.tState = 0;
        }
        Se(false);
      }, false);
    } else if (u.running) {
      u.running = false, u.effects.push.apply(u.effects, S), S = null, Se(true);
      return;
    }
  }
  let s = S;
  S = null, s.length && V(() => Te(s), false), t && t();
}
function Re(e) {
  for (let t = 0; t < e.length; t++)
    ee(e[t]);
}
function ut(e) {
  for (let t = 0; t < e.length; t++) {
    let s = e[t], n = u.queue;
    n.has(s) || (n.add(s), K(() => {
      n.delete(s), V(() => {
        u.running = true, ee(s);
      }, false), u && (u.running = false);
    }));
  }
}
function ot(e) {
  let t, s = 0;
  for (t = 0; t < e.length; t++) {
    let n = e[t];
    n.user ? e[s++] = n : ee(n);
  }
  for (w.context && L(), t = 0; t < s; t++)
    ee(e[t]);
}
function ie(e, t) {
  let s = u && u.running;
  s ? e.tState = 0 : e.state = 0;
  for (let n = 0; n < e.sources.length; n += 1) {
    let r = e.sources[n];
    if (r.sources) {
      let i = s ? r.tState : r.state;
      i === M ? r !== t && (!r.updatedAt || r.updatedAt < ue) && ee(r) : i === Z && ie(r, t);
    }
  }
}
function De(e) {
  let t = u && u.running;
  for (let s = 0; s < e.observers.length; s += 1) {
    let n = e.observers[s];
    (t ? !n.tState : !n.state) && (t ? n.tState = Z : n.state = Z, n.pure ? x.push(n) : S.push(n), n.observers && De(n));
  }
}
function H(e) {
  let t;
  if (e.sources)
    for (; e.sources.length; ) {
      let s = e.sources.pop(), n = e.sourceSlots.pop(), r = s.observers;
      if (r && r.length) {
        let i = r.pop(), l = s.observerSlots.pop();
        n < r.length && (i.sourceSlots[l] = n, r[n] = i, s.observerSlots[n] = l);
      }
    }
  if (u && u.running && e.pure) {
    if (e.tOwned) {
      for (t = e.tOwned.length - 1; t >= 0; t--)
        H(e.tOwned[t]);
      delete e.tOwned;
    }
    Ne(e, true);
  } else if (e.owned) {
    for (t = e.owned.length - 1; t >= 0; t--)
      H(e.owned[t]);
    e.owned = null;
  }
  if (e.cleanups) {
    for (t = e.cleanups.length - 1; t >= 0; t--)
      e.cleanups[t]();
    e.cleanups = null;
  }
  u && u.running ? e.tState = 0 : e.state = 0, e.context = null;
}
function Ne(e, t) {
  if (t || (e.tState = 0, u.disposed.add(e)), e.owned)
    for (let s = 0; s < e.owned.length; s++)
      Ne(e.owned[s]);
}
function Ue(e) {
  return e instanceof Error ? e : new Error(typeof e == "string" ? e : "Unknown error", { cause: e });
}
function X(e, t = d) {
  let s = q && J(t, q), n = Ue(e);
  if (!s)
    throw n;
  if (S)
    S.push({ fn() {
      try {
        for (let r of s)
          r(n);
      } catch (r) {
        X(r, t?.owner || null);
      }
    }, state: M });
  else
    try {
      for (let r of s)
        r(n);
    } catch (r) {
      X(r, t?.owner || null);
    }
}
function J(e, t) {
  return e ? e.context && e.context[t] !== void 0 ? e.context[t] : J(e.owner, t) : void 0;
}
function be(e) {
  if (typeof e == "function" && !e.length)
    return be(e());
  if (Array.isArray(e)) {
    let t = [];
    for (let s = 0; s < e.length; s++) {
      let n = be(e[s]);
      Array.isArray(n) ? t.push.apply(t, n) : t.push(n);
    }
    return t;
  }
  return e;
}
function ct(e, t) {
  return function(n) {
    let r;
    return tt(() => r = k(() => (d.context = { [e]: n.value }, $e(() => n.children))), void 0), r;
  };
}
function Pt(e) {
  return { subscribe(t) {
    if (!(t instanceof Object) || t == null)
      throw new TypeError("Expected the observer to be an object.");
    let s = typeof t == "function" ? t : t.next && t.next.bind(t);
    if (!s)
      return { unsubscribe() {
      } };
    let n = B((r) => (Fe(() => {
      let i = e();
      k(() => s(i));
    }), r));
    return je() && N(n), { unsubscribe() {
      n();
    } };
  }, [Symbol.observable || "@@observable"]() {
    return this;
  } };
}
function Ft(e) {
  let [t, s] = I(void 0, { equals: false });
  if ("subscribe" in e) {
    let n = e.subscribe((r) => s(() => r));
    N(() => "unsubscribe" in n ? n.unsubscribe() : n());
  } else {
    let n = e(s);
    N(n);
  }
  return t;
}
var me = Symbol("fallback");
function le(e) {
  for (let t = 0; t < e.length; t++)
    e[t]();
}
function ft(e, t, s = {}) {
  let n = [], r = [], i = [], l = 0, o = t.length > 1 ? [] : null;
  return N(() => le(i)), () => {
    let f = e() || [], a, c;
    return f[Ae], k(() => {
      let p = f.length, b2, T, O, F2, j, m, v2, C2, $2;
      if (p === 0)
        l !== 0 && (le(i), i = [], n = [], r = [], l = 0, o && (o = [])), s.fallback && (n = [me], r[0] = B((R2) => (i[0] = R2, s.fallback())), l = 1);
      else if (l === 0) {
        for (r = new Array(p), c = 0; c < p; c++)
          n[c] = f[c], r[c] = B(g);
        l = p;
      } else {
        for (O = new Array(p), F2 = new Array(p), o && (j = new Array(p)), m = 0, v2 = Math.min(l, p); m < v2 && n[m] === f[m]; m++)
          ;
        for (v2 = l - 1, C2 = p - 1; v2 >= m && C2 >= m && n[v2] === f[C2]; v2--, C2--)
          O[C2] = r[v2], F2[C2] = i[v2], o && (j[C2] = o[v2]);
        for (b2 = /* @__PURE__ */ new Map(), T = new Array(C2 + 1), c = C2; c >= m; c--)
          $2 = f[c], a = b2.get($2), T[c] = a === void 0 ? -1 : a, b2.set($2, c);
        for (a = m; a <= v2; a++)
          $2 = n[a], c = b2.get($2), c !== void 0 && c !== -1 ? (O[c] = r[a], F2[c] = i[a], o && (j[c] = o[a]), c = T[c], b2.set($2, c)) : i[a]();
        for (c = m; c < p; c++)
          c in O ? (r[c] = O[c], i[c] = F2[c], o && (o[c] = j[c], o[c](c))) : r[c] = B(g);
        r = r.slice(0, l = p), n = f.slice(0);
      }
      return r;
    });
    function g(p) {
      if (i[c] = p, o) {
        let [b2, T] = I(c);
        return o[c] = T, t(f[c], b2);
      }
      return t(f[c]);
    }
  };
}
function at(e, t, s = {}) {
  let n = [], r = [], i = [], l = [], o = 0, f;
  return N(() => le(i)), () => {
    let a = e() || [];
    return a[Ae], k(() => {
      if (a.length === 0)
        return o !== 0 && (le(i), i = [], n = [], r = [], o = 0, l = []), s.fallback && (n = [me], r[0] = B((g) => (i[0] = g, s.fallback())), o = 1), r;
      for (n[0] === me && (i[0](), i = [], n = [], r = [], o = 0), f = 0; f < a.length; f++)
        f < n.length && n[f] !== a[f] ? l[f](() => a[f]) : f >= n.length && (r[f] = B(c));
      for (; f < n.length; f++)
        i[f]();
      return o = l.length = i.length = a.length, n = a.slice(0), r = r.slice(0, o);
    });
    function c(g) {
      i[f] = g;
      let [p, b2] = I(a[f]);
      return l[f] = b2, t(p, f);
    }
  };
}
var We = false;
function jt() {
  We = true;
}
function He(e, t) {
  if (We && w.context) {
    let s = w.context;
    L(Ze());
    let n = k(() => e(t || {}));
    return L(s), n;
  }
  return k(() => e(t || {}));
}
function te() {
  return true;
}
var ye = { get(e, t, s) {
  return t === re ? s : e.get(t);
}, has(e, t) {
  return t === re ? true : e.has(t);
}, set: te, deleteProperty: te, getOwnPropertyDescriptor(e, t) {
  return { configurable: true, enumerable: true, get() {
    return e.get(t);
  }, set: te, deleteProperty: te };
}, ownKeys(e) {
  return e.keys();
} };
function de(e) {
  return (e = typeof e == "function" ? e() : e) ? e : {};
}
function dt() {
  for (let e = 0, t = this.length; e < t; ++e) {
    let s = this[e]();
    if (s !== void 0)
      return s;
  }
}
function It(...e) {
  let t = false;
  for (let i = 0; i < e.length; i++) {
    let l = e[i];
    t = t || !!l && re in l, e[i] = typeof l == "function" ? (t = true, A(l)) : l;
  }
  if (t)
    return new Proxy({ get(i) {
      for (let l = e.length - 1; l >= 0; l--) {
        let o = de(e[l])[i];
        if (o !== void 0)
          return o;
      }
    }, has(i) {
      for (let l = e.length - 1; l >= 0; l--)
        if (i in de(e[l]))
          return true;
      return false;
    }, keys() {
      let i = [];
      for (let l = 0; l < e.length; l++)
        i.push(...Object.keys(de(e[l])));
      return [...new Set(i)];
    } }, ye);
  let s = {}, n = {}, r = /* @__PURE__ */ new Set();
  for (let i = e.length - 1; i >= 0; i--) {
    let l = e[i];
    if (!l)
      continue;
    let o = Object.getOwnPropertyNames(l);
    for (let f = 0, a = o.length; f < a; f++) {
      let c = o[f];
      if (c === "__proto__" || c === "constructor")
        continue;
      let g = Object.getOwnPropertyDescriptor(l, c);
      if (!r.has(c))
        g.get ? (r.add(c), Object.defineProperty(s, c, { enumerable: true, configurable: true, get: dt.bind(n[c] = [g.get.bind(l)]) })) : (g.value !== void 0 && r.add(c), s[c] = g.value);
      else {
        let p = n[c];
        p ? g.get ? p.push(g.get.bind(l)) : g.value !== void 0 && p.push(() => g.value) : s[c] === void 0 && (s[c] = g.value);
      }
    }
  }
  return s;
}
function Mt(e, ...t) {
  if (re in e) {
    let r = new Set(t.length > 1 ? t.flat() : t[0]), i = t.map((l) => new Proxy({ get(o) {
      return l.includes(o) ? e[o] : void 0;
    }, has(o) {
      return l.includes(o) && o in e;
    }, keys() {
      return l.filter((o) => o in e);
    } }, ye));
    return i.push(new Proxy({ get(l) {
      return r.has(l) ? void 0 : e[l];
    }, has(l) {
      return r.has(l) ? false : l in e;
    }, keys() {
      return Object.keys(e).filter((l) => !r.has(l));
    } }, ye)), i;
  }
  let s = {}, n = t.map(() => ({}));
  for (let r of Object.getOwnPropertyNames(e)) {
    let i = Object.getOwnPropertyDescriptor(e, r), l = !i.get && !i.set && i.enumerable && i.writable && i.configurable, o = false, f = 0;
    for (let a of t)
      a.includes(r) && (o = true, l ? n[f][r] = i.value : Object.defineProperty(n[f], r, i)), ++f;
    o || (l ? s[r] = i.value : Object.defineProperty(s, r, i));
  }
  return [...n, s];
}
function Vt(e) {
  let t, s, n = (r) => {
    let i = w.context;
    if (i) {
      let [o, f] = I();
      (s || (s = e())).then((a) => {
        L(i), f(() => a.default), L();
      }), t = o;
    } else if (!t) {
      let [o] = nt(() => (s || (s = e())).then((f) => f.default));
      t = o;
    }
    let l;
    return A(() => (l = t()) && k(() => {
      if (!i)
        return l(r);
      let o = w.context;
      L(i);
      let f = l(r);
      return L(o), f;
    }));
  };
  return n.preload = () => s || ((s = e()).then((r) => t = () => r.default), s), n;
}
var ht = 0;
function $t() {
  let e = w.context;
  return e ? `${e.id}${e.count++}` : `cl-${ht++}`;
}
var _e = (e) => `Stale read from <${e}>.`;
function qt(e) {
  let t = "fallback" in e && { fallback: () => e.fallback };
  return A(ft(() => e.each, e.children, t || void 0));
}
function Lt(e) {
  let t = "fallback" in e && { fallback: () => e.fallback };
  return A(at(() => e.each, e.children, t || void 0));
}
function Rt(e) {
  let t = e.keyed, s = A(() => e.when, void 0, { equals: (n, r) => t ? n === r : !n == !r });
  return A(() => {
    let n = s();
    if (n) {
      let r = e.children;
      return typeof r == "function" && r.length > 0 ? k(() => r(t ? n : () => {
        if (!k(s))
          throw _e("Show");
        return e.when;
      })) : r;
    }
    return e.fallback;
  }, void 0, void 0);
}
function Dt(e) {
  let t = false, s = (i, l) => i[0] === l[0] && (t ? i[1] === l[1] : !i[1] == !l[1]) && i[2] === l[2], n = $e(() => e.children), r = A(() => {
    let i = n();
    Array.isArray(i) || (i = [i]);
    for (let l = 0; l < i.length; l++) {
      let o = i[l].when;
      if (o)
        return t = !!i[l].keyed, [l, o, i[l]];
    }
    return [-1];
  }, void 0, { equals: s });
  return A(() => {
    let [i, l, o] = r();
    if (i < 0)
      return e.fallback;
    let f = o.children;
    return typeof f == "function" && f.length > 0 ? k(() => f(t ? l : () => {
      if (k(r)[0] !== i)
        throw _e("Match");
      return o.when;
    })) : f;
  }, void 0, void 0);
}
function Nt(e) {
  return e;
}
var Q;
function Ut() {
  Q && [...Q].forEach((e) => e());
}
function Wt(e) {
  let t, s;
  w.context && w.load && (s = w.load(w.context.id + w.context.count)) && (t = s[0]);
  let [n, r] = I(t, void 0);
  return Q || (Q = /* @__PURE__ */ new Set()), Q.add(r), N(() => Q.delete(r)), A(() => {
    let i;
    if (i = n()) {
      let l = e.fallback;
      return typeof l == "function" && l.length ? k(() => l(i, () => r())) : l;
    }
    return rt(() => e.children, r);
  }, void 0, void 0);
}
var gt = (e, t) => e.showContent === t.showContent && e.showFallback === t.showFallback, xe = Me();
function Ht(e) {
  let [t, s] = I(() => ({ inFallback: false })), n, r = Ve(xe), [i, l] = I([]);
  r && (n = r.register(A(() => t()().inFallback)));
  let o = A((f) => {
    let a = e.revealOrder, c = e.tail, { showContent: g = true, showFallback: p = true } = n ? n() : {}, b2 = i(), T = a === "backwards";
    if (a === "together") {
      let m = b2.every((C2) => !C2()), v2 = b2.map(() => ({ showContent: m && g, showFallback: p }));
      return v2.inFallback = !m, v2;
    }
    let O = false, F2 = f.inFallback, j = [];
    for (let m = 0, v2 = b2.length; m < v2; m++) {
      let C2 = T ? v2 - m - 1 : m, $2 = b2[C2]();
      if (!O && !$2)
        j[C2] = { showContent: g, showFallback: p };
      else {
        let R2 = !O;
        R2 && (F2 = true), j[C2] = { showContent: R2, showFallback: !c || R2 && c === "collapsed" ? p : false }, O = true;
      }
    }
    return O || (F2 = false), j.inFallback = F2, j;
  }, { inFallback: false });
  return s(() => o), He(xe.Provider, { value: { register: (f) => {
    let a;
    return l((c) => (a = c.length, [...c, f])), A(() => o()[a], void 0, { equals: gt });
  } }, get children() {
    return e.children;
  } });
}
function _t(e) {
  let t = 0, s, n, r, i, l, [o, f] = I(false), a = it(), c = { increment: () => {
    ++t === 1 && f(true);
  }, decrement: () => {
    --t === 0 && f(false);
  }, inFallback: o, effects: [], resolved: false }, g = je();
  if (w.context && w.load) {
    let T = w.context.id + w.context.count, O = w.load(T);
    if (O && (r = O[0]) && r !== "$$f") {
      (typeof r != "object" || !("then" in r)) && (r = Promise.resolve(r));
      let [F2, j] = I(void 0, { equals: false });
      i = F2, r.then((m) => {
        if (m || w.done)
          return m && (l = m), j();
        w.gather(T), L(n), j(), L();
      });
    }
  }
  let p = Ve(xe);
  p && (s = p.register(c.inFallback));
  let b2;
  return N(() => b2 && b2()), He(a.Provider, { value: c, get children() {
    return A(() => {
      if (l)
        throw l;
      if (n = w.context, i)
        return i(), i = void 0;
      n && r === "$$f" && L();
      let T = A(() => e.children);
      return A((O) => {
        let F2 = c.inFallback(), { showContent: j = true, showFallback: m = true } = s ? s() : {};
        if ((!F2 || r && r !== "$$f") && j)
          return c.resolved = true, b2 && b2(), b2 = n = r = void 0, st(c.effects), T();
        if (m)
          return b2 ? O : B((v2) => (b2 = v2, n && (L({ id: n.id + "f", count: 0 }), n = void 0), e.fallback), g);
      });
    });
  } });
}
var zt = void 0;

// http-url:https://esm.sh/stable/solid-js@1.7.7/esnext/web.js
var _2 = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"], F = /* @__PURE__ */ new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ..._2]), R = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]), U2 = Object.assign(/* @__PURE__ */ Object.create(null), { className: "class", htmlFor: "for" }), K2 = Object.assign(/* @__PURE__ */ Object.create(null), { class: "className", formnovalidate: { $: "formNoValidate", BUTTON: 1, INPUT: 1 }, ismap: { $: "isMap", IMG: 1 }, nomodule: { $: "noModule", SCRIPT: 1 }, playsinline: { $: "playsInline", VIDEO: 1 }, readonly: { $: "readOnly", INPUT: 1, TEXTAREA: 1 } });
function Y(n, t) {
  let e = K2[n];
  return typeof e == "object" ? e[t] ? e.$ : void 0 : e;
}
var X2 = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]), v = /* @__PURE__ */ new Set(["altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "linearGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "svg", "switch", "symbol", "text", "textPath", "tref", "tspan", "use", "view", "vkern"]), W2 = { xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace" }, ge2 = /* @__PURE__ */ new Set(["html", "base", "head", "link", "meta", "style", "title", "body", "address", "article", "aside", "footer", "header", "main", "nav", "section", "body", "blockquote", "dd", "div", "dl", "dt", "figcaption", "figure", "hr", "li", "ol", "p", "pre", "ul", "a", "abbr", "b", "bdi", "bdo", "br", "cite", "code", "data", "dfn", "em", "i", "kbd", "mark", "q", "rp", "rt", "ruby", "s", "samp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr", "area", "audio", "img", "map", "track", "video", "embed", "iframe", "object", "param", "picture", "portal", "source", "svg", "math", "canvas", "noscript", "script", "del", "ins", "caption", "col", "colgroup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "button", "datalist", "fieldset", "form", "input", "label", "legend", "meter", "optgroup", "option", "output", "progress", "select", "textarea", "details", "dialog", "menu", "summary", "details", "slot", "template", "acronym", "applet", "basefont", "bgsound", "big", "blink", "center", "content", "dir", "font", "frame", "frameset", "hgroup", "image", "keygen", "marquee", "menuitem", "nobr", "noembed", "noframes", "plaintext", "rb", "rtc", "shadow", "spacer", "strike", "tt", "xmp", "a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "portal", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp", "input", "h1", "h2", "h3", "h4", "h5", "h6"]);
function J2(n, t, e) {
  let i = e.length, s = t.length, r = i, l = 0, o = 0, f = t[s - 1].nextSibling, a = null;
  for (; l < s || o < r; ) {
    if (t[l] === e[o]) {
      l++, o++;
      continue;
    }
    for (; t[s - 1] === e[r - 1]; )
      s--, r--;
    if (s === l) {
      let u2 = r < i ? o ? e[o - 1].nextSibling : e[r - o] : f;
      for (; o < r; )
        n.insertBefore(e[o++], u2);
    } else if (r === o)
      for (; l < s; )
        (!a || !a.has(t[l])) && t[l].remove(), l++;
    else if (t[l] === e[r - 1] && e[o] === t[s - 1]) {
      let u2 = t[--s].nextSibling;
      n.insertBefore(e[o++], t[l++].nextSibling), n.insertBefore(e[--r], u2), t[s] = e[r];
    } else {
      if (!a) {
        a = /* @__PURE__ */ new Map();
        let d2 = o;
        for (; d2 < r; )
          a.set(e[d2], d2++);
      }
      let u2 = a.get(t[l]);
      if (u2 != null)
        if (o < u2 && u2 < r) {
          let d2 = l, m = 1, p;
          for (; ++d2 < s && d2 < r && !((p = a.get(t[d2])) == null || p !== u2 + m); )
            m++;
          if (m > u2 - o) {
            let j = t[l];
            for (; o < u2; )
              n.insertBefore(e[o++], j);
          } else
            n.replaceChild(e[o++], t[l++]);
        } else
          l++;
      else
        t[l++].remove();
    }
  }
}
var b = "_$DX_DELEGATE";
function Q2(n, t, e, i = {}) {
  let s;
  return B((r) => {
    s = r, t === document ? n() : S2(t, n(), t.firstChild ? null : void 0, e);
  }, i.owner), () => {
    s(), t.textContent = "";
  };
}
function ye2(n, t, e) {
  let i, s = () => {
    let l = document.createElement("template");
    return l.innerHTML = n, e ? l.content.firstChild.firstChild : l.content.firstChild;
  }, r = t ? () => k(() => document.importNode(i || (i = s()), true)) : () => (i || (i = s())).cloneNode(true);
  return r.cloneNode = r, r;
}
function Z2(n, t = window.document) {
  let e = t[b] || (t[b] = /* @__PURE__ */ new Set());
  for (let i = 0, s = n.length; i < s; i++) {
    let r = n[i];
    e.has(r) || (e.add(r), t.addEventListener(r, N2));
  }
}
function be2(n = window.document) {
  if (n[b]) {
    for (let t of n[b].keys())
      n.removeEventListener(t, N2);
    delete n[b];
  }
}
function x2(n, t, e) {
  e == null ? n.removeAttribute(t) : n.setAttribute(t, e);
}
function z2(n, t, e, i) {
  i == null ? n.removeAttributeNS(t, e) : n.setAttributeNS(t, e, i);
}
function ee2(n, t) {
  t == null ? n.removeAttribute("class") : n.className = t;
}
function te2(n, t, e, i) {
  if (i)
    Array.isArray(e) ? (n[`$$${t}`] = e[0], n[`$$${t}Data`] = e[1]) : n[`$$${t}`] = e;
  else if (Array.isArray(e)) {
    let s = e[0];
    n.addEventListener(t, e[0] = (r) => s.call(n, e[1], r));
  } else
    n.addEventListener(t, e);
}
function ne2(n, t, e = {}) {
  let i = Object.keys(t || {}), s = Object.keys(e), r, l;
  for (r = 0, l = s.length; r < l; r++) {
    let o = s[r];
    !o || o === "undefined" || t[o] || ($(n, o, false), delete e[o]);
  }
  for (r = 0, l = i.length; r < l; r++) {
    let o = i[r], f = !!t[o];
    !o || o === "undefined" || e[o] === f || !f || ($(n, o, true), e[o] = f);
  }
  return e;
}
function ie2(n, t, e) {
  if (!t)
    return e ? x2(n, "style") : t;
  let i = n.style;
  if (typeof t == "string")
    return i.cssText = t;
  typeof e == "string" && (i.cssText = e = void 0), e || (e = {}), t || (t = {});
  let s, r;
  for (r in e)
    t[r] == null && i.removeProperty(r), delete e[r];
  for (r in t)
    s = t[r], s !== e[r] && (i.setProperty(r, s), e[r] = s);
  return e;
}
function oe(n, t = {}, e, i) {
  let s = {};
  return i || tt(() => s.children = y(n, t.children, s.children)), tt(() => t.ref && t.ref(n)), tt(() => se2(n, t, e, true, s, true)), s;
}
function pe2(n, t) {
  let e = n[t];
  return Object.defineProperty(n, t, { get() {
    return e();
  }, enumerable: true }), n;
}
function we2(n, t) {
  !w.context && (n.innerHTML = t);
}
function xe2(n, t, e) {
  return k(() => n(t, e));
}
function S2(n, t, e, i) {
  if (e !== void 0 && !i && (i = []), typeof t != "function")
    return y(n, t, i, e);
  tt((s) => y(n, t(), s, e), i);
}
function se2(n, t, e, i, s = {}, r = false) {
  t || (t = {});
  for (let l in s)
    if (!(l in t)) {
      if (l === "children")
        continue;
      s[l] = L2(n, l, null, s[l], e, r);
    }
  for (let l in t) {
    if (l === "children") {
      i || y(n, t.children);
      continue;
    }
    let o = t[l];
    s[l] = L2(n, l, o, s[l], e, r);
  }
}
function re2(n, t, e = {}) {
  w.completed = globalThis._$HY.completed, w.events = globalThis._$HY.events, w.load = globalThis._$HY.load, w.gather = (s) => P(t, s), w.registry = /* @__PURE__ */ new Map(), w.context = { id: e.renderId || "", count: 0 }, P(t, e.renderId);
  let i = Q2(n, t, [...t.childNodes], e);
  return w.context = null, i;
}
function le2(n) {
  let t, e;
  if (!w.context || !(t = w.registry.get(e = ce()))) {
    if (w.context && console.warn("Unable to find DOM nodes for hydration key:", e), !n)
      throw new Error("Unrecoverable Hydration Mismatch. No template for key: " + e);
    return n();
  }
  return w.completed && w.completed.add(t), w.registry.delete(e), t;
}
function Se2(n, t) {
  for (; n && n.localName !== t; )
    n = n.nextSibling;
  return n;
}
function Ae2(n) {
  let t = n, e = 0, i = [];
  if (w.context)
    for (; t; ) {
      if (t.nodeType === 8) {
        let s = t.nodeValue;
        if (s === "#")
          e++;
        else if (s === "/") {
          if (e === 0)
            return [t, i];
          e--;
        }
      }
      i.push(t), t = t.nextSibling;
    }
  return [t, i];
}
function Ee2() {
  w.events && !w.events.queued && (queueMicrotask(() => {
    let { completed: n, events: t } = w;
    for (t.queued = false; t.length; ) {
      let [e, i] = t[0];
      if (!n.has(e))
        return;
      N2(i), t.shift();
    }
  }), w.events.queued = true);
}
function fe2(n) {
  return n.toLowerCase().replace(/-([a-z])/g, (t, e) => e.toUpperCase());
}
function $(n, t, e) {
  let i = t.trim().split(/\s+/);
  for (let s = 0, r = i.length; s < r; s++)
    n.classList.toggle(i[s], e);
}
function L2(n, t, e, i, s, r) {
  let l, o, f, a, u2;
  if (t === "style")
    return ie2(n, e, i);
  if (t === "classList")
    return ne2(n, e, i);
  if (e === i)
    return i;
  if (t === "ref")
    r || e(n);
  else if (t.slice(0, 3) === "on:") {
    let d2 = t.slice(3);
    i && n.removeEventListener(d2, i), e && n.addEventListener(d2, e);
  } else if (t.slice(0, 10) === "oncapture:") {
    let d2 = t.slice(10);
    i && n.removeEventListener(d2, i, true), e && n.addEventListener(d2, e, true);
  } else if (t.slice(0, 2) === "on") {
    let d2 = t.slice(2).toLowerCase(), m = X2.has(d2);
    if (!m && i) {
      let p = Array.isArray(i) ? i[0] : i;
      n.removeEventListener(d2, p);
    }
    (m || e) && (te2(n, d2, e, m), m && Z2([d2]));
  } else if (t.slice(0, 5) === "attr:")
    x2(n, t.slice(5), e);
  else if ((u2 = t.slice(0, 5) === "prop:") || (f = R.has(t)) || !s && ((a = Y(t, n.tagName)) || (o = F.has(t))) || (l = n.nodeName.includes("-")))
    u2 && (t = t.slice(5), o = true), t === "class" || t === "className" ? ee2(n, e) : l && !o && !f ? n[fe2(t)] = e : n[a || t] = e;
  else {
    let d2 = s && t.indexOf(":") > -1 && W2[t.split(":")[0]];
    d2 ? z2(n, d2, t, e) : x2(n, U2[t] || t, e);
  }
  return e;
}
function N2(n) {
  let t = `$$${n.type}`, e = n.composedPath && n.composedPath()[0] || n.target;
  for (n.target !== e && Object.defineProperty(n, "target", { configurable: true, value: e }), Object.defineProperty(n, "currentTarget", { configurable: true, get() {
    return e || document;
  } }), w.registry && !w.done && (w.done = _$HY.done = true); e; ) {
    let i = e[t];
    if (i && !e.disabled) {
      let s = e[`${t}Data`];
      if (s !== void 0 ? i.call(e, s, n) : i.call(e, n), n.cancelBubble)
        return;
    }
    e = e._$host || e.parentNode || e.host;
  }
}
function y(n, t, e, i, s) {
  if (w.context) {
    !e && (e = [...n.childNodes]);
    let o = [];
    for (let f = 0; f < e.length; f++) {
      let a = e[f];
      a.nodeType === 8 && a.data.slice(0, 2) === "!$" ? a.remove() : o.push(a);
    }
    e = o;
  }
  for (; typeof e == "function"; )
    e = e();
  if (t === e)
    return e;
  let r = typeof t, l = i !== void 0;
  if (n = l && e[0] && e[0].parentNode || n, r === "string" || r === "number") {
    if (w.context)
      return e;
    if (r === "number" && (t = t.toString()), l) {
      let o = e[0];
      o && o.nodeType === 3 ? o.data = t : o = document.createTextNode(t), e = h2(n, e, i, o);
    } else
      e !== "" && typeof e == "string" ? e = n.firstChild.data = t : e = n.textContent = t;
  } else if (t == null || r === "boolean") {
    if (w.context)
      return e;
    e = h2(n, e, i);
  } else {
    if (r === "function")
      return tt(() => {
        let o = t();
        for (; typeof o == "function"; )
          o = o();
        e = y(n, o, e, i);
      }), () => e;
    if (Array.isArray(t)) {
      let o = [], f = e && Array.isArray(e);
      if (A2(o, t, e, s))
        return tt(() => e = y(n, o, e, i, true)), () => e;
      if (w.context) {
        if (!o.length)
          return e;
        for (let a = 0; a < o.length; a++)
          if (o[a].parentNode)
            return e = o;
      }
      if (o.length === 0) {
        if (e = h2(n, e, i), l)
          return e;
      } else
        f ? e.length === 0 ? M2(n, o, i) : J2(n, e, o) : (e && h2(n), M2(n, o));
      e = o;
    } else if (t.nodeType) {
      if (w.context && t.parentNode)
        return e = l ? [t] : t;
      if (Array.isArray(e)) {
        if (l)
          return e = h2(n, e, i, t);
        h2(n, e, null, t);
      } else
        e == null || e === "" || !n.firstChild ? n.appendChild(t) : n.replaceChild(t, n.firstChild);
      e = t;
    } else
      console.warn("Unrecognized value. Skipped inserting", t);
  }
  return e;
}
function A2(n, t, e, i) {
  let s = false;
  for (let r = 0, l = t.length; r < l; r++) {
    let o = t[r], f = e && e[r], a;
    if (!(o == null || o === true || o === false))
      if ((a = typeof o) == "object" && o.nodeType)
        n.push(o);
      else if (Array.isArray(o))
        s = A2(n, o, f) || s;
      else if (a === "function")
        if (i) {
          for (; typeof o == "function"; )
            o = o();
          s = A2(n, Array.isArray(o) ? o : [o], Array.isArray(f) ? f : [f]) || s;
        } else
          n.push(o), s = true;
      else {
        let u2 = String(o);
        f && f.nodeType === 3 && f.data === u2 ? n.push(f) : n.push(document.createTextNode(u2));
      }
  }
  return s;
}
function M2(n, t, e = null) {
  for (let i = 0, s = t.length; i < s; i++)
    n.insertBefore(t[i], e);
}
function h2(n, t, e, i) {
  if (e === void 0)
    return n.textContent = "";
  let s = i || document.createTextNode("");
  if (t.length) {
    let r = false;
    for (let l = t.length - 1; l >= 0; l--) {
      let o = t[l];
      if (s !== o) {
        let f = o.parentNode === n;
        !r && !l ? f ? n.replaceChild(s, o) : n.insertBefore(s, e) : f && o.remove();
      } else
        r = true;
    }
  } else
    n.insertBefore(s, e);
  return [s];
}
function P(n, t) {
  let e = n.querySelectorAll("*[data-hk]");
  for (let i = 0; i < e.length; i++) {
    let s = e[i], r = s.getAttribute("data-hk");
    (!t || r.startsWith(t)) && !w.registry.has(r) && w.registry.set(r, s);
  }
}
function ce() {
  let n = w.context;
  return `${n.id}${n.count++}`;
}
function Ne2(n) {
  return w.context ? void 0 : n.children;
}
function Ce2(n) {
  return n.children;
}
function Te2() {
}
function C(n) {
  let t = new Error(`${n.name} is not supported in the browser, returning undefined`);
  console.error(t);
}
function ae2(n, t) {
  C(ae2);
}
function de2(n, t) {
  C(de2);
}
function ue2(n, t) {
  C(ue2);
}
function ke2(n, ...t) {
}
function $e2(n, t, e, i) {
}
function Le2(n) {
}
function Me2(n) {
}
function Pe2(n, t) {
}
function Oe2() {
}
function He2(n) {
}
function je2(n) {
}
function De2(n, t, e) {
}
var Ie2 = false, Be2 = false, me2 = "http://www.w3.org/2000/svg";
function H2(n, t = false) {
  return t ? document.createElementNS(me2, n) : document.createElement(n);
}
var qe2 = (...n) => (jt(), re2(...n));
function Ge2(n) {
  let { useShadow: t } = n, e = document.createTextNode(""), i = () => n.mount || document.body, s = je(), r, l = !!w.context;
  return Fe(() => {
    l && (je().user = l = false), r || (r = Ct(s, () => A(() => n.children)));
    let o = i();
    if (o instanceof HTMLHeadElement) {
      let [f, a] = I(false), u2 = () => a(true);
      B((d2) => S2(o, () => f() ? d2() : r(), null)), N(u2);
    } else {
      let f = H2(n.isSVG ? "g" : "div", n.isSVG), a = t && f.attachShadow ? f.attachShadow({ mode: "open" }) : f;
      Object.defineProperty(f, "_$host", { get() {
        return e.parentNode;
      }, configurable: true }), S2(a, r), o.appendChild(f), n.ref && n.ref(f), N(() => o.removeChild(f));
    }
  }, void 0, { render: !l }), e;
}
function Ve2(n) {
  let [t, e] = Mt(n, ["component"]), i = A(() => t.component);
  return A(() => {
    let s = i();
    switch (typeof s) {
      case "function":
        return Object.assign(s, { [wt]: true }), k(() => s(e));
      case "string":
        let r = v.has(s), l = w.context ? le2() : H2(s, r);
        return oe(l, e, r), l;
    }
  });
}

// _tmp/solid-shorty.jsx
var _tmpl$ = /* @__PURE__ */ template(`<div>The solidify shortcode is active!`);
function Solidify() {
  return _tmpl$();
}
Q2(() => createComponent(Solidify, {}), document.getElementById("shorty"));
</script>
  </template>
</is-land> 
<h2>The webC component</h2>
<p><tester></tester></p>
<h2>SolidJS</h2>
<p>A more interesting example</p>
<p id="wordapp"></p>
<script type="module" src="/11ty-solid-base/app/undefined"></script>
<div id="pdfapp"></div>
<script type="module" src="/11ty-solid-base/app/render-VZAL773I.min.js"></script>
<p>To do:</p>
<ul>
<li>A more complex webC example making use of:</li>
<li>bundling of webC with Solid-js</li>
<li>webC with scoped css</li>
<li>Solid-js web components/progressive enhancement example</li>
</ul>
<p>Look at <a href="https://www.11ty.dev/docs/languages/webc/">11ty docs</a> &amp; <a href="https://11ty.rocks/">11ty.rocks</a>.</p>

  </main>
</body>
</html>