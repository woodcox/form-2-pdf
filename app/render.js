(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "node_modules/pako/lib/utils/common.js"(exports) {
      "use strict";
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      function _has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (var p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf;
        }
        if (buf.subarray) {
          return buf.subarray(0, size);
        }
        buf.length = size;
        return buf;
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks);
        }
      };
      exports.setTyped = function(on2) {
        if (on2) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped);
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped);
        }
      };
      exports.setTyped(TYPED_OK);
    }
  });

  // node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "node_modules/pako/lib/zlib/trees.js"(exports) {
      "use strict";
      var utils = require_common();
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      );
      var extra_dbits = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      );
      var extra_blbits = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      );
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      }
      function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      }
      function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length;
        }
      }
      function send_code(s, c, tree) {
        send_bits(
          s,
          tree[c * 2],
          tree[c * 2 + 1]
          /*.Len*/
        );
      }
      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      }
      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      }
      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      }
      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      }
      function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      }
      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      }
      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      }
      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
      }
      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      }
      function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      }
      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
      }
      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[
            1
            /*SMALLEST*/
          ] = s.heap[s.heap_len--];
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
          m = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[
            1
            /*SMALLEST*/
          ] = node++;
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[
          1
          /*SMALLEST*/
        ];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      }
      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      }
      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      }
      function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      }
      var static_init_done = false;
      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      }
      function _tr_stored_block(s, buf, stored_len, last2) {
        send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
      }
      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      }
      function _tr_flush_block(s, buf, stored_len, last2) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last2);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last2) {
          bi_windup(s);
        }
      }
      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.last_lit === s.lit_bufsize - 1;
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align;
    }
  });

  // node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      }
      module.exports = adler32;
    }
  });

  // node_modules/pako/lib/zlib/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      }
      var crcTable = makeTable();
      function crc32(crc, buf, len, pos) {
        var t = crcTable, end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      }
      module.exports = crc32;
    }
  });

  // node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }
  });

  // node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "node_modules/pako/lib/zlib/deflate.js"(exports) {
      "use strict";
      var utils = require_common();
      var trees = require_trees();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var msg = require_messages();
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }
      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0);
      }
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      }
      function flush_block_only(s, last2) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      }
      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
      }
      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      }
      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      }
      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      }
      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      }
      function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      }
      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_huff(s, flush) {
        var bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table;
      configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),
        /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),
        /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),
        /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),
        /* 3 */
        new Config(4, 4, 16, 16, deflate_slow),
        /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),
        /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),
        /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),
        /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),
        /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)
        /* 9 max compression */
      ];
      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      }
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
      }
      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      }
      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      }
      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        var s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      }
      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      }
      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(
                s,
                (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
              );
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s);
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      }
      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      }
      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateSetDictionary = deflateSetDictionary;
      exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/pako/lib/utils/strings.js"(exports) {
      "use strict";
      var utils = require_common();
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (__) {
        STR_APPLY_OK = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new utils.Buf8(256);
      for (q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      _utf8len[254] = _utf8len[254] = 1;
      exports.string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new utils.Buf8(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i++] = c;
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          }
        }
        return buf;
      };
      function buf2binstring(buf, len) {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
          }
        }
        var result = "";
        for (var i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      }
      exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
      };
      exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i = 0, len = buf.length; i < len; i++) {
          buf[i] = str.charCodeAt(i);
        }
        return buf;
      };
      exports.buf2string = function(buf, max) {
        var i, out, c, c_len;
        var len = max || buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      exports.utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
      var q;
    }
  });

  // node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "node_modules/pako/lib/deflate.js"(exports) {
      "use strict";
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;
      function Deflate(options) {
        if (!(this instanceof Deflate))
          return new Deflate(options);
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(
          this.strm,
          opt.level,
          opt.method,
          opt.windowBits,
          opt.memLevel,
          opt.strategy
        );
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      exports.Deflate = Deflate;
      exports.deflate = deflate;
      exports.deflateRaw = deflateRaw;
      exports.gzip = gzip;
    }
  });

  // node_modules/pako/lib/zlib/inffast.js
  var require_inffast = __commonJS({
    "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
      "use strict";
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last2;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from2;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last2 = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from2 = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from2 += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from2++];
                              } while (--op);
                              from2 = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from2 += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from2++];
                              } while (--op);
                              from2 = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from2++];
                                } while (--op);
                                from2 = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from2 += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from2++];
                              } while (--op);
                              from2 = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from2++];
                            output[_out++] = from_source[from2++];
                            output[_out++] = from_source[from2++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from2++];
                            if (len > 1) {
                              output[_out++] = from_source[from2++];
                            }
                          }
                        } else {
                          from2 = _out - dist;
                          do {
                            output[_out++] = output[from2++];
                            output[_out++] = output[from2++];
                            output[_out++] = output[from2++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from2++];
                            if (len > 1) {
                              output[_out++] = output[from2++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last2 && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }
  });

  // node_modules/pako/lib/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
      "use strict";
      var utils = require_common();
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ];
      var lext = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ];
      var dbase = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ];
      var dext = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0, max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill2;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          base = dbase;
          extra = dext;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill2 = 1 << curr;
          min = fill2;
          do {
            fill2 -= incr;
            table[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill2 !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
    }
  });

  // node_modules/pako/lib/zlib/inflate.js
  var require_inflate = __commonJS({
    "node_modules/pako/lib/zlib/inflate.js"(exports) {
      "use strict";
      var utils = require_common();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var inflate_fast = require_inffast();
      var inflate_table = require_inftrees();
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      function zswap32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      }
      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      }
      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      }
      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      }
      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        state = new InflateState();
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      }
      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
      }
      var virgin = true;
      var lenfix, distfix;
      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      }
      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize);
        }
        if (copy >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy;
          }
          utils.arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;
          if (copy) {
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      }
      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy;
        var from2;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                state.flags = 0;
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || /* check if zlib header allowed */
                (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                } else if (len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << len;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 1024) {
                  copy = state.length;
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Array(state.head.extra_len);
                      }
                      utils.arraySet(
                        state.head.extra,
                        input,
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        copy,
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        len
                      );
                    }
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    state.length -= copy;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy = state.length;
                if (copy) {
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  if (copy === 0) {
                    break inf_leave;
                  }
                  utils.arraySet(output, input, next, copy, put);
                  have -= copy;
                  next += copy;
                  left -= copy;
                  put += copy;
                  state.length -= copy;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                  copy = state.offset - copy;
                  if (copy > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy > state.wnext) {
                    copy -= state.wnext;
                    from2 = state.wsize - copy;
                  } else {
                    from2 = state.wnext - copy;
                  }
                  if (copy > state.length) {
                    copy = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from2 = put - state.offset;
                  copy = state.length;
                }
                if (copy > left) {
                  copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                  output[put++] = from_source[from2++];
                } while (--copy);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (_out) {
                    strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                    state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      }
      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        var state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      }
      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      }
      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      }
      exports.inflateReset = inflateReset;
      exports.inflateReset2 = inflateReset2;
      exports.inflateResetKeep = inflateResetKeep;
      exports.inflateInit = inflateInit;
      exports.inflateInit2 = inflateInit2;
      exports.inflate = inflate;
      exports.inflateEnd = inflateEnd;
      exports.inflateGetHeader = inflateGetHeader;
      exports.inflateSetDictionary = inflateSetDictionary;
      exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/zlib/constants.js
  var require_constants = __commonJS({
    "node_modules/pako/lib/zlib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }
  });

  // node_modules/pako/lib/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
      "use strict";
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }
  });

  // node_modules/pako/lib/inflate.js
  var require_inflate2 = __commonJS({
    "node_modules/pako/lib/inflate.js"(exports) {
      "use strict";
      var zlib_inflate = require_inflate();
      var utils = require_common();
      var strings = require_strings();
      var c = require_constants();
      var msg = require_messages();
      var ZStream = require_zstream();
      var GZheader = require_gzheader();
      var toString = Object.prototype.toString;
      function Inflate(options) {
        if (!(this instanceof Inflate))
          return new Inflate(options);
        this.options = utils.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_inflate.inflateInit2(
          this.strm,
          opt.windowBits
        );
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== c.Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var dictionary = this.options.dictionary;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        var allowBufError = false;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.binstring2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
          if (status === c.Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
          }
          if (status === c.Z_BUF_ERROR && allowBufError === true) {
            status = c.Z_OK;
            allowBufError = false;
          }
          if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                tail = strm.next_out - next_out_utf8;
                utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail) {
                  utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                }
                this.onData(utf8str);
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          }
          if (strm.avail_in === 0 && strm.avail_out === 0) {
            allowBufError = true;
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
        if (status === c.Z_STREAM_END) {
          _mode = c.Z_FINISH;
        }
        if (_mode === c.Z_FINISH) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === c.Z_OK;
        }
        if (_mode === c.Z_SYNC_FLUSH) {
          this.onEnd(c.Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === c.Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        var inflator = new Inflate(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg || msg[inflator.err];
        }
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      exports.Inflate = Inflate;
      exports.inflate = inflate;
      exports.inflateRaw = inflateRaw;
      exports.ungzip = inflate;
    }
  });

  // node_modules/pako/index.js
  var require_pako = __commonJS({
    "node_modules/pako/index.js"(exports, module) {
      "use strict";
      var assign2 = require_common().assign;
      var deflate = require_deflate2();
      var inflate = require_inflate2();
      var constants = require_constants();
      var pako5 = {};
      assign2(pako5, deflate, inflate, constants);
      module.exports = pako5;
    }
  });

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      module.exports = function equal(a, b) {
        if (a === b)
          return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor)
            return false;
          var length, i, keys;
          if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length)
              return false;
            for (i = length; i-- !== 0; )
              if (!equal(a[i], b[i]))
                return false;
            return true;
          }
          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString();
          keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length)
            return false;
          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
              return false;
          for (i = length; i-- !== 0; ) {
            var key = keys[i];
            if (!equal(a[key], b[key]))
              return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength2;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup4 = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup4[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength2(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup4[num >> 18 & 63] + lookup4[num >> 12 & 63] + lookup4[num >> 6 & 63] + lookup4[num & 63];
      }
      function encodeChunk(uint82, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint82[i2] << 16 & 16711680) + (uint82[i2 + 1] << 8 & 65280) + (uint82[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint82) {
        var tmp;
        var len2 = uint82.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint82, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint82[len2 - 1];
          parts.push(
            lookup4[tmp >> 2] + lookup4[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
          parts.push(
            lookup4[tmp >> 10] + lookup4[tmp >> 4 & 63] + lookup4[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
      var i;
      var len;
    }
  });

  // node_modules/tiny-inflate/index.js
  var require_tiny_inflate = __commonJS({
    "node_modules/tiny-inflate/index.js"(exports, module) {
      var TINF_OK = 0;
      var TINF_DATA_ERROR = -3;
      function Tree() {
        this.table = new Uint16Array(16);
        this.trans = new Uint16Array(288);
      }
      function Data(source, dest) {
        this.source = source;
        this.sourceIndex = 0;
        this.tag = 0;
        this.bitcount = 0;
        this.dest = dest;
        this.destLen = 0;
        this.ltree = new Tree();
        this.dtree = new Tree();
      }
      var sltree = new Tree();
      var sdtree = new Tree();
      var length_bits = new Uint8Array(30);
      var length_base = new Uint16Array(30);
      var dist_bits = new Uint8Array(30);
      var dist_base = new Uint16Array(30);
      var clcidx = new Uint8Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      ]);
      var code_tree = new Tree();
      var lengths = new Uint8Array(288 + 32);
      function tinf_build_bits_base(bits, base, delta, first) {
        var i, sum2;
        for (i = 0; i < delta; ++i)
          bits[i] = 0;
        for (i = 0; i < 30 - delta; ++i)
          bits[i + delta] = i / delta | 0;
        for (sum2 = first, i = 0; i < 30; ++i) {
          base[i] = sum2;
          sum2 += 1 << bits[i];
        }
      }
      function tinf_build_fixed_trees(lt, dt) {
        var i;
        for (i = 0; i < 7; ++i)
          lt.table[i] = 0;
        lt.table[7] = 24;
        lt.table[8] = 152;
        lt.table[9] = 112;
        for (i = 0; i < 24; ++i)
          lt.trans[i] = 256 + i;
        for (i = 0; i < 144; ++i)
          lt.trans[24 + i] = i;
        for (i = 0; i < 8; ++i)
          lt.trans[24 + 144 + i] = 280 + i;
        for (i = 0; i < 112; ++i)
          lt.trans[24 + 144 + 8 + i] = 144 + i;
        for (i = 0; i < 5; ++i)
          dt.table[i] = 0;
        dt.table[5] = 32;
        for (i = 0; i < 32; ++i)
          dt.trans[i] = i;
      }
      var offs = new Uint16Array(16);
      function tinf_build_tree(t, lengths2, off, num) {
        var i, sum2;
        for (i = 0; i < 16; ++i)
          t.table[i] = 0;
        for (i = 0; i < num; ++i)
          t.table[lengths2[off + i]]++;
        t.table[0] = 0;
        for (sum2 = 0, i = 0; i < 16; ++i) {
          offs[i] = sum2;
          sum2 += t.table[i];
        }
        for (i = 0; i < num; ++i) {
          if (lengths2[off + i])
            t.trans[offs[lengths2[off + i]]++] = i;
        }
      }
      function tinf_getbit(d) {
        if (!d.bitcount--) {
          d.tag = d.source[d.sourceIndex++];
          d.bitcount = 7;
        }
        var bit = d.tag & 1;
        d.tag >>>= 1;
        return bit;
      }
      function tinf_read_bits(d, num, base) {
        if (!num)
          return base;
        while (d.bitcount < 24) {
          d.tag |= d.source[d.sourceIndex++] << d.bitcount;
          d.bitcount += 8;
        }
        var val = d.tag & 65535 >>> 16 - num;
        d.tag >>>= num;
        d.bitcount -= num;
        return val + base;
      }
      function tinf_decode_symbol(d, t) {
        while (d.bitcount < 24) {
          d.tag |= d.source[d.sourceIndex++] << d.bitcount;
          d.bitcount += 8;
        }
        var sum2 = 0, cur = 0, len = 0;
        var tag = d.tag;
        do {
          cur = 2 * cur + (tag & 1);
          tag >>>= 1;
          ++len;
          sum2 += t.table[len];
          cur -= t.table[len];
        } while (cur >= 0);
        d.tag = tag;
        d.bitcount -= len;
        return t.trans[sum2 + cur];
      }
      function tinf_decode_trees(d, lt, dt) {
        var hlit, hdist, hclen;
        var i, num, length;
        hlit = tinf_read_bits(d, 5, 257);
        hdist = tinf_read_bits(d, 5, 1);
        hclen = tinf_read_bits(d, 4, 4);
        for (i = 0; i < 19; ++i)
          lengths[i] = 0;
        for (i = 0; i < hclen; ++i) {
          var clen = tinf_read_bits(d, 3, 0);
          lengths[clcidx[i]] = clen;
        }
        tinf_build_tree(code_tree, lengths, 0, 19);
        for (num = 0; num < hlit + hdist; ) {
          var sym = tinf_decode_symbol(d, code_tree);
          switch (sym) {
            case 16:
              var prev = lengths[num - 1];
              for (length = tinf_read_bits(d, 2, 3); length; --length) {
                lengths[num++] = prev;
              }
              break;
            case 17:
              for (length = tinf_read_bits(d, 3, 3); length; --length) {
                lengths[num++] = 0;
              }
              break;
            case 18:
              for (length = tinf_read_bits(d, 7, 11); length; --length) {
                lengths[num++] = 0;
              }
              break;
            default:
              lengths[num++] = sym;
              break;
          }
        }
        tinf_build_tree(lt, lengths, 0, hlit);
        tinf_build_tree(dt, lengths, hlit, hdist);
      }
      function tinf_inflate_block_data(d, lt, dt) {
        while (1) {
          var sym = tinf_decode_symbol(d, lt);
          if (sym === 256) {
            return TINF_OK;
          }
          if (sym < 256) {
            d.dest[d.destLen++] = sym;
          } else {
            var length, dist, offs2;
            var i;
            sym -= 257;
            length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
            dist = tinf_decode_symbol(d, dt);
            offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
            for (i = offs2; i < offs2 + length; ++i) {
              d.dest[d.destLen++] = d.dest[i];
            }
          }
        }
      }
      function tinf_inflate_uncompressed_block(d) {
        var length, invlength;
        var i;
        while (d.bitcount > 8) {
          d.sourceIndex--;
          d.bitcount -= 8;
        }
        length = d.source[d.sourceIndex + 1];
        length = 256 * length + d.source[d.sourceIndex];
        invlength = d.source[d.sourceIndex + 3];
        invlength = 256 * invlength + d.source[d.sourceIndex + 2];
        if (length !== (~invlength & 65535))
          return TINF_DATA_ERROR;
        d.sourceIndex += 4;
        for (i = length; i; --i)
          d.dest[d.destLen++] = d.source[d.sourceIndex++];
        d.bitcount = 0;
        return TINF_OK;
      }
      function tinf_uncompress(source, dest) {
        var d = new Data(source, dest);
        var bfinal, btype, res;
        do {
          bfinal = tinf_getbit(d);
          btype = tinf_read_bits(d, 2, 0);
          switch (btype) {
            case 0:
              res = tinf_inflate_uncompressed_block(d);
              break;
            case 1:
              res = tinf_inflate_block_data(d, sltree, sdtree);
              break;
            case 2:
              tinf_decode_trees(d, d.ltree, d.dtree);
              res = tinf_inflate_block_data(d, d.ltree, d.dtree);
              break;
            default:
              res = TINF_DATA_ERROR;
          }
          if (res !== TINF_OK)
            throw new Error("Data error");
        } while (!bfinal);
        if (d.destLen < d.dest.length) {
          if (typeof d.dest.slice === "function")
            return d.dest.slice(0, d.destLen);
          else
            return d.dest.subarray(0, d.destLen);
        }
        return d.dest;
      }
      tinf_build_fixed_trees(sltree, sdtree);
      tinf_build_bits_base(length_bits, length_base, 4, 3);
      tinf_build_bits_base(dist_bits, dist_base, 2, 1);
      length_bits[28] = 0;
      length_base[28] = 258;
      module.exports = tinf_uncompress;
    }
  });

  // node_modules/unicode-trie/swap.js
  var require_swap = __commonJS({
    "node_modules/unicode-trie/swap.js"(exports, module) {
      var isBigEndian2 = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
      var swap = (b, n, m) => {
        let i = b[n];
        b[n] = b[m];
        b[m] = i;
      };
      var swap32 = (array) => {
        const len = array.length;
        for (let i = 0; i < len; i += 4) {
          swap(array, i, i + 3);
          swap(array, i + 1, i + 2);
        }
      };
      var swap32LE = (array) => {
        if (isBigEndian2) {
          swap32(array);
        }
      };
      module.exports = {
        swap32LE
      };
    }
  });

  // node_modules/unicode-trie/index.js
  var require_unicode_trie = __commonJS({
    "node_modules/unicode-trie/index.js"(exports, module) {
      var inflate = require_tiny_inflate();
      var { swap32LE } = require_swap();
      var SHIFT_1 = 6 + 5;
      var SHIFT_2 = 5;
      var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
      var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
      var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
      var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
      var INDEX_SHIFT = 2;
      var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
      var DATA_MASK = DATA_BLOCK_LENGTH - 1;
      var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
      var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
      var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
      var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
      var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
      var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
      var DATA_GRANULARITY = 1 << INDEX_SHIFT;
      var UnicodeTrie = class {
        constructor(data) {
          const isBuffer = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
          if (isBuffer || data instanceof Uint8Array) {
            let uncompressedLength;
            if (isBuffer) {
              this.highStart = data.readUInt32LE(0);
              this.errorValue = data.readUInt32LE(4);
              uncompressedLength = data.readUInt32LE(8);
              data = data.slice(12);
            } else {
              const view = new DataView(data.buffer);
              this.highStart = view.getUint32(0, true);
              this.errorValue = view.getUint32(4, true);
              uncompressedLength = view.getUint32(8, true);
              data = data.subarray(12);
            }
            data = inflate(data, new Uint8Array(uncompressedLength));
            data = inflate(data, new Uint8Array(uncompressedLength));
            swap32LE(data);
            this.data = new Uint32Array(data.buffer);
          } else {
            ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);
          }
        }
        get(codePoint) {
          let index;
          if (codePoint < 0 || codePoint > 1114111) {
            return this.errorValue;
          }
          if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
            index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
            return this.data[index];
          }
          if (codePoint <= 65535) {
            index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
            return this.data[index];
          }
          if (codePoint < this.highStart) {
            index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
            index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
            index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
            return this.data[index];
          }
          return this.data[this.data.length - DATA_GRANULARITY];
        }
      };
      module.exports = UnicodeTrie;
    }
  });

  // node_modules/dfa/index.js
  var require_dfa = __commonJS({
    "node_modules/dfa/index.js"(exports, module) {
      "use strict";
      var INITIAL_STATE = 1;
      var FAIL_STATE = 0;
      var StateMachine = class {
        constructor(dfa) {
          this.stateTable = dfa.stateTable;
          this.accepting = dfa.accepting;
          this.tags = dfa.tags;
        }
        /**
         * Returns an iterable object that yields pattern matches over the input sequence.
         * Matches are of the form [startIndex, endIndex, tags].
         */
        match(str) {
          var self = this;
          return {
            *[Symbol.iterator]() {
              var state = INITIAL_STATE;
              var startRun = null;
              var lastAccepting = null;
              var lastState = null;
              for (var p = 0; p < str.length; p++) {
                var c = str[p];
                lastState = state;
                state = self.stateTable[state][c];
                if (state === FAIL_STATE) {
                  if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                    yield [startRun, lastAccepting, self.tags[lastState]];
                  }
                  state = self.stateTable[INITIAL_STATE][c];
                  startRun = null;
                }
                if (state !== FAIL_STATE && startRun == null) {
                  startRun = p;
                }
                if (self.accepting[state]) {
                  lastAccepting = p;
                }
                if (state === FAIL_STATE) {
                  state = INITIAL_STATE;
                }
              }
              if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                yield [startRun, lastAccepting, self.tags[state]];
              }
            }
          };
        }
        /**
         * For each match over the input sequence, action functions matching
         * the tag definitions in the input pattern are called with the startIndex,
         * endIndex, and sub-match sequence.
         */
        apply(str, actions) {
          for (var [start, end, tags] of this.match(str)) {
            for (var tag of tags) {
              if (typeof actions[tag] === "function") {
                actions[tag](start, end, str.slice(start, end + 1));
              }
            }
          }
        }
      };
      module.exports = StateMachine;
    }
  });

  // node_modules/clone/clone.js
  var require_clone = __commonJS({
    "node_modules/clone/clone.js"(exports, module) {
      var clone = function() {
        "use strict";
        function _instanceof(obj, type) {
          return type != null && obj instanceof type;
        }
        var nativeMap;
        try {
          nativeMap = Map;
        } catch (_) {
          nativeMap = function() {
          };
        }
        var nativeSet;
        try {
          nativeSet = Set;
        } catch (_) {
          nativeSet = function() {
          };
        }
        var nativePromise;
        try {
          nativePromise = Promise;
        } catch (_) {
          nativePromise = function() {
          };
        }
        function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
          if (typeof circular === "object") {
            depth = circular.depth;
            prototype = circular.prototype;
            includeNonEnumerable = circular.includeNonEnumerable;
            circular = circular.circular;
          }
          var allParents = [];
          var allChildren = [];
          var useBuffer = typeof Buffer != "undefined";
          if (typeof circular == "undefined")
            circular = true;
          if (typeof depth == "undefined")
            depth = Infinity;
          function _clone(parent2, depth2) {
            if (parent2 === null)
              return null;
            if (depth2 === 0)
              return parent2;
            var child;
            var proto;
            if (typeof parent2 != "object") {
              return parent2;
            }
            if (_instanceof(parent2, nativeMap)) {
              child = new nativeMap();
            } else if (_instanceof(parent2, nativeSet)) {
              child = new nativeSet();
            } else if (_instanceof(parent2, nativePromise)) {
              child = new nativePromise(function(resolve, reject) {
                parent2.then(function(value) {
                  resolve(_clone(value, depth2 - 1));
                }, function(err) {
                  reject(_clone(err, depth2 - 1));
                });
              });
            } else if (clone2.__isArray(parent2)) {
              child = [];
            } else if (clone2.__isRegExp(parent2)) {
              child = new RegExp(parent2.source, __getRegExpFlags(parent2));
              if (parent2.lastIndex)
                child.lastIndex = parent2.lastIndex;
            } else if (clone2.__isDate(parent2)) {
              child = new Date(parent2.getTime());
            } else if (useBuffer && Buffer.isBuffer(parent2)) {
              if (Buffer.allocUnsafe) {
                child = Buffer.allocUnsafe(parent2.length);
              } else {
                child = new Buffer(parent2.length);
              }
              parent2.copy(child);
              return child;
            } else if (_instanceof(parent2, Error)) {
              child = Object.create(parent2);
            } else {
              if (typeof prototype == "undefined") {
                proto = Object.getPrototypeOf(parent2);
                child = Object.create(proto);
              } else {
                child = Object.create(prototype);
                proto = prototype;
              }
            }
            if (circular) {
              var index = allParents.indexOf(parent2);
              if (index != -1) {
                return allChildren[index];
              }
              allParents.push(parent2);
              allChildren.push(child);
            }
            if (_instanceof(parent2, nativeMap)) {
              parent2.forEach(function(value, key) {
                var keyChild = _clone(key, depth2 - 1);
                var valueChild = _clone(value, depth2 - 1);
                child.set(keyChild, valueChild);
              });
            }
            if (_instanceof(parent2, nativeSet)) {
              parent2.forEach(function(value) {
                var entryChild = _clone(value, depth2 - 1);
                child.add(entryChild);
              });
            }
            for (var i in parent2) {
              var attrs;
              if (proto) {
                attrs = Object.getOwnPropertyDescriptor(proto, i);
              }
              if (attrs && attrs.set == null) {
                continue;
              }
              child[i] = _clone(parent2[i], depth2 - 1);
            }
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(parent2);
              for (var i = 0; i < symbols.length; i++) {
                var symbol2 = symbols[i];
                var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol2);
                if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                  continue;
                }
                child[symbol2] = _clone(parent2[symbol2], depth2 - 1);
                if (!descriptor.enumerable) {
                  Object.defineProperty(child, symbol2, {
                    enumerable: false
                  });
                }
              }
            }
            if (includeNonEnumerable) {
              var allPropertyNames = Object.getOwnPropertyNames(parent2);
              for (var i = 0; i < allPropertyNames.length; i++) {
                var propertyName = allPropertyNames[i];
                var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
                if (descriptor && descriptor.enumerable) {
                  continue;
                }
                child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
                Object.defineProperty(child, propertyName, {
                  enumerable: false
                });
              }
            }
            return child;
          }
          return _clone(parent, depth);
        }
        clone2.clonePrototype = function clonePrototype(parent) {
          if (parent === null)
            return null;
          var c = function() {
          };
          c.prototype = parent;
          return new c();
        };
        function __objToStr(o) {
          return Object.prototype.toString.call(o);
        }
        clone2.__objToStr = __objToStr;
        function __isDate(o) {
          return typeof o === "object" && __objToStr(o) === "[object Date]";
        }
        clone2.__isDate = __isDate;
        function __isArray(o) {
          return typeof o === "object" && __objToStr(o) === "[object Array]";
        }
        clone2.__isArray = __isArray;
        function __isRegExp(o) {
          return typeof o === "object" && __objToStr(o) === "[object RegExp]";
        }
        clone2.__isRegExp = __isRegExp;
        function __getRegExpFlags(re) {
          var flags = "";
          if (re.global)
            flags += "g";
          if (re.ignoreCase)
            flags += "i";
          if (re.multiline)
            flags += "m";
          return flags;
        }
        clone2.__getRegExpFlags = __getRegExpFlags;
        return clone2;
      }();
      if (typeof module === "object" && module.exports) {
        module.exports = clone;
      }
    }
  });

  // node_modules/brotli/dec/streams.js
  var require_streams = __commonJS({
    "node_modules/brotli/dec/streams.js"(exports) {
      function BrotliInput(buffer) {
        this.buffer = buffer;
        this.pos = 0;
      }
      BrotliInput.prototype.read = function(buf, i, count) {
        if (this.pos + count > this.buffer.length) {
          count = this.buffer.length - this.pos;
        }
        for (var p = 0; p < count; p++)
          buf[i + p] = this.buffer[this.pos + p];
        this.pos += count;
        return count;
      };
      exports.BrotliInput = BrotliInput;
      function BrotliOutput(buf) {
        this.buffer = buf;
        this.pos = 0;
      }
      BrotliOutput.prototype.write = function(buf, count) {
        if (this.pos + count > this.buffer.length)
          throw new Error("Output buffer is not large enough");
        this.buffer.set(buf.subarray(0, count), this.pos);
        this.pos += count;
        return count;
      };
      exports.BrotliOutput = BrotliOutput;
    }
  });

  // node_modules/brotli/dec/bit_reader.js
  var require_bit_reader = __commonJS({
    "node_modules/brotli/dec/bit_reader.js"(exports, module) {
      var BROTLI_READ_SIZE = 4096;
      var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
      var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
      var kBitMask = new Uint32Array([
        0,
        1,
        3,
        7,
        15,
        31,
        63,
        127,
        255,
        511,
        1023,
        2047,
        4095,
        8191,
        16383,
        32767,
        65535,
        131071,
        262143,
        524287,
        1048575,
        2097151,
        4194303,
        8388607,
        16777215
      ]);
      function BrotliBitReader(input) {
        this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
        this.input_ = input;
        this.reset();
      }
      BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
      BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
      BrotliBitReader.prototype.reset = function() {
        this.buf_ptr_ = 0;
        this.val_ = 0;
        this.pos_ = 0;
        this.bit_pos_ = 0;
        this.bit_end_pos_ = 0;
        this.eos_ = 0;
        this.readMoreInput();
        for (var i = 0; i < 4; i++) {
          this.val_ |= this.buf_[this.pos_] << 8 * i;
          ++this.pos_;
        }
        return this.bit_end_pos_ > 0;
      };
      BrotliBitReader.prototype.readMoreInput = function() {
        if (this.bit_end_pos_ > 256) {
          return;
        } else if (this.eos_) {
          if (this.bit_pos_ > this.bit_end_pos_)
            throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
        } else {
          var dst = this.buf_ptr_;
          var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
          if (bytes_read < 0) {
            throw new Error("Unexpected end of input");
          }
          if (bytes_read < BROTLI_READ_SIZE) {
            this.eos_ = 1;
            for (var p = 0; p < 32; p++)
              this.buf_[dst + bytes_read + p] = 0;
          }
          if (dst === 0) {
            for (var p = 0; p < 32; p++)
              this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];
            this.buf_ptr_ = BROTLI_READ_SIZE;
          } else {
            this.buf_ptr_ = 0;
          }
          this.bit_end_pos_ += bytes_read << 3;
        }
      };
      BrotliBitReader.prototype.fillBitWindow = function() {
        while (this.bit_pos_ >= 8) {
          this.val_ >>>= 8;
          this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
          ++this.pos_;
          this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
          this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
        }
      };
      BrotliBitReader.prototype.readBits = function(n_bits) {
        if (32 - this.bit_pos_ < n_bits) {
          this.fillBitWindow();
        }
        var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
        this.bit_pos_ += n_bits;
        return val;
      };
      module.exports = BrotliBitReader;
    }
  });

  // node_modules/brotli/dec/dictionary.bin.js
  var require_dictionary_bin = __commonJS({
    "node_modules/brotli/dec/dictionary.bin.js"(exports, module) {
      module.exports = "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";
    }
  });

  // node_modules/brotli/dec/dictionary-browser.js
  var require_dictionary_browser = __commonJS({
    "node_modules/brotli/dec/dictionary-browser.js"(exports) {
      var base64 = require_base64_js();
      exports.init = function() {
        var BrotliDecompressBuffer = require_decode().BrotliDecompressBuffer;
        var compressed = base64.toByteArray(require_dictionary_bin());
        return BrotliDecompressBuffer(compressed);
      };
    }
  });

  // node_modules/brotli/dec/dictionary.js
  var require_dictionary = __commonJS({
    "node_modules/brotli/dec/dictionary.js"(exports) {
      var data = require_dictionary_browser();
      exports.init = function() {
        exports.dictionary = data.init();
      };
      exports.offsetsByLength = new Uint32Array([
        0,
        0,
        0,
        0,
        0,
        4096,
        9216,
        21504,
        35840,
        44032,
        53248,
        63488,
        74752,
        87040,
        93696,
        100864,
        104704,
        106752,
        108928,
        113536,
        115968,
        118528,
        119872,
        121280,
        122016
      ]);
      exports.sizeBitsByLength = new Uint8Array([
        0,
        0,
        0,
        0,
        10,
        10,
        11,
        11,
        10,
        10,
        10,
        10,
        10,
        9,
        9,
        8,
        7,
        7,
        8,
        7,
        7,
        6,
        6,
        5,
        5
      ]);
      exports.minDictionaryWordLength = 4;
      exports.maxDictionaryWordLength = 24;
    }
  });

  // node_modules/brotli/dec/huffman.js
  var require_huffman = __commonJS({
    "node_modules/brotli/dec/huffman.js"(exports) {
      function HuffmanCode(bits, value) {
        this.bits = bits;
        this.value = value;
      }
      exports.HuffmanCode = HuffmanCode;
      var MAX_LENGTH = 15;
      function GetNextKey(key, len) {
        var step = 1 << len - 1;
        while (key & step) {
          step >>= 1;
        }
        return (key & step - 1) + step;
      }
      function ReplicateValue(table, i, step, end, code) {
        do {
          end -= step;
          table[i + end] = new HuffmanCode(code.bits, code.value);
        } while (end > 0);
      }
      function NextTableBitSize(count, len, root_bits) {
        var left = 1 << len - root_bits;
        while (len < MAX_LENGTH) {
          left -= count[len];
          if (left <= 0)
            break;
          ++len;
          left <<= 1;
        }
        return len - root_bits;
      }
      exports.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
        var start_table = table;
        var code;
        var len;
        var symbol2;
        var key;
        var step;
        var low;
        var mask;
        var table_bits;
        var table_size;
        var total_size;
        var sorted;
        var count = new Int32Array(MAX_LENGTH + 1);
        var offset = new Int32Array(MAX_LENGTH + 1);
        sorted = new Int32Array(code_lengths_size);
        for (symbol2 = 0; symbol2 < code_lengths_size; symbol2++) {
          count[code_lengths[symbol2]]++;
        }
        offset[1] = 0;
        for (len = 1; len < MAX_LENGTH; len++) {
          offset[len + 1] = offset[len] + count[len];
        }
        for (symbol2 = 0; symbol2 < code_lengths_size; symbol2++) {
          if (code_lengths[symbol2] !== 0) {
            sorted[offset[code_lengths[symbol2]]++] = symbol2;
          }
        }
        table_bits = root_bits;
        table_size = 1 << table_bits;
        total_size = table_size;
        if (offset[MAX_LENGTH] === 1) {
          for (key = 0; key < total_size; ++key) {
            root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
          }
          return total_size;
        }
        key = 0;
        symbol2 = 0;
        for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
          for (; count[len] > 0; --count[len]) {
            code = new HuffmanCode(len & 255, sorted[symbol2++] & 65535);
            ReplicateValue(root_table, table + key, step, table_size, code);
            key = GetNextKey(key, len);
          }
        }
        mask = total_size - 1;
        low = -1;
        for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
          for (; count[len] > 0; --count[len]) {
            if ((key & mask) !== low) {
              table += table_size;
              table_bits = NextTableBitSize(count, len, root_bits);
              table_size = 1 << table_bits;
              total_size += table_size;
              low = key & mask;
              root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
            }
            code = new HuffmanCode(len - root_bits & 255, sorted[symbol2++] & 65535);
            ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
            key = GetNextKey(key, len);
          }
        }
        return total_size;
      };
    }
  });

  // node_modules/brotli/dec/context.js
  var require_context = __commonJS({
    "node_modules/brotli/dec/context.js"(exports) {
      var CONTEXT_LSB6 = 0;
      var CONTEXT_MSB6 = 1;
      var CONTEXT_UTF8 = 2;
      var CONTEXT_SIGNED = 3;
      exports.lookup = new Uint8Array([
        /* CONTEXT_UTF8, last byte. */
        /* ASCII range. */
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        4,
        4,
        0,
        0,
        4,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        8,
        12,
        16,
        12,
        12,
        20,
        12,
        16,
        24,
        28,
        12,
        12,
        32,
        12,
        36,
        12,
        44,
        44,
        44,
        44,
        44,
        44,
        44,
        44,
        44,
        44,
        32,
        32,
        24,
        40,
        28,
        12,
        12,
        48,
        52,
        52,
        52,
        48,
        52,
        52,
        52,
        48,
        52,
        52,
        52,
        52,
        52,
        48,
        52,
        52,
        52,
        52,
        52,
        48,
        52,
        52,
        52,
        52,
        52,
        24,
        12,
        28,
        12,
        12,
        12,
        56,
        60,
        60,
        60,
        56,
        60,
        60,
        60,
        56,
        60,
        60,
        60,
        60,
        60,
        56,
        60,
        60,
        60,
        60,
        60,
        56,
        60,
        60,
        60,
        60,
        60,
        24,
        12,
        28,
        12,
        0,
        /* UTF8 continuation byte range. */
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        /* UTF8 lead byte range. */
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        /* CONTEXT_UTF8 second last byte. */
        /* ASCII range. */
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        1,
        1,
        1,
        1,
        0,
        /* UTF8 continuation byte range. */
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        /* UTF8 lead byte range. */
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        /* CONTEXT_SIGNED, second last byte. */
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        7,
        /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
        0,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        24,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        48,
        56,
        /* CONTEXT_LSB6, last byte. */
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        /* CONTEXT_MSB6, last byte. */
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        6,
        6,
        6,
        6,
        7,
        7,
        7,
        7,
        8,
        8,
        8,
        8,
        9,
        9,
        9,
        9,
        10,
        10,
        10,
        10,
        11,
        11,
        11,
        11,
        12,
        12,
        12,
        12,
        13,
        13,
        13,
        13,
        14,
        14,
        14,
        14,
        15,
        15,
        15,
        15,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        22,
        22,
        22,
        22,
        23,
        23,
        23,
        23,
        24,
        24,
        24,
        24,
        25,
        25,
        25,
        25,
        26,
        26,
        26,
        26,
        27,
        27,
        27,
        27,
        28,
        28,
        28,
        28,
        29,
        29,
        29,
        29,
        30,
        30,
        30,
        30,
        31,
        31,
        31,
        31,
        32,
        32,
        32,
        32,
        33,
        33,
        33,
        33,
        34,
        34,
        34,
        34,
        35,
        35,
        35,
        35,
        36,
        36,
        36,
        36,
        37,
        37,
        37,
        37,
        38,
        38,
        38,
        38,
        39,
        39,
        39,
        39,
        40,
        40,
        40,
        40,
        41,
        41,
        41,
        41,
        42,
        42,
        42,
        42,
        43,
        43,
        43,
        43,
        44,
        44,
        44,
        44,
        45,
        45,
        45,
        45,
        46,
        46,
        46,
        46,
        47,
        47,
        47,
        47,
        48,
        48,
        48,
        48,
        49,
        49,
        49,
        49,
        50,
        50,
        50,
        50,
        51,
        51,
        51,
        51,
        52,
        52,
        52,
        52,
        53,
        53,
        53,
        53,
        54,
        54,
        54,
        54,
        55,
        55,
        55,
        55,
        56,
        56,
        56,
        56,
        57,
        57,
        57,
        57,
        58,
        58,
        58,
        58,
        59,
        59,
        59,
        59,
        60,
        60,
        60,
        60,
        61,
        61,
        61,
        61,
        62,
        62,
        62,
        62,
        63,
        63,
        63,
        63,
        /* CONTEXT_{M,L}SB6, second last byte, */
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      exports.lookupOffsets = new Uint16Array([
        /* CONTEXT_LSB6 */
        1024,
        1536,
        /* CONTEXT_MSB6 */
        1280,
        1536,
        /* CONTEXT_UTF8 */
        0,
        256,
        /* CONTEXT_SIGNED */
        768,
        512
      ]);
    }
  });

  // node_modules/brotli/dec/prefix.js
  var require_prefix = __commonJS({
    "node_modules/brotli/dec/prefix.js"(exports) {
      function PrefixCodeRange(offset, nbits) {
        this.offset = offset;
        this.nbits = nbits;
      }
      exports.kBlockLengthPrefixCode = [
        new PrefixCodeRange(1, 2),
        new PrefixCodeRange(5, 2),
        new PrefixCodeRange(9, 2),
        new PrefixCodeRange(13, 2),
        new PrefixCodeRange(17, 3),
        new PrefixCodeRange(25, 3),
        new PrefixCodeRange(33, 3),
        new PrefixCodeRange(41, 3),
        new PrefixCodeRange(49, 4),
        new PrefixCodeRange(65, 4),
        new PrefixCodeRange(81, 4),
        new PrefixCodeRange(97, 4),
        new PrefixCodeRange(113, 5),
        new PrefixCodeRange(145, 5),
        new PrefixCodeRange(177, 5),
        new PrefixCodeRange(209, 5),
        new PrefixCodeRange(241, 6),
        new PrefixCodeRange(305, 6),
        new PrefixCodeRange(369, 7),
        new PrefixCodeRange(497, 8),
        new PrefixCodeRange(753, 9),
        new PrefixCodeRange(1265, 10),
        new PrefixCodeRange(2289, 11),
        new PrefixCodeRange(4337, 12),
        new PrefixCodeRange(8433, 13),
        new PrefixCodeRange(16625, 24)
      ];
      exports.kInsertLengthPrefixCode = [
        new PrefixCodeRange(0, 0),
        new PrefixCodeRange(1, 0),
        new PrefixCodeRange(2, 0),
        new PrefixCodeRange(3, 0),
        new PrefixCodeRange(4, 0),
        new PrefixCodeRange(5, 0),
        new PrefixCodeRange(6, 1),
        new PrefixCodeRange(8, 1),
        new PrefixCodeRange(10, 2),
        new PrefixCodeRange(14, 2),
        new PrefixCodeRange(18, 3),
        new PrefixCodeRange(26, 3),
        new PrefixCodeRange(34, 4),
        new PrefixCodeRange(50, 4),
        new PrefixCodeRange(66, 5),
        new PrefixCodeRange(98, 5),
        new PrefixCodeRange(130, 6),
        new PrefixCodeRange(194, 7),
        new PrefixCodeRange(322, 8),
        new PrefixCodeRange(578, 9),
        new PrefixCodeRange(1090, 10),
        new PrefixCodeRange(2114, 12),
        new PrefixCodeRange(6210, 14),
        new PrefixCodeRange(22594, 24)
      ];
      exports.kCopyLengthPrefixCode = [
        new PrefixCodeRange(2, 0),
        new PrefixCodeRange(3, 0),
        new PrefixCodeRange(4, 0),
        new PrefixCodeRange(5, 0),
        new PrefixCodeRange(6, 0),
        new PrefixCodeRange(7, 0),
        new PrefixCodeRange(8, 0),
        new PrefixCodeRange(9, 0),
        new PrefixCodeRange(10, 1),
        new PrefixCodeRange(12, 1),
        new PrefixCodeRange(14, 2),
        new PrefixCodeRange(18, 2),
        new PrefixCodeRange(22, 3),
        new PrefixCodeRange(30, 3),
        new PrefixCodeRange(38, 4),
        new PrefixCodeRange(54, 4),
        new PrefixCodeRange(70, 5),
        new PrefixCodeRange(102, 5),
        new PrefixCodeRange(134, 6),
        new PrefixCodeRange(198, 7),
        new PrefixCodeRange(326, 8),
        new PrefixCodeRange(582, 9),
        new PrefixCodeRange(1094, 10),
        new PrefixCodeRange(2118, 24)
      ];
      exports.kInsertRangeLut = [
        0,
        0,
        8,
        8,
        0,
        16,
        8,
        16,
        16
      ];
      exports.kCopyRangeLut = [
        0,
        8,
        0,
        8,
        16,
        0,
        16,
        8,
        16
      ];
    }
  });

  // node_modules/brotli/dec/transform.js
  var require_transform = __commonJS({
    "node_modules/brotli/dec/transform.js"(exports) {
      var BrotliDictionary = require_dictionary();
      var kIdentity = 0;
      var kOmitLast1 = 1;
      var kOmitLast2 = 2;
      var kOmitLast3 = 3;
      var kOmitLast4 = 4;
      var kOmitLast5 = 5;
      var kOmitLast6 = 6;
      var kOmitLast7 = 7;
      var kOmitLast8 = 8;
      var kOmitLast9 = 9;
      var kUppercaseFirst = 10;
      var kUppercaseAll = 11;
      var kOmitFirst1 = 12;
      var kOmitFirst2 = 13;
      var kOmitFirst3 = 14;
      var kOmitFirst4 = 15;
      var kOmitFirst5 = 16;
      var kOmitFirst6 = 17;
      var kOmitFirst7 = 18;
      var kOmitFirst8 = 19;
      var kOmitFirst9 = 20;
      function Transform(prefix, transform, suffix) {
        this.prefix = new Uint8Array(prefix.length);
        this.transform = transform;
        this.suffix = new Uint8Array(suffix.length);
        for (var i = 0; i < prefix.length; i++)
          this.prefix[i] = prefix.charCodeAt(i);
        for (var i = 0; i < suffix.length; i++)
          this.suffix[i] = suffix.charCodeAt(i);
      }
      var kTransforms = [
        new Transform("", kIdentity, ""),
        new Transform("", kIdentity, " "),
        new Transform(" ", kIdentity, " "),
        new Transform("", kOmitFirst1, ""),
        new Transform("", kUppercaseFirst, " "),
        new Transform("", kIdentity, " the "),
        new Transform(" ", kIdentity, ""),
        new Transform("s ", kIdentity, " "),
        new Transform("", kIdentity, " of "),
        new Transform("", kUppercaseFirst, ""),
        new Transform("", kIdentity, " and "),
        new Transform("", kOmitFirst2, ""),
        new Transform("", kOmitLast1, ""),
        new Transform(", ", kIdentity, " "),
        new Transform("", kIdentity, ", "),
        new Transform(" ", kUppercaseFirst, " "),
        new Transform("", kIdentity, " in "),
        new Transform("", kIdentity, " to "),
        new Transform("e ", kIdentity, " "),
        new Transform("", kIdentity, '"'),
        new Transform("", kIdentity, "."),
        new Transform("", kIdentity, '">'),
        new Transform("", kIdentity, "\n"),
        new Transform("", kOmitLast3, ""),
        new Transform("", kIdentity, "]"),
        new Transform("", kIdentity, " for "),
        new Transform("", kOmitFirst3, ""),
        new Transform("", kOmitLast2, ""),
        new Transform("", kIdentity, " a "),
        new Transform("", kIdentity, " that "),
        new Transform(" ", kUppercaseFirst, ""),
        new Transform("", kIdentity, ". "),
        new Transform(".", kIdentity, ""),
        new Transform(" ", kIdentity, ", "),
        new Transform("", kOmitFirst4, ""),
        new Transform("", kIdentity, " with "),
        new Transform("", kIdentity, "'"),
        new Transform("", kIdentity, " from "),
        new Transform("", kIdentity, " by "),
        new Transform("", kOmitFirst5, ""),
        new Transform("", kOmitFirst6, ""),
        new Transform(" the ", kIdentity, ""),
        new Transform("", kOmitLast4, ""),
        new Transform("", kIdentity, ". The "),
        new Transform("", kUppercaseAll, ""),
        new Transform("", kIdentity, " on "),
        new Transform("", kIdentity, " as "),
        new Transform("", kIdentity, " is "),
        new Transform("", kOmitLast7, ""),
        new Transform("", kOmitLast1, "ing "),
        new Transform("", kIdentity, "\n	"),
        new Transform("", kIdentity, ":"),
        new Transform(" ", kIdentity, ". "),
        new Transform("", kIdentity, "ed "),
        new Transform("", kOmitFirst9, ""),
        new Transform("", kOmitFirst7, ""),
        new Transform("", kOmitLast6, ""),
        new Transform("", kIdentity, "("),
        new Transform("", kUppercaseFirst, ", "),
        new Transform("", kOmitLast8, ""),
        new Transform("", kIdentity, " at "),
        new Transform("", kIdentity, "ly "),
        new Transform(" the ", kIdentity, " of "),
        new Transform("", kOmitLast5, ""),
        new Transform("", kOmitLast9, ""),
        new Transform(" ", kUppercaseFirst, ", "),
        new Transform("", kUppercaseFirst, '"'),
        new Transform(".", kIdentity, "("),
        new Transform("", kUppercaseAll, " "),
        new Transform("", kUppercaseFirst, '">'),
        new Transform("", kIdentity, '="'),
        new Transform(" ", kIdentity, "."),
        new Transform(".com/", kIdentity, ""),
        new Transform(" the ", kIdentity, " of the "),
        new Transform("", kUppercaseFirst, "'"),
        new Transform("", kIdentity, ". This "),
        new Transform("", kIdentity, ","),
        new Transform(".", kIdentity, " "),
        new Transform("", kUppercaseFirst, "("),
        new Transform("", kUppercaseFirst, "."),
        new Transform("", kIdentity, " not "),
        new Transform(" ", kIdentity, '="'),
        new Transform("", kIdentity, "er "),
        new Transform(" ", kUppercaseAll, " "),
        new Transform("", kIdentity, "al "),
        new Transform(" ", kUppercaseAll, ""),
        new Transform("", kIdentity, "='"),
        new Transform("", kUppercaseAll, '"'),
        new Transform("", kUppercaseFirst, ". "),
        new Transform(" ", kIdentity, "("),
        new Transform("", kIdentity, "ful "),
        new Transform(" ", kUppercaseFirst, ". "),
        new Transform("", kIdentity, "ive "),
        new Transform("", kIdentity, "less "),
        new Transform("", kUppercaseAll, "'"),
        new Transform("", kIdentity, "est "),
        new Transform(" ", kUppercaseFirst, "."),
        new Transform("", kUppercaseAll, '">'),
        new Transform(" ", kIdentity, "='"),
        new Transform("", kUppercaseFirst, ","),
        new Transform("", kIdentity, "ize "),
        new Transform("", kUppercaseAll, "."),
        new Transform("\xC2\xA0", kIdentity, ""),
        new Transform(" ", kIdentity, ","),
        new Transform("", kUppercaseFirst, '="'),
        new Transform("", kUppercaseAll, '="'),
        new Transform("", kIdentity, "ous "),
        new Transform("", kUppercaseAll, ", "),
        new Transform("", kUppercaseFirst, "='"),
        new Transform(" ", kUppercaseFirst, ","),
        new Transform(" ", kUppercaseAll, '="'),
        new Transform(" ", kUppercaseAll, ", "),
        new Transform("", kUppercaseAll, ","),
        new Transform("", kUppercaseAll, "("),
        new Transform("", kUppercaseAll, ". "),
        new Transform(" ", kUppercaseAll, "."),
        new Transform("", kUppercaseAll, "='"),
        new Transform(" ", kUppercaseAll, ". "),
        new Transform(" ", kUppercaseFirst, '="'),
        new Transform(" ", kUppercaseAll, "='"),
        new Transform(" ", kUppercaseFirst, "='")
      ];
      exports.kTransforms = kTransforms;
      exports.kNumTransforms = kTransforms.length;
      function ToUpperCase(p, i) {
        if (p[i] < 192) {
          if (p[i] >= 97 && p[i] <= 122) {
            p[i] ^= 32;
          }
          return 1;
        }
        if (p[i] < 224) {
          p[i + 1] ^= 32;
          return 2;
        }
        p[i + 2] ^= 5;
        return 3;
      }
      exports.transformDictionaryWord = function(dst, idx, word, len, transform) {
        var prefix = kTransforms[transform].prefix;
        var suffix = kTransforms[transform].suffix;
        var t = kTransforms[transform].transform;
        var skip = t < kOmitFirst1 ? 0 : t - (kOmitFirst1 - 1);
        var i = 0;
        var start_idx = idx;
        var uppercase;
        if (skip > len) {
          skip = len;
        }
        var prefix_pos = 0;
        while (prefix_pos < prefix.length) {
          dst[idx++] = prefix[prefix_pos++];
        }
        word += skip;
        len -= skip;
        if (t <= kOmitLast9) {
          len -= t;
        }
        for (i = 0; i < len; i++) {
          dst[idx++] = BrotliDictionary.dictionary[word + i];
        }
        uppercase = idx - len;
        if (t === kUppercaseFirst) {
          ToUpperCase(dst, uppercase);
        } else if (t === kUppercaseAll) {
          while (len > 0) {
            var step = ToUpperCase(dst, uppercase);
            uppercase += step;
            len -= step;
          }
        }
        var suffix_pos = 0;
        while (suffix_pos < suffix.length) {
          dst[idx++] = suffix[suffix_pos++];
        }
        return idx - start_idx;
      };
    }
  });

  // node_modules/brotli/dec/decode.js
  var require_decode = __commonJS({
    "node_modules/brotli/dec/decode.js"(exports) {
      var BrotliInput = require_streams().BrotliInput;
      var BrotliOutput = require_streams().BrotliOutput;
      var BrotliBitReader = require_bit_reader();
      var BrotliDictionary = require_dictionary();
      var HuffmanCode = require_huffman().HuffmanCode;
      var BrotliBuildHuffmanTable = require_huffman().BrotliBuildHuffmanTable;
      var Context = require_context();
      var Prefix = require_prefix();
      var Transform = require_transform();
      var kDefaultCodeLength = 8;
      var kCodeLengthRepeatCode = 16;
      var kNumLiteralCodes = 256;
      var kNumInsertAndCopyCodes = 704;
      var kNumBlockLengthCodes = 26;
      var kLiteralContextBits = 6;
      var kDistanceContextBits = 2;
      var HUFFMAN_TABLE_BITS = 8;
      var HUFFMAN_TABLE_MASK = 255;
      var HUFFMAN_MAX_TABLE_SIZE = 1080;
      var CODE_LENGTH_CODES = 18;
      var kCodeLengthCodeOrder = new Uint8Array([
        1,
        2,
        3,
        4,
        0,
        5,
        17,
        6,
        16,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15
      ]);
      var NUM_DISTANCE_SHORT_CODES = 16;
      var kDistanceShortCodeIndexOffset = new Uint8Array([
        3,
        2,
        1,
        0,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2
      ]);
      var kDistanceShortCodeValueOffset = new Int8Array([
        0,
        0,
        0,
        0,
        -1,
        1,
        -2,
        2,
        -3,
        3,
        -1,
        1,
        -2,
        2,
        -3,
        3
      ]);
      var kMaxHuffmanTableSize = new Uint16Array([
        256,
        402,
        436,
        468,
        500,
        534,
        566,
        598,
        630,
        662,
        694,
        726,
        758,
        790,
        822,
        854,
        886,
        920,
        952,
        984,
        1016,
        1048,
        1080
      ]);
      function DecodeWindowBits(br) {
        var n;
        if (br.readBits(1) === 0) {
          return 16;
        }
        n = br.readBits(3);
        if (n > 0) {
          return 17 + n;
        }
        n = br.readBits(3);
        if (n > 0) {
          return 8 + n;
        }
        return 17;
      }
      function DecodeVarLenUint8(br) {
        if (br.readBits(1)) {
          var nbits = br.readBits(3);
          if (nbits === 0) {
            return 1;
          } else {
            return br.readBits(nbits) + (1 << nbits);
          }
        }
        return 0;
      }
      function MetaBlockLength() {
        this.meta_block_length = 0;
        this.input_end = 0;
        this.is_uncompressed = 0;
        this.is_metadata = false;
      }
      function DecodeMetaBlockLength(br) {
        var out = new MetaBlockLength();
        var size_nibbles;
        var size_bytes;
        var i;
        out.input_end = br.readBits(1);
        if (out.input_end && br.readBits(1)) {
          return out;
        }
        size_nibbles = br.readBits(2) + 4;
        if (size_nibbles === 7) {
          out.is_metadata = true;
          if (br.readBits(1) !== 0)
            throw new Error("Invalid reserved bit");
          size_bytes = br.readBits(2);
          if (size_bytes === 0)
            return out;
          for (i = 0; i < size_bytes; i++) {
            var next_byte = br.readBits(8);
            if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
              throw new Error("Invalid size byte");
            out.meta_block_length |= next_byte << i * 8;
          }
        } else {
          for (i = 0; i < size_nibbles; ++i) {
            var next_nibble = br.readBits(4);
            if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
              throw new Error("Invalid size nibble");
            out.meta_block_length |= next_nibble << i * 4;
          }
        }
        ++out.meta_block_length;
        if (!out.input_end && !out.is_metadata) {
          out.is_uncompressed = br.readBits(1);
        }
        return out;
      }
      function ReadSymbol(table, index, br) {
        var start_index = index;
        var nbits;
        br.fillBitWindow();
        index += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
        nbits = table[index].bits - HUFFMAN_TABLE_BITS;
        if (nbits > 0) {
          br.bit_pos_ += HUFFMAN_TABLE_BITS;
          index += table[index].value;
          index += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
        }
        br.bit_pos_ += table[index].bits;
        return table[index].value;
      }
      function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
        var symbol2 = 0;
        var prev_code_len = kDefaultCodeLength;
        var repeat = 0;
        var repeat_code_len = 0;
        var space = 32768;
        var table = [];
        for (var i = 0; i < 32; i++)
          table.push(new HuffmanCode(0, 0));
        BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
        while (symbol2 < num_symbols && space > 0) {
          var p = 0;
          var code_len;
          br.readMoreInput();
          br.fillBitWindow();
          p += br.val_ >>> br.bit_pos_ & 31;
          br.bit_pos_ += table[p].bits;
          code_len = table[p].value & 255;
          if (code_len < kCodeLengthRepeatCode) {
            repeat = 0;
            code_lengths[symbol2++] = code_len;
            if (code_len !== 0) {
              prev_code_len = code_len;
              space -= 32768 >> code_len;
            }
          } else {
            var extra_bits = code_len - 14;
            var old_repeat;
            var repeat_delta;
            var new_len = 0;
            if (code_len === kCodeLengthRepeatCode) {
              new_len = prev_code_len;
            }
            if (repeat_code_len !== new_len) {
              repeat = 0;
              repeat_code_len = new_len;
            }
            old_repeat = repeat;
            if (repeat > 0) {
              repeat -= 2;
              repeat <<= extra_bits;
            }
            repeat += br.readBits(extra_bits) + 3;
            repeat_delta = repeat - old_repeat;
            if (symbol2 + repeat_delta > num_symbols) {
              throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
            }
            for (var x = 0; x < repeat_delta; x++)
              code_lengths[symbol2 + x] = repeat_code_len;
            symbol2 += repeat_delta;
            if (repeat_code_len !== 0) {
              space -= repeat_delta << 15 - repeat_code_len;
            }
          }
        }
        if (space !== 0) {
          throw new Error("[ReadHuffmanCodeLengths] space = " + space);
        }
        for (; symbol2 < num_symbols; symbol2++)
          code_lengths[symbol2] = 0;
      }
      function ReadHuffmanCode(alphabet_size, tables, table, br) {
        var table_size = 0;
        var simple_code_or_skip;
        var code_lengths = new Uint8Array(alphabet_size);
        br.readMoreInput();
        simple_code_or_skip = br.readBits(2);
        if (simple_code_or_skip === 1) {
          var i;
          var max_bits_counter = alphabet_size - 1;
          var max_bits = 0;
          var symbols = new Int32Array(4);
          var num_symbols = br.readBits(2) + 1;
          while (max_bits_counter) {
            max_bits_counter >>= 1;
            ++max_bits;
          }
          for (i = 0; i < num_symbols; ++i) {
            symbols[i] = br.readBits(max_bits) % alphabet_size;
            code_lengths[symbols[i]] = 2;
          }
          code_lengths[symbols[0]] = 1;
          switch (num_symbols) {
            case 1:
              break;
            case 3:
              if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
                throw new Error("[ReadHuffmanCode] invalid symbols");
              }
              break;
            case 2:
              if (symbols[0] === symbols[1]) {
                throw new Error("[ReadHuffmanCode] invalid symbols");
              }
              code_lengths[symbols[1]] = 1;
              break;
            case 4:
              if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
                throw new Error("[ReadHuffmanCode] invalid symbols");
              }
              if (br.readBits(1)) {
                code_lengths[symbols[2]] = 3;
                code_lengths[symbols[3]] = 3;
              } else {
                code_lengths[symbols[0]] = 2;
              }
              break;
          }
        } else {
          var i;
          var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
          var space = 32;
          var num_codes = 0;
          var huff = [
            new HuffmanCode(2, 0),
            new HuffmanCode(2, 4),
            new HuffmanCode(2, 3),
            new HuffmanCode(3, 2),
            new HuffmanCode(2, 0),
            new HuffmanCode(2, 4),
            new HuffmanCode(2, 3),
            new HuffmanCode(4, 1),
            new HuffmanCode(2, 0),
            new HuffmanCode(2, 4),
            new HuffmanCode(2, 3),
            new HuffmanCode(3, 2),
            new HuffmanCode(2, 0),
            new HuffmanCode(2, 4),
            new HuffmanCode(2, 3),
            new HuffmanCode(4, 5)
          ];
          for (i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; ++i) {
            var code_len_idx = kCodeLengthCodeOrder[i];
            var p = 0;
            var v;
            br.fillBitWindow();
            p += br.val_ >>> br.bit_pos_ & 15;
            br.bit_pos_ += huff[p].bits;
            v = huff[p].value;
            code_length_code_lengths[code_len_idx] = v;
            if (v !== 0) {
              space -= 32 >> v;
              ++num_codes;
            }
          }
          if (!(num_codes === 1 || space === 0))
            throw new Error("[ReadHuffmanCode] invalid num_codes or space");
          ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
        }
        table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
        if (table_size === 0) {
          throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
        }
        return table_size;
      }
      function ReadBlockLength(table, index, br) {
        var code;
        var nbits;
        code = ReadSymbol(table, index, br);
        nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
        return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
      }
      function TranslateShortCodes(code, ringbuffer, index) {
        var val;
        if (code < NUM_DISTANCE_SHORT_CODES) {
          index += kDistanceShortCodeIndexOffset[code];
          index &= 3;
          val = ringbuffer[index] + kDistanceShortCodeValueOffset[code];
        } else {
          val = code - NUM_DISTANCE_SHORT_CODES + 1;
        }
        return val;
      }
      function MoveToFront(v, index) {
        var value = v[index];
        var i = index;
        for (; i; --i)
          v[i] = v[i - 1];
        v[0] = value;
      }
      function InverseMoveToFrontTransform(v, v_len) {
        var mtf = new Uint8Array(256);
        var i;
        for (i = 0; i < 256; ++i) {
          mtf[i] = i;
        }
        for (i = 0; i < v_len; ++i) {
          var index = v[i];
          v[i] = mtf[index];
          if (index)
            MoveToFront(mtf, index);
        }
      }
      function HuffmanTreeGroup(alphabet_size, num_htrees) {
        this.alphabet_size = alphabet_size;
        this.num_htrees = num_htrees;
        this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
        this.htrees = new Uint32Array(num_htrees);
      }
      HuffmanTreeGroup.prototype.decode = function(br) {
        var i;
        var table_size;
        var next = 0;
        for (i = 0; i < this.num_htrees; ++i) {
          this.htrees[i] = next;
          table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
          next += table_size;
        }
      };
      function DecodeContextMap(context_map_size, br) {
        var out = { num_htrees: null, context_map: null };
        var use_rle_for_zeros;
        var max_run_length_prefix = 0;
        var table;
        var i;
        br.readMoreInput();
        var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
        var context_map = out.context_map = new Uint8Array(context_map_size);
        if (num_htrees <= 1) {
          return out;
        }
        use_rle_for_zeros = br.readBits(1);
        if (use_rle_for_zeros) {
          max_run_length_prefix = br.readBits(4) + 1;
        }
        table = [];
        for (i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {
          table[i] = new HuffmanCode(0, 0);
        }
        ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
        for (i = 0; i < context_map_size; ) {
          var code;
          br.readMoreInput();
          code = ReadSymbol(table, 0, br);
          if (code === 0) {
            context_map[i] = 0;
            ++i;
          } else if (code <= max_run_length_prefix) {
            var reps = 1 + (1 << code) + br.readBits(code);
            while (--reps) {
              if (i >= context_map_size) {
                throw new Error("[DecodeContextMap] i >= context_map_size");
              }
              context_map[i] = 0;
              ++i;
            }
          } else {
            context_map[i] = code - max_run_length_prefix;
            ++i;
          }
        }
        if (br.readBits(1)) {
          InverseMoveToFrontTransform(context_map, context_map_size);
        }
        return out;
      }
      function DecodeBlockType(max_block_type, trees, tree_type, block_types, ringbuffers, indexes, br) {
        var ringbuffer = tree_type * 2;
        var index = tree_type;
        var type_code = ReadSymbol(trees, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
        var block_type;
        if (type_code === 0) {
          block_type = ringbuffers[ringbuffer + (indexes[index] & 1)];
        } else if (type_code === 1) {
          block_type = ringbuffers[ringbuffer + (indexes[index] - 1 & 1)] + 1;
        } else {
          block_type = type_code - 2;
        }
        if (block_type >= max_block_type) {
          block_type -= max_block_type;
        }
        block_types[tree_type] = block_type;
        ringbuffers[ringbuffer + (indexes[index] & 1)] = block_type;
        ++indexes[index];
      }
      function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
        var rb_size = ringbuffer_mask + 1;
        var rb_pos = pos & ringbuffer_mask;
        var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
        var nbytes;
        if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
          while (len-- > 0) {
            br.readMoreInput();
            ringbuffer[rb_pos++] = br.readBits(8);
            if (rb_pos === rb_size) {
              output.write(ringbuffer, rb_size);
              rb_pos = 0;
            }
          }
          return;
        }
        if (br.bit_end_pos_ < 32) {
          throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
        }
        while (br.bit_pos_ < 32) {
          ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
          br.bit_pos_ += 8;
          ++rb_pos;
          --len;
        }
        nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
        if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
          var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
          for (var x = 0; x < tail; x++)
            ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
          nbytes -= tail;
          rb_pos += tail;
          len -= tail;
          br_pos = 0;
        }
        for (var x = 0; x < nbytes; x++)
          ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
        rb_pos += nbytes;
        len -= nbytes;
        if (rb_pos >= rb_size) {
          output.write(ringbuffer, rb_size);
          rb_pos -= rb_size;
          for (var x = 0; x < rb_pos; x++)
            ringbuffer[x] = ringbuffer[rb_size + x];
        }
        while (rb_pos + len >= rb_size) {
          nbytes = rb_size - rb_pos;
          if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
            throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
          }
          output.write(ringbuffer, rb_size);
          len -= nbytes;
          rb_pos = 0;
        }
        if (br.input_.read(ringbuffer, rb_pos, len) < len) {
          throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
        }
        br.reset();
      }
      function JumpToByteBoundary(br) {
        var new_bit_pos = br.bit_pos_ + 7 & ~7;
        var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
        return pad_bits == 0;
      }
      function BrotliDecompressedSize(buffer) {
        var input = new BrotliInput(buffer);
        var br = new BrotliBitReader(input);
        DecodeWindowBits(br);
        var out = DecodeMetaBlockLength(br);
        return out.meta_block_length;
      }
      exports.BrotliDecompressedSize = BrotliDecompressedSize;
      function BrotliDecompressBuffer(buffer, output_size) {
        var input = new BrotliInput(buffer);
        if (output_size == null) {
          output_size = BrotliDecompressedSize(buffer);
        }
        var output_buffer = new Uint8Array(output_size);
        var output = new BrotliOutput(output_buffer);
        BrotliDecompress(input, output);
        if (output.pos < output.buffer.length) {
          output.buffer = output.buffer.subarray(0, output.pos);
        }
        return output.buffer;
      }
      exports.BrotliDecompressBuffer = BrotliDecompressBuffer;
      function BrotliDecompress(input, output) {
        var i;
        var pos = 0;
        var input_end = 0;
        var window_bits = 0;
        var max_backward_distance;
        var max_distance = 0;
        var ringbuffer_size;
        var ringbuffer_mask;
        var ringbuffer;
        var ringbuffer_end;
        var dist_rb = [16, 15, 11, 4];
        var dist_rb_idx = 0;
        var prev_byte1 = 0;
        var prev_byte2 = 0;
        var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
        var block_type_trees;
        var block_len_trees;
        var br;
        var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
        br = new BrotliBitReader(input);
        window_bits = DecodeWindowBits(br);
        max_backward_distance = (1 << window_bits) - 16;
        ringbuffer_size = 1 << window_bits;
        ringbuffer_mask = ringbuffer_size - 1;
        ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
        ringbuffer_end = ringbuffer_size;
        block_type_trees = [];
        block_len_trees = [];
        for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
          block_type_trees[x] = new HuffmanCode(0, 0);
          block_len_trees[x] = new HuffmanCode(0, 0);
        }
        while (!input_end) {
          var meta_block_remaining_len = 0;
          var is_uncompressed;
          var block_length = [1 << 28, 1 << 28, 1 << 28];
          var block_type = [0];
          var num_block_types = [1, 1, 1];
          var block_type_rb = [0, 1, 0, 1, 0, 1];
          var block_type_rb_index = [0];
          var distance_postfix_bits;
          var num_direct_distance_codes;
          var distance_postfix_mask;
          var num_distance_codes;
          var context_map = null;
          var context_modes = null;
          var num_literal_htrees;
          var dist_context_map = null;
          var num_dist_htrees;
          var context_offset = 0;
          var context_map_slice = null;
          var literal_htree_index = 0;
          var dist_context_offset = 0;
          var dist_context_map_slice = null;
          var dist_htree_index = 0;
          var context_lookup_offset1 = 0;
          var context_lookup_offset2 = 0;
          var context_mode;
          var htree_command;
          for (i = 0; i < 3; ++i) {
            hgroup[i].codes = null;
            hgroup[i].htrees = null;
          }
          br.readMoreInput();
          var _out = DecodeMetaBlockLength(br);
          meta_block_remaining_len = _out.meta_block_length;
          if (pos + meta_block_remaining_len > output.buffer.length) {
            var tmp = new Uint8Array(pos + meta_block_remaining_len);
            tmp.set(output.buffer);
            output.buffer = tmp;
          }
          input_end = _out.input_end;
          is_uncompressed = _out.is_uncompressed;
          if (_out.is_metadata) {
            JumpToByteBoundary(br);
            for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
              br.readMoreInput();
              br.readBits(8);
            }
            continue;
          }
          if (meta_block_remaining_len === 0) {
            continue;
          }
          if (is_uncompressed) {
            br.bit_pos_ = br.bit_pos_ + 7 & ~7;
            CopyUncompressedBlockToOutput(
              output,
              meta_block_remaining_len,
              pos,
              ringbuffer,
              ringbuffer_mask,
              br
            );
            pos += meta_block_remaining_len;
            continue;
          }
          for (i = 0; i < 3; ++i) {
            num_block_types[i] = DecodeVarLenUint8(br) + 1;
            if (num_block_types[i] >= 2) {
              ReadHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
              ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
              block_length[i] = ReadBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
              block_type_rb_index[i] = 1;
            }
          }
          br.readMoreInput();
          distance_postfix_bits = br.readBits(2);
          num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
          distance_postfix_mask = (1 << distance_postfix_bits) - 1;
          num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
          context_modes = new Uint8Array(num_block_types[0]);
          for (i = 0; i < num_block_types[0]; ++i) {
            br.readMoreInput();
            context_modes[i] = br.readBits(2) << 1;
          }
          var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
          num_literal_htrees = _o1.num_htrees;
          context_map = _o1.context_map;
          var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
          num_dist_htrees = _o2.num_htrees;
          dist_context_map = _o2.context_map;
          hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
          hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
          hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
          for (i = 0; i < 3; ++i) {
            hgroup[i].decode(br);
          }
          context_map_slice = 0;
          dist_context_map_slice = 0;
          context_mode = context_modes[block_type[0]];
          context_lookup_offset1 = Context.lookupOffsets[context_mode];
          context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
          htree_command = hgroup[1].htrees[0];
          while (meta_block_remaining_len > 0) {
            var cmd_code;
            var range_idx;
            var insert_code;
            var copy_code;
            var insert_length;
            var copy_length;
            var distance_code;
            var distance;
            var context;
            var j;
            var copy_dst;
            br.readMoreInput();
            if (block_length[1] === 0) {
              DecodeBlockType(
                num_block_types[1],
                block_type_trees,
                1,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
              htree_command = hgroup[1].htrees[block_type[1]];
            }
            --block_length[1];
            cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
            range_idx = cmd_code >> 6;
            if (range_idx >= 2) {
              range_idx -= 2;
              distance_code = -1;
            } else {
              distance_code = 0;
            }
            insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
            copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
            insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
            copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
            prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
            prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
            for (j = 0; j < insert_length; ++j) {
              br.readMoreInput();
              if (block_length[0] === 0) {
                DecodeBlockType(
                  num_block_types[0],
                  block_type_trees,
                  0,
                  block_type,
                  block_type_rb,
                  block_type_rb_index,
                  br
                );
                block_length[0] = ReadBlockLength(block_len_trees, 0, br);
                context_offset = block_type[0] << kLiteralContextBits;
                context_map_slice = context_offset;
                context_mode = context_modes[block_type[0]];
                context_lookup_offset1 = Context.lookupOffsets[context_mode];
                context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
              }
              context = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
              literal_htree_index = context_map[context_map_slice + context];
              --block_length[0];
              prev_byte2 = prev_byte1;
              prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
              ringbuffer[pos & ringbuffer_mask] = prev_byte1;
              if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                output.write(ringbuffer, ringbuffer_size);
              }
              ++pos;
            }
            meta_block_remaining_len -= insert_length;
            if (meta_block_remaining_len <= 0)
              break;
            if (distance_code < 0) {
              var context;
              br.readMoreInput();
              if (block_length[2] === 0) {
                DecodeBlockType(
                  num_block_types[2],
                  block_type_trees,
                  2,
                  block_type,
                  block_type_rb,
                  block_type_rb_index,
                  br
                );
                block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
                dist_context_offset = block_type[2] << kDistanceContextBits;
                dist_context_map_slice = dist_context_offset;
              }
              --block_length[2];
              context = (copy_length > 4 ? 3 : copy_length - 2) & 255;
              dist_htree_index = dist_context_map[dist_context_map_slice + context];
              distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
              if (distance_code >= num_direct_distance_codes) {
                var nbits;
                var postfix;
                var offset;
                distance_code -= num_direct_distance_codes;
                postfix = distance_code & distance_postfix_mask;
                distance_code >>= distance_postfix_bits;
                nbits = (distance_code >> 1) + 1;
                offset = (2 + (distance_code & 1) << nbits) - 4;
                distance_code = num_direct_distance_codes + (offset + br.readBits(nbits) << distance_postfix_bits) + postfix;
              }
            }
            distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
            if (distance < 0) {
              throw new Error("[BrotliDecompress] invalid distance");
            }
            if (pos < max_backward_distance && max_distance !== max_backward_distance) {
              max_distance = pos;
            } else {
              max_distance = max_backward_distance;
            }
            copy_dst = pos & ringbuffer_mask;
            if (distance > max_distance) {
              if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
                var offset = BrotliDictionary.offsetsByLength[copy_length];
                var word_id = distance - max_distance - 1;
                var shift = BrotliDictionary.sizeBitsByLength[copy_length];
                var mask = (1 << shift) - 1;
                var word_idx = word_id & mask;
                var transform_idx = word_id >> shift;
                offset += word_idx * copy_length;
                if (transform_idx < Transform.kNumTransforms) {
                  var len = Transform.transformDictionaryWord(ringbuffer, copy_dst, offset, copy_length, transform_idx);
                  copy_dst += len;
                  pos += len;
                  meta_block_remaining_len -= len;
                  if (copy_dst >= ringbuffer_end) {
                    output.write(ringbuffer, ringbuffer_size);
                    for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                      ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                  }
                } else {
                  throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
                }
              } else {
                throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
              }
            } else {
              if (distance_code > 0) {
                dist_rb[dist_rb_idx & 3] = distance;
                ++dist_rb_idx;
              }
              if (copy_length > meta_block_remaining_len) {
                throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
              }
              for (j = 0; j < copy_length; ++j) {
                ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
                if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                  output.write(ringbuffer, ringbuffer_size);
                }
                ++pos;
                --meta_block_remaining_len;
              }
            }
            prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
            prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
          }
          pos &= 1073741823;
        }
        output.write(ringbuffer, pos & ringbuffer_mask);
      }
      exports.BrotliDecompress = BrotliDecompress;
      BrotliDictionary.init();
    }
  });

  // node_modules/brotli/decompress.js
  var require_decompress = __commonJS({
    "node_modules/brotli/decompress.js"(exports, module) {
      module.exports = require_decode().BrotliDecompressBuffer;
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer4;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer4.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer4.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function Buffer4(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from2(arg, encodingOrOffset, length);
      }
      Buffer4.poolSize = 8192;
      function from2(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer4.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer4.from = function(value, encodingOrOffset, length) {
        return from2(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer4, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill2, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill2 !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill2, encoding) : createBuffer(size).fill(fill2);
        }
        return createBuffer(size);
      }
      Buffer4.alloc = function(size, fill2, encoding) {
        return alloc(size, fill2, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer4.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer4.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength2(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer4.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer4.alloc(+length);
      }
      Buffer4.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer4.prototype;
      };
      Buffer4.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer4.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer4.from(b, b.offset, b.byteLength);
        if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer4.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer4.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer4.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer4.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer4.isBuffer(buf))
                buf = Buffer4.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer4.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength2(string, encoding) {
        if (Buffer4.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.byteLength = byteLength2;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer4.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer4.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer4.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer4.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
      Buffer4.prototype.equals = function equals(b) {
        if (!Buffer4.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer4.compare(this, b) === 0;
      };
      Buffer4.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
      }
      Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer4.from(target, target.offset, target.byteLength);
        }
        if (!Buffer4.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer4.from(val, encoding);
        }
        if (Buffer4.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer4.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer4.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer4.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer4.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength3, this.length);
        }
        let val = this[offset + --byteLength3];
        let mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength3] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last2 = this[offset + 7];
        if (first === void 0 || last2 === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last2 = this[offset + 7];
        if (first === void 0 || last2 === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let i = byteLength3;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last2 = this[offset + 7];
        if (first === void 0 || last2 === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last2 = this[offset + 7];
        if (first === void 0 || last2 === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
      });
      Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer4.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        let i = byteLength3 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        let i = byteLength3 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer4.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer4.prototype.fill = function fill2(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base2) {
        errors[sym] = class NodeError extends Base2 {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range2, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range2}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength3) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
          boundsError(offset, buf.length - (byteLength3 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength3) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range2;
          if (byteLength3 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
            } else {
              range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
            }
          } else {
            range2 = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
        }
        checkBounds(buf, offset, byteLength3);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/solid-js/dist/solid.js
  var taskIdCounter = 1, isCallbackScheduled = false, isPerformingWork = false, taskQueue = [], currentTask = null, shouldYieldToHost = null, yieldInterval = 5, deadline = 0, maxYieldInterval = 300, scheduleCallback = null, scheduledCallback = null;
  var maxSigned31BitInt = 1073741823;
  function setupScheduler() {
    const channel = new MessageChannel(), port = channel.port2;
    scheduleCallback = () => port.postMessage(null);
    channel.port1.onmessage = () => {
      if (scheduledCallback !== null) {
        const currentTime = performance.now();
        deadline = currentTime + yieldInterval;
        const hasTimeRemaining = true;
        try {
          const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);
          if (!hasMoreWork) {
            scheduledCallback = null;
          } else
            port.postMessage(null);
        } catch (error2) {
          port.postMessage(null);
          throw error2;
        }
      }
    };
    if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {
      const scheduling = navigator.scheduling;
      shouldYieldToHost = () => {
        const currentTime = performance.now();
        if (currentTime >= deadline) {
          if (scheduling.isInputPending()) {
            return true;
          }
          return currentTime >= maxYieldInterval;
        } else {
          return false;
        }
      };
    } else {
      shouldYieldToHost = () => performance.now() >= deadline;
    }
  }
  function enqueue(taskQueue2, task) {
    function findIndex() {
      let m = 0;
      let n = taskQueue2.length - 1;
      while (m <= n) {
        const k = n + m >> 1;
        const cmp = task.expirationTime - taskQueue2[k].expirationTime;
        if (cmp > 0)
          m = k + 1;
        else if (cmp < 0)
          n = k - 1;
        else
          return k;
      }
      return m;
    }
    taskQueue2.splice(findIndex(), 0, task);
  }
  function requestCallback(fn, options) {
    if (!scheduleCallback)
      setupScheduler();
    let startTime = performance.now(), timeout = maxSigned31BitInt;
    if (options && options.timeout)
      timeout = options.timeout;
    const newTask = {
      id: taskIdCounter++,
      fn,
      startTime,
      expirationTime: startTime + timeout
    };
    enqueue(taskQueue, newTask);
    if (!isCallbackScheduled && !isPerformingWork) {
      isCallbackScheduled = true;
      scheduledCallback = flushWork;
      scheduleCallback();
    }
    return newTask;
  }
  function cancelCallback(task) {
    task.fn = null;
  }
  function flushWork(hasTimeRemaining, initialTime) {
    isCallbackScheduled = false;
    isPerformingWork = true;
    try {
      return workLoop(hasTimeRemaining, initialTime);
    } finally {
      currentTask = null;
      isPerformingWork = false;
    }
  }
  function workLoop(hasTimeRemaining, initialTime) {
    let currentTime = initialTime;
    currentTask = taskQueue[0] || null;
    while (currentTask !== null) {
      if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
        break;
      }
      const callback = currentTask.fn;
      if (callback !== null) {
        currentTask.fn = null;
        const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
        callback(didUserCallbackTimeout);
        currentTime = performance.now();
        if (currentTask === taskQueue[0]) {
          taskQueue.shift();
        }
      } else
        taskQueue.shift();
      currentTask = taskQueue[0] || null;
    }
    return currentTask !== null;
  }
  var sharedConfig = {
    context: void 0,
    registry: void 0
  };
  function setHydrateContext(context) {
    sharedConfig.context = context;
  }
  function nextHydrateContext() {
    return {
      ...sharedConfig.context,
      id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,
      count: 0
    };
  }
  var equalFn = (a, b) => a === b;
  var $PROXY = Symbol("solid-proxy");
  var $TRACK = Symbol("solid-track");
  var $DEVCOMP = Symbol("solid-dev-component");
  var signalOptions = {
    equals: equalFn
  };
  var ERROR = null;
  var runEffects = runQueue;
  var STALE = 1;
  var PENDING = 2;
  var UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
  };
  var NO_INIT = {};
  var Owner = null;
  var Transition = null;
  var Scheduler = null;
  var ExternalSourceFactory = null;
  var Listener = null;
  var Updates = null;
  var Effects = null;
  var ExecCount = 0;
  var [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
  function createRoot(fn, detachedOwner) {
    const listener = Listener, owner = Owner, unowned = fn.length === 0, root = unowned ? UNOWNED : {
      owned: null,
      cleanups: null,
      context: null,
      owner: detachedOwner === void 0 ? owner : detachedOwner
    }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
    Owner = root;
    Listener = null;
    try {
      return runUpdates(updateFn, true);
    } finally {
      Listener = listener;
      Owner = owner;
    }
  }
  function createSignal(value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const s = {
      value,
      observers: null,
      observerSlots: null,
      comparator: options.equals || void 0
    };
    const setter = (value2) => {
      if (typeof value2 === "function") {
        if (Transition && Transition.running && Transition.sources.has(s))
          value2 = value2(s.tValue);
        else
          value2 = value2(s.value);
      }
      return writeSignal(s, value2);
    };
    return [readSignal.bind(s), setter];
  }
  function createComputed(fn, value, options) {
    const c = createComputation(fn, value, true, STALE);
    if (Scheduler && Transition && Transition.running)
      Updates.push(c);
    else
      updateComputation(c);
  }
  function createRenderEffect(fn, value, options) {
    const c = createComputation(fn, value, false, STALE);
    if (Scheduler && Transition && Transition.running)
      Updates.push(c);
    else
      updateComputation(c);
  }
  function createEffect(fn, value, options) {
    runEffects = runUserEffects;
    const c = createComputation(fn, value, false, STALE), s = SuspenseContext && lookup(Owner, SuspenseContext.id);
    if (s)
      c.suspense = s;
    if (!options || !options.render)
      c.user = true;
    Effects ? Effects.push(c) : updateComputation(c);
  }
  function createReaction(onInvalidate, options) {
    let fn;
    const c = createComputation(() => {
      fn ? fn() : untrack(onInvalidate);
      fn = void 0;
    }, void 0, false, 0), s = SuspenseContext && lookup(Owner, SuspenseContext.id);
    if (s)
      c.suspense = s;
    c.user = true;
    return (tracking) => {
      fn = tracking;
      updateComputation(c);
    };
  }
  function createMemo(fn, value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const c = createComputation(fn, value, true, 0);
    c.observers = null;
    c.observerSlots = null;
    c.comparator = options.equals || void 0;
    if (Scheduler && Transition && Transition.running) {
      c.tState = STALE;
      Updates.push(c);
    } else
      updateComputation(c);
    return readSignal.bind(c);
  }
  function createResource(pSource, pFetcher, pOptions) {
    let source;
    let fetcher;
    let options;
    if (arguments.length === 2 && typeof pFetcher === "object" || arguments.length === 1) {
      source = true;
      fetcher = pSource;
      options = pFetcher || {};
    } else {
      source = pSource;
      fetcher = pFetcher;
      options = pOptions || {};
    }
    let pr = null, initP = NO_INIT, id = null, loadedUnderTransition = false, scheduled = false, resolved = "initialValue" in options, dynamic = typeof source === "function" && createMemo(source);
    const contexts = /* @__PURE__ */ new Set(), [value, setValue] = (options.storage || createSignal)(options.initialValue), [error2, setError] = createSignal(void 0), [track, trigger] = createSignal(void 0, {
      equals: false
    }), [state, setState] = createSignal(resolved ? "ready" : "unresolved");
    if (sharedConfig.context) {
      id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;
      let v;
      if (options.ssrLoadFrom === "initial")
        initP = options.initialValue;
      else if (sharedConfig.load && (v = sharedConfig.load(id)))
        initP = v[0];
    }
    function loadEnd(p, v, error3, key) {
      if (pr === p) {
        pr = null;
        key !== void 0 && (resolved = true);
        if ((p === initP || v === initP) && options.onHydrated)
          queueMicrotask(() => options.onHydrated(key, {
            value: v
          }));
        initP = NO_INIT;
        if (Transition && p && loadedUnderTransition) {
          Transition.promises.delete(p);
          loadedUnderTransition = false;
          runUpdates(() => {
            Transition.running = true;
            completeLoad(v, error3);
          }, false);
        } else
          completeLoad(v, error3);
      }
      return v;
    }
    function completeLoad(v, err) {
      runUpdates(() => {
        if (err === void 0)
          setValue(() => v);
        setState(err !== void 0 ? "errored" : resolved ? "ready" : "unresolved");
        setError(err);
        for (const c of contexts.keys())
          c.decrement();
        contexts.clear();
      }, false);
    }
    function read() {
      const c = SuspenseContext && lookup(Owner, SuspenseContext.id), v = value(), err = error2();
      if (err !== void 0 && !pr)
        throw err;
      if (Listener && !Listener.user && c) {
        createComputed(() => {
          track();
          if (pr) {
            if (c.resolved && Transition && loadedUnderTransition)
              Transition.promises.add(pr);
            else if (!contexts.has(c)) {
              c.increment();
              contexts.add(c);
            }
          }
        });
      }
      return v;
    }
    function load(refetching = true) {
      if (refetching !== false && scheduled)
        return;
      scheduled = false;
      const lookup4 = dynamic ? dynamic() : source;
      loadedUnderTransition = Transition && Transition.running;
      if (lookup4 == null || lookup4 === false) {
        loadEnd(pr, untrack(value));
        return;
      }
      if (Transition && pr)
        Transition.promises.delete(pr);
      const p = initP !== NO_INIT ? initP : untrack(() => fetcher(lookup4, {
        value: value(),
        refetching
      }));
      if (typeof p !== "object" || !(p && "then" in p)) {
        loadEnd(pr, p, void 0, lookup4);
        return p;
      }
      pr = p;
      scheduled = true;
      queueMicrotask(() => scheduled = false);
      runUpdates(() => {
        setState(resolved ? "refreshing" : "pending");
        trigger();
      }, false);
      return p.then((v) => loadEnd(p, v, void 0, lookup4), (e) => loadEnd(p, void 0, castError(e), lookup4));
    }
    Object.defineProperties(read, {
      state: {
        get: () => state()
      },
      error: {
        get: () => error2()
      },
      loading: {
        get() {
          const s = state();
          return s === "pending" || s === "refreshing";
        }
      },
      latest: {
        get() {
          if (!resolved)
            return read();
          const err = error2();
          if (err && !pr)
            throw err;
          return value();
        }
      }
    });
    if (dynamic)
      createComputed(() => load(false));
    else
      load(false);
    return [read, {
      refetch: load,
      mutate: setValue
    }];
  }
  function createDeferred(source, options) {
    let t, timeout = options ? options.timeoutMs : void 0;
    const node = createComputation(() => {
      if (!t || !t.fn)
        t = requestCallback(() => setDeferred(() => node.value), timeout !== void 0 ? {
          timeout
        } : void 0);
      return source();
    }, void 0, true);
    const [deferred, setDeferred] = createSignal(node.value, options);
    updateComputation(node);
    setDeferred(() => node.value);
    return deferred;
  }
  function createSelector(source, fn = equalFn, options) {
    const subs = /* @__PURE__ */ new Map();
    const node = createComputation((p) => {
      const v = source();
      for (const [key, val] of subs.entries())
        if (fn(key, v) !== fn(key, p)) {
          for (const c of val.values()) {
            c.state = STALE;
            if (c.pure)
              Updates.push(c);
            else
              Effects.push(c);
          }
        }
      return v;
    }, void 0, true, STALE);
    updateComputation(node);
    return (key) => {
      const listener = Listener;
      if (listener) {
        let l;
        if (l = subs.get(key))
          l.add(listener);
        else
          subs.set(key, l = /* @__PURE__ */ new Set([listener]));
        onCleanup(() => {
          l.delete(listener);
          !l.size && subs.delete(key);
        });
      }
      return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
    };
  }
  function batch(fn) {
    return runUpdates(fn, false);
  }
  function untrack(fn) {
    if (Listener === null)
      return fn();
    const listener = Listener;
    Listener = null;
    try {
      return fn();
    } finally {
      Listener = listener;
    }
  }
  function on(deps, fn, options) {
    const isArray = Array.isArray(deps);
    let prevInput;
    let defer = options && options.defer;
    return (prevValue) => {
      let input;
      if (isArray) {
        input = Array(deps.length);
        for (let i = 0; i < deps.length; i++)
          input[i] = deps[i]();
      } else
        input = deps();
      if (defer) {
        defer = false;
        return void 0;
      }
      const result = untrack(() => fn(input, prevInput, prevValue));
      prevInput = input;
      return result;
    };
  }
  function onMount(fn) {
    createEffect(() => untrack(fn));
  }
  function onCleanup(fn) {
    if (Owner === null)
      ;
    else if (Owner.cleanups === null)
      Owner.cleanups = [fn];
    else
      Owner.cleanups.push(fn);
    return fn;
  }
  function catchError(fn, handler) {
    ERROR || (ERROR = Symbol("error"));
    Owner = createComputation(void 0, void 0, true);
    Owner.context = {
      [ERROR]: [handler]
    };
    if (Transition && Transition.running)
      Transition.sources.add(Owner);
    try {
      return fn();
    } catch (err) {
      handleError(err);
    } finally {
      Owner = Owner.owner;
    }
  }
  function onError(fn) {
    ERROR || (ERROR = Symbol("error"));
    if (Owner === null)
      ;
    else if (Owner.context === null)
      Owner.context = {
        [ERROR]: [fn]
      };
    else if (!Owner.context[ERROR])
      Owner.context[ERROR] = [fn];
    else
      Owner.context[ERROR].push(fn);
  }
  function getListener() {
    return Listener;
  }
  function getOwner() {
    return Owner;
  }
  function runWithOwner(o, fn) {
    const prev = Owner;
    const prevListener = Listener;
    Owner = o;
    Listener = null;
    try {
      return runUpdates(fn, true);
    } catch (err) {
      handleError(err);
    } finally {
      Owner = prev;
      Listener = prevListener;
    }
  }
  function enableScheduling(scheduler = requestCallback) {
    Scheduler = scheduler;
  }
  function startTransition(fn) {
    if (Transition && Transition.running) {
      fn();
      return Transition.done;
    }
    const l = Listener;
    const o = Owner;
    return Promise.resolve().then(() => {
      Listener = l;
      Owner = o;
      let t;
      if (Scheduler || SuspenseContext) {
        t = Transition || (Transition = {
          sources: /* @__PURE__ */ new Set(),
          effects: [],
          promises: /* @__PURE__ */ new Set(),
          disposed: /* @__PURE__ */ new Set(),
          queue: /* @__PURE__ */ new Set(),
          running: true
        });
        t.done || (t.done = new Promise((res) => t.resolve = res));
        t.running = true;
      }
      runUpdates(fn, false);
      Listener = Owner = null;
      return t ? t.done : void 0;
    });
  }
  function useTransition() {
    return [transPending, startTransition];
  }
  function resumeEffects(e) {
    Effects.push.apply(Effects, e);
    e.length = 0;
  }
  function createContext(defaultValue, options) {
    const id = Symbol("context");
    return {
      id,
      Provider: createProvider(id),
      defaultValue
    };
  }
  function useContext(context) {
    let ctx;
    return (ctx = lookup(Owner, context.id)) !== void 0 ? ctx : context.defaultValue;
  }
  function children(fn) {
    const children2 = createMemo(fn);
    const memo = createMemo(() => resolveChildren(children2()));
    memo.toArray = () => {
      const c = memo();
      return Array.isArray(c) ? c : c != null ? [c] : [];
    };
    return memo;
  }
  var SuspenseContext;
  function getSuspenseContext() {
    return SuspenseContext || (SuspenseContext = createContext({}));
  }
  function enableExternalSource(factory) {
    if (ExternalSourceFactory) {
      const oldFactory = ExternalSourceFactory;
      ExternalSourceFactory = (fn, trigger) => {
        const oldSource = oldFactory(fn, trigger);
        const source = factory((x) => oldSource.track(x), trigger);
        return {
          track: (x) => source.track(x),
          dispose() {
            source.dispose();
            oldSource.dispose();
          }
        };
      };
    } else {
      ExternalSourceFactory = factory;
    }
  }
  function readSignal() {
    const runningTransition = Transition && Transition.running;
    if (this.sources && (runningTransition ? this.tState : this.state)) {
      if ((runningTransition ? this.tState : this.state) === STALE)
        updateComputation(this);
      else {
        const updates = Updates;
        Updates = null;
        runUpdates(() => lookUpstream(this), false);
        Updates = updates;
      }
    }
    if (Listener) {
      const sSlot = this.observers ? this.observers.length : 0;
      if (!Listener.sources) {
        Listener.sources = [this];
        Listener.sourceSlots = [sSlot];
      } else {
        Listener.sources.push(this);
        Listener.sourceSlots.push(sSlot);
      }
      if (!this.observers) {
        this.observers = [Listener];
        this.observerSlots = [Listener.sources.length - 1];
      } else {
        this.observers.push(Listener);
        this.observerSlots.push(Listener.sources.length - 1);
      }
    }
    if (runningTransition && Transition.sources.has(this))
      return this.tValue;
    return this.value;
  }
  function writeSignal(node, value, isComp) {
    let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
    if (!node.comparator || !node.comparator(current, value)) {
      if (Transition) {
        const TransitionRunning = Transition.running;
        if (TransitionRunning || !isComp && Transition.sources.has(node)) {
          Transition.sources.add(node);
          node.tValue = value;
        }
        if (!TransitionRunning)
          node.value = value;
      } else
        node.value = value;
      if (node.observers && node.observers.length) {
        runUpdates(() => {
          for (let i = 0; i < node.observers.length; i += 1) {
            const o = node.observers[i];
            const TransitionRunning = Transition && Transition.running;
            if (TransitionRunning && Transition.disposed.has(o))
              continue;
            if (TransitionRunning ? !o.tState : !o.state) {
              if (o.pure)
                Updates.push(o);
              else
                Effects.push(o);
              if (o.observers)
                markDownstream(o);
            }
            if (!TransitionRunning)
              o.state = STALE;
            else
              o.tState = STALE;
          }
          if (Updates.length > 1e6) {
            Updates = [];
            if (false)
              ;
            throw new Error();
          }
        }, false);
      }
    }
    return value;
  }
  function updateComputation(node) {
    if (!node.fn)
      return;
    cleanNode(node);
    const owner = Owner, listener = Listener, time = ExecCount;
    Listener = Owner = node;
    runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
    if (Transition && !Transition.running && Transition.sources.has(node)) {
      queueMicrotask(() => {
        runUpdates(() => {
          Transition && (Transition.running = true);
          Listener = Owner = node;
          runComputation(node, node.tValue, time);
          Listener = Owner = null;
        }, false);
      });
    }
    Listener = listener;
    Owner = owner;
  }
  function runComputation(node, value, time) {
    let nextValue;
    try {
      nextValue = node.fn(value);
    } catch (err) {
      if (node.pure) {
        if (Transition && Transition.running) {
          node.tState = STALE;
          node.tOwned && node.tOwned.forEach(cleanNode);
          node.tOwned = void 0;
        } else {
          node.state = STALE;
          node.owned && node.owned.forEach(cleanNode);
          node.owned = null;
        }
      }
      node.updatedAt = time + 1;
      return handleError(err);
    }
    if (!node.updatedAt || node.updatedAt <= time) {
      if (node.updatedAt != null && "observers" in node) {
        writeSignal(node, nextValue, true);
      } else if (Transition && Transition.running && node.pure) {
        Transition.sources.add(node);
        node.tValue = nextValue;
      } else
        node.value = nextValue;
      node.updatedAt = time;
    }
  }
  function createComputation(fn, init, pure, state = STALE, options) {
    const c = {
      fn,
      state,
      updatedAt: null,
      owned: null,
      sources: null,
      sourceSlots: null,
      cleanups: null,
      value: init,
      owner: Owner,
      context: null,
      pure
    };
    if (Transition && Transition.running) {
      c.state = 0;
      c.tState = state;
    }
    if (Owner === null)
      ;
    else if (Owner !== UNOWNED) {
      if (Transition && Transition.running && Owner.pure) {
        if (!Owner.tOwned)
          Owner.tOwned = [c];
        else
          Owner.tOwned.push(c);
      } else {
        if (!Owner.owned)
          Owner.owned = [c];
        else
          Owner.owned.push(c);
      }
    }
    if (ExternalSourceFactory) {
      const [track, trigger] = createSignal(void 0, {
        equals: false
      });
      const ordinary = ExternalSourceFactory(c.fn, trigger);
      onCleanup(() => ordinary.dispose());
      const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
      const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);
      c.fn = (x) => {
        track();
        return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
      };
    }
    return c;
  }
  function runTop(node) {
    const runningTransition = Transition && Transition.running;
    if ((runningTransition ? node.tState : node.state) === 0)
      return;
    if ((runningTransition ? node.tState : node.state) === PENDING)
      return lookUpstream(node);
    if (node.suspense && untrack(node.suspense.inFallback))
      return node.suspense.effects.push(node);
    const ancestors = [node];
    while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
      if (runningTransition && Transition.disposed.has(node))
        return;
      if (runningTransition ? node.tState : node.state)
        ancestors.push(node);
    }
    for (let i = ancestors.length - 1; i >= 0; i--) {
      node = ancestors[i];
      if (runningTransition) {
        let top = node, prev = ancestors[i + 1];
        while ((top = top.owner) && top !== prev) {
          if (Transition.disposed.has(top))
            return;
        }
      }
      if ((runningTransition ? node.tState : node.state) === STALE) {
        updateComputation(node);
      } else if ((runningTransition ? node.tState : node.state) === PENDING) {
        const updates = Updates;
        Updates = null;
        runUpdates(() => lookUpstream(node, ancestors[0]), false);
        Updates = updates;
      }
    }
  }
  function runUpdates(fn, init) {
    if (Updates)
      return fn();
    let wait = false;
    if (!init)
      Updates = [];
    if (Effects)
      wait = true;
    else
      Effects = [];
    ExecCount++;
    try {
      const res = fn();
      completeUpdates(wait);
      return res;
    } catch (err) {
      if (!wait)
        Effects = null;
      Updates = null;
      handleError(err);
    }
  }
  function completeUpdates(wait) {
    if (Updates) {
      if (Scheduler && Transition && Transition.running)
        scheduleQueue(Updates);
      else
        runQueue(Updates);
      Updates = null;
    }
    if (wait)
      return;
    let res;
    if (Transition) {
      if (!Transition.promises.size && !Transition.queue.size) {
        const sources = Transition.sources;
        const disposed = Transition.disposed;
        Effects.push.apply(Effects, Transition.effects);
        res = Transition.resolve;
        for (const e2 of Effects) {
          "tState" in e2 && (e2.state = e2.tState);
          delete e2.tState;
        }
        Transition = null;
        runUpdates(() => {
          for (const d of disposed)
            cleanNode(d);
          for (const v of sources) {
            v.value = v.tValue;
            if (v.owned) {
              for (let i = 0, len = v.owned.length; i < len; i++)
                cleanNode(v.owned[i]);
            }
            if (v.tOwned)
              v.owned = v.tOwned;
            delete v.tValue;
            delete v.tOwned;
            v.tState = 0;
          }
          setTransPending(false);
        }, false);
      } else if (Transition.running) {
        Transition.running = false;
        Transition.effects.push.apply(Transition.effects, Effects);
        Effects = null;
        setTransPending(true);
        return;
      }
    }
    const e = Effects;
    Effects = null;
    if (e.length)
      runUpdates(() => runEffects(e), false);
    if (res)
      res();
  }
  function runQueue(queue) {
    for (let i = 0; i < queue.length; i++)
      runTop(queue[i]);
  }
  function scheduleQueue(queue) {
    for (let i = 0; i < queue.length; i++) {
      const item = queue[i];
      const tasks = Transition.queue;
      if (!tasks.has(item)) {
        tasks.add(item);
        Scheduler(() => {
          tasks.delete(item);
          runUpdates(() => {
            Transition.running = true;
            runTop(item);
          }, false);
          Transition && (Transition.running = false);
        });
      }
    }
  }
  function runUserEffects(queue) {
    let i, userLength = 0;
    for (i = 0; i < queue.length; i++) {
      const e = queue[i];
      if (!e.user)
        runTop(e);
      else
        queue[userLength++] = e;
    }
    if (sharedConfig.context)
      setHydrateContext();
    for (i = 0; i < userLength; i++)
      runTop(queue[i]);
  }
  function lookUpstream(node, ignore) {
    const runningTransition = Transition && Transition.running;
    if (runningTransition)
      node.tState = 0;
    else
      node.state = 0;
    for (let i = 0; i < node.sources.length; i += 1) {
      const source = node.sources[i];
      if (source.sources) {
        const state = runningTransition ? source.tState : source.state;
        if (state === STALE) {
          if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
            runTop(source);
        } else if (state === PENDING)
          lookUpstream(source, ignore);
      }
    }
  }
  function markDownstream(node) {
    const runningTransition = Transition && Transition.running;
    for (let i = 0; i < node.observers.length; i += 1) {
      const o = node.observers[i];
      if (runningTransition ? !o.tState : !o.state) {
        if (runningTransition)
          o.tState = PENDING;
        else
          o.state = PENDING;
        if (o.pure)
          Updates.push(o);
        else
          Effects.push(o);
        o.observers && markDownstream(o);
      }
    }
  }
  function cleanNode(node) {
    let i;
    if (node.sources) {
      while (node.sources.length) {
        const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
        if (obs && obs.length) {
          const n = obs.pop(), s = source.observerSlots.pop();
          if (index < obs.length) {
            n.sourceSlots[s] = index;
            obs[index] = n;
            source.observerSlots[index] = s;
          }
        }
      }
    }
    if (Transition && Transition.running && node.pure) {
      if (node.tOwned) {
        for (i = node.tOwned.length - 1; i >= 0; i--)
          cleanNode(node.tOwned[i]);
        delete node.tOwned;
      }
      reset(node, true);
    } else if (node.owned) {
      for (i = node.owned.length - 1; i >= 0; i--)
        cleanNode(node.owned[i]);
      node.owned = null;
    }
    if (node.cleanups) {
      for (i = node.cleanups.length - 1; i >= 0; i--)
        node.cleanups[i]();
      node.cleanups = null;
    }
    if (Transition && Transition.running)
      node.tState = 0;
    else
      node.state = 0;
    node.context = null;
  }
  function reset(node, top) {
    if (!top) {
      node.tState = 0;
      Transition.disposed.add(node);
    }
    if (node.owned) {
      for (let i = 0; i < node.owned.length; i++)
        reset(node.owned[i]);
    }
  }
  function castError(err) {
    if (err instanceof Error)
      return err;
    return new Error(typeof err === "string" ? err : "Unknown error", {
      cause: err
    });
  }
  function handleError(err, owner = Owner) {
    const fns = ERROR && lookup(owner, ERROR);
    const error2 = castError(err);
    if (!fns)
      throw error2;
    if (Effects)
      Effects.push({
        fn() {
          try {
            for (const f of fns)
              f(error2);
          } catch (e) {
            handleError(e, owner?.owner || null);
          }
        },
        state: STALE
      });
    else {
      try {
        for (const f of fns)
          f(error2);
      } catch (e) {
        handleError(e, owner?.owner || null);
      }
    }
  }
  function lookup(owner, key) {
    return owner ? owner.context && owner.context[key] !== void 0 ? owner.context[key] : lookup(owner.owner, key) : void 0;
  }
  function resolveChildren(children2) {
    if (typeof children2 === "function" && !children2.length)
      return resolveChildren(children2());
    if (Array.isArray(children2)) {
      const results = [];
      for (let i = 0; i < children2.length; i++) {
        const result = resolveChildren(children2[i]);
        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
      }
      return results;
    }
    return children2;
  }
  function createProvider(id, options) {
    return function provider(props) {
      let res;
      createRenderEffect(() => res = untrack(() => {
        Owner.context = {
          [id]: props.value
        };
        return children(() => props.children);
      }), void 0);
      return res;
    };
  }
  function observable(input) {
    return {
      subscribe(observer) {
        if (!(observer instanceof Object) || observer == null) {
          throw new TypeError("Expected the observer to be an object.");
        }
        const handler = typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
        if (!handler) {
          return {
            unsubscribe() {
            }
          };
        }
        const dispose2 = createRoot((disposer) => {
          createEffect(() => {
            const v = input();
            untrack(() => handler(v));
          });
          return disposer;
        });
        if (getOwner())
          onCleanup(dispose2);
        return {
          unsubscribe() {
            dispose2();
          }
        };
      },
      [Symbol.observable || "@@observable"]() {
        return this;
      }
    };
  }
  function from(producer) {
    const [s, set] = createSignal(void 0, {
      equals: false
    });
    if ("subscribe" in producer) {
      const unsub = producer.subscribe((v) => set(() => v));
      onCleanup(() => "unsubscribe" in unsub ? unsub.unsubscribe() : unsub());
    } else {
      const clean = producer(set);
      onCleanup(clean);
    }
    return s;
  }
  var FALLBACK = Symbol("fallback");
  function dispose(d) {
    for (let i = 0; i < d.length; i++)
      d[i]();
  }
  function mapArray(list, mapFn, options = {}) {
    let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
    onCleanup(() => dispose(disposers));
    return () => {
      let newItems = list() || [], i, j;
      newItems[$TRACK];
      return untrack(() => {
        let newLen = newItems.length, newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
        if (newLen === 0) {
          if (len !== 0) {
            dispose(disposers);
            disposers = [];
            items = [];
            mapped = [];
            len = 0;
            indexes && (indexes = []);
          }
          if (options.fallback) {
            items = [FALLBACK];
            mapped[0] = createRoot((disposer) => {
              disposers[0] = disposer;
              return options.fallback();
            });
            len = 1;
          }
        } else if (len === 0) {
          mapped = new Array(newLen);
          for (j = 0; j < newLen; j++) {
            items[j] = newItems[j];
            mapped[j] = createRoot(mapper);
          }
          len = newLen;
        } else {
          temp = new Array(newLen);
          tempdisposers = new Array(newLen);
          indexes && (tempIndexes = new Array(newLen));
          for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++)
            ;
          for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
            temp[newEnd] = mapped[end];
            tempdisposers[newEnd] = disposers[end];
            indexes && (tempIndexes[newEnd] = indexes[end]);
          }
          newIndices = /* @__PURE__ */ new Map();
          newIndicesNext = new Array(newEnd + 1);
          for (j = newEnd; j >= start; j--) {
            item = newItems[j];
            i = newIndices.get(item);
            newIndicesNext[j] = i === void 0 ? -1 : i;
            newIndices.set(item, j);
          }
          for (i = start; i <= end; i++) {
            item = items[i];
            j = newIndices.get(item);
            if (j !== void 0 && j !== -1) {
              temp[j] = mapped[i];
              tempdisposers[j] = disposers[i];
              indexes && (tempIndexes[j] = indexes[i]);
              j = newIndicesNext[j];
              newIndices.set(item, j);
            } else
              disposers[i]();
          }
          for (j = start; j < newLen; j++) {
            if (j in temp) {
              mapped[j] = temp[j];
              disposers[j] = tempdisposers[j];
              if (indexes) {
                indexes[j] = tempIndexes[j];
                indexes[j](j);
              }
            } else
              mapped[j] = createRoot(mapper);
          }
          mapped = mapped.slice(0, len = newLen);
          items = newItems.slice(0);
        }
        return mapped;
      });
      function mapper(disposer) {
        disposers[j] = disposer;
        if (indexes) {
          const [s, set] = createSignal(j);
          indexes[j] = set;
          return mapFn(newItems[j], s);
        }
        return mapFn(newItems[j]);
      }
    };
  }
  function indexArray(list, mapFn, options = {}) {
    let items = [], mapped = [], disposers = [], signals = [], len = 0, i;
    onCleanup(() => dispose(disposers));
    return () => {
      const newItems = list() || [];
      newItems[$TRACK];
      return untrack(() => {
        if (newItems.length === 0) {
          if (len !== 0) {
            dispose(disposers);
            disposers = [];
            items = [];
            mapped = [];
            len = 0;
            signals = [];
          }
          if (options.fallback) {
            items = [FALLBACK];
            mapped[0] = createRoot((disposer) => {
              disposers[0] = disposer;
              return options.fallback();
            });
            len = 1;
          }
          return mapped;
        }
        if (items[0] === FALLBACK) {
          disposers[0]();
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
        }
        for (i = 0; i < newItems.length; i++) {
          if (i < items.length && items[i] !== newItems[i]) {
            signals[i](() => newItems[i]);
          } else if (i >= items.length) {
            mapped[i] = createRoot(mapper);
          }
        }
        for (; i < items.length; i++) {
          disposers[i]();
        }
        len = signals.length = disposers.length = newItems.length;
        items = newItems.slice(0);
        return mapped = mapped.slice(0, len);
      });
      function mapper(disposer) {
        disposers[i] = disposer;
        const [s, set] = createSignal(newItems[i]);
        signals[i] = set;
        return mapFn(s, i);
      }
    };
  }
  var hydrationEnabled = false;
  function enableHydration() {
    hydrationEnabled = true;
  }
  function createComponent(Comp, props) {
    if (hydrationEnabled) {
      if (sharedConfig.context) {
        const c = sharedConfig.context;
        setHydrateContext(nextHydrateContext());
        const r = untrack(() => Comp(props || {}));
        setHydrateContext(c);
        return r;
      }
    }
    return untrack(() => Comp(props || {}));
  }
  function trueFn() {
    return true;
  }
  var propTraps = {
    get(_, property, receiver) {
      if (property === $PROXY)
        return receiver;
      return _.get(property);
    },
    has(_, property) {
      if (property === $PROXY)
        return true;
      return _.has(property);
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor(_, property) {
      return {
        configurable: true,
        enumerable: true,
        get() {
          return _.get(property);
        },
        set: trueFn,
        deleteProperty: trueFn
      };
    },
    ownKeys(_) {
      return _.keys();
    }
  };
  function resolveSource(s) {
    return !(s = typeof s === "function" ? s() : s) ? {} : s;
  }
  function resolveSources() {
    for (let i = 0, length = this.length; i < length; ++i) {
      const v = this[i]();
      if (v !== void 0)
        return v;
    }
  }
  function mergeProps(...sources) {
    let proxy = false;
    for (let i = 0; i < sources.length; i++) {
      const s = sources[i];
      proxy = proxy || !!s && $PROXY in s;
      sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
    }
    if (proxy) {
      return new Proxy({
        get(property) {
          for (let i = sources.length - 1; i >= 0; i--) {
            const v = resolveSource(sources[i])[property];
            if (v !== void 0)
              return v;
          }
        },
        has(property) {
          for (let i = sources.length - 1; i >= 0; i--) {
            if (property in resolveSource(sources[i]))
              return true;
          }
          return false;
        },
        keys() {
          const keys = [];
          for (let i = 0; i < sources.length; i++)
            keys.push(...Object.keys(resolveSource(sources[i])));
          return [...new Set(keys)];
        }
      }, propTraps);
    }
    const target = {};
    const sourcesMap = {};
    const defined = /* @__PURE__ */ new Set();
    for (let i = sources.length - 1; i >= 0; i--) {
      const source = sources[i];
      if (!source)
        continue;
      const sourceKeys = Object.getOwnPropertyNames(source);
      for (let i2 = 0, length = sourceKeys.length; i2 < length; i2++) {
        const key = sourceKeys[i2];
        if (key === "__proto__" || key === "constructor")
          continue;
        const desc = Object.getOwnPropertyDescriptor(source, key);
        if (!defined.has(key)) {
          if (desc.get) {
            defined.add(key);
            Object.defineProperty(target, key, {
              enumerable: true,
              configurable: true,
              get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
            });
          } else {
            if (desc.value !== void 0)
              defined.add(key);
            target[key] = desc.value;
          }
        } else {
          const sources2 = sourcesMap[key];
          if (sources2) {
            if (desc.get) {
              sources2.push(desc.get.bind(source));
            } else if (desc.value !== void 0) {
              sources2.push(() => desc.value);
            }
          } else if (target[key] === void 0)
            target[key] = desc.value;
        }
      }
    }
    return target;
  }
  function splitProps(props, ...keys) {
    if ($PROXY in props) {
      const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
      const res = keys.map((k) => {
        return new Proxy({
          get(property) {
            return k.includes(property) ? props[property] : void 0;
          },
          has(property) {
            return k.includes(property) && property in props;
          },
          keys() {
            return k.filter((property) => property in props);
          }
        }, propTraps);
      });
      res.push(new Proxy({
        get(property) {
          return blocked.has(property) ? void 0 : props[property];
        },
        has(property) {
          return blocked.has(property) ? false : property in props;
        },
        keys() {
          return Object.keys(props).filter((k) => !blocked.has(k));
        }
      }, propTraps));
      return res;
    }
    const otherObject = {};
    const objects = keys.map(() => ({}));
    for (const propName of Object.getOwnPropertyNames(props)) {
      const desc = Object.getOwnPropertyDescriptor(props, propName);
      const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
      let blocked = false;
      let objectIndex = 0;
      for (const k of keys) {
        if (k.includes(propName)) {
          blocked = true;
          isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
        }
        ++objectIndex;
      }
      if (!blocked) {
        isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
      }
    }
    return [...objects, otherObject];
  }
  function lazy(fn) {
    let comp;
    let p;
    const wrap = (props) => {
      const ctx = sharedConfig.context;
      if (ctx) {
        const [s, set] = createSignal();
        (p || (p = fn())).then((mod) => {
          setHydrateContext(ctx);
          set(() => mod.default);
          setHydrateContext();
        });
        comp = s;
      } else if (!comp) {
        const [s] = createResource(() => (p || (p = fn())).then((mod) => mod.default));
        comp = s;
      }
      let Comp;
      return createMemo(() => (Comp = comp()) && untrack(() => {
        if (false)
          ;
        if (!ctx)
          return Comp(props);
        const c = sharedConfig.context;
        setHydrateContext(ctx);
        const r = Comp(props);
        setHydrateContext(c);
        return r;
      }));
    };
    wrap.preload = () => p || ((p = fn()).then((mod) => comp = () => mod.default), p);
    return wrap;
  }
  var counter = 0;
  function createUniqueId() {
    const ctx = sharedConfig.context;
    return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;
  }
  var narrowedError = (name) => `Stale read from <${name}>.`;
  function For(props) {
    const fallback = "fallback" in props && {
      fallback: () => props.fallback
    };
    return createMemo(mapArray(() => props.each, props.children, fallback || void 0));
  }
  function Index(props) {
    const fallback = "fallback" in props && {
      fallback: () => props.fallback
    };
    return createMemo(indexArray(() => props.each, props.children, fallback || void 0));
  }
  function Show(props) {
    const keyed = props.keyed;
    const condition = createMemo(() => props.when, void 0, {
      equals: (a, b) => keyed ? a === b : !a === !b
    });
    return createMemo(() => {
      const c = condition();
      if (c) {
        const child = props.children;
        const fn = typeof child === "function" && child.length > 0;
        return fn ? untrack(() => child(keyed ? c : () => {
          if (!untrack(condition))
            throw narrowedError("Show");
          return props.when;
        })) : child;
      }
      return props.fallback;
    }, void 0, void 0);
  }
  function Switch(props) {
    let keyed = false;
    const equals = (a, b) => a[0] === b[0] && (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];
    const conditions = children(() => props.children), evalConditions = createMemo(() => {
      let conds = conditions();
      if (!Array.isArray(conds))
        conds = [conds];
      for (let i = 0; i < conds.length; i++) {
        const c = conds[i].when;
        if (c) {
          keyed = !!conds[i].keyed;
          return [i, c, conds[i]];
        }
      }
      return [-1];
    }, void 0, {
      equals
    });
    return createMemo(() => {
      const [index, when, cond] = evalConditions();
      if (index < 0)
        return props.fallback;
      const c = cond.children;
      const fn = typeof c === "function" && c.length > 0;
      return fn ? untrack(() => c(keyed ? when : () => {
        if (untrack(evalConditions)[0] !== index)
          throw narrowedError("Match");
        return cond.when;
      })) : c;
    }, void 0, void 0);
  }
  function Match(props) {
    return props;
  }
  var Errors;
  function resetErrorBoundaries() {
    Errors && [...Errors].forEach((fn) => fn());
  }
  function ErrorBoundary(props) {
    let err;
    let v;
    if (sharedConfig.context && sharedConfig.load && (v = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count)))
      err = v[0];
    const [errored, setErrored] = createSignal(err, void 0);
    Errors || (Errors = /* @__PURE__ */ new Set());
    Errors.add(setErrored);
    onCleanup(() => Errors.delete(setErrored));
    return createMemo(() => {
      let e;
      if (e = errored()) {
        const f = props.fallback;
        return typeof f === "function" && f.length ? untrack(() => f(e, () => setErrored())) : f;
      }
      return catchError(() => props.children, setErrored);
    }, void 0, void 0);
  }
  var suspenseListEquals = (a, b) => a.showContent === b.showContent && a.showFallback === b.showFallback;
  var SuspenseListContext = createContext();
  function SuspenseList(props) {
    let [wrapper, setWrapper] = createSignal(() => ({
      inFallback: false
    })), show;
    const listContext = useContext(SuspenseListContext);
    const [registry, setRegistry] = createSignal([]);
    if (listContext) {
      show = listContext.register(createMemo(() => wrapper()().inFallback));
    }
    const resolved = createMemo((prev) => {
      const reveal = props.revealOrder, tail = props.tail, {
        showContent = true,
        showFallback = true
      } = show ? show() : {}, reg = registry(), reverse = reveal === "backwards";
      if (reveal === "together") {
        const all = reg.every((inFallback2) => !inFallback2());
        const res2 = reg.map(() => ({
          showContent: all && showContent,
          showFallback
        }));
        res2.inFallback = !all;
        return res2;
      }
      let stop = false;
      let inFallback = prev.inFallback;
      const res = [];
      for (let i = 0, len = reg.length; i < len; i++) {
        const n = reverse ? len - i - 1 : i, s = reg[n]();
        if (!stop && !s) {
          res[n] = {
            showContent,
            showFallback
          };
        } else {
          const next = !stop;
          if (next)
            inFallback = true;
          res[n] = {
            showContent: next,
            showFallback: !tail || next && tail === "collapsed" ? showFallback : false
          };
          stop = true;
        }
      }
      if (!stop)
        inFallback = false;
      res.inFallback = inFallback;
      return res;
    }, {
      inFallback: false
    });
    setWrapper(() => resolved);
    return createComponent(SuspenseListContext.Provider, {
      value: {
        register: (inFallback) => {
          let index;
          setRegistry((registry2) => {
            index = registry2.length;
            return [...registry2, inFallback];
          });
          return createMemo(() => resolved()[index], void 0, {
            equals: suspenseListEquals
          });
        }
      },
      get children() {
        return props.children;
      }
    });
  }
  function Suspense(props) {
    let counter2 = 0, show, ctx, p, flicker, error2;
    const [inFallback, setFallback] = createSignal(false), SuspenseContext2 = getSuspenseContext(), store = {
      increment: () => {
        if (++counter2 === 1)
          setFallback(true);
      },
      decrement: () => {
        if (--counter2 === 0)
          setFallback(false);
      },
      inFallback,
      effects: [],
      resolved: false
    }, owner = getOwner();
    if (sharedConfig.context && sharedConfig.load) {
      const key = sharedConfig.context.id + sharedConfig.context.count;
      let ref = sharedConfig.load(key);
      if (ref && (p = ref[0]) && p !== "$$f") {
        if (typeof p !== "object" || !("then" in p))
          p = Promise.resolve(p);
        const [s, set] = createSignal(void 0, {
          equals: false
        });
        flicker = s;
        p.then((err) => {
          if (err || sharedConfig.done) {
            err && (error2 = err);
            return set();
          }
          sharedConfig.gather(key);
          setHydrateContext(ctx);
          set();
          setHydrateContext();
        });
      }
    }
    const listContext = useContext(SuspenseListContext);
    if (listContext)
      show = listContext.register(store.inFallback);
    let dispose2;
    onCleanup(() => dispose2 && dispose2());
    return createComponent(SuspenseContext2.Provider, {
      value: store,
      get children() {
        return createMemo(() => {
          if (error2)
            throw error2;
          ctx = sharedConfig.context;
          if (flicker) {
            flicker();
            return flicker = void 0;
          }
          if (ctx && p === "$$f")
            setHydrateContext();
          const rendered = createMemo(() => props.children);
          return createMemo((prev) => {
            const inFallback2 = store.inFallback(), {
              showContent = true,
              showFallback = true
            } = show ? show() : {};
            if ((!inFallback2 || p && p !== "$$f") && showContent) {
              store.resolved = true;
              dispose2 && dispose2();
              dispose2 = ctx = p = void 0;
              resumeEffects(store.effects);
              return rendered();
            }
            if (!showFallback)
              return;
            if (dispose2)
              return prev;
            return createRoot((disposer) => {
              dispose2 = disposer;
              if (ctx) {
                setHydrateContext({
                  id: ctx.id + "f",
                  count: 0
                });
                ctx = void 0;
              }
              return props.fallback;
            }, owner);
          });
        });
      }
    });
  }
  var DEV = void 0;

  // node_modules/solid-js/web/dist/web.js
  var booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
  var Properties = /* @__PURE__ */ new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
  var ChildProperties = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]);
  var Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
    className: "class",
    htmlFor: "for"
  });
  var PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
    class: "className",
    formnovalidate: {
      $: "formNoValidate",
      BUTTON: 1,
      INPUT: 1
    },
    ismap: {
      $: "isMap",
      IMG: 1
    },
    nomodule: {
      $: "noModule",
      SCRIPT: 1
    },
    playsinline: {
      $: "playsInline",
      VIDEO: 1
    },
    readonly: {
      $: "readOnly",
      INPUT: 1,
      TEXTAREA: 1
    }
  });
  function getPropAlias(prop, tagName) {
    const a = PropAliases[prop];
    return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
  }
  var DelegatedEvents = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]);
  var SVGElements = /* @__PURE__ */ new Set([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animate",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "circle",
    "clipPath",
    "color-profile",
    "cursor",
    "defs",
    "desc",
    "ellipse",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "filter",
    "font",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignObject",
    "g",
    "glyph",
    "glyphRef",
    "hkern",
    "image",
    "line",
    "linearGradient",
    "marker",
    "mask",
    "metadata",
    "missing-glyph",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "set",
    "stop",
    "svg",
    "switch",
    "symbol",
    "text",
    "textPath",
    "tref",
    "tspan",
    "use",
    "view",
    "vkern"
  ]);
  var SVGNamespace = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace"
  };
  var DOMElements = /* @__PURE__ */ new Set(["html", "base", "head", "link", "meta", "style", "title", "body", "address", "article", "aside", "footer", "header", "main", "nav", "section", "body", "blockquote", "dd", "div", "dl", "dt", "figcaption", "figure", "hr", "li", "ol", "p", "pre", "ul", "a", "abbr", "b", "bdi", "bdo", "br", "cite", "code", "data", "dfn", "em", "i", "kbd", "mark", "q", "rp", "rt", "ruby", "s", "samp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr", "area", "audio", "img", "map", "track", "video", "embed", "iframe", "object", "param", "picture", "portal", "source", "svg", "math", "canvas", "noscript", "script", "del", "ins", "caption", "col", "colgroup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "button", "datalist", "fieldset", "form", "input", "label", "legend", "meter", "optgroup", "option", "output", "progress", "select", "textarea", "details", "dialog", "menu", "summary", "details", "slot", "template", "acronym", "applet", "basefont", "bgsound", "big", "blink", "center", "content", "dir", "font", "frame", "frameset", "hgroup", "image", "keygen", "marquee", "menuitem", "nobr", "noembed", "noframes", "plaintext", "rb", "rtc", "shadow", "spacer", "strike", "tt", "xmp", "a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "portal", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp", "input", "h1", "h2", "h3", "h4", "h5", "h6"]);
  function reconcileArrays(parentNode, a, b) {
    let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
    while (aStart < aEnd || bStart < bEnd) {
      if (a[aStart] === b[bStart]) {
        aStart++;
        bStart++;
        continue;
      }
      while (a[aEnd - 1] === b[bEnd - 1]) {
        aEnd--;
        bEnd--;
      }
      if (aEnd === aStart) {
        const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
        while (bStart < bEnd)
          parentNode.insertBefore(b[bStart++], node);
      } else if (bEnd === bStart) {
        while (aStart < aEnd) {
          if (!map || !map.has(a[aStart]))
            a[aStart].remove();
          aStart++;
        }
      } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
        const node = a[--aEnd].nextSibling;
        parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
        parentNode.insertBefore(b[--bEnd], node);
        a[aEnd] = b[bEnd];
      } else {
        if (!map) {
          map = /* @__PURE__ */ new Map();
          let i = bStart;
          while (i < bEnd)
            map.set(b[i], i++);
        }
        const index = map.get(a[aStart]);
        if (index != null) {
          if (bStart < index && index < bEnd) {
            let i = aStart, sequence = 1, t;
            while (++i < aEnd && i < bEnd) {
              if ((t = map.get(a[i])) == null || t !== index + sequence)
                break;
              sequence++;
            }
            if (sequence > index - bStart) {
              const node = a[aStart];
              while (bStart < index)
                parentNode.insertBefore(b[bStart++], node);
            } else
              parentNode.replaceChild(b[bStart++], a[aStart++]);
          } else
            aStart++;
        } else
          a[aStart++].remove();
      }
    }
  }
  var $$EVENTS = "_$DX_DELEGATE";
  function render(code, element, init, options = {}) {
    let disposer;
    createRoot((dispose2) => {
      disposer = dispose2;
      element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
    }, options.owner);
    return () => {
      disposer();
      element.textContent = "";
    };
  }
  function template(html, isCE, isSVG) {
    let node;
    const create = () => {
      const t = document.createElement("template");
      t.innerHTML = html;
      return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;
    };
    const fn = isCE ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
    fn.cloneNode = fn;
    return fn;
  }
  function delegateEvents(eventNames, document2 = window.document) {
    const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
    for (let i = 0, l = eventNames.length; i < l; i++) {
      const name = eventNames[i];
      if (!e.has(name)) {
        e.add(name);
        document2.addEventListener(name, eventHandler);
      }
    }
  }
  function clearDelegatedEvents(document2 = window.document) {
    if (document2[$$EVENTS]) {
      for (let name of document2[$$EVENTS].keys())
        document2.removeEventListener(name, eventHandler);
      delete document2[$$EVENTS];
    }
  }
  function setAttribute(node, name, value) {
    if (value == null)
      node.removeAttribute(name);
    else
      node.setAttribute(name, value);
  }
  function setAttributeNS(node, namespace, name, value) {
    if (value == null)
      node.removeAttributeNS(namespace, name);
    else
      node.setAttributeNS(namespace, name, value);
  }
  function className(node, value) {
    if (value == null)
      node.removeAttribute("class");
    else
      node.className = value;
  }
  function addEventListener(node, name, handler, delegate) {
    if (delegate) {
      if (Array.isArray(handler)) {
        node[`$$${name}`] = handler[0];
        node[`$$${name}Data`] = handler[1];
      } else
        node[`$$${name}`] = handler;
    } else if (Array.isArray(handler)) {
      const handlerFn = handler[0];
      node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
    } else
      node.addEventListener(name, handler);
  }
  function classList(node, value, prev = {}) {
    const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
    let i, len;
    for (i = 0, len = prevKeys.length; i < len; i++) {
      const key = prevKeys[i];
      if (!key || key === "undefined" || value[key])
        continue;
      toggleClassKey(node, key, false);
      delete prev[key];
    }
    for (i = 0, len = classKeys.length; i < len; i++) {
      const key = classKeys[i], classValue = !!value[key];
      if (!key || key === "undefined" || prev[key] === classValue || !classValue)
        continue;
      toggleClassKey(node, key, true);
      prev[key] = classValue;
    }
    return prev;
  }
  function style(node, value, prev) {
    if (!value)
      return prev ? setAttribute(node, "style") : value;
    const nodeStyle = node.style;
    if (typeof value === "string")
      return nodeStyle.cssText = value;
    typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
    prev || (prev = {});
    value || (value = {});
    let v, s;
    for (s in prev) {
      value[s] == null && nodeStyle.removeProperty(s);
      delete prev[s];
    }
    for (s in value) {
      v = value[s];
      if (v !== prev[s]) {
        nodeStyle.setProperty(s, v);
        prev[s] = v;
      }
    }
    return prev;
  }
  function spread(node, props = {}, isSVG, skipChildren) {
    const prevProps = {};
    if (!skipChildren) {
      createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
    }
    createRenderEffect(() => props.ref && props.ref(node));
    createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
    return prevProps;
  }
  function dynamicProperty(props, key) {
    const src = props[key];
    Object.defineProperty(props, key, {
      get() {
        return src();
      },
      enumerable: true
    });
    return props;
  }
  function innerHTML(parent, content) {
    !sharedConfig.context && (parent.innerHTML = content);
  }
  function use(fn, element, arg) {
    return untrack(() => fn(element, arg));
  }
  function insert(parent, accessor, marker, initial) {
    if (marker !== void 0 && !initial)
      initial = [];
    if (typeof accessor !== "function")
      return insertExpression(parent, accessor, initial, marker);
    createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
  }
  function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
    props || (props = {});
    for (const prop in prevProps) {
      if (!(prop in props)) {
        if (prop === "children")
          continue;
        prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);
      }
    }
    for (const prop in props) {
      if (prop === "children") {
        if (!skipChildren)
          insertExpression(node, props.children);
        continue;
      }
      const value = props[prop];
      prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);
    }
  }
  function hydrate$1(code, element, options = {}) {
    sharedConfig.completed = globalThis._$HY.completed;
    sharedConfig.events = globalThis._$HY.events;
    sharedConfig.load = globalThis._$HY.load;
    sharedConfig.gather = (root) => gatherHydratable(element, root);
    sharedConfig.registry = /* @__PURE__ */ new Map();
    sharedConfig.context = {
      id: options.renderId || "",
      count: 0
    };
    gatherHydratable(element, options.renderId);
    const dispose2 = render(code, element, [...element.childNodes], options);
    sharedConfig.context = null;
    return dispose2;
  }
  function getNextElement(template2) {
    let node, key;
    if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {
      if (sharedConfig.context)
        console.warn("Unable to find DOM nodes for hydration key:", key);
      if (!template2)
        throw new Error("Unrecoverable Hydration Mismatch. No template for key: " + key);
      return template2();
    }
    if (sharedConfig.completed)
      sharedConfig.completed.add(node);
    sharedConfig.registry.delete(key);
    return node;
  }
  function getNextMatch(el, nodeName) {
    while (el && el.localName !== nodeName)
      el = el.nextSibling;
    return el;
  }
  function getNextMarker(start) {
    let end = start, count = 0, current = [];
    if (sharedConfig.context) {
      while (end) {
        if (end.nodeType === 8) {
          const v = end.nodeValue;
          if (v === "#")
            count++;
          else if (v === "/") {
            if (count === 0)
              return [end, current];
            count--;
          }
        }
        current.push(end);
        end = end.nextSibling;
      }
    }
    return [end, current];
  }
  function runHydrationEvents() {
    if (sharedConfig.events && !sharedConfig.events.queued) {
      queueMicrotask(() => {
        const {
          completed,
          events
        } = sharedConfig;
        events.queued = false;
        while (events.length) {
          const [el, e] = events[0];
          if (!completed.has(el))
            return;
          eventHandler(e);
          events.shift();
        }
      });
      sharedConfig.events.queued = true;
    }
  }
  function toPropertyName(name) {
    return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
  }
  function toggleClassKey(node, key, value) {
    const classNames = key.trim().split(/\s+/);
    for (let i = 0, nameLen = classNames.length; i < nameLen; i++)
      node.classList.toggle(classNames[i], value);
  }
  function assignProp(node, prop, value, prev, isSVG, skipRef) {
    let isCE, isProp, isChildProp, propAlias, forceProp;
    if (prop === "style")
      return style(node, value, prev);
    if (prop === "classList")
      return classList(node, value, prev);
    if (value === prev)
      return prev;
    if (prop === "ref") {
      if (!skipRef)
        value(node);
    } else if (prop.slice(0, 3) === "on:") {
      const e = prop.slice(3);
      prev && node.removeEventListener(e, prev);
      value && node.addEventListener(e, value);
    } else if (prop.slice(0, 10) === "oncapture:") {
      const e = prop.slice(10);
      prev && node.removeEventListener(e, prev, true);
      value && node.addEventListener(e, value, true);
    } else if (prop.slice(0, 2) === "on") {
      const name = prop.slice(2).toLowerCase();
      const delegate = DelegatedEvents.has(name);
      if (!delegate && prev) {
        const h = Array.isArray(prev) ? prev[0] : prev;
        node.removeEventListener(name, h);
      }
      if (delegate || value) {
        addEventListener(node, name, value, delegate);
        delegate && delegateEvents([name]);
      }
    } else if (prop.slice(0, 5) === "attr:") {
      setAttribute(node, prop.slice(5), value);
    } else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-"))) {
      if (forceProp) {
        prop = prop.slice(5);
        isProp = true;
      }
      if (prop === "class" || prop === "className")
        className(node, value);
      else if (isCE && !isProp && !isChildProp)
        node[toPropertyName(prop)] = value;
      else
        node[propAlias || prop] = value;
    } else {
      const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
      if (ns)
        setAttributeNS(node, ns, prop, value);
      else
        setAttribute(node, Aliases[prop] || prop, value);
    }
    return value;
  }
  function eventHandler(e) {
    const key = `$$${e.type}`;
    let node = e.composedPath && e.composedPath()[0] || e.target;
    if (e.target !== node) {
      Object.defineProperty(e, "target", {
        configurable: true,
        value: node
      });
    }
    Object.defineProperty(e, "currentTarget", {
      configurable: true,
      get() {
        return node || document;
      }
    });
    if (sharedConfig.registry && !sharedConfig.done)
      sharedConfig.done = _$HY.done = true;
    while (node) {
      const handler = node[key];
      if (handler && !node.disabled) {
        const data = node[`${key}Data`];
        data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
        if (e.cancelBubble)
          return;
      }
      node = node._$host || node.parentNode || node.host;
    }
  }
  function insertExpression(parent, value, current, marker, unwrapArray) {
    if (sharedConfig.context) {
      !current && (current = [...parent.childNodes]);
      let cleaned = [];
      for (let i = 0; i < current.length; i++) {
        const node = current[i];
        if (node.nodeType === 8 && node.data.slice(0, 2) === "!$")
          node.remove();
        else
          cleaned.push(node);
      }
      current = cleaned;
    }
    while (typeof current === "function")
      current = current();
    if (value === current)
      return current;
    const t = typeof value, multi = marker !== void 0;
    parent = multi && current[0] && current[0].parentNode || parent;
    if (t === "string" || t === "number") {
      if (sharedConfig.context)
        return current;
      if (t === "number")
        value = value.toString();
      if (multi) {
        let node = current[0];
        if (node && node.nodeType === 3) {
          node.data = value;
        } else
          node = document.createTextNode(value);
        current = cleanChildren(parent, current, marker, node);
      } else {
        if (current !== "" && typeof current === "string") {
          current = parent.firstChild.data = value;
        } else
          current = parent.textContent = value;
      }
    } else if (value == null || t === "boolean") {
      if (sharedConfig.context)
        return current;
      current = cleanChildren(parent, current, marker);
    } else if (t === "function") {
      createRenderEffect(() => {
        let v = value();
        while (typeof v === "function")
          v = v();
        current = insertExpression(parent, v, current, marker);
      });
      return () => current;
    } else if (Array.isArray(value)) {
      const array = [];
      const currentArray = current && Array.isArray(current);
      if (normalizeIncomingArray(array, value, current, unwrapArray)) {
        createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
        return () => current;
      }
      if (sharedConfig.context) {
        if (!array.length)
          return current;
        for (let i = 0; i < array.length; i++) {
          if (array[i].parentNode)
            return current = array;
        }
      }
      if (array.length === 0) {
        current = cleanChildren(parent, current, marker);
        if (multi)
          return current;
      } else if (currentArray) {
        if (current.length === 0) {
          appendNodes(parent, array, marker);
        } else
          reconcileArrays(parent, current, array);
      } else {
        current && cleanChildren(parent);
        appendNodes(parent, array);
      }
      current = array;
    } else if (value.nodeType) {
      if (sharedConfig.context && value.parentNode)
        return current = multi ? [value] : value;
      if (Array.isArray(current)) {
        if (multi)
          return current = cleanChildren(parent, current, marker, value);
        cleanChildren(parent, current, null, value);
      } else if (current == null || current === "" || !parent.firstChild) {
        parent.appendChild(value);
      } else
        parent.replaceChild(value, parent.firstChild);
      current = value;
    } else
      console.warn(`Unrecognized value. Skipped inserting`, value);
    return current;
  }
  function normalizeIncomingArray(normalized, array, current, unwrap) {
    let dynamic = false;
    for (let i = 0, len = array.length; i < len; i++) {
      let item = array[i], prev = current && current[i], t;
      if (item == null || item === true || item === false)
        ;
      else if ((t = typeof item) === "object" && item.nodeType) {
        normalized.push(item);
      } else if (Array.isArray(item)) {
        dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
      } else if (t === "function") {
        if (unwrap) {
          while (typeof item === "function")
            item = item();
          dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
        } else {
          normalized.push(item);
          dynamic = true;
        }
      } else {
        const value = String(item);
        if (prev && prev.nodeType === 3 && prev.data === value)
          normalized.push(prev);
        else
          normalized.push(document.createTextNode(value));
      }
    }
    return dynamic;
  }
  function appendNodes(parent, array, marker = null) {
    for (let i = 0, len = array.length; i < len; i++)
      parent.insertBefore(array[i], marker);
  }
  function cleanChildren(parent, current, marker, replacement) {
    if (marker === void 0)
      return parent.textContent = "";
    const node = replacement || document.createTextNode("");
    if (current.length) {
      let inserted = false;
      for (let i = current.length - 1; i >= 0; i--) {
        const el = current[i];
        if (node !== el) {
          const isParent = el.parentNode === parent;
          if (!inserted && !i)
            isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
          else
            isParent && el.remove();
        } else
          inserted = true;
      }
    } else
      parent.insertBefore(node, marker);
    return [node];
  }
  function gatherHydratable(element, root) {
    const templates = element.querySelectorAll(`*[data-hk]`);
    for (let i = 0; i < templates.length; i++) {
      const node = templates[i];
      const key = node.getAttribute("data-hk");
      if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key))
        sharedConfig.registry.set(key, node);
    }
  }
  function getHydrationKey() {
    const hydrate2 = sharedConfig.context;
    return `${hydrate2.id}${hydrate2.count++}`;
  }
  function NoHydration(props) {
    return sharedConfig.context ? void 0 : props.children;
  }
  function Hydration(props) {
    return props.children;
  }
  function voidFn() {
  }
  function throwInBrowser(func) {
    const err = new Error(`${func.name} is not supported in the browser, returning undefined`);
    console.error(err);
  }
  function renderToString(fn, options) {
    throwInBrowser(renderToString);
  }
  function renderToStringAsync(fn, options) {
    throwInBrowser(renderToStringAsync);
  }
  function renderToStream(fn, options) {
    throwInBrowser(renderToStream);
  }
  function ssr(template2, ...nodes) {
  }
  function ssrElement(name, props, children2, needsId) {
  }
  function ssrClassList(value) {
  }
  function ssrStyle(value) {
  }
  function ssrAttribute(key, value) {
  }
  function ssrHydrationKey() {
  }
  function resolveSSRNode(node) {
  }
  function escape(html) {
  }
  function ssrSpread(props, isSVG, skipChildren) {
  }
  var isServer = false;
  var isDev = false;
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  function createElement(tagName, isSVG = false) {
    return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
  }
  var hydrate = (...args) => {
    enableHydration();
    return hydrate$1(...args);
  };
  function Portal(props) {
    const {
      useShadow
    } = props, marker = document.createTextNode(""), mount = () => props.mount || document.body, owner = getOwner();
    let content;
    let hydrating = !!sharedConfig.context;
    createEffect(() => {
      if (hydrating)
        getOwner().user = hydrating = false;
      content || (content = runWithOwner(owner, () => createMemo(() => props.children)));
      const el = mount();
      if (el instanceof HTMLHeadElement) {
        const [clean, setClean] = createSignal(false);
        const cleanup = () => setClean(true);
        createRoot((dispose2) => insert(el, () => !clean() ? content() : dispose2(), null));
        onCleanup(cleanup);
      } else {
        const container = createElement(props.isSVG ? "g" : "div", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({
          mode: "open"
        }) : container;
        Object.defineProperty(container, "_$host", {
          get() {
            return marker.parentNode;
          },
          configurable: true
        });
        insert(renderRoot, content);
        el.appendChild(container);
        props.ref && props.ref(container);
        onCleanup(() => el.removeChild(container));
      }
    }, void 0, {
      render: !hydrating
    });
    return marker;
  }
  function Dynamic(props) {
    const [p, others] = splitProps(props, ["component"]);
    const cached = createMemo(() => p.component);
    return createMemo(() => {
      const component = cached();
      switch (typeof component) {
        case "function":
          Object.assign(component, {
            [$DEVCOMP]: true
          });
          return untrack(() => component(others));
        case "string":
          const isSvg = SVGElements.has(component);
          const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);
          spread(el, others, isSvg);
          return el;
      }
    });
  }

  // node_modules/tslib/tslib.es6.js
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign3(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __createBinding(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }
  function __exportStar(m, exports) {
    for (var p in m)
      if (p !== "default" && !exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  ;
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw2) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw2 });
    } else {
      cooked.raw = raw2;
    }
    return cooked;
  }
  ;
  function __importStar(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result.default = mod;
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
  }
  function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
  }

  // node_modules/@pdfme/pdf-lib/es/utils/base64.js
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup2 = new Uint8Array(256);
  for (i = 0; i < chars.length; i++) {
    lookup2[chars.charCodeAt(i)] = i;
  }
  var encodeToBase64 = function(bytes) {
    var base64 = "";
    var len = bytes.length;
    for (var i = 0; i < len; i += 3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }
    return base64;
  };
  var decodeFromBase64 = function(base64) {
    var bufferLength = base64.length * 0.75;
    var len = base64.length;
    var i;
    var p = 0;
    var encoded1;
    var encoded2;
    var encoded3;
    var encoded4;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }
    var bytes = new Uint8Array(bufferLength);
    for (i = 0; i < len; i += 4) {
      encoded1 = lookup2[base64.charCodeAt(i)];
      encoded2 = lookup2[base64.charCodeAt(i + 1)];
      encoded3 = lookup2[base64.charCodeAt(i + 2)];
      encoded4 = lookup2[base64.charCodeAt(i + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return bytes;
  };
  var DATA_URI_PREFIX_REGEX = /^(data)?:?([\w\/\+]+)?;?(charset=[\w-]+|base64)?.*,/i;
  var decodeFromBase64DataUri = function(dataUri) {
    var trimmedUri = dataUri.trim();
    var prefix = trimmedUri.substring(0, 100);
    var res = prefix.match(DATA_URI_PREFIX_REGEX);
    if (!res)
      return decodeFromBase64(trimmedUri);
    var fullMatch = res[0];
    var data = trimmedUri.substring(fullMatch.length);
    return decodeFromBase64(data);
  };
  var i;

  // node_modules/@pdfme/pdf-lib/es/utils/strings.js
  var toCharCode = function(character) {
    return character.charCodeAt(0);
  };
  var toCodePoint = function(character) {
    return character.codePointAt(0);
  };
  var toHexStringOfMinLength = function(num, minLength) {
    return padStart(num.toString(16), minLength, "0").toUpperCase();
  };
  var toHexString = function(num) {
    return toHexStringOfMinLength(num, 2);
  };
  var charFromCode = function(code) {
    return String.fromCharCode(code);
  };
  var charFromHexCode = function(hex) {
    return charFromCode(parseInt(hex, 16));
  };
  var padStart = function(value, length, padChar) {
    var padding = "";
    for (var idx = 0, len = length - value.length; idx < len; idx++) {
      padding += padChar;
    }
    return padding + value;
  };
  var copyStringIntoBuffer = function(str, buffer, offset) {
    var length = str.length;
    for (var idx = 0; idx < length; idx++) {
      buffer[offset++] = str.charCodeAt(idx);
    }
    return length;
  };
  var addRandomSuffix = function(prefix, suffixLength) {
    if (suffixLength === void 0) {
      suffixLength = 4;
    }
    return prefix + "-" + Math.floor(Math.random() * Math.pow(10, suffixLength));
  };
  var escapeRegExp = function(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  };
  var cleanText = function(text) {
    return text.replace(/\t|\u0085|\u2028|\u2029/g, "    ").replace(/[\b\v]/g, "");
  };
  var escapedNewlineChars = ["\\n", "\\f", "\\r", "\\u000B"];
  var newlineChars = ["\n", "\f", "\r", "\v"];
  var isNewlineChar = function(text) {
    return /^[\n\f\r\u000B]$/.test(text);
  };
  var lineSplit = function(text) {
    return text.split(/[\n\f\r\u000B]/);
  };
  var mergeLines = function(text) {
    return text.replace(/[\n\f\r\u000B]/g, " ");
  };
  var charAtIndex = function(text, index) {
    var cuFirst = text.charCodeAt(index);
    var cuSecond;
    var nextIndex = index + 1;
    var length = 1;
    if (
      // Check if it's the start of a surrogate pair.
      cuFirst >= 55296 && cuFirst <= 56319 && // high surrogate
      text.length > nextIndex
    ) {
      cuSecond = text.charCodeAt(nextIndex);
      if (cuSecond >= 56320 && cuSecond <= 57343)
        length = 2;
    }
    return [text.slice(index, index + length), length];
  };
  var charSplit = function(text) {
    var chars3 = [];
    for (var idx = 0, len = text.length; idx < len; ) {
      var _a = charAtIndex(text, idx), c = _a[0], cLen = _a[1];
      chars3.push(c);
      idx += cLen;
    }
    return chars3;
  };
  var buildWordBreakRegex = function(wordBreaks) {
    var newlineCharUnion = escapedNewlineChars.join("|");
    var escapedRules = ["$"];
    for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {
      var wordBreak = wordBreaks[idx];
      if (isNewlineChar(wordBreak)) {
        throw new TypeError("`wordBreak` must not include " + newlineCharUnion);
      }
      escapedRules.push(wordBreak === "" ? "." : escapeRegExp(wordBreak));
    }
    var breakRules = escapedRules.join("|");
    return new RegExp("(" + newlineCharUnion + ")|((.*?)(" + breakRules + "))", "gm");
  };
  var breakTextIntoLines = function(text, wordBreaks, maxWidth, computeWidthOfText) {
    var regex = buildWordBreakRegex(wordBreaks);
    var words = cleanText(text).match(regex);
    var currLine = "";
    var currWidth = 0;
    var lines = [];
    var pushCurrLine = function() {
      if (currLine !== "")
        lines.push(currLine);
      currLine = "";
      currWidth = 0;
    };
    for (var idx = 0, len = words.length; idx < len; idx++) {
      var word = words[idx];
      if (isNewlineChar(word)) {
        pushCurrLine();
      } else {
        var width = computeWidthOfText(word);
        if (currWidth + width > maxWidth)
          pushCurrLine();
        currLine += word;
        currWidth += width;
      }
    }
    pushCurrLine();
    return lines;
  };
  var dateRegex = /^D:(\d\d\d\d)(\d\d)?(\d\d)?(\d\d)?(\d\d)?(\d\d)?([+\-Z])?(\d\d)?'?(\d\d)?'?$/;
  var parseDate = function(dateStr) {
    var match = dateStr.match(dateRegex);
    if (!match)
      return void 0;
    var year = match[1], _a = match[2], month = _a === void 0 ? "01" : _a, _b = match[3], day = _b === void 0 ? "01" : _b, _c = match[4], hours = _c === void 0 ? "00" : _c, _d = match[5], mins = _d === void 0 ? "00" : _d, _e = match[6], secs = _e === void 0 ? "00" : _e, _f = match[7], offsetSign = _f === void 0 ? "Z" : _f, _g = match[8], offsetHours = _g === void 0 ? "00" : _g, _h = match[9], offsetMins = _h === void 0 ? "00" : _h;
    var tzOffset = offsetSign === "Z" ? "Z" : "" + offsetSign + offsetHours + ":" + offsetMins;
    var date = /* @__PURE__ */ new Date(year + "-" + month + "-" + day + "T" + hours + ":" + mins + ":" + secs + tzOffset);
    return date;
  };
  var findLastMatch = function(value, regex) {
    var _a;
    var position = 0;
    var lastMatch;
    while (position < value.length) {
      var match = value.substring(position).match(regex);
      if (!match)
        return { match: lastMatch, pos: position };
      lastMatch = match;
      position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;
    }
    return { match: lastMatch, pos: position };
  };

  // node_modules/@pdfme/pdf-lib/es/utils/arrays.js
  var last = function(array) {
    return array[array.length - 1];
  };
  var typedArrayFor = function(value) {
    if (value instanceof Uint8Array)
      return value;
    var length = value.length;
    var typedArray = new Uint8Array(length);
    for (var idx = 0; idx < length; idx++) {
      typedArray[idx] = value.charCodeAt(idx);
    }
    return typedArray;
  };
  var mergeIntoTypedArray = function() {
    var arrays = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      arrays[_i] = arguments[_i];
    }
    var arrayCount = arrays.length;
    var typedArrays = [];
    for (var idx = 0; idx < arrayCount; idx++) {
      var element = arrays[idx];
      typedArrays[idx] = element instanceof Uint8Array ? element : typedArrayFor(element);
    }
    var totalSize = 0;
    for (var idx = 0; idx < arrayCount; idx++) {
      totalSize += arrays[idx].length;
    }
    var merged = new Uint8Array(totalSize);
    var offset = 0;
    for (var arrIdx = 0; arrIdx < arrayCount; arrIdx++) {
      var arr = typedArrays[arrIdx];
      for (var byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {
        merged[offset++] = arr[byteIdx];
      }
    }
    return merged;
  };
  var mergeUint8Arrays = function(arrays) {
    var totalSize = 0;
    for (var idx = 0, len = arrays.length; idx < len; idx++) {
      totalSize += arrays[idx].length;
    }
    var mergedBuffer = new Uint8Array(totalSize);
    var offset = 0;
    for (var idx = 0, len = arrays.length; idx < len; idx++) {
      var array = arrays[idx];
      mergedBuffer.set(array, offset);
      offset += array.length;
    }
    return mergedBuffer;
  };
  var arrayAsString = function(array) {
    var str = "";
    for (var idx = 0, len = array.length; idx < len; idx++) {
      str += charFromCode(array[idx]);
    }
    return str;
  };
  var byAscendingId = function(a, b) {
    return a.id - b.id;
  };
  var sortedUniq = function(array, indexer) {
    var uniq2 = [];
    for (var idx = 0, len = array.length; idx < len; idx++) {
      var curr = array[idx];
      var prev = array[idx - 1];
      if (idx === 0 || indexer(curr) !== indexer(prev)) {
        uniq2.push(curr);
      }
    }
    return uniq2;
  };
  var reverseArray = function(array) {
    var arrayLen = array.length;
    for (var idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {
      var leftIdx = idx;
      var rightIdx = arrayLen - idx - 1;
      var temp = array[idx];
      array[leftIdx] = array[rightIdx];
      array[rightIdx] = temp;
    }
    return array;
  };
  var sum = function(array) {
    var total = 0;
    for (var idx = 0, len = array.length; idx < len; idx++) {
      total += array[idx];
    }
    return total;
  };
  var range = function(start, end) {
    var arr = new Array(end - start);
    for (var idx = 0, len = arr.length; idx < len; idx++) {
      arr[idx] = start + idx;
    }
    return arr;
  };
  var pluckIndices = function(arr, indices) {
    var plucked = new Array(indices.length);
    for (var idx = 0, len = indices.length; idx < len; idx++) {
      plucked[idx] = arr[indices[idx]];
    }
    return plucked;
  };
  var canBeConvertedToUint8Array = function(input) {
    return input instanceof Uint8Array || input instanceof ArrayBuffer || typeof input === "string";
  };
  var toUint8Array = function(input) {
    if (typeof input === "string") {
      return decodeFromBase64DataUri(input);
    } else if (input instanceof ArrayBuffer) {
      return new Uint8Array(input);
    } else if (input instanceof Uint8Array) {
      return input;
    } else {
      throw new TypeError("`input` must be one of `string | ArrayBuffer | Uint8Array`");
    }
  };

  // node_modules/@pdfme/pdf-lib/es/utils/async.js
  var waitForTick = function() {
    return new Promise(function(resolve) {
      setTimeout(function() {
        return resolve();
      }, 0);
    });
  };

  // node_modules/@pdfme/pdf-lib/es/utils/unicode.js
  var utf8Encode = function(input, byteOrderMark) {
    if (byteOrderMark === void 0) {
      byteOrderMark = true;
    }
    var encoded = [];
    if (byteOrderMark)
      encoded.push(239, 187, 191);
    for (var idx = 0, len = input.length; idx < len; ) {
      var codePoint = input.codePointAt(idx);
      if (codePoint < 128) {
        var byte1 = codePoint & 127;
        encoded.push(byte1);
        idx += 1;
      } else if (codePoint < 2048) {
        var byte1 = codePoint >> 6 & 31 | 192;
        var byte2 = codePoint & 63 | 128;
        encoded.push(byte1, byte2);
        idx += 1;
      } else if (codePoint < 65536) {
        var byte1 = codePoint >> 12 & 15 | 224;
        var byte2 = codePoint >> 6 & 63 | 128;
        var byte3 = codePoint & 63 | 128;
        encoded.push(byte1, byte2, byte3);
        idx += 1;
      } else if (codePoint < 1114112) {
        var byte1 = codePoint >> 18 & 7 | 240;
        var byte2 = codePoint >> 12 & 63 | 128;
        var byte3 = codePoint >> 6 & 63 | 128;
        var byte4 = codePoint >> 0 & 63 | 128;
        encoded.push(byte1, byte2, byte3, byte4);
        idx += 2;
      } else
        throw new Error("Invalid code point: 0x" + toHexString(codePoint));
    }
    return new Uint8Array(encoded);
  };
  var utf16Encode = function(input, byteOrderMark) {
    if (byteOrderMark === void 0) {
      byteOrderMark = true;
    }
    var encoded = [];
    if (byteOrderMark)
      encoded.push(65279);
    for (var idx = 0, len = input.length; idx < len; ) {
      var codePoint = input.codePointAt(idx);
      if (codePoint < 65536) {
        encoded.push(codePoint);
        idx += 1;
      } else if (codePoint < 1114112) {
        encoded.push(highSurrogate(codePoint), lowSurrogate(codePoint));
        idx += 2;
      } else
        throw new Error("Invalid code point: 0x" + toHexString(codePoint));
    }
    return new Uint16Array(encoded);
  };
  var isWithinBMP = function(codePoint) {
    return codePoint >= 0 && codePoint <= 65535;
  };
  var hasSurrogates = function(codePoint) {
    return codePoint >= 65536 && codePoint <= 1114111;
  };
  var highSurrogate = function(codePoint) {
    return Math.floor((codePoint - 65536) / 1024) + 55296;
  };
  var lowSurrogate = function(codePoint) {
    return (codePoint - 65536) % 1024 + 56320;
  };
  var ByteOrder;
  (function(ByteOrder2) {
    ByteOrder2["BigEndian"] = "BigEndian";
    ByteOrder2["LittleEndian"] = "LittleEndian";
  })(ByteOrder || (ByteOrder = {}));
  var REPLACEMENT = "\uFFFD".codePointAt(0);
  var utf16Decode = function(input, byteOrderMark) {
    if (byteOrderMark === void 0) {
      byteOrderMark = true;
    }
    if (input.length <= 1)
      return String.fromCodePoint(REPLACEMENT);
    var byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;
    var idx = byteOrderMark ? 2 : 0;
    var codePoints = [];
    while (input.length - idx >= 2) {
      var first = decodeValues(input[idx++], input[idx++], byteOrder);
      if (isHighSurrogate(first)) {
        if (input.length - idx < 2) {
          codePoints.push(REPLACEMENT);
        } else {
          var second = decodeValues(input[idx++], input[idx++], byteOrder);
          if (isLowSurrogate(second)) {
            codePoints.push(first, second);
          } else {
            codePoints.push(REPLACEMENT);
          }
        }
      } else if (isLowSurrogate(first)) {
        idx += 2;
        codePoints.push(REPLACEMENT);
      } else {
        codePoints.push(first);
      }
    }
    if (idx < input.length)
      codePoints.push(REPLACEMENT);
    return String.fromCodePoint.apply(String, codePoints);
  };
  var isHighSurrogate = function(codePoint) {
    return codePoint >= 55296 && codePoint <= 56319;
  };
  var isLowSurrogate = function(codePoint) {
    return codePoint >= 56320 && codePoint <= 57343;
  };
  var decodeValues = function(first, second, byteOrder) {
    if (byteOrder === ByteOrder.LittleEndian)
      return second << 8 | first;
    if (byteOrder === ByteOrder.BigEndian)
      return first << 8 | second;
    throw new Error("Invalid byteOrder: " + byteOrder);
  };
  var readBOM = function(bytes) {
    return hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian : ByteOrder.BigEndian;
  };
  var hasUtf16BigEndianBOM = function(bytes) {
    return bytes[0] === 254 && bytes[1] === 255;
  };
  var hasUtf16LittleEndianBOM = function(bytes) {
    return bytes[0] === 255 && bytes[1] === 254;
  };
  var hasUtf16BOM = function(bytes) {
    return hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);
  };

  // node_modules/@pdfme/pdf-lib/es/utils/numbers.js
  var numberToString = function(num) {
    var numStr = String(num);
    if (Math.abs(num) < 1) {
      var e = parseInt(num.toString().split("e-")[1]);
      if (e) {
        var negative = num < 0;
        if (negative)
          num *= -1;
        num *= Math.pow(10, e - 1);
        numStr = "0." + new Array(e).join("0") + num.toString().substring(2);
        if (negative)
          numStr = "-" + numStr;
      }
    } else {
      var e = parseInt(num.toString().split("+")[1]);
      if (e > 20) {
        e -= 20;
        num /= Math.pow(10, e);
        numStr = num.toString() + new Array(e + 1).join("0");
      }
    }
    return numStr;
  };
  var sizeInBytes = function(n) {
    return Math.ceil(n.toString(2).length / 8);
  };
  var bytesFor = function(n) {
    var bytes = new Uint8Array(sizeInBytes(n));
    for (var i = 1; i <= bytes.length; i++) {
      bytes[i - 1] = n >> (bytes.length - i) * 8;
    }
    return bytes;
  };

  // node_modules/@pdfme/pdf-lib/es/utils/errors.js
  var error = function(msg) {
    throw new Error(msg);
  };

  // node_modules/@pdf-lib/standard-fonts/es/utils.js
  var import_pako = __toESM(require_pako());
  var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup3 = new Uint8Array(256);
  for (i = 0; i < chars2.length; i++) {
    lookup3[chars2.charCodeAt(i)] = i;
  }
  var decodeFromBase642 = function(base64) {
    var bufferLength = base64.length * 0.75;
    var len = base64.length;
    var i;
    var p = 0;
    var encoded1;
    var encoded2;
    var encoded3;
    var encoded4;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }
    var bytes = new Uint8Array(bufferLength);
    for (i = 0; i < len; i += 4) {
      encoded1 = lookup3[base64.charCodeAt(i)];
      encoded2 = lookup3[base64.charCodeAt(i + 1)];
      encoded3 = lookup3[base64.charCodeAt(i + 2)];
      encoded4 = lookup3[base64.charCodeAt(i + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return bytes;
  };
  var arrayToString = function(array) {
    var str = "";
    for (var i = 0; i < array.length; i++) {
      str += String.fromCharCode(array[i]);
    }
    return str;
  };
  var decompressJson = function(compressedJson) {
    return arrayToString(import_pako.default.inflate(decodeFromBase642(compressedJson)));
  };
  var padStart2 = function(value, length, padChar) {
    var padding = "";
    for (var idx = 0, len = length - value.length; idx < len; idx++) {
      padding += padChar;
    }
    return padding + value;
  };
  var i;

  // node_modules/@pdf-lib/standard-fonts/es/Courier-Bold.compressed.json
  var Courier_Bold_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Courier-BoldOblique.compressed.json
  var Courier_BoldOblique_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Courier-Oblique.compressed.json
  var Courier_Oblique_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Courier.compressed.json
  var Courier_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Helvetica-Bold.compressed.json
  var Helvetica_Bold_compressed_default = "eJyNnVtzG0eyrf8KA0/7RMhzJJK6+U2+zMX2mJYsEuJMzANEtihsgYQMEITaO/Z/P41CV+bKlaug86JQf6uArsrKXNVX8H8m3y9vb7u7+8m3k4t/btazm+7o5PmTZy+PTl88eXk6eTT56/Lu/tfZbTc0+Hu3eOju51ezb75bLq532maxYO2oarPb+aJndRCm3fzm425/Y8N/3M8W86tXdzeLoeXjYXv91/mX7vq3+f3Vx8m396tN92jy/cfZanZ1361+73af/PHLfXd33V2/Wd7O7sY+fvfd8svk239/8+T540ffHB+/ePTk8eOTRy+fHf/n0eR8aLxazO+635br+f18eTf59ptBBuHtx/nVp7tuvZ58+3TgF91qXZpNHj8+/svjx4+Hnfy6HAawG8z3y8/9ajeGo/+6+j9HT16+ePpo9+/z8u/L3b8vH5d/nx+9ul6+745+79f33e366B93V8vV5+Vqdt9d/+Xo6NVicfRm9z3rozfduls9DNTDOF8fzY7uV7Pr7na2+nS0/HD0y/xued9/7r4ZGi2OXv3taHZ3/X+Xq6P58AXrzfv1/Ho+W8279V+Gzv447Op6fnfz+9XHrsxA6cnv98NHZqvrqg4Nv599/vs4Ic+fvHg0eVe3np4cP5q8Wl/tAr0axR862/7m+PHzR5Pf76//Pp18+2QnDv+/2P3/9PF+vv7Z3a/mV0NA//0/k+m7ybfHz4dGvw5dWX+eDXH830d7fHJyssfdl6vF7Nb46fPTPf9jsxzi9X5hytOnz/bK3eb2/W6ibu6ydr1cLGYr4y+GiSn8c7e62qV7FZ4fH++F2e0grYf4mGQdLj0oM557/Xm26u4W3YeWRB+r3Zitd9+4/uQdfzEO9/Nis85duBqqdJZ38bH//LG7y82HocyXYiTrxWz9MQfrz261zHR512V4vxUt7z+uOtH2w3KzEnT+INqu518E7B46MbddiKmnw/xOpNXVcrG8y3jd3c6jZDOw2NlAot0fm9ki45tVN5SzD/PZkyc1abp1sZqqvHz+dJx7kX2vMvouo+8z+sH3/Oz5Hv2YO/NX/2BNhb/l7/p7Tph/5DD/lD/4c97jL156NeT/zB/8NffrLA/ot9zqdf6uN/mDv+d+vc0fPM8fvPBZOx0neppbvcvoMu/xXzn53g+L2afuPtiGhfz9oMU65c9FT7FUnK2v5vOr+epqc5tnbbOz7fWw/nR5j8XfQmfsY7M8nve51VVudZ1bieL8kD94k9HH3OV5Rv+d9/gpt/IStiXhNu/xLqNlRp9F1WerFxa4zpG4z9+1yR98yJWwza2Ek/aOdsc9xfRzV3f5FRPh+MXjmpWrRvtD2Xg/X1w3l/rr5VaYe1idPWL35TjNk+NJrbgPuwND9Fkfs1o7PiyWq7ng667xLVeb1bCMX3kAj0+wbNbzcuCaoluPWnRZ3Wzmg3K7vNdHDju5fPFX5Bh6S5wPc8HE8dNwKCcPB65nNzedSNs9x0MxOuDYzV236kTtD8dCs5vV7DOY2tOaWcNJRCd80MP7frY+EOHD6kofK9gERH04KRg/Pxxizz+v52shDWO9/7jchGPFtOyH5PaZW80eRD3Mrjb36tClePmHRfcla43Kup1drdThzvtVp3Z8vbyfXYWKc2k+zCQGwJQV1qF3trseQqqOUTd3N7PV5nYx24jdLG+Gw8xP4utmOA6Yl9uQsy688sOek+cjW66uPwzHeeHA0I9Q4iLrByCR+x7OYA/Pntoebgen2yxwF7ayzMRie70r+vVaLGCLuGNfeSK3I5KlGNRQn8Mp8ZD34hziH2lK3QliBvryH/PGlyY5qf51cfb86Cj3oC4X1/OHOSS0fyT2zA+YRXF4txsfOj/0ob4Rg3U596IygaHmr/T9hVJx3J6IGdWDfyb2zmeCPuBnAWknfs4weASchBxXJ1YDfX7yvIrjVQ+xK3IdXztjHvgodVx+VR3w8mjlaDRVP9KXw7FTqda3RWOFcCarhAzRw1yzJ/rha9z76ct66rn8s7u7EZn7Ju7Cz+LUID05DhbJocx9xQuJHc02xnrFY/Xznxw5i+rbj8uVGNUZ7d3DQFVgJ3pU8Kd1EaOwWTXRDjxienErFzjWm3KUsxL9jSnoUWzxaKtmgrebxf3886IX/WqU/9s4QEuk4Xjrfj5bXM8/fMhz1bet4de4H09YkSxeGwfT7MCq05auGuO9a9lgK2N+jQHyxZDqHy+/DUcMeA3OToFWy0/dHZ4ImTmuupv5Oh76eonGyYblONdFPdRYb4aqDucjHmw6hrTCbERm2Ur1fzU+8C+q8NOX9di1XOmK18Eszj/ef8zw+6YBLpRv2VjuGybTNVfHlvCqdfhwICtjgP18uVUavG9zhdaMtJae1jK6bu0517Ht++BhCa+Y9bigW9wLA78PJu2euF0ecMTUNfu6240YSWMNX8rjTK8FPvixq0/xCOfFySn4+JDAqyGR1/n7fud8Pa2Tv2gsJD8fXH9/iRPnpxJ2X0eZYrIFt4wYJuetGv8ldtviMETt42wBS0Mt8t2pSaxwnwu1BJgvx8MmT7WvTGCjFLrWgG6imeKAxmlVs6rPRn6XB4iWwbLnlhDXg010KmMbS/731AlbuMhtTs3Or+dXymh/iF8EB2aHDnd/pcNa625j3t4czuuD+3rV+M5XTZOOpwM2A/F73IgPHFD+2Fruad9+iVie3dkBWTwSsG87WAo0QeaXB/e0WN7s5vtuKcK9bJvpJq9jNYOGr2pU8s3Bye1gJfeYN9L3Tq7jdnHnLh80u+e3lrsfN7u7kf95NPm5W939NpuvdveQ/z15tbtbPXn0zenj/zwat/buEdC+nxGNpo7wb8PWU9/au0pAODAUzsL3nOUu4NIbuE1VoPv6Dyg4T1DGkAW2vzoU0L5wEL0OW2+HrZe+VWOGKIzehfMQi/M6ekBh9MBh9EDr6AHR6EGx0QMb6zqwYidILoatF7Y1Hbae2dblsPXkiW/WISGDvgPeDJsnvlU/CCjEAjh8H9AaC0AUC1AsFsAsFsDGWDh5CJmwDVoft/KI+tzzsRGWpiEqDuNUpM65UqsC5WqIata4LNyqnuXv5hI2rurYxFzMJlFFG9dlbTLXtglU4Mapyit/nRHUuyEqeueq8qt6niPKHmBcGYGJ2Q1MIkswrn3BZDYHE9ghTIg2UTF4RUVgGBWhaxhj6zBB+EfVwEQMUd0ZV3ZiYrsy2ViMa3cxmS3GBPYZE6LZVPyQE3KbW/UCNQIhXGg0A3QhQ1TfxsmFnLMLVQVcyBC5kHHpQlU9y9/NLmRcuZCJ2YVMIhcyrl3IZHYhE8iFjJMLVf46I3AhQ+RCzpULVfU8R5RdyLhyIROzC5lELmRcu5DJ7EImsAuZEF2oYnChisCFKkIXMsYuZIJwoaqBCxmi4jOuXMjEdmWyCxnXLmQyu5AJ7EImRBeq+CEn5Da36gVqBEK4EIYGrShyqvQokimRyM4UZLCnyMmjoiiNKjQ5a+yPLSuKyrdii2xeUScHi6K2sdiGvSyqZGhRJFcL4usGB3+LnEyOROV0ocl5Y17Y86KojC+2yO4XdbLAKGofjG3YDKPKjhjVaItBA28MHAwycHTJKLBVRlX4ZWgAphk5GUYUlX3GFl/xFTbSKGo3jW3YUqPKvhrVaK5Be2jUxbbRvm/xQ/ETrusEPRcpGRVK5LdBYrcFEbwWKTktStJnocGZ3A97LErKYVHP/ooquStK2luxBTsrauSrKJGrgvRaUnBUpOSnQVJuCg3OZezZSVFSPop6dlFUyUNR0g6KLdg/UWP3RC16JyjgnEDBN4GiayJmz0RNOCbI4JdIqdpRUl6J+kEvYJ9ESbsktmCPRI0dErXoj6A8yAzfyra9pu1ICVccR4+WaIhMxTiZoXN2wqqADRoiDzQuDbCqZ/m72fqMK98zMZueSeR4xrXdmcxeZwIZnXFyucpfZwT+ZojMzblytqqe54iypxlXhmZidjOTyMqMax8zmU3MBHYwE6J9VQzeVREYV0XoWsbYskwQflU1MCtDVH/GlU2Z2K5MNijj2p1MZmsygX3JhGhKFT/khNzmVr1AjUAIF6p9RRtyRhXuAhkRCOxEJoEVOSMvckGakcln4vvZjlxQfuRqNiTXyJFc0JbkOnuSK2RKLpArmfBaMPAlZ2RMIChnMvlcxJe9yQVlTq5md3KN7MkF7U+us0G5wg7lSrQo4+BRxsCkjKFLOWSbckX4lIlgVM6oQF1QVuXqgfpls3JBu5XrbFeusF+5Eg3L+IPI1a1o1yvWiolwrdoxdC1nZAQukGuBwK5lEriWM3ItF6RrmXwmvp9dywXlWq5m13KNXMsF7Vqus2u5Qq7lArmWCa8FA9dyRq4FgnItk89FfNm1XFCu5Wp2LdfItVzQruU6u5Yr7FquRNcyDq5lDFzLGLqWQ3YtV4RrmQiu5Ywq1AXlWq4eqF92LRe0a7nOruUKu5Yr0bWMP4hc3Yp2vWKtmAjXWo2/6OG7q4RMoGLyK8PsVqMAXlUJOVXF0qdG8Sx9L3tUxcqhqpb9qSrkThVrb6oqO1Pl5EsVkyuN+HUi4EiVkB8ZVm40iucphuxEFSsfqlp2oaqQB1WsHaiq7D+Vs/tUHr1npOA8IwHfGQm6TkXsOZULxxkl8JtKqLIqVl5TtWbNsc9UrF2mquwxlbPDVB79ZaQPKeu2qU2fiR69cJUx19FWDFHhGidjcc7OUhWwFkPkLcaluVT1LH8324tx5S8mZoMxiRzGuLYYk9ljTCCTMU4uU/nrjMBnDJHROFdOU9XzHFH2GuPKbEzMbmMS2Y1x7Tcms+GYwI5jQrScisFzKgLTqQhdxxjbjgnCd6oGxmOIas+4sh4T25XJ5mNcu4/JbD8msP+YEA2o4oeckNvcqheoEYjsQt8N9FXcip8tqDoGIBHSwvUeYiALoiAVRvEpLISmkFq+jnbV9cS3LJ0che4CxwRzWrsLiKYcFBsIMBsIsHEge/LDGPdT34pu+gPGHZDw1h8o7kCjo/4Q4g7Mugts7C6QaJs/jCXvW9OwtSv0575VRwcIuux0/3tsdXJ3ZPzJNUOj/2L4DFEMjVMgjatomphDahLF1TgH1wSOsAkxzIYp1pVfZDTNCEJviOJvPE9ClWgmKk7TUV4IjNNREU9H5TwdlcvpqKKYjirxdFSepqMKaTqqQNNRMU/HyC8ymmaE01ERT0flYjpGiadjxDQdfx1n4oVv1V0BqvEHFEIPHDoEtAYckMUamIUZ2BhhIDW4jnbjPPatOgJAdQSAwgiAwwiA1hEAshEAsxEAG0cApI7AUZ2tJ48N2UyN7Kdxqo59Kw70J5wqQGKgP9FUAY0D/SlMFTAa6E8wVUDiQH+CgTqxcTraxK08zE1jTBs5pk0eEx+SgSJGuxGj3YTR/jzZn/Kc+FY8LipIHAQVng6CCo0HQQXJA8mi0OFRYfV8BlA8Ftqhctzy1LbsWMhRPYFBFA6PnOPhEVB7TTRgO2py5MdGzvzYyNhyNwLfskg7ipF2jpF2apF2xJF2xSPtzCLtyCJtaBPivsn5oc47fp6oU46fJ+ls42eR1aCI/ODTi58nfGaxI70tUGUrLtEFpYU2vIsf6oIECgGpKhrUJAeGGlCMSNXhokYcOZKpyEileosqJD8JVIWkUkGyKmqTmuQy5Qa5YqkFFS+pXMckc0lHGaqbBCp0UlXNU5Nc/tSAnIBUbQrUiP2BZLIKUsk1orppJRJ7CalfLyThMNTgYCE1fIcaHS6k5EYkR2OKIngUCWRXpCbn+mWC1/DKVrx8t0fiyt1O2B3ej5eddptTO0bdbZULWce+aSUODOvScfwFzUE6jZLgfo3nl0m6vPPLRF3Z+SW/o+qIgnDwHVVTMRz4BueLiDAw+Q1OFkSIqtaKU9BbYp8DwWFrv/X4S8wriCAJFEdWVTRjG4xpVCCyUcD4ksJRJlnEOrZoRVy0Otykb4WS56BdwGOD0V5xDgxR9J2ruFcVI14ZxLoijLIxjq8JIrJVa8U06C2xz4HgCBpPsRuO08oJ5lPfirccCop3gwoSNyAKT/ceCo23HQqiWwqF0d2EwsKNhELqeunorZn5Gc45ojDdLlyE75mGrXdhy6/QnE3SxZmzibous6P13Nd3aee+I6oWA9NgiObCOE2IcTUrJuapMYnmxzhPkgk8UybE6TJMc4brDoWBZ6+x7pB6kb97mtG7jGBa00LEPE9wlWiWK+apDi9TwXxHTpMeRZr5KKrpjy1yDkSdEiGKnA1R5ZSIasyLqFFypPc6VfQ4TQ6916maXDT2N23wdw0O+aNfb5RizqSgUzoFjXMKXkSBjEJK+YQSZRNKKpdQz5mEKuURSpxFqHEOoRYzCBXKH3qHLceJc6f9DltucCH3M5X0naSQMerVLiHlbAGVcgUUzpT6pgCkiSHKEeOUIMZVdpiYU8MkygvjnBQmcEaYENPBMOUCvuxDYeAsaLzsQ+pF/u5pRu8ygmlP78YwzxNeJZrtinmq47k5zjgrNPEs0/yzrNKA2+Rs4BaUFCxzbrDOKcJ6zBRWKWFIftuMKadPklUWUaOL5n6nTeVdU4EMY4USjeWcb9SC0o5Uzj57uh/yzhllnAuUay6oLHM155drlFkucE65wtnkSswj55RB4UUejghnTetFHpYvxPdPBXsnGORFft8lCTkXTKMsMM7zX083YfoN0ewbp8k3rubexDz1JtHMG+eJN4Hn3YQ47YZp1vEaBIWB57xxDYLUi/zd04zeZQTTnS5KMM+TXSWa64p5qutTYzDVhmiqjdNUG1dTbWKeapNoqo3zVJvAU21CnGrDNNX44CeFgae68eAnqRf5u6cZvcsIpjo9J8k8T3WVaKorpqn+bZzl8cmE33CGkdXZRUZP1rkQHq1z7M/WOYNH6BzCM3QO7SE6R3UGgflzMmUrXjErKD7RWJC4q1J4uq5WaLx/UhDdDymMboIUFu58FBLvKv4G8zZeTdyh2KDLg7L7iIj0oDo5qHCbEHAeayfG2omxLkOK2f0+QOKRr8LTrZxC44NeBcmHw4tCT38VFh8JLyg+2/UbVscY/dcTfMS0bMVHTAsSj5gWnh4xLTQ+YlqQfMS0KPSIaWH0iGlh4RHT155GPow6tD15M9nfzYet+GxOQeLZnMLTszmFxmdzCpLP5hSFns0prE4RoPjY0ZvRn2GrZj6i4MounMetPN7zxnjP5XjP83h5IkER4z2nZ5HewEQ68WXkzQQfMnwzrhSuXcal+Q2tDyOtVzFh9g1RSIyruJiYg2MSRci4DpPJHCsTKEGMU5bgdWhGlC+N69CkngvUiJXMIRPbseJsMn44VimvTODkMiFmWL7UbghyDa+rUyvOOnVdfZTqg8SQeoYonMZVOE3M4TSJwmlch9NkDqcJlHrGKfUqfysQpZ5zlXpVPReoESuZeia2Y8WpZ/xwrFLqmcCpZ0JMPXy0nTIEUg8fbadWnHrq0fYqpefYjqXAoT3wHJtuIsKsn2PTaiPkjefYtMypqp9jk+rbpsDJe+h5B9nmvCkcjLlO6tjkazFPCR7V/5+Y52SPckr5KFPipwdBZJZiEaTnQOQnUkE0nwLZNximu5z9vfSt+g2A6hkToDApwGEPQGv4AVk4gVkMgY2BA1Lz15G/oPoWSxiQONV4S8UKNJ5qvBVlCQqdarzFAgQUTzV2aHeO98K34rsaBcV3NQoS72oUnt7VKDS+q1EQvatRGL2rUVh4V6OQ+K7GDl0tFzTyeu7qbXafeOZbdZSAqrEgwlECh1EihVNXwHXwgGzwwGzwzj72nz925Zzr2NgyjGqZZ2vZmJqlnJplnho+nQVFTJqdzgLKM2Sns45WcSsPZBW93IV1dzvPU74JpbjJ9rFpeMVGesUmewU/kgqKcJGNcJFNcpFtmPA+buUk7XPm4buILwlRENK7iMxVhNS7iCxRrPK7iCxwbPhdRMbktXj8fkqIXFcfv7OY/TcdvzPXTpyP31kgT07H78TBxQxRrRgnnzauHMHEbAsmkTcYZxswgQ3chOjihsko/LXPhQodmXrFXa4Ftnfj5PHOhdGb2K45Zfmmke8bZ/M3gVeAKqRloArLHAxeEIwfygGxNJjUyIHGImFyK0V4uTDeSAVeOCpfCdQYul5HqioWkyrBimKo4ahybTGx7Zy8yhjXS43JLWNNi44J2li3Odt6gRrlpFajcKCPa1IUOI5R5fUpqjLWsYmIeGzAcY9qCm+UU5CjTKGOIq9k6XLAqRR4VTtwOUA3ESucvhyg1cZq17gcoGVe+fTlAKmi7UeBiz6qvCJGVXpibCKcMTZgf4xqssEop/UyyrRqRpENM6jsaCTGdTS+SNeq5bSmRpVXVlLV+hqbfM1L5FobW/CKG9W07kY5rb5BzmtwfMmuFc60Hkf16xmo1ubY4GAGttbp2OhwmqY1O6oHEzGt30FdNYWDYWus6KGNWtdDA1zdo3BwbdIrfWzytdUnrfpRbaz9sdHhJSofB0T50BK1bdVA3xQOWkM+Sjif4BM953g8ACg+x3OeVn7g6XriOa7xgOiZnfOwmgMLT+qc47rtqNroiRH6IZR6PRnH2nj1xjmN+tCrNy7m8TdevXHOkWi9euNCjEnj1RvjFJ30ysrIG6+sEKdgHXplhUQVtq+8skI6BfDgKyukcigPvLJCGgVVvr2hIsjhlW9vBEqhbb+9ESQV1oNvbwSVQnrg7Y2gcTibb28EhUIpXm3IseIw5lcbHFEAG682OFeha7/a4BIFrfVqgwscLv1qg2MKFL8SQKHgEDVfCUgKBezwKwFJVuH76isBqQUF8yuvBCSdQ3vwlYCkUqAbz8LruHLYxbPwwCjUrWfhQVDhPfAsPGgU0uaz8KBwGBvPwgOn0KVHxzkqHC77iW0IlzMKlwsULhdUuFzN4XKNwuUCh8sVDpcrMVzOKVwmULiMc7jGXw6GYFVCoaqYAlWxClPVcpCqQiGqmANUOYen8hicSik0I6bAjJTCcjGG5IVvxdOVCwwFIHG2d0EhABrP6y7C0IHRNYQLGDKQeJK2Q/6zzGUrzlxB8SzLhbO4FVOhIDHfhae5LjTOc0Hy94KLQrNfWD0/BRSnd4d20/rMt+IpS0E1BIDEdYvC0ylNofH6Q0F00aEwutJQ2DhjQOoIHMXT2YtJekR7h+Kguzw5dqUGkZ6vTs5XuBADOE9jJyarozLdMbu44tm5u6Dy0rfiKXlB4jy88HTyXWg84y5InmYXhc6tC6s5Biheyr2Y5Ke2dyxfiNjRTZjZTc7GTSP1NjL1Njn1+DICKCIpNyIpNyEpp6PrwVbs9RRdD5AYyJRcD2gcyDS4HjDq7hRcD0isoekEH7iboncBEo95Tcm7gMYHuqbCu0ChR7em6F2A4oNx09G7Tn0r3gyYoncBEjcFpuRdQOPl/2nwLmD0q7VT8C4g8Vr+FLzrCRC8Cj0drWv/I2VTtC5A9nYJoPwLbVOyLqT4donj+BNt02BdwPztEmNmXT7UZUi4ZS6SZaMilrIilrki2LpAEbVi1gUoFwZdqJ2Sc/m87Zzr1MZvzgUoJp5zTDynlniO+GaTK56SzjwlndWUNNKHeupz3fepvi9Hwxt/qekSHQ+ZvZEGLL6IAwK+iQPYXsUB5m/cAPRXbgDWd24A2RtpznbW99y34ot8l8n6gKd3+y7R+gDRxIFigwFW8xJQ7bajmS2wl2h9gOLN4stkfcDTscElWh8gOgK4DNYHLFxHv0Trc1RL6CmQW/xl5svR+174VjyfuETvQ5TPJy7J+5CC9wGOpxmXwfuA0WnG5Wh0MARzOmTq1cxL8jrE9GrmpXA7lPitzUv0O2T0hublJP8Y9iVZns/XJjbaiIFuWgPd6IFuxEDZ91BSA3XnQxhfT7206/RgBukmRBLY0/RtiKQKd0s3IpKQfC7fikgKOV66GcECeF96x4y5ckH1jhlL5Ietd8xYZmdM75gxJ4+sHIzSELmlcbJM48o3TczmaRI5qHG2URPYS02IhmqYXNVvMoVS5XtPXANgc4bIaY2T3ToXnmtiNl6XsvuaRhZsnH3YBDbjKizFoJMtmyAty1ThW6axeZnQcDDTk42ZwqZtAjt3upPIgvDwKm1E8+TmJhyMj/J101rxaTm86c34ZK83hQyfbvlVJ1T3/JTGzt+866caCP9X9/2UllYBeedPibQWqHt/QoMVASktCiipdQH1vDSgSqsDSnqBwBa8RqBGywRKtFKABIsFUlovUKIlAyW1aqCeFw5Uae1AiZcP1HgFQS0uIqjQOhJuBgfHELeJRYGBaSOlNQUlWlaCJFYW1PPiEtS8vqBMSwxKvMqgxgsNaEsdkrTcoCYdFRsIU0WZfRW1hrVik+SuKPIChBqvQepRAaGJlQjUjf5QWo9Q+1oA1aqE8oEAttYmbHIogHmFQjEuUkM5TfxXQsqW/66PoXj/yYXd3yTc/5WH3dY2bPl1nrIVr/MUlK7zVNfDHhmibhmXfasqdLCibUZ97gH313ju9Ngx7LQh6rRx2emqQqcr2mbU5x5wp43nTodnlaDnkVP3oyjHEJrAQALfNnjf6B+PK4p5cJDuMDSkNDCU5LCgAQwK6FbSXvaJh4NSHkx9zAdGYoiGYVyOoaowgIq2GfW5B9xv47nT9tgH9NoZddsF2W+ToePGtoL1oh/cdxdy5+0hDOi8M+q8C7Lz4c/Tjx0Nf56eWS/6wZ2Xf55+1MYHJaDrlVDHK5bdhr96PXYQ/up1JH3aN3dX/NXrUam/QAe9NUTdNS77i38kd+we/pFcQn3uAfdZ/ZHcvfR+oAvbc9ny4wRDqpdF8IObijbhq+nv4b1PxxrAZd/o7+G9FwcUoNCN0Pfh8AFY+LWK92OkfauPW3kMOY5XA/VA7LY+Be2T+gGRqzH4sBX3dZWDD0K8xXs1dtx70MeZvKKOj7QeC3zMCIZgSPamqguBaETGD38RjQ2PbaiTPEp1bDNK9uJrRjBUQ7KHVV0IREM1fviLaKj4viR1koeq3pes0nBat1jMaLAGcbgOdT9NX0jIg3bla1/HAzelV11Og3clD39/cjRZf55d7T5yOtJywp3/bM1xlhta/MLh9GxybTstW1f7v10LyE38Ovj3dR2ob9kIHeHQ9nTcA+7YEO298of86W1GvUDUI+OpW7uKG4O03zleSj028hA+sA1bX8JWH7diR1J97yldpx87whd2jyN+yJ/fZvQlo14g6qb0or1EPz4w9pVfTz+O+CF/fpvRl4x6gaiv0kxGSbwmUjus3hI5FtpD4+u2Df6lwfsW5+G0zqpGPV+IG0ckrsEcJ+VBftFW0i+S9prSKBonU1X1a3M8CFB4FCA96O/aavxF476BeSio5bHQayHjOPitkOOIH/Lntxl9yagXiPqrzgdHiV8PGDub3g44Jv4gvmIr2BfBesWoy/I0cNT4Gf2xz+kR/WPiD+IrtoJ9EaxXjPosz/722ocJXiSvpItb8aigoHotHFH+AePC05HDnuKflHUcf9e4IPr14sLo14t3bGlHOWUrHjIVJE6KCk8nGoXGk6KC5ElRUeikqLB46FVQfDr0wyRcgq6IDp1OohDozX6unvjGOGwg40whgTgA9jAg9GkCOsYGSA0AoDpHjvykXVxeaF5aqO1gpEbicA3HMTvOAzctjd6VFAKTYhwMUzCMU0TyZeCbxmXgm4OXgSOEMOkfgdBiDNmBn4DQLVL42j8AoRvEUDZ+/kGrFNao3rTCxCEmVQW6/knNY9+KNsN/SHNPP43utHfcT+hOgKJ9Ok+W/QndCRDfA3LFHdSZXVVyZHfK9ij/SoYWaCyHfiVDN8kjbPxKhlb1uFu/kqFlikbjVzL26iKszouwBi/y6ruQ6+4inwct8knPonHSs2if9MQrAvj1+QchtEC7av8gxNig/v2XbUa9QPT16u/P7qXbCV7pLFux2goSi3rhqQoLjYt6QXJRLwot6oXRlc7CwpXO2wn+2d1bHDEg6N2e3k3qTWXbikddd2mwwNMh1t0k3DA2JP9GxN0k3h42RkdZdxO8GVzJ7uD11LbcHsU9FH335C4+4RURBaH1fFcUczjE012R68CoZ7uiwCHKT3YFDMHKt5LvUrUzz7HD37t7Qohip3/vjsUcu/R7d8x17PLv3bHAsePfuyMMscNLLhQIjp265FKl9JtCT6TAcTzwm0K6iYip/k0hrTbi2/hNIS2nWMvfFJIixj0tITKUaQ6aS8jYoN47gzkwRNE3ruJuYo64SRRr4zrKJnN8TeDImhBjivcbTyPqcyA4gu2bi8sJ3llbhnV4t+V/uGkZdrXMe1nqHaB3EYJd4UXck9iqzx/kPbcdbpmucCoOHUlXOE9E+77xPdyvrzw3Aoeu2DV5uRIpdEs++xEodengsx9LvGpHCLqCV+1OYqs+f5B70H6Kg47FsRekQGdIgT6R0je/jXvIcu5ouF7IDDoXrheeULtefJa7cuCxkXrWgX3IB9OGoAd4fE0f5P2r4+tRQksiBLuvCHafjWvZMK5l27g+T/D84DN+FlA6K6gXzFp3GKPeEuM9RvoqU1+4uug+3Ncv3f//m9NnptYPXscPGa73DIXmN3wjjnGMmrrpG1vEa49BC3ERY1jFsBiuHVJavRostdBZ0WI3t88ErjtUWvzFUtLqTWuthu6oFnnyq+SFMgRp96wHbsUJK6j2EpF1DuB4/f2ZkeugW/o4urF6KFt2KcsRXb8ywV569y9bxq08EHXlvPBU1IXGk+yC5El2Uegku7CYvQXFK+c7ZFfOPWx/hAbrMO51NJcVZhEimx+EjVje11s5ZSO0cv5QL0yu9oYHG+GC7Cra3QjtdrsPzRBNlHFKO+ece3Qvv0ay4uvcklPRnqn2uBiipDQuo2lPSFF6Vr4UqDF+ma0m5pQ1ifLWuE5ekzmDTaA0Nk65zM9O8DT8kZuuc+A4v41TkjvnTHfl0AR5bhtRiQ8nDZTJfSaxDsS5wKjY8xweEUOUDMapGJxzMfBfqngW8XVuycVQORSDISoG4zLW6Y9H0A6WAjXGL4tB/e0IlqgYWn87gmUuhvS3I5hTMaS/HUHT8Eduus6B42IwTsXgnIvBlUMT5PluRBUDXMGiTO4zicUgLl9VJVxUwZKIAidGVLk8SE1FEnUqlSBetz6Vyibfr3uqBC6hg/frVJtUTukGlxYORlAXWPMGl27AxXbwBpdulApP3+DSKhdhUFMpBvWP1sfWrWlIxRlVLlFSU6GS/vU0gLqMXJYuXwqV1de3OBVz6zroXo/Xi2qYEOUHEj0gATbuAcJLjXQKPG6Vv905vuhnyJ/1IU63yIN6YadQlUwT2f0JyvHM3JAlB3G8EBClevY+npa/yOKo7PN3mMOJO1rZigVeUDUbQKLQC0/VXWgs6YKoRAuj+4mFhfuJhcT6fADrfWFk518nvhVvOj4kpwKebkY+oCcBIiMCxX9xzVm1HEB1HI7op8u2MLRTI27N2+zH24YJb6XzbrPdbpseuxXGus1uus0WusWh7Qeyu4Ls9x3KVry1UVB8rm6P8o2OwtM9jj1Nz9UVHO96FER3NAqjmxn9WCsnvhXzqsdaASRSradaARpTrQ+1Asx/ws/ZWCtAYo71qVb6MA99noc+z0PfmIdezkOv56HP89CLeegb81CK4KltWRE4ikXgHIvAqRWBIy4CV7wInFkROLIiMET1XRdEzCpDlFrGKb+MqyQzMWeaSZRuxjnnTODEMyFmn2FKQb7MQqGAdDBEGWmc0tK5yE0Tc4K6lLPUNEpV45yvJnDShms3TyOi9G1cuyExJ3K+dkNcp7S4dkMCJXe+dhM5pzncpINMR0rJjhLlO0oq5VHPWY8qJT5KnPuocfqjFisAFSqC/C6IiBWkG1KqBpSoIIIkagL1XBZBzZWBMhUHSlwfqHGJgAZVgpQKBSVVK6jnckGVKgYlXTTYgusGNSodlKh6xGtAY1L8OYHnmP+EHAASnlj+k2ccMJ9n/UnzCzQ8hfwnziag+Lzxn+DjTGKn2cUTzt0XHp6UNBB2cMY0pOTfI68nm10mcVyG47gc53GZlsblShqXSXFchmlcxmlc+JJUp2kcX5DiGKOUxxn0NNaopvEGOY45SDTuoMHY//O//w/7Vd1G";

  // node_modules/@pdf-lib/standard-fonts/es/Helvetica-BoldOblique.compressed.json
  var Helvetica_BoldOblique_compressed_default = "eJyNnVtzG0eyrf8KA0/7RMhzRIq6+U2+zMX2mJYsEuJMzANEtihsgYQMEITaO/Z/P41CV+bKlaug86JQf6uArsrKXNVX8H8m3y9vb7u7+8m3k4t/btazm+7o+PT0xcnRsxdPXzybPJr8dXl3/+vsthsa/L1bPHT386vZN98tF9dn7xfzPzbdrslmseAmR7smR9Bmdjtf9NxqEKbd/Objbve7Dwzb/7ifLeZXr+5uFkPLb45PBrL+6/xLd/3b/P7q4+Tb+9WmezT5/uNsNbu671a/d7vP/vjlvru77q7fLG9nd2Onv/tu+WXy7b+/OX5++uibk5MXj46Pj08fvXx28p9Hk/Oh8Woxv+t+W67n9/Pl3W5Xjx+D8Pbj/OrTXbdeT759OvCLbrUuzSaPH5/85fHjx8NOfl0OQ9gN5/vl5361G8XRf139n6Pjly+ePtr9+7z8+3L378vH5d/nR6+ul++7o9/79X13uz76x93VcvV5uZrdd9d/OTp6tVgcvdl9z/roTbfuVg8D9YDO10ezo/vV7Lq7na0+HS0/HP0yv1ve95+7b4ZGi6NXfzua3V3/3+XqaD58wXrzfj2/ns9W8279l6GzPw67up7f3fx+9bErc1B68vv98JHZ6rqqQ8PvZ5//Pk7J8+MXjybv6tbTJ8NcvFpf7QK9GsUfOtv+5uTx80eT3++v/z6dfHu8E4f/X+z+f/p4P1//7O5X86shoP/+n8n03eTbk+dDo1+Hrqw/z4Y4/u+jPX7y5Mked1+uFrNb46fDPBb+x2Y5xOv9wpSnT5/tlbvN7fvdRN3cZe16uVjMVsZfDBNT+OdudbXL/yo8PznZC7PbQVoP8THJOlx6UGY89/rzbNXdLboPLYk+VrsxW+++cf3JO/5iHO7nxWadu3A1lO0s7+Jj//ljd5ebD0OZL8VI1ovZ+mMO1p/dapnp8q7L8H4rWt5/XHWi7YflZiXo/EG0Xc+/CNg9dGJuuxBTT4f5nUirq+VieZfxurudR8lmYLGzgUS7PzazRcY3q24oZx/ms+PjmjTdulhNVV4+fzrOvci+Vxl9l9H3Gf3ge372fI9+zJ35q3+wpsLf8nf9PSfMP3KYf8of/Dnv8RcvvRryf+YP/pr7dZYH9Ftu9Tp/15v8wd9zv97mD57nD174rJ2OEz3Nrd5ldJn3+K+cfO+HxexTdx9sw0L+ftBinfLnoqdYKs7WV/P51Xx1tbnNs7bZ2fZ6WH+6vMfib6Ez9rFZHs/73Ooqt7rOrURxfsgfvMnoY+7yPKP/znv8lFt5CduScJv3eJfRMqPPouqz1QsLXOdI3Ofv2uQPPuRK2OZWwkl7R7vjnmL6uau7/IqJcPLicc3KVaP9oWy8ny+um0v99XIrzD2szh6x+3Kc5slxXCvuw+7AEH3Wx6zWjg+L5Wou+LprfMvVZjUs41cewJMnWDbreTl0TdGtRy26rG4280G5Xd7rI4edXL74K3IMvSXOh7lg4vhpOJSThwPXs5ubTqTtnuOhGB1w7OauW3Wi9odjodnNavYZTO1pzazhdKITPujhfT9bH4jwYXWljxVsAqI+nBSMnx8Oseef1/O1kIax3n9cbsKxYlr2Q3L7zK1mD6IeZlebe3XoUrz8w6L7krVGZd3OrlbqcOf9qlM7vl7ez65Cxbk0H2YSA2DKCuvQO9tdDyFVx6ibu5vZanO7mG3EbpY3w2HmJ/F1MxwHzMttyFkXXvlhz5PnI1uurj8Mx3nhwNCPUOIi6wcgkfsezmAPz57aHm4Hp9sscBe2sszEYnu9K/r1Wixgi7hjX3kityOSpRjUUJ/DKfGQ9+Ic4h9pSt0JYgb68h/zxpcmOan+dXH2/Ogo96AuF9fzhzkktH8k9swPmEVxeLcbHzo/9KG+EYN1OfeiMoGh5q/0/YVScdyeiBnVg38m9s5ngj7gZwFpJ37OMHgEnIScVCdWA33+5HkVx6seYlfkOr52xjzwUeq4/Ko64OXRytFoqn6kL4djp1Ktb4vGCuFMVgkZooe5Zk/0w9e499OX9dRz+Wd3dyMy903chZ/FqUF6chwskkOZ+4oXEjuabYz1isfq5z85chbVtx+XKzGqM9q7h4GqwE70qOBP6yJGYbNqoh14xPTiVi5wrDflKGcl+htT0KPY4tFWzQRvN4v7+edFL/rVKP+3cYCWSMPx1v18trief/iQ56pvW8OvcT+esCJZvDYOptmBVactXTXGe9eywVbG/BoD5Ish1T9efhuOGPAanJ0CrZafujs8ETJzXHU383U89PUSjZMNy3Gui3qosd4MVR3ORzzYdAxphdmIzLKV6v9qfOBfVOGnL+uxa7nSFa+DWZx/vP+Y4fdNA1wo37Kx3DdMpmuuji3hVevw4UBWxgD7+XKrNHjf5gqtGWktPa1ldN3ac65j2/fBwxJeMetxQbe4FwZ+H0zaPXG7POCIqWv2dbcbMZLGGr6Ux5leC3zwY1ef4hHOiyen4ONDAq+GRF7n7/ud8/W0Tv6isZD8fHD9/SVOnJ9K2H0dZYrJFtwyYpict2r8l9hti8MQtY+zBSwNtch3pyaxwn0u1BJgvhwPmzzVvjKBjVLoWgO6iWaKAxqnVc2qPhv5XR4gWgbLnltCXA820amMbSz531MnbOEitzk1O7+eXymj/SF+ERyYHTrc/ZUOa627jXl7czivD+7rVeM7XzVNOp4O2AzE73EjPnBA+WNruad9+yVieXZnB2TxSMC+7WAp0ASZXx7c02J5s5vvu6UI97Jtppu8jtUMGr6qUck3Bye3g5XcY95I3zu5jtvFnbt80Oye31ruftzs7kb+59Hk525199tsvtrdQ/735NXubvXk0Tenj//zaNzau0dA+35GNJo6wr8NW099a+8qAeHAUDgL33OWu4BLb+A2VYHu6z+g4DxBGUMW2P7qUED7wkH0Omy9HbZe+laNGaIwehfOQyzO6+gBhdEDh9EDraMHRKMHxUYPbKzrwIqdILkYtl7Y1nTYemZbl8PW8bFv1iEhg74D3gybT3yrfhBQiAVw+D6gNRaAKBagWCyAWSyAjbFw8hAyYRu0Pm7lEfW552MjLE1DVBzGqUidc6VWBcrVENWscVm4VT3L380lbFzVsYm5mE2iijauy9pkrm0TqMCNU5VX/jojqHdDVPTOVeVX9TxHlD3AuDICE7MbmESWYFz7gslsDiawQ5gQbaJi8IqKwDAqQtcwxtZhgvCPqoGJGKK6M67sxMR2ZbKxGNfuYjJbjAnsMyZEs6n4ISfkNrfqBWoEQrjQaAboQoaovo2TCzlnF6oKuJAhciHj0oWqepa/m13IuHIhE7MLmUQuZFy7kMnsQiaQCxknF6r8dUbgQobIhZwrF6rqeY4ou5Bx5UImZhcyiVzIuHYhk9mFTGAXMiG6UMXgQhWBC1WELmSMXcgE4UJVAxcyRMVnXLmQie3KZBcyrl3IZHYhE9iFTIguVPFDTshtbtUL1AiEcCEMDVpR5FTpUSRTIpGdKchgT5GTR0VRGlVoctbYH1tWFJVvxRbZvKJODhZFbWOxDXtZVMnQokiuFsTXDQ7+FjmZHInK6UKT88a8sOdFURlfbJHdL+pkgVHUPhjbsBlGlR0xqtEWgwbeGDgYZODoklFgq4yq8MvQAEwzcjKMKCr7jC2+4itspFHUbhrbsKVGlX01qtFcg/bQqItto33f4ofiJ1zXCXouUjIqlMhvg8RuCyJ4LVJyWpSkz0KDM7kf9liUlMOinv0VVXJXlLS3Ygt2VtTIV1EiVwXptaTgqEjJT4Ok3BQanMvYs5OipHwU9eyiqJKHoqQdFFuwf6LG7ola9E5QwDmBgm8CRddEzJ6JmnBMkMEvkVK1o6S8EvWDXsA+iZJ2SWzBHokaOyRq0R9BeZAZvpVte03bkRKuOI4eLdEQmYpxMkPn7IRVARs0RB5oXBpgVc/yd7P1GVe+Z2I2PZPI8YxruzOZvc4EMjrj5HKVv84I/M0QmZtz5WxVPc8RZU8zrgzNxOxmJpGVGdc+ZjKbmAnsYCZE+6oYvKsiMK6K0LWMsWWZIPyqamBWhqj+jCubMrFdmWxQxrU7mczWZAL7kgnRlCp+yAm5za16gRqBEC5U+4o25Iwq3AUyIhDYiUwCK3JGXuSCNCOTz8T3sx25oPzI1WxIrpEjuaAtyXX2JFfIlFwgVzLhtWDgS87ImEBQzmTyuYgve5MLypxcze7kGtmTC9qfXGeDcoUdypVoUcbBo4yBSRlDl3LINuWK8CkTwaicUYG6oKzK1QP1y2blgnYr19muXGG/ciUalvEHkatb0a5XrBUT4Vq1Y+hazsgIXCDXAoFdyyRwLWfkWi5I1zL5THw/u5YLyrVcza7lGrmWC9q1XGfXcoVcywVyLRNeCwau5YxcCwTlWiafi/iya7mgXMvV7FqukWu5oF3LdXYtV9i1XImuZRxcyxi4ljF0LYfsWq4I1zIRXMsZVagLyrVcPVC/7FouaNdynV3LFXYtV6JrGX8QuboV7XrFWjERrrUaf9HDd1cJmUDF5FeG2a1GAbyqEnKqiqVPjeJZ+l72qIqVQ1Ut+1NVyJ0q1t5UVXamysmXKiZXGvHrRMCRKiE/MqzcaBTPUwzZiSpWPlS17EJVIQ+qWDtQVdl/Kmf3qTx6z0jBeUYCvjMSdJ2K2HMqF44zSuA3lVBlVay8pmrNmmOfqVi7TFXZYypnh6k8+stIH1LWbVObPhM9euEqY66jrRiiwjVOxuKcnaUqYC2GyFuMS3Op6ln+brYX48pfTMwGYxI5jHFtMSazx5hAJmOcXKby1xmBzxgio3GunKaq5zmi7DXGldmYmN3GJLIb49pvTGbDMYEdx4RoORWD51QEplMRuo4xth0ThO9UDYzHENWecWU9JrYrk83HuHYfk9l+TGD/MSEaUMUPOSG3uVUvUCMQ2YW+G+iruBU/W1B1DEAipIXrPcRAFkRBKoziU1gITSG1fB3tquvYtyydHIXuAscEc1q7C4imHBQbCDAbCLBxIHvywxj3U9+KbvoDxh2Q8NYfKO5Ao6P+EOIOzLoLbOwukGibP4wl71vTsLUr9Oe+VUcHCLrsdP97bHVyd2T8yTVDo/9i+AxRDI1TII2raJqYQ2oSxdU4B9cEjrAJMcyGKdaVX2Q0zQhCb4jibzxPQpVoJipO01FeCIzTURFPR+U8HZXL6aiimI4q8XRUnqajCmk6qkDTUTFPx8gvMppmhNNREU9H5WI6RomnY8Q0HX8dZ+KFb9VdAarxBxRCDxw6BLQGHJDFGpiFGdgYYSA1uI524zzxrToCQHUEgMIIgMMIgNYRALIRALMRABtHAKSOwFGdrePHhmymRvbTOFUnvhUH+hNOFSAx0J9oqoDGgf4UpgoYDfQnmCogcaA/wUCd2DgdbeJWHuamMaaNHNMmj4kPyUARo92I0W7CaH+e7E95nvhWPC4qSBwEFZ4OggqNB0EFyQPJotDhUWH1fAZQPBbaoXLc8tS27FjIUT2BQRQOj5zj4RFQe000YDtqcuTHRs782MjYcjcC37JIO4qRdo6RdmqRdsSRdsUj7cwi7cgibWgT4r7J+aHOO36eqFOOnyfpbONnkdWgiPzg04ufJ3xmsSO9LVBlKy7RBaWFNryLH+qCBAoBqSoa1CQHhhpQjEjV4aJGHDmSqchIpXqLKiQ/CVSFpFJBsipqk5rkMuUGuWKpBRUvqVzHJHNJRxmqmwQqdFJVzVOTXP7UgJyAVG0K1Ij9gWSyClLJNaK6aSUSewmpXy8k4TDU4GAhNXyHGh0upORGJEdjiiJ4FAlkV6Qm5/plgtfwyla8fLdH4srdTtgd3o+XnXabUztG3W2VC1knvmklDgzr0nH8Bc1BOo2S4H6N55dJurzzy0Rd2fklv6PqiIJw8B1VUzEc+Abni4gwMPkNThZEiKrWilPQW2KfA8Fha7/1+EvMK4ggCRRHVlU0YxuMaVQgslHA+JLCUSZZxDq2aEVctDrcpG+FkuegXcBjg9FecQ4MUfSdq7hXFSNeGcS6IoyyMY6vCSKyVWvFNOgtsc+B4AgaT7EbjtPKCeZT34q3HAqKd4MKEjcgCk/3HgqNtx0KolsKhdHdhMLCjYRC6nrp6K2Z+RnOOaIw3S5chO+Zhq13Ycuv0JxN0sWZs4m6LrOj9dzXd2nnviOqFgPTYIjmwjhNiHE1KybmqTGJ5sc4T5IJPFMmxOkyTHOG6w6FgWevse6QepG/e5rRu4xgWtNCxDxPcJVolivmqQ4vU8F8R06THkWa+Siq6Y8tcg5EnRIhipwNUeWUiGrMi6hRcqT3OlX0OE0Ovdepmlw09jdt8HcNDvmjX2+UYs6koFM6BY1zCl5EgYxCSvmEEmUTSiqXUM+ZhCrlEUqcRahxDqEWMwgVyh96hy3HiXOn/Q5bbnAh9zOV9J2kkDHq1S4h5WwBlXIFFM6U+qYApIkhyhHjlCDGVXaYmFPDJMoL45wUJnBGmBDTwTDlAr7sQ2HgLGi87EPqRf7uaUbvMoJpT+/GMM8TXiWa7Yp5quO5Oc44KzTxLNP8s6zSgNvkbOAWlBQsc26wzinCeswUVilhSH7bjCmnT5JVFlGji+Z+p03lXVOBDGOFEo3lnG/UgtKOVM4+e7of8s4ZZZwLlGsuqCxzNeeXa5RZLnBOucLZ5ErMI+eUQeFFHo4IZ03rRR6WL8T3TwV7JxjkRX7fJQk5F0yjLDDO819PN2H6DdHsG6fJN67m3sQ89SbRzBvniTeB592EOO2GadbxGgSFgee8cQ2C1Iv83dOM3mUE050uSjDPk10lmuuKearrU2Mw1YZoqo3TVBtXU21inmqTaKqN81SbwFNtQpxqwzTV+OAnhYGnuvHgJ6kX+bunGb3LCKY6PSfJPE91lWiqK6ap/m2c5fHJhN9whpHV2UVGT9a5EB6tc+zP1jmDR+gcwjN0Du0hOkd1BoH5czJlK14xKyg+0ViQuKtSeLquVmi8f1IQ3Q8pjG6CFBbufBQS7yr+BvM2Xk3codigy4Oy+4iI9KA6OahwmxBwHmsnxtqJsS5Ditn9PkDika/C062cQuODXgXJh8OLQk9/FRYfCS8oPtv1G1bHGP3XE3zEtGzFR0wLEo+YFp4eMS00PmJakHzEtCj0iGlh9IhpYeER09eeRj6MOrQ9eTPZ382HrfhsTkHi2ZzC07M5hcZncwqSz+YUhZ7NKaxOEaD42NGb0Z9hq2Y+ouDKLpzHrTze88Z4z+V4z/N4eSJBEeM9p2eR3sBEOvFl5M0EHzJ8M64Url3GpfkNrQ8jrVcxYfYNUUiMq7iYmINjEkXIuA6TyRwrEyhBjFOW4HVoRpQvjevQpJ4L1IiVzCET27HibDJ+OFYpr0zg5DIhZli+1G4Icg2vq1Mrzjp1XX2U6oPEkHqGKJzGVThNzOE0icJpXIfTZA6nCZR6xin1Kn8rEKWec5V6VT0XqBErmXomtmPFqWf8cKxS6pnAqWdCTD18tJ0yBFIPH22nVpx66tH2KqXn2E6kwKE98BybbiLCrJ9j02oj5I3n2LTMqaqfY5Pq26bAyXvoeQfZ5rwpHIy5TurY5GsxTwke1f+fmOdkj3JK+ShT4qcHQWSWYhGk50DkJ1JBNJ8C2TcYpruc/b30rfoNgOoZE6AwKcBhD0Br+AFZOIFZDIGNgQNS89eRv6D6FksYkDjVeEvFCjSearwVZQkKnWq8xQIEFE81dmh3jvfCt+K7GgXFdzUKEu9qFJ7e1Sg0vqtREL2rURi9q1FYeFejkPiuxg5dLRc08nru6m12n3jmW3WUgKqxIMJRAodRIoVTV8B18IBs8MBs8M4+9p8/duWc68TYMoxqmWdr2ZiapZyaZZ4aPp0FRUyanc4CyjNkp7OOVnErD2QVvdyFdXc7z1O+CaW4yfaxaXjFRnrFJnsFP5IKinCRjXCRTXKRbZjwPm7lJO1z5uG7iC8JURDSu4jMVYTUu4gsUazyu4gscGz4XUTG5LV4/H5KiFxXH7+zmP03Hb8z106cj99ZIE9Ox+/EwcUMUa0YJ582rhzBxGwLJpE3GGcbMIEN3ITo4obJKPy1z4UKHZl6xV2uBbZ34+TxzoXRm9iuOWX5ppHvG2fzN4FXgCqkZaAKyxwMXhCMH8oBsTSY1MiBxiJhcitFeLkw3kgFXjgqXwnUGLpeR6oqFpMqwYpiqOGocm0xse2cvMoY10uNyS1jTYuOCdpYtznbeoEa5aRWo3Cgj2tSFDiOUeX1Kaoy1rGJiHhswHGPagpvlFOQo0yhjiKvZOlywKkUeFU7cDlANxErnL4coNXGate4HKBlXvn05QCpou1HgYs+qrwiRlV6YmwinDE2YH+MarLBKKf1Msq0akaRDTOo7GgkxnU0vkjXquW0pkaVV1ZS1foam3zNS+RaG1vwihvVtO5GOa2+Qc5rcHzJrhXOtB5H9esZqNbm2OBgBrbW6djocJqmNTuqBxMxrd9BXTWFg2FrrOihjVrXQwNc3aNwcG3SK31s8rXVJ636UW2s/bHR4SUqHwdE+dAStW3VQN8UDlpDPko4n+ATPed4PAAoPsdznlZ+4Ol64jmu8YDomZ3zsJoDC0/qnOO67aja6BMj9EMo9XoyjrXx6o1zGvWhV29czONvvHrjnCPRevXGhRiTxqs3xik66ZWVkTdeWSFOwTr0ygqJKmxfeWWFdArgwVdWSOVQHnhlhTQKqnx7Q0WQwyvf3giUQtt+eyNIKqwH394IKoX0wNsbQeNwNt/eCAqFUrzakGPFYcyvNjiiADZebXCuQtd+tcElClrr1QYXOFz61QbHFCh+JYBCwSFqvhKQFArY4VcCkqzC99VXAlILCuZXXglIOof24CsBSaVAN56F13HlsItn4YFRqFvPwoOgwnvgWXjQKKTNZ+FB4TA2noUHTqFLj45zVDhc9hPbEC5nFC4XKFwuqHC5msPlGoXLBQ6XKxwuV2K4nFO4TKBwGedwjb8cDMGqhEJVMQWqYhWmquUgVYVCVDEHqHIOT+UxOJVSaEZMgRkpheViDMkL34qnKxcYCkDibO+CQgA0ntddhKEDo2sIFzBkIPEkbYf8Z5nLVpy5guJZlgtncSumQkFivgtPc11onOeC5O8FF4Vmv7B6fgooTu8O7ab1mW/FU5aCaggAiesWhadTmkLj9YeC6KJDYXSlobBxxoDUETiKp7MXk/SI9g7FQXd5cuxKDSI9X52cr3AhBnCexk5MVkdlumN2ccWzc3dB5aVvxVPygsR5eOHp5LvQeMZdkDzNLgqdWxdWcwxQvJR7MclPbe9YvhCxo5sws5ucjZtG6m1k6m1y6vFlBFBEUm5EUm5CUk5H14Ot2Ospuh4gMZApuR7QOJBpcD1g1N0puB6QWEPTCT5wN0XvAiQe85qSdwGND3RNhXeBQo9uTdG7AMUH46ajd536VrwZMEXvAiRuCkzJu4DGy//T4F3A6Fdrp+BdQOK1/Cl41zEQvAo9Ha1r/yNlU7QuQPZ2CaD8C21Tsi6k+HaJ4/gTbdNgXcD87RJjZl0+1GVIuGUukmWjIpayIpa5Iti6QBG1YtYFKBcGXaidknP5vO2c69TGb84FKCaec0w8p5Z4jvhmkyueks48JZ3VlDTSh3rqc933qb4vR8Mbf6npEh0Pmb2RBiy+iAMCvokD2F7FAeZv3AD0V24A1nduANkbac521vfct+KLfJfJ+oCnd/su0foA0cSBYoMBVvMSUO22o5ktsJdofYDizeLLZH3A07HBJVofIDoCuAzWByxcR79E63NUS+gpkFv8ZebL0fte+FY8n7hE70OUzycuyfuQgvcBjqcZl8H7gNFpxuVodDAEczpk6tXMS/I6xPRq5qVwO5T4rc1L9Dtk9Ibm5ST/GPYlWZ7P1yY22oiBbloD3eiBbsRA2fdQUgN150MYX0+9tOv0YAbpJkQS2NP0bYikCndLNyKSkHwu34pICjleuhnBAnhfeseMuXJB9Y4ZS+SHrXfMWGZnTO+YMSePrByM0hC5pXGyTOPKN03M5mkSOahxtlET2EtNiIZqmFzVbzKFUuV7T1wDYHOGyGmNk906F55rYjZel7L7mkYWbJx92AQ24yosxaCTLZsgLctU4VumsXmZ0HAw05ONmcKmbQI7d7qTyILw8CptRPPk5iYcjI/yddNa8Wk5vOnN+GSvN4UMn275VSdU9/yUxs7fvOunGgj/V/f9lJZWAXnnT4m0Fqh7f0KDFQEpLQooqXUB9bw0oEqrA0p6gcAWvEagRssESrRSgASLBVJaL1CiJQMltWqgnhcOVGntQImXD9R4BUEtLiKo0DoSbgYHxxC3iUWBgWkjpTUFJVpWgiRWFtTz4hLUvL6gTEsMSrzKoMYLDWhLHZK03KAmHRUbCFNFmX0VtYa1YpPkrijyAoQar0HqUQGhiZUI1I3+UFqPUPtaANWqhPKBALbWJmxyKIB5hUIxLlJDOU38V0LKlv+uj6F4/8mF3d8k3P+Vh93WNmz5dZ6yFa/zFJSu81TXwx4Zom4Zl32rKnSwom1Gfe4B99d47vTYMey0Ieq0cdnpqkKnK9pm1OcecKeN506HZ5Wg55FT96MoxxCawEAC3zZ43+gfjyuKeXCQ7jA0pDQwlOSwoAEMCuhW0l72iYeDUh5MfcwHRmKIhmFcjqGqMICKthn1uQfcb+O50/bYB/TaGXXbBdlvk6HjxraC9aIf3HcXcuftIQzovDPqvAuy8+HP048dDX+enlkv+sGdl3+eftTGByWg65VQxyuW3Ya/ej12EP7qdSR92jd3V/zV61Gpv0AHvTVE3TUu+4t/JHfsHv6RXEJ97gH3Wf2R3L30fqAL23PZ8uMEQ6qXRfCDm4o24avp7+G9T8cawGXf6O/hvRcHFKDQjdD34fABWPi1ivdjpH2rj1t5DDmOVwP1QOy2PgXtk/oBkasx+LAV93WVgw9CvMV7NXbce9DHmbyijo+0Hgt8zAiGYEj2pqoLgWhExg9/EY0Nj22okzxKdWwzSvbia0YwVEOyh1VdCERDNX74i2io+L4kdZKHqt6XrNJwWrdYzGiwBnG4DnU/TV9IyIN25WtfxwM3pVddToN3JQ9/f3I0WX+eXe0+cjrScsKd/2zNSZYbWvzC4fRscm07LVtX+79dC8hN/Dr493UdqG/ZCB3h0PZ03APu2BDtvfKH/OltRr1A1CPjqVu7ihuDtN85Xko9MfIQPrANW1/CVh+3YkdSfe8pXacfO8IXdk8ifsif32b0JaNeIOqm9KK9RD8+MPaVX08/ifghf36b0ZeMeoGor9JMRkm8JlI7rN4SORHaQ+Prtg3+pcH7FufhtM6qRj1fiBtHJK7BnCTlQX7RVtIvkvaa0igaJ1NV9WtzPAhQeBQgPejv2mr8ReO+gXkoqOWx0Gsh4zj4rZCTiB/y57cZfcmoF4j6q84HR4lfDxg7m94OOCH+IL5iK9gXwXrFqMvyNHDU+Bn9sc/pEf0T4g/iK7aCfRGsV4z6LM/+9tqHCV4kr6SLW/GooKB6LRxR/gHjwtORw57in5R1HH/XuCD69eLC6NeLd2xpRzllKx4yFSROigpPJxqFxpOiguRJUVHopKiweOhVUHw69MMkXIKuiA6dnkQh0Jv9XB37xjhsIONMIYE4APYwIPRpAjrGBkgNAKA6R478pF1cXmheWqjtYKRG4nANxzE7zgM3LY3elRQCk2IcDFMwjFNE8mXgm8Zl4JuDl4EjhDDpH4HQYgzZgZ+A0C1S+No/AKEbxFA2fv5BqxTWqN60wsQhJlUFuv5JzRPfijbDf0hzTz+N7rR33E/oToCifTpPlv0J3QkQ3wNyxR3UmV1VcmR3yvYo/0qGFmgsh34lQzfJI2z8SoZW9bhbv5KhZYpG41cy9uoirM6LsAYv8uq7kOvuIp8HLfJJz6Jx0rNon/TEKwL49fkHIbRAu2r/IMTYoP79l21GvUD09ervz+6l2wle6SxbsdoKEot64akKC42LekFyUS8KLeqF0ZXOwsKVztsJ/tndWxwxIOjdnt5N6k1l24pHXXdpsMDTIdbdJNwwNiT/RsTdJN4eNkZHWXcTvBlcye7g9dS23B7FPRR99+QuPuEVEQWh9XxXFHM4xNNdkevAqGe7osAhyk92BQzByreS71K1M8+xw9+7OyZEsdO/d8dijl36vTvmOnb59+5Y4Njx790RhtjhJRcKBMdOXXKpUvpNoWMpcBwP/KaQbiJiqn9TSKuN+DZ+U0jLKdbyN4WkiHFPS4gMZZqD5hIyNqj3zmAODFH0jau4m5gjbhLF2riOsskcXxM4sibEmOL9xtOI+hwIjmD75uJygnfWlmEd3m35H25ahl0t816WegfoXYRgV3gR90ls1ecP8p7bDrdMVzgVh46kK5xPRPu+8T3cr688NwKHrtg1ebkSKXRLPvsRKHXp4LMfS7xqRwi6glftnsRWff4g96D9FAcdi2MvSIHOkAJ9IqVvfhv3kOXc0XC9kBl0LlwvfELtevFZ7sqBx0bqWQf2IR9MG4Ie4PE1fZD3r46vRwktiRDsviLYfTauZcO4lm3j+jzB84PP+FlA6aygXjBr3WGMekuM9xjpq0x94eqi+3Bfv3T//29On5laP3gdP2S43jMUmt/wjTjGMWrqpm9sEa89Bi3ERYxhFcNiuHZIafVqsNRCZ0WL3dw+E7juUGnxF0tJqzettRq6o1rkya+SF8oQpN2zHrgVJ6yg2ktE1jmA4/X3Z0aug27p4+jG6qFs2aUsR3T9ygR76d2/bBm38kDUlfPCU1EXGk+yC5In2UWhk+zCYvYWFK+c75BdOfew/REarMO419FcVphFiGx+EDZieV9v5ZSN0Mr5Q70wudobHmyEC7KraHcjtNvtPjRDNFHGKe2cc+7RvfwayYqvc0tORXum2uNiiJLSuIymPSFF6Vn5UqDG+GW2mphT1iTKW+M6eU3mDDaB0tg45TI/O8HT8Eduus6B4/w2TknunDPdlUMT5LltRCU+nDRQJveZxDoQ5wKjYs9zeEQMUTIYp2JwzsXAf6niWcTXuSUXQ+VQDIaoGIzLWKc/HkE7WArUGL8sBvW3I1iiYmj97QiWuRjS345gTsWQ/nYETcMfuek6B46LwTgVg3MuBlcOTZDnuxFVDHAFizK5zyQWg7h8VZVwUQVLIgqcGFHl8iA1FUnUqVSCeN36VCqbfL/uqRK4hA7er1NtUjmlG1xaOBhBXWDNG1y6ARfbwRtculEqPH2DS6tchEFNpRjUP1ofW7emIRVnVLlESU2FSvrX0wDqMnJZunwpVFZf3+JUzK3roHs9Xi+qYUKUH0j0gATYuAcILzXSKfC4Vf525/iinyF/1oc43SIP6oWdQlUyTWT3JyjHM3NDlhzE8UJAlOrZ+3ha/iKLo7LP32EOJ+5oZSsWeEHVbACJQi88VXehsaQLohItjO4nFhbuJxYS6/MBrPeFkZ1/PfGteNPxITkV8HQz8gE9CRAZESj+i2vOquUAquNwRD9dtoWhnRpxa95mP942THgrnXeb7Xbb9NitMNZtdtNtttAtDm0/kN0VZL/vULbirY2C4nN1e5RvdBSe7nHsaXquruB416MguqNRGN3M6MdaeeJbMa96rBVAItV6qhWgMdX6UCvA/Cf8nI21AiTmWJ9qpQ/z0Od56PM89I156OU89Hoe+jwPvZiHvjEPpQie2pYVgaNYBM6xCJxaETjiInDFi8CZFYEjKwJDVN91QcSsMkSpZZzyy7hKMhNzpplE6Wacc84ETjwTYvYZphTkyywUCkgHQ5SRxiktnYvcNDEnqEs5S02jVDXO+WoCJ224dvM0IkrfxrUbEnMi52s3xHVKi2s3JFBy52s3kXOaw006yHSklOwoUb6jpFIe9Zz1qFLio8S5jxqnP2qxAlChIsjvgohYQbohpWpAiQoiSKImUM9lEdRcGShTcaDE9YEalwhoUCVIqVBQUrWCei4XVKliUNJFgy24blCj0kGJqke8BjQmxZ8TeI75T8gBIOGJ5T95xgHzedafNL9Aw1PIf+JsAorPG/8JPs4kdppdPOHcfeHhSUkDYQdnTENK/j3yerLZZRLHZTiOy3Eel2lpXK6kcZkUx2WYxmWcxoUvSXWaxvEFKY4xSnmcQU9jjWoab5DjmINE4w4ajP0///v/AGoZ428=";

  // node_modules/@pdf-lib/standard-fonts/es/Helvetica-Oblique.compressed.json
  var Helvetica_Oblique_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Helvetica.compressed.json
  var Helvetica_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Times-Bold.compressed.json
  var Times_Bold_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Times-BoldItalic.compressed.json
  var Times_BoldItalic_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Times-Italic.compressed.json
  var Times_Italic_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Times-Roman.compressed.json
  var Times_Roman_compressed_default = "eJyFnVtzG0mOhf+Kgk+7Ee5ZSdbN/aa+ebzuMdvupmjORD9QUlnmmmJpSMoSZ2L++9YNwMEBkn5xuL6TdUkkgLxUFvXv0Y/1/X212o6+H1397XEzv6sOTl6+Onx1cHry6uXJ6MXol3q1fTe/r5oCfyzuq813H+r7+aoVHpdLFA5UmN8vljuUGjitFnef27tIqTfb+XJxc7m6WzbFDpvjzS+L5+r2t8X25vPo++36sXox+vHzfD2/2Vbr36v21J+ft9XqtrrVGzWP9sMP9fPo+398d3R28eK746OLF0eHh4cvLl5d/PliNGkKr5eLVfVbvVlsF/Vq9P13jQzCH58XN19W1WYz+v604VfVetMVGx0eHv+luVBzk3f1dnHT1uTH+mG3bitx8F83/31w9Ori9EX773n376v231eH3b8vu3/PDy5v6+vq4PfdZlvdbw7erG7q9UO9nm+r278cHFwulwcf2qs1dqs21fprQ3szLjYH84Pten5b3c/XXw7qTwe/Llb1dvdQfffXqjnr8vXBfHX7P/X6YNGcvHm83ixuF/P1otr8pXncn5vb3C5Wd7/ffK66Buie4vdtc8p8fStqU/DH+cNfhzY5Ozt+MfooRyetJS43N62p14148fLF6KdKjxsjn78Y/b69/et09P3xRfffq+a/Fyd9e/2t2q4XN41B//Hv0fRjU6S93LvmQTYP88aO/3nR45cvX/a4er5Zzu+Vnxxe9Pyfj3VjqeulKqeHw4VWj/fXbUPdraJ2Wy+X87XyC7nLQ7W+ab1chPPz4Tbz+0baNNaJT9Y9QdfiUXuYr6vVsvpUkvxp+njzTXvFzRdTzk6Gs5aPG6Vqs5smOOfxFp93D5+rVSzeVGVRW02OpZKb5XzzOT7Nv6p1HWm9qiLcPiUlt5/XVVL2U/24Tujia1J2s3hOYPW1Stq2ym26WsADa5Vv6mW9SixR3S+8pC2wbNNAoNU/H+fLiO/WVRPIVs2TkxNxmmrTpRpRXh0fDW0P3nd83LNLRWdn5z36IaIf44k/Wamj4fo/21OenvXol3ji64j+Gh3sjaEmtXXof+OJb+ND/GqhJyf+LZ74LqJxfPrfYqn30Tgf4om/x+f6I15rEtGVtZq05zSW+hjRLN7x79Gq101n9qXaurShnnndaD5O+TyfU07OXklOuVksbhbrm0fLohocj23S3jQ9T5J5u/zmHka9eB6vdB1L3ST5N5ZK7vwpnngX0edopEVE/xdP/BJLWQhr5k+slSSdJO09RPTPWEfLDRpCm/hcST57jOhr9LinWCrJpLvYHP8ydHFo/uUd4VhbHTpTX556uJMj8MbtYnlb7Opv66fEzq53tp5g243TzDmOJOw/tQNDzLNW56zv+LSs14uEb6rCVW4e1003fmMGPJLad2GzWXQD1yT996MWZ01z8sdFo9zX23zk0Mrdhb8hk+kl7X1aJCwZPzUDuXQ4cDu/u6uSnrvnOBSjAUfbdtW6gtg/tbHQ/G49f4CkJqdeN9OHKqmlmfd6vtlj4f1qYfylDeD1bs7Q22a5XDxsFptEauq6/Vw/urFi6Padc1vLredfk3iY3zxuE9zn8k/L6jlqhci6n9+s6+TG1+squ/FtvZ3fuIgzadG0JBrAEhrGoT1sdduYNBujPq7u5uvH++X8MblNfdcMM78kl5tjPaBd7p3P6uDi0kY9x+eDz9fr20/NMM+NC22A4vtYG394rjcY2w1eHh3qDe6bPPe4dHeQzDRPRqO3bchvNkn3tSyMzevCc9bJILqJzmZC3Hh90mpvQoNax+z9zzp/7zXWMaVNapfzbWdjo/AEOoq+XXxdgDvbKf7JbLichIY9duGkSXKSdRYUg9pVdzMvChKoaryk3c8FiuFyQ8wpGuwc/3TWEnSCzQHCTWzG0GQImIL4KSZV9PxMxWHNI7kV5RwbFXo/sFrmdnmXPYCFR8lHfUq1cX52NZtIla7m0yqYMyZK8xBXTeCUEW3wSnc/H+6yrP9Vre6STPKhEFGvs0qac+wNkn2ee1nqRtaFJr3hutrsJ1pOxyR/fK7XSa3GdHczA0WBTvOIX0iyLZhtQjcwi/muzS1vbB67Mc46eV7vgmbFEqe0Kknw/nG5XTwsd8lz+QqCk/vmkI6vGW1tF/Pl7eJTMsHalVPDO38fc9jEWSw29rrZnl6nLN0U0t2qlAapQSGnzFM/fkMXwsW3ZsCAK3A6AVrXX6oVToM0Oa6ru8XGD3wtRAsjrzcxLs50LvLYRLWbjZixCyPIdcEyNceSxmXBpf7uLXZ68kpGrt06l18F01r+vLURiiXZYgJcZnnr5fHgvdtCkqmKvWNJuCwNH/Z4pTewzZZLoVG697jUIqWuh3Ou9iOlO5fjeLx3WMI9powLquU2We7ZuiRtOfGp3pMR40hPzrt/TGrin8hMlY4zLRbI9DZP9SOc81PM440DrxtHhkfTbiRMYaRtloWO5G06yNAZhm+4V7JuoK90spxYnpC9KYT+m1KI/0pPLWZojPZ5voSeQWK8nZnQMrc2xb6x88qPmszTvtF+hUioSt3znc+lWKGhVbNG9fnMeDbcVQfOZzjqYE2WyF541BRalgnn+XiDks2pZvPbxU2WZ38q9GfrvbV559vHHpdGuzbc3OvWe+91WfCFy2KOzmcDY38dy8NJv2kjkUJvX0oUX9Lxs47H3EDArrY3FPwj2PLu3jst67u2vVd1Moqvy7n0MUoSys2lCpF8t3fOUEFHbjYvuO8q7cbh9WHoISzll2L858f2VeSfL0Zvq/Xqt/li3b5A/sfosn1RPXrx3cnhny+Goz57ONQ/p0dDTkf42h/1WcUhrBgK4+bo9FSP5BEAgXM4rk3laB//DrnM45TBZI71i0MO9YGD6L07+qM5Ojo60kMxmmOu/qBM3KUm0QCTggEmqQEm0QCTogEmiQFk6OdYl1GQXLWVeKmH0+bwlbbprBUPVZxJnZDBwwOGfQHOSF+bw/MTOXpq73YsRzt/JDcDBPca6FAIA0ARRYFyCgXjHA+ivE4QRYbyNDxEhRhRRH6iPHMWFaPHqERuozz3HZXZgVSgMFJOsST8fUQYVco4tExI40vkSbw8R5ryfRZMYk6lggUL0adyyYIhDlXwwSgYI1IYhKUgjE1lHKAqJFEqWhqqIkK8CoKgFbRLEIWv8hjDQyhhDCuiGFZOMWycY1iU1wmiGFaexrCoEMOKyAOVZx6oYvRAlcgDleceqDJ7oAoUw8ophoW/jwhjWBnHsAlpDIs8iZfnGFa+z4JJDKtUsGAhhlUuWTDEsAo+hgVjDAuDGBaEMayMY1iFJIZFS2NYRIhhQRDDgnYJohhWHmMY2wkD2XOKZi9SSJPIce3k1yVOEe7FNMxdEYh1z8ldvZj5rC8RHdfr5L1ezF3Yl2E/9iqlAy9STnDi+wLH7OAFThGkpnnClZkUbskZw4vfbIIkd3h9XxMUsogvs7cJQj7xqk8qTsPM4gRIL45jjvECJxqvJtnGFUhTjisBecdxSD6O70qc0pAXYy4ygpkIKeUhlCgLOYlzEIivc0r5B6U0+0AByD1Iye1Rypwe9ejyqJLDo5S7O5ZgZ0eNsg1KlGtAep9SzDOIOcs4Lc0xUGKS3orzC0rfMHSSW1AtG7qQV7DEHkOHnIKazyigYD4BDNkEKOYSxJxJUEvyCMhpFgEdcghQyCBAdzml7IFSzB1D42DiUERZQzmlDOOcL0R5nSDKFMrTNCEq5AhF5LfKM6dVMXqsSuSuynNfVZkdVQVKB8opFwh/HxFmAWWcAkxI41/kSbw8R77yfRZMYl6lggUL0a5yyYIhzlXwQS4YI1wYhLcgjG1lHNgqJFEtWhrSIkI8C4JgFrRLEIWx8hjDYjgMYmMUxSZQGIPAcazS64xRJJuQhrLKEMvGyBVNyHzR1OiMppE3mpC7o+nsj6ZQSJtAMa3C+4RhVBvksAYljWvVJ8ktOLJN2GvOJLZNK5mzEN2mF80Z4tsUH+DKMcIVQogrwxg3yEFuShLlKqZhrirEuTIIdGW7jFGomxBjXWyFsW6MYt0EinUQONZVep0xinUT0lhXGWLdGDmnCZlzmhqd0zRyThNy5zSdndMUinUTKNZVeJ8wjHWDHOugpLGu+iS5Bce6CXvNmcS6aSVzFmLd9KI5Q6yb4mNdOca6Qoh1ZRjrBjnWTUliXcU01lWFWFfWxvopheguY9pMLGBD9Np6+CjbAkoIxblginLFHOOD8DoSim/BaXQPIsS2EHJFwZkjihbdUBRyQsG5C4rKDiicolkwxfKA3weCcSyIo1h5GsODOgmX5vgVvMdoSeyKkhutELeiFowWYla4j9iBYrwOCKJ1IBirgjhShSdxOkhplA4axOhAoDceyC4S6okFx3548BgMTkUUncopPI1zfIryOkEUocrTEBUVYlQR+ZvyzOFUjB6nErmc8tznVGanU4FCVTnFqvD3EWG0KuNwNSGNV5En8fIcscr3WTCJWZUKFixErcolC4a4VcEHrmCMXGEQuoIwdpVx8KqQRK9oafiKCPErCAJY0C5BFMLKQwz/0NDL5qivcnck5wKSeAPk2hc43AGotCogbTFg2ljAhnYCIs5vaNJZVo+sIRS5xwXumkapPC4g8j9QtCLAtCLAhor05KfB7id25DPmT2h3QK4iwKEiQKUigPRxgenjAhseF4jY3dCVO2rj5KUezTS4fsLgABSywLCb11lGEZlHOdlIeWYoFaO1VCKTKWe7qcDGU8FbUDGZUfhVRGBQQbNoLDat8sS+3XcA3r6C2L7C2b7CU/uKmNhXJLav8GBfEYJ9RSD7Cmb7DvwqIrTvgGbRWMG+woN9fxlM2+fsX9CqgMSggJwtgcMdgIoFAanxgKndgA0mAyLWMtSOwY60PnNNpoakBoB8fjWO+dWo5ldDlkWNWRY1JlnUiNTAUP/jUC++uzgUUju9jnWqCxWo0wrUsQI1dxCmJFWrZWAHKNZj+NUqqcj/Du51ZkdSEUDSOIBc3YBD3YBK3QBpDYBp4wAbGgeIVKpHb0f9MPylHelow5AfWhjHoYVRHVoYoqYAxQYdxqQpAOkIQ1F7dHyqR/LUgGRMjQgrAhwqglQ/5HBY6gdIawFMm8NYrWOkt+j0gJJB3FtyeqB+EPc2cXpQaHj3Fp0ekB/LtehRQ6A78qHaoSRUOx5CtaM+VDuUhmqnUKh2jLJQx1wWasnOWX4X/WMXG91NtjAuSKAQITWLFioSA4cKUAyRmocTFeLIIpmCjFSKN69WJYtxFJJKAclqEptU5FstlkUslaDgJZXjmGQOaS9DdJNAgU5qFvNUJIY/FaBMQGqeFKgQ5weSKVWQSlnDq5BASKBcQmqWVqhIzDBUgJINqXneoUKcgkjmbESyT0xe3JVcidMVqSEOfh3160r9EkJ3JMGGyK0lmdAtsRweyuFUB5+/jmRhRUVYUzHm5uyK3UqK3a17/6BPvfNj+V+pegPFb1iGK4VPWALPauu+7hgeFb/uGOrtv+7wxYIF8q87vJbZAj/boHqyVbLPNgZJJpfZHUTbxeJ8B+XJHZzzQROQQA3BatYcvgw2ilegabwwK54SmonkpLF8idSgIXxTGwXjFsN3KDAkVzSuIjKr8cygoqIphYERBc2SYsFwKiQmEy0zlmi7WE82kPJgmncjXA7tjnxv2iG/HNqhpFfteOhKO+r7zw5Rf9gxWg7tmFsO7YjvDN9J8F4miOqinCqkPKuVirFqKlH9lHMlVeCaquCrq5jqjOuGjKjOYd2QeVbnbN2QJapzXDdkgevM64aMuc4uyi+LAtffq2wFr6a28EUSi/gCbBevBut4OdjIy2QpL5K95B3IZYLIRsrJOsozu6gYLaIS2UI5W0EFrr8KvuaKfZ3HrrrjWNNxrOS4UL9xWrVxrNU4qdA4qcs4VGOc16DtpfqF2zF2UIiS177joVs61aOpu+pHV3LmStqKryHsKnoaE+24kGjHhUQ73pdox+VEOy4k2nEp0Y5LiXacJ9pxIdEqhzYJI+PAs9bBkTHZcxpv9zGeOIsncrNlI+VBcl8TQQN6Tq3oRWpKL2bt6UvERvU6tawXuXm9ym3sVd/QXqPWDp/7nSTW43bf97FfVuSq0CrTwnN8LFxnVrgOe0Xxg7dBh09FwDGQklugRE6BUuYSqEeHQJXcASV2BtTYFVDzjoAKuQF9i3US7MQuUP4SKxa4Si0/Te/+Mb3CLL0CN3vh66RBlQ8LoMUVUXMrp7ZWnjW0irGVVaImVs7tqwI3rgq+ZRVTs+KXNSfeDNyghe9qSL2K9pzG232MJ87iidx82Tcog+RX1bAJWaGWZJkalOWsXblMbF4uQa3MMjc269zmrPumZ5U8gGRwBFbIH4KcuQUVuiq22LT4RB+LV5sVr8aew3J0IP3UAFzHGDmNCeQuJmSOYmp0EdPIOUxgtzCFHcIU7wrGyQnctzgnZBFu+NKXOCxfJdadJvf8mJw7S87lRk2/Vhk0Wd2B1lREjamc2lJ51pQqxpZUiRpSObejCtyMKvhWVEyNiCt6J94M3ISFFT1Sr6I9p/F2H+OJs3giN162wjdIcZI+LkzSx4VJ+njfJH1cnqSPC5P0cWmSPi5N0sf5JH1cmqTjTt0TbwZuu8I+XVKvoj2n8XYf44mzeCK3XbantZd+G5qtX479DVsMkDQWINdOwMNe1d+wdQBpwwDTNgE2NAcQaQlDtvmpO/JvDDvkNz91KHlz2PHwurCj/h1hh+idX8foRV/H3Nu9jvhNQy2SzU/DZuIW6T6igb0f4ZbZ7shvme1QsmW242HLbEf9ltkOpVtmO4W2zHaMtsx2zG2Z/TDqN0mc2JHfs9ihZFtix8OOxI76zYgdoqcGhXYodkzeUwPy+w8/DJF9ZkcS1IhcPJswcdeZxPpOCvWdpPWdxPpyK4GS1HdCmzE/QCsZaRPQhR61uad/u/JhyDFndqQb2AzhrrSeykIOtL4iMonyzC4qRuOoRBZSnptJZbaVCuQgyslLcGHtjBD5S2FhjdRJvDa7j/J9tkocSaWCrQoupXLJVsG5VPAehmuHFx6Br+FCIfkRe122UDhI8vYFXE8RmVN5Zk4VozlVInMqz82pMptTBXI95eR6wsH1FJHrGc9cT9RJvDa7nvJ9tkpcT6WCrQqup3LJVsH1VPCuh5v1LzwC18PN+uRH7HrZZn2RwvZAeYh8e2CupgYubg/MC7Cx924PzAsFw+fbA3OVHTbsEDlLBXbefTtE0jKT0j2DO3v12zbPXNsX2Gvzkpv7QvttHl3ey+T4YevMRSZgEISdM6lfh4Ao7pvpC/wxGqYZL/VIpxmGdJphyE8zjOM0w6hOMwzZNMOYTTOMyTTDiE4zFLXRfHShRzr6NuRH38Zx9G1UR9+GePRtio2+jen3CIZ0aqHIvqnojuSpAYndAbmKAA8R0FHv9h0iN+6Y2h0uONgdiM8bLer/wrVMWXvST5f6rUotac84V103GQOSxILIfcFjPGy97ilsHIbC+mGPIdpW3TH7sEfZ8HfPZSbbosVIpvzdkV896RCtW7SsdgasYwvXhebEPcNApUaAyC9B0boCE78EJK1qSOe31ohrV611rP1aGhGR6xJMsL+NLtmtpe0+4xM70i7BkO8HjKPrG1XXN8Rp3hQLCmOW0I1JFlfy5Cy380exvXexXXGz1ZDRwmYr5pSP881WLMbMHDZbMeccHTdbseCzddhsRRzydpgGMM8yeDYNYIlyeWkawDJn9TANYE75Xfg8tjRneuWU7pVnSULFmPhVouyvnLsAFbgfUMF3BoqpRxBO3YJh1zcIhhStiHoJ5dRVGI9f7ZgYOw2TYs+hGnUfyrkPUYE7EhG4NxEOXYoiyqzKuXMRoY6twt2M8n1ulHQ4KlGvozzvelTm/kcF6oSUU08knLsj4etoDe6YlFPvZDzrokRN+imRoLNSRD2W8qzbUjH2XSpRB6Y878VU5q5MBe7PVPCdmuCn2BK7BBWcLevowg5b6Q3yHba5yl3fnh22eZGkG8x32OZq6BILO2xzmbrHfIdtqmJXmS9Y5GrabRYXLPIC3IXuXbDIC4XuNF+wyFXuWp06L3lY6Ga9yp2tV9Nc6YskHa8vwN2vV0Mn7OXQFXuZOmQvcrfsVO6cSfRdtP+CEro2L3B37VXutEnNum5fJOnAqUDSjfsS/pNcVu33HlI5dOxODt27U7GT9wL3VV4NHb7/ZLPU9qHz9+q33TobCPgCPBzwamFQ4AuFoYGXeYDgVR4mODUMFpy6LtkzDBy8ysMHUtNBhCuTDSVcARxQeIGHFV5NBxe+SDLE8AV4oOHVwnDDFwqDDi+HoYeXaQDixKdSS++Kwt4QiAOTyTAaObEjvx49wXEHoGRdekIjDKC+N5i4sQQwWkaewKgBiM/wsn6O1QjfTjCnCuXfTrAYqxa+nWDOlYzfTrDgqxu+nRh4+OYg5VT7/JuDVMzsUPzmINXJIoVvDlKVbZN+c5BqZCXafp9QslC2/T6RMusUtt8nKlkm3X6faGyVZPt9opBFcG86I7JF2JvOPLNCtjedJap/3JvOAtec96Yzpjone7oLClmgtKe7IGf22LOnu1CCrFPc013Q2VaFPd0FlSznNjMHRtaKm5mDkFko3cwcNLJKspk5KGyJsJk5cKq9/pL0Zcao9iZQ7U3Iam9qrL1pVHsTuPamcO1N8bU3TrUffqn3MhKquWCqt+Cs1qLFOotCNRbM9RXOtRXu6yrU1/RqqOXwS61XWEVkulcTmF9fAAFXFQDrWgIwWxwAaBsYAcoORkC6OGCs/Y3jIzvyW0w75IfsJoydTWgvSIeSxux4aMiO+kbsULrXoFOoaTvmd3J0KLYd7E/tDrXtgKkRgPm3rMbxdxKN6nq4IZs3G7N2gztJuwHSX0pUJBOkfurWk2Hz7fErQVSHKqmrLTgAyqtapVV16wl44WiCKjFBlZlAVwmGH99oWbs2cGZHunXDkP9ZLeP4G0JG9eexDNlvYhmjnxpsWe2NbL/oCMxHOgg4ozKqywSGeKUQrmErAsZ0URDK6eRfke3GtmI43TZvaufY5xrqOrEG5L3EOHqJUfUGQ1RDUMxPjNm6kjH5SdGOTCUx9603dYkZmAY3MGouEzAxA9bEDMwSM0DzboAS4IA0MRvrFrHtyO+Sn4b0Cjzskp9iegWU7pKfuvQKTF3MkD62Ilthno7CsvJ0FNaSpyG3Ag/LD1PMrYBojWw6iovC0xGvBE8xsxqSWHh5bqTPrP2a5XRIrHZGFWupaRVRXssq9IZTTqtQ2HeSU5dVgSWV16R6puGycCctfA8+denPWO2uWse6ZwunU859RmNz5uui01FcDJ2OwgrodBSWPaeY+awRMfFZY7eJ71RP08QHyP95AePhs6QpJj5A/PcETLE/JWDM/oqAMfkDAkraBb7zl3qk6doQpuWOzny+nCX5cpbky1kpX87yfDlL8uUsy5ezLF/OYr6cJflyNsIfMZ1hvgSUvD2ZUb4E6t+CzJJ8CQrtc5hhvgTkf2x0NuTLYZQzw4SJTFsAGOV+E3DXqlH/w8ozlzOBwYdQBvVLKEP+p5VnkDX78JqNwnh0NqRNuEyVVFYTp2OFylZpZf2IFEpHI1SJEarMCDYi7UepsyF79u8nZpg9AdEfAJkN2fPoSK9rg0dgvrogYAwb9XtvZkkCxWvQ67sZZlAsp1MORTx4nFEOtaZ/9IZ6pHnHLGRRFMIsY4ZpFFCopEk00Zi5PIoF/VxrpuvnkFrCy4EgcIbMXw8ENcmV4QVBEELWjK8IgkL5M7wkYAEyafjWjXmWU7Nv3Vii7Fr61o1lzrPhWzfmlHGFY9pVxulIBU7AKqSJSdWYnVSiVKSc85EKISmpQulZOeVo4RSthn22Fp5VO+RtFTh5m7DPUEkaNynJ5SoWrBiyugpFK4b8LgIkeUWU6ZVzuhcBc74yTvwqpNlf1dgFqET9gPJCZ6A69wgqcLegAvUNwkMHIULSS4j0mNg89BcqpJ2GqrHnUIm6D+WFPkR17khUCL2JKtSl0EtFybXZW8VM476l+F4xK5D0MNmbxUwL/Uz6bjETqbfJ3i4mGvQ5SKnbQSnreVCPnQ+q1P+glHdBWIJ7IdSoI0KJ+iKQsDtCzIkWNe6UUEvTLRaIGRdVyqsocWpFLWRXFKmbQslWkYJGWcMpvsMCqXCt0G2hxj2X075hzaT/cmrShaFetnboyFDbZ+3QnYEGPRpS6tRQ4n4NNOzaEHPvhlrawWGB2MehSt0cSoWeDotwZ4ca93eoUZcHUuj1QEs6PlAf8wYK3R9qaQ+IBWIniCr1gygVukIswr0haqFDRNH3iU3Ydn9fsu8F2qN241r/YlFSHhYQBKWG5IelBEEpt9sHijoO5eGRoTRQKCvbR6CgICiluwWgmDIo5/629VDO/W3roRz8dd2hFPx13aEM/gnPoRD+Cc++1DV6br+4ez245LEdiScCSt6yXZPfAfVv2a4TPwOF3r9dO7cCNniTka9arZtRvxYKRxpNhnBc1FNxsV2C6ALK41Xw2w9GdJXs2w+R5M8Ru+sY5CuZEq/Vd5L9Hy24vV7K3y3os5hTvdRW0H7uqTvyOwM6lO0MUM/Toyd39OxK7vyRr1puZenG8fkU0UMqT5/UpRqPniJ6jifuEkRVKHuLDDmwHoqoHsrTeogK9cAPkwg9xxN3CaJ6lP3VDY9cZRznGjkxr1bI3gl/KvDnwnV2Jc71dWKsNHQKdzmlCqOUVpc7n0CfUvqcXmGXU6okSkkVbdzq6oiYK4laXksogdUE/JTj5/wiuwLmqqIW6ypd912CqI7K0/q5YYFHTxE9xxN3CaK6KI/10LHFXcaoJiakVfFjF2JPCXtOzt1ljOpjQqyQDoLuMkYVMiGtkB9kEXtK2HNy7i5jVCETQoU+jWS2r0d+Z0eHbG6vKNns0fGw2aOjfrNHh2hLR8fohw875n74sCN+l0eLmmhaVptNN5VU+Ekt2B4tdITWHfmR5CcadfQTy7vBNnagk1IlYhkj/nW8Ynwbr1BfxiuxN+6KbLqrSN63KxCT9ESmHvNIfA0U+2ooTuqiWqiQKr5Wiqlqyql+yl0llfqaxs9JU+5rXfiYNBUTC5Q/JU11b43Sh6SpSpbJPyNNNWcl/VNgeuDsEf78VwsXLi0t4tB0URgOLdJxwyL2Q4skny+SlNgeWbR3Rz5DdcjWywzFDNXxkKF66lbFFPvE1SFKXB2jxNWy2h/FZ64LD1inD1jHJwnrS6Ykz1j7/XId8pnUdydJR5J3IV/il8bD9QpfGucqteC+L43zItFse740zkuQjUtfGucy+0D86jcX9poldZLyV795gb3VKnhR6avfXCbfKnz1m6q7kiOx85W/Be0LLIdRU3+XpVul61H8OnUQ5GfYDUleOtEje85kzJiPFleYNocrxbn6qjBXX5Xn6iucYg8XjpPnVWHyvCpPnlfeRHj5QqOxwLf6RqOtcHVwuJWgXSzFl1ceLlyPcB2udiPqWi5+qEc+CGu+ZE+xOYfrxgWa2rWwP5Fvk7ZwL4XudbhhYbWhjqsKyXX4/uVVhV6nvnx4hHQNoObZfrgC37w02+9VHDAM940T19rNUv2JfLt0ltpL9B0h3JIUuDMpu+LV+DlYjo/jBkbDgyQT3dpPaulcvm0+qe01SX9wP8yIxx7t4ol8s+yvyg4SxvtwL3wbcOzRLp7I90pTQCc9uAs8xHMf8tOG1xCFVWove03OWFaf5Fvdi1SQ58hV/0kCq8l2di4CdcoL+E3urNKudpZpMz/L7qMGFv1O+E7NjbXHUnvM9C0b7TfQHuvsM80+u5SN8m2LwP+HL6HQ5Ubtm7LTw4ibB5xvc22pTu6xDwuv0dJVUsIP/pzmYyTWYZ0/p/6kS6bJRCHV3MMmJboJ7mnEfruB1/SGmSZvu3LVP05S4mF+U+Wm6ax9ETG1RyzxVWveWFf3pZwoudPTuiNd2zOU3aIVdBvHsV5M39n2lZOG49u6d2QXHtEDlN6ReZUfJez5G56Hf79yeB73ruvCI3qe0rsur/LzhB9AlOdJf7JLnsqJ+Gxe4Cf0av6c+c9eHWc3pmcefLRL0ER81CjWFTWP/Vqa13D9ySu6fuaxrZx5TpuDlMtqmae6TubwH2o3Jbo6QTixtYj2t6eEdH96ypH2t+BfeSI2JQwG6pUmzLsFz37E1B3porYhaQpAfseEcdwxYVR3TBiyfRHGbF+EMdkXYUTMbUgi4EyJze66Iz/h65C2BaD4Z6c6HqaFPcWFIMP+r1F1iP4aVcfor1G1rNZQ6o78y4UOJdtUOh62qXTUb1PpULpNpVNom0rHpEsGpLZXpHHeG/9phK+CntChAPlXQU/BoYCHkfUTOhQgWlx6cg4FzL0KekKHMuQd6mmEK29Po7Dc9hQaB3hagTpWIF9CexrFdbOnUVgsexqFFbKn2DjPLjKeY2Q8x8h4LkTGcxoZz3lkPMfIeE4i4zmJjF1ojl2s2I5HDIS5eLLlNip40p//+X+DG1I7";

  // node_modules/@pdf-lib/standard-fonts/es/Symbol.compressed.json
  var Symbol_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/ZapfDingbats.compressed.json
  var ZapfDingbats_compressed_default = "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w==";

  // node_modules/@pdf-lib/standard-fonts/es/Font.js
  var compressedJsonForFontName = {
    "Courier": Courier_compressed_default,
    "Courier-Bold": Courier_Bold_compressed_default,
    "Courier-Oblique": Courier_Oblique_compressed_default,
    "Courier-BoldOblique": Courier_BoldOblique_compressed_default,
    "Helvetica": Helvetica_compressed_default,
    "Helvetica-Bold": Helvetica_Bold_compressed_default,
    "Helvetica-Oblique": Helvetica_Oblique_compressed_default,
    "Helvetica-BoldOblique": Helvetica_BoldOblique_compressed_default,
    "Times-Roman": Times_Roman_compressed_default,
    "Times-Bold": Times_Bold_compressed_default,
    "Times-Italic": Times_Italic_compressed_default,
    "Times-BoldItalic": Times_BoldItalic_compressed_default,
    "Symbol": Symbol_compressed_default,
    "ZapfDingbats": ZapfDingbats_compressed_default
  };
  var FontNames;
  (function(FontNames2) {
    FontNames2["Courier"] = "Courier";
    FontNames2["CourierBold"] = "Courier-Bold";
    FontNames2["CourierOblique"] = "Courier-Oblique";
    FontNames2["CourierBoldOblique"] = "Courier-BoldOblique";
    FontNames2["Helvetica"] = "Helvetica";
    FontNames2["HelveticaBold"] = "Helvetica-Bold";
    FontNames2["HelveticaOblique"] = "Helvetica-Oblique";
    FontNames2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
    FontNames2["TimesRoman"] = "Times-Roman";
    FontNames2["TimesRomanBold"] = "Times-Bold";
    FontNames2["TimesRomanItalic"] = "Times-Italic";
    FontNames2["TimesRomanBoldItalic"] = "Times-BoldItalic";
    FontNames2["Symbol"] = "Symbol";
    FontNames2["ZapfDingbats"] = "ZapfDingbats";
  })(FontNames || (FontNames = {}));
  var fontCache = {};
  var Font = (
    /** @class */
    function() {
      function Font3() {
        var _this = this;
        this.getWidthOfGlyph = function(glyphName) {
          return _this.CharWidths[glyphName];
        };
        this.getXAxisKerningForPair = function(leftGlyphName, rightGlyphName) {
          return (_this.KernPairXAmounts[leftGlyphName] || {})[rightGlyphName];
        };
      }
      Font3.load = function(fontName) {
        var cachedFont = fontCache[fontName];
        if (cachedFont)
          return cachedFont;
        var json = decompressJson(compressedJsonForFontName[fontName]);
        var font = Object.assign(new Font3(), JSON.parse(json));
        font.CharWidths = font.CharMetrics.reduce(function(acc, metric) {
          acc[metric.N] = metric.WX;
          return acc;
        }, {});
        font.KernPairXAmounts = font.KernPairs.reduce(function(acc, _a) {
          var name1 = _a[0], name2 = _a[1], width = _a[2];
          if (!acc[name1])
            acc[name1] = {};
          acc[name1][name2] = width;
          return acc;
        }, {});
        fontCache[fontName] = font;
        return font;
      };
      return Font3;
    }()
  );

  // node_modules/@pdf-lib/standard-fonts/es/all-encodings.compressed.json
  var all_encodings_compressed_default = "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";

  // node_modules/@pdf-lib/standard-fonts/es/Encoding.js
  var decompressedEncodings = decompressJson(all_encodings_compressed_default);
  var allUnicodeMappings = JSON.parse(decompressedEncodings);
  var Encoding = (
    /** @class */
    function() {
      function Encoding2(name, unicodeMappings) {
        var _this = this;
        this.canEncodeUnicodeCodePoint = function(codePoint) {
          return codePoint in _this.unicodeMappings;
        };
        this.encodeUnicodeCodePoint = function(codePoint) {
          var mapped = _this.unicodeMappings[codePoint];
          if (!mapped) {
            var str = String.fromCharCode(codePoint);
            var hexCode = "0x" + padStart2(codePoint.toString(16), 4, "0");
            var msg = _this.name + ' cannot encode "' + str + '" (' + hexCode + ")";
            throw new Error(msg);
          }
          return { code: mapped[0], name: mapped[1] };
        };
        this.name = name;
        this.supportedCodePoints = Object.keys(unicodeMappings).map(Number).sort(function(a, b) {
          return a - b;
        });
        this.unicodeMappings = unicodeMappings;
      }
      return Encoding2;
    }()
  );
  var Encodings = {
    Symbol: new Encoding("Symbol", allUnicodeMappings.symbol),
    ZapfDingbats: new Encoding("ZapfDingbats", allUnicodeMappings.zapfdingbats),
    WinAnsi: new Encoding("WinAnsi", allUnicodeMappings.win1252)
  };

  // node_modules/@pdfme/pdf-lib/es/utils/objects.js
  var values = function(obj) {
    return Object.keys(obj).map(function(k) {
      return obj[k];
    });
  };
  var StandardFontValues = values(FontNames);
  var isStandardFont = function(input) {
    return StandardFontValues.includes(input);
  };
  var rectanglesAreEqual = function(a, b) {
    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
  };

  // node_modules/@pdfme/pdf-lib/es/utils/validators.js
  var backtick = function(val) {
    return "`" + val + "`";
  };
  var singleQuote = function(val) {
    return "'" + val + "'";
  };
  var formatValue = function(value) {
    var type = typeof value;
    if (type === "string")
      return singleQuote(value);
    else if (type === "undefined")
      return backtick(value);
    else
      return value;
  };
  var createValueErrorMsg = function(value, valueName, values2) {
    var allowedValues = new Array(values2.length);
    for (var idx = 0, len = values2.length; idx < len; idx++) {
      var v = values2[idx];
      allowedValues[idx] = formatValue(v);
    }
    var joinedValues = allowedValues.join(" or ");
    return backtick(valueName) + " must be one of " + joinedValues + ", but was actually " + formatValue(value);
  };
  var assertIsOneOf = function(value, valueName, allowedValues) {
    if (!Array.isArray(allowedValues)) {
      allowedValues = values(allowedValues);
    }
    for (var idx = 0, len = allowedValues.length; idx < len; idx++) {
      if (value === allowedValues[idx])
        return;
    }
    throw new TypeError(createValueErrorMsg(value, valueName, allowedValues));
  };
  var assertIsOneOfOrUndefined = function(value, valueName, allowedValues) {
    if (!Array.isArray(allowedValues)) {
      allowedValues = values(allowedValues);
    }
    assertIsOneOf(value, valueName, allowedValues.concat(void 0));
  };
  var assertIsSubset = function(values2, valueName, allowedValues) {
    if (!Array.isArray(allowedValues)) {
      allowedValues = values(allowedValues);
    }
    for (var idx = 0, len = values2.length; idx < len; idx++) {
      assertIsOneOf(values2[idx], valueName, allowedValues);
    }
  };
  var getType = function(val) {
    if (val === null)
      return "null";
    if (val === void 0)
      return "undefined";
    if (typeof val === "string")
      return "string";
    if (isNaN(val))
      return "NaN";
    if (typeof val === "number")
      return "number";
    if (typeof val === "boolean")
      return "boolean";
    if (typeof val === "symbol")
      return "symbol";
    if (typeof val === "bigint")
      return "bigint";
    if (val.constructor && val.constructor.name)
      return val.constructor.name;
    if (val.name)
      return val.name;
    if (val.constructor)
      return String(val.constructor);
    return String(val);
  };
  var isType = function(value, type) {
    if (type === "null")
      return value === null;
    if (type === "undefined")
      return value === void 0;
    if (type === "string")
      return typeof value === "string";
    if (type === "number")
      return typeof value === "number" && !isNaN(value);
    if (type === "boolean")
      return typeof value === "boolean";
    if (type === "symbol")
      return typeof value === "symbol";
    if (type === "bigint")
      return typeof value === "bigint";
    if (type === Date)
      return value instanceof Date;
    if (type === Array)
      return value instanceof Array;
    if (type === Uint8Array)
      return value instanceof Uint8Array;
    if (type === ArrayBuffer)
      return value instanceof ArrayBuffer;
    if (type === Function)
      return value instanceof Function;
    return value instanceof type[0];
  };
  var createTypeErrorMsg = function(value, valueName, types) {
    var allowedTypes = new Array(types.length);
    for (var idx = 0, len = types.length; idx < len; idx++) {
      var type = types[idx];
      if (type === "null")
        allowedTypes[idx] = backtick("null");
      if (type === "undefined")
        allowedTypes[idx] = backtick("undefined");
      if (type === "string")
        allowedTypes[idx] = backtick("string");
      else if (type === "number")
        allowedTypes[idx] = backtick("number");
      else if (type === "boolean")
        allowedTypes[idx] = backtick("boolean");
      else if (type === "symbol")
        allowedTypes[idx] = backtick("symbol");
      else if (type === "bigint")
        allowedTypes[idx] = backtick("bigint");
      else if (type === Array)
        allowedTypes[idx] = backtick("Array");
      else if (type === Uint8Array)
        allowedTypes[idx] = backtick("Uint8Array");
      else if (type === ArrayBuffer)
        allowedTypes[idx] = backtick("ArrayBuffer");
      else
        allowedTypes[idx] = backtick(type[1]);
    }
    var joinedTypes = allowedTypes.join(" or ");
    return backtick(valueName) + " must be of type " + joinedTypes + ", but was actually of type " + backtick(getType(value));
  };
  var assertIs = function(value, valueName, types) {
    for (var idx = 0, len = types.length; idx < len; idx++) {
      if (isType(value, types[idx]))
        return;
    }
    throw new TypeError(createTypeErrorMsg(value, valueName, types));
  };
  var assertOrUndefined = function(value, valueName, types) {
    assertIs(value, valueName, types.concat("undefined"));
  };
  var assertEachIs = function(values2, valueName, types) {
    for (var idx = 0, len = values2.length; idx < len; idx++) {
      assertIs(values2[idx], valueName, types);
    }
  };
  var assertRange = function(value, valueName, min, max) {
    assertIs(value, valueName, ["number"]);
    assertIs(min, "min", ["number"]);
    assertIs(max, "max", ["number"]);
    max = Math.max(min, max);
    if (value < min || value > max) {
      throw new Error(backtick(valueName) + " must be at least " + min + " and at most " + max + ", but was actually " + value);
    }
  };
  var assertRangeOrUndefined = function(value, valueName, min, max) {
    assertIs(value, valueName, ["number", "undefined"]);
    if (typeof value === "number")
      assertRange(value, valueName, min, max);
  };
  var assertMultiple = function(value, valueName, multiplier) {
    assertIs(value, valueName, ["number"]);
    if (value % multiplier !== 0) {
      throw new Error(backtick(valueName) + " must be a multiple of " + multiplier + ", but was actually " + value);
    }
  };
  var assertInteger = function(value, valueName) {
    if (!Number.isInteger(value)) {
      throw new Error(backtick(valueName) + " must be an integer, but was actually " + value);
    }
  };
  var assertPositive = function(value, valueName) {
    if (![1, 0].includes(Math.sign(value))) {
      throw new Error(backtick(valueName) + " must be a positive number or 0, but was actually " + value);
    }
  };

  // node_modules/@pdfme/pdf-lib/es/utils/pdfDocEncoding.js
  var pdfDocEncodingToUnicode = new Uint16Array(256);
  for (idx = 0; idx < 256; idx++) {
    pdfDocEncodingToUnicode[idx] = idx;
  }
  pdfDocEncodingToUnicode[22] = toCharCode("");
  pdfDocEncodingToUnicode[24] = toCharCode("\u02D8");
  pdfDocEncodingToUnicode[25] = toCharCode("\u02C7");
  pdfDocEncodingToUnicode[26] = toCharCode("\u02C6");
  pdfDocEncodingToUnicode[27] = toCharCode("\u02D9");
  pdfDocEncodingToUnicode[28] = toCharCode("\u02DD");
  pdfDocEncodingToUnicode[29] = toCharCode("\u02DB");
  pdfDocEncodingToUnicode[30] = toCharCode("\u02DA");
  pdfDocEncodingToUnicode[31] = toCharCode("\u02DC");
  pdfDocEncodingToUnicode[127] = toCharCode("\uFFFD");
  pdfDocEncodingToUnicode[128] = toCharCode("\u2022");
  pdfDocEncodingToUnicode[129] = toCharCode("\u2020");
  pdfDocEncodingToUnicode[130] = toCharCode("\u2021");
  pdfDocEncodingToUnicode[131] = toCharCode("\u2026");
  pdfDocEncodingToUnicode[132] = toCharCode("\u2014");
  pdfDocEncodingToUnicode[133] = toCharCode("\u2013");
  pdfDocEncodingToUnicode[134] = toCharCode("\u0192");
  pdfDocEncodingToUnicode[135] = toCharCode("\u2044");
  pdfDocEncodingToUnicode[136] = toCharCode("\u2039");
  pdfDocEncodingToUnicode[137] = toCharCode("\u203A");
  pdfDocEncodingToUnicode[138] = toCharCode("\u2212");
  pdfDocEncodingToUnicode[139] = toCharCode("\u2030");
  pdfDocEncodingToUnicode[140] = toCharCode("\u201E");
  pdfDocEncodingToUnicode[141] = toCharCode("\u201C");
  pdfDocEncodingToUnicode[142] = toCharCode("\u201D");
  pdfDocEncodingToUnicode[143] = toCharCode("\u2018");
  pdfDocEncodingToUnicode[144] = toCharCode("\u2019");
  pdfDocEncodingToUnicode[145] = toCharCode("\u201A");
  pdfDocEncodingToUnicode[146] = toCharCode("\u2122");
  pdfDocEncodingToUnicode[147] = toCharCode("\uFB01");
  pdfDocEncodingToUnicode[148] = toCharCode("\uFB02");
  pdfDocEncodingToUnicode[149] = toCharCode("\u0141");
  pdfDocEncodingToUnicode[150] = toCharCode("\u0152");
  pdfDocEncodingToUnicode[151] = toCharCode("\u0160");
  pdfDocEncodingToUnicode[152] = toCharCode("\u0178");
  pdfDocEncodingToUnicode[153] = toCharCode("\u017D");
  pdfDocEncodingToUnicode[154] = toCharCode("\u0131");
  pdfDocEncodingToUnicode[155] = toCharCode("\u0142");
  pdfDocEncodingToUnicode[156] = toCharCode("\u0153");
  pdfDocEncodingToUnicode[157] = toCharCode("\u0161");
  pdfDocEncodingToUnicode[158] = toCharCode("\u017E");
  pdfDocEncodingToUnicode[159] = toCharCode("\uFFFD");
  pdfDocEncodingToUnicode[160] = toCharCode("\u20AC");
  pdfDocEncodingToUnicode[173] = toCharCode("\uFFFD");
  var pdfDocEncodingDecode = function(bytes) {
    var codePoints = new Array(bytes.length);
    for (var idx = 0, len = bytes.length; idx < len; idx++) {
      codePoints[idx] = pdfDocEncodingToUnicode[bytes[idx]];
    }
    return String.fromCodePoint.apply(String, codePoints);
  };
  var idx;

  // node_modules/@pdfme/pdf-lib/es/utils/Cache.js
  var Cache = (
    /** @class */
    function() {
      function Cache2(populate) {
        this.populate = populate;
        this.value = void 0;
      }
      Cache2.prototype.getValue = function() {
        return this.value;
      };
      Cache2.prototype.access = function() {
        if (!this.value)
          this.value = this.populate();
        return this.value;
      };
      Cache2.prototype.invalidate = function() {
        this.value = void 0;
      };
      Cache2.populatedBy = function(populate) {
        return new Cache2(populate);
      };
      return Cache2;
    }()
  );
  var Cache_default = Cache;

  // node_modules/@pdfme/pdf-lib/es/core/errors.js
  var MethodNotImplementedError = (
    /** @class */
    function(_super) {
      __extends(MethodNotImplementedError2, _super);
      function MethodNotImplementedError2(className2, methodName) {
        var _this = this;
        var msg = "Method " + className2 + "." + methodName + "() not implemented";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return MethodNotImplementedError2;
    }(Error)
  );
  var PrivateConstructorError = (
    /** @class */
    function(_super) {
      __extends(PrivateConstructorError2, _super);
      function PrivateConstructorError2(className2) {
        var _this = this;
        var msg = "Cannot construct " + className2 + " - it has a private constructor";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return PrivateConstructorError2;
    }(Error)
  );
  var UnexpectedObjectTypeError = (
    /** @class */
    function(_super) {
      __extends(UnexpectedObjectTypeError2, _super);
      function UnexpectedObjectTypeError2(expected, actual) {
        var _this = this;
        var name = function(t) {
          var _a, _b;
          return (_a = t === null || t === void 0 ? void 0 : t.name) !== null && _a !== void 0 ? _a : (_b = t === null || t === void 0 ? void 0 : t.constructor) === null || _b === void 0 ? void 0 : _b.name;
        };
        var expectedTypes = Array.isArray(expected) ? expected.map(name) : [name(expected)];
        var msg = "Expected instance of " + expectedTypes.join(" or ") + ", " + ("but got instance of " + (actual ? name(actual) : actual));
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return UnexpectedObjectTypeError2;
    }(Error)
  );
  var UnsupportedEncodingError = (
    /** @class */
    function(_super) {
      __extends(UnsupportedEncodingError2, _super);
      function UnsupportedEncodingError2(encoding) {
        var _this = this;
        var msg = encoding + " stream encoding not supported";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return UnsupportedEncodingError2;
    }(Error)
  );
  var ReparseError = (
    /** @class */
    function(_super) {
      __extends(ReparseError2, _super);
      function ReparseError2(className2, methodName) {
        var _this = this;
        var msg = "Cannot call " + className2 + "." + methodName + "() more than once";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return ReparseError2;
    }(Error)
  );
  var MissingCatalogError = (
    /** @class */
    function(_super) {
      __extends(MissingCatalogError2, _super);
      function MissingCatalogError2(ref) {
        var _this = this;
        var msg = "Missing catalog (ref=" + ref + ")";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return MissingCatalogError2;
    }(Error)
  );
  var MissingPageContentsEmbeddingError = (
    /** @class */
    function(_super) {
      __extends(MissingPageContentsEmbeddingError2, _super);
      function MissingPageContentsEmbeddingError2() {
        var _this = this;
        var msg = "Can't embed page with missing Contents";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return MissingPageContentsEmbeddingError2;
    }(Error)
  );
  var UnrecognizedStreamTypeError = (
    /** @class */
    function(_super) {
      __extends(UnrecognizedStreamTypeError2, _super);
      function UnrecognizedStreamTypeError2(stream2) {
        var _a, _b, _c;
        var _this = this;
        var streamType = (_c = (_b = (_a = stream2 === null || stream2 === void 0 ? void 0 : stream2.contructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : stream2 === null || stream2 === void 0 ? void 0 : stream2.name) !== null && _c !== void 0 ? _c : stream2;
        var msg = "Unrecognized stream type: " + streamType;
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return UnrecognizedStreamTypeError2;
    }(Error)
  );
  var PageEmbeddingMismatchedContextError = (
    /** @class */
    function(_super) {
      __extends(PageEmbeddingMismatchedContextError2, _super);
      function PageEmbeddingMismatchedContextError2() {
        var _this = this;
        var msg = "Found mismatched contexts while embedding pages. All pages in the array passed to `PDFDocument.embedPages()` must be from the same document.";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return PageEmbeddingMismatchedContextError2;
    }(Error)
  );
  var PDFArrayIsNotRectangleError = (
    /** @class */
    function(_super) {
      __extends(PDFArrayIsNotRectangleError2, _super);
      function PDFArrayIsNotRectangleError2(size) {
        var _this = this;
        var msg = "Attempted to convert PDFArray with " + size + " elements to rectangle, but must have exactly 4 elements.";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return PDFArrayIsNotRectangleError2;
    }(Error)
  );
  var InvalidPDFDateStringError = (
    /** @class */
    function(_super) {
      __extends(InvalidPDFDateStringError2, _super);
      function InvalidPDFDateStringError2(value) {
        var _this = this;
        var msg = 'Attempted to convert "' + value + '" to a date, but it does not match the PDF date string format.';
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return InvalidPDFDateStringError2;
    }(Error)
  );
  var InvalidTargetIndexError = (
    /** @class */
    function(_super) {
      __extends(InvalidTargetIndexError2, _super);
      function InvalidTargetIndexError2(targetIndex, Count) {
        var _this = this;
        var msg = "Invalid targetIndex specified: targetIndex=" + targetIndex + " must be less than Count=" + Count;
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return InvalidTargetIndexError2;
    }(Error)
  );
  var CorruptPageTreeError = (
    /** @class */
    function(_super) {
      __extends(CorruptPageTreeError2, _super);
      function CorruptPageTreeError2(targetIndex, operation) {
        var _this = this;
        var msg = "Failed to " + operation + " at targetIndex=" + targetIndex + " due to corrupt page tree: It is likely that one or more 'Count' entries are invalid";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return CorruptPageTreeError2;
    }(Error)
  );
  var IndexOutOfBoundsError = (
    /** @class */
    function(_super) {
      __extends(IndexOutOfBoundsError2, _super);
      function IndexOutOfBoundsError2(index, min, max) {
        var _this = this;
        var msg = "index should be at least " + min + " and at most " + max + ", but was actually " + index;
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return IndexOutOfBoundsError2;
    }(Error)
  );
  var InvalidAcroFieldValueError = (
    /** @class */
    function(_super) {
      __extends(InvalidAcroFieldValueError2, _super);
      function InvalidAcroFieldValueError2() {
        var _this = this;
        var msg = "Attempted to set invalid field value";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return InvalidAcroFieldValueError2;
    }(Error)
  );
  var MultiSelectValueError = (
    /** @class */
    function(_super) {
      __extends(MultiSelectValueError2, _super);
      function MultiSelectValueError2() {
        var _this = this;
        var msg = "Attempted to select multiple values for single-select field";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return MultiSelectValueError2;
    }(Error)
  );
  var MissingDAEntryError = (
    /** @class */
    function(_super) {
      __extends(MissingDAEntryError2, _super);
      function MissingDAEntryError2(fieldName) {
        var _this = this;
        var msg = "No /DA (default appearance) entry found for field: " + fieldName;
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return MissingDAEntryError2;
    }(Error)
  );
  var MissingTfOperatorError = (
    /** @class */
    function(_super) {
      __extends(MissingTfOperatorError2, _super);
      function MissingTfOperatorError2(fieldName) {
        var _this = this;
        var msg = "No Tf operator found for DA of field: " + fieldName;
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return MissingTfOperatorError2;
    }(Error)
  );
  var NumberParsingError = (
    /** @class */
    function(_super) {
      __extends(NumberParsingError2, _super);
      function NumberParsingError2(pos, value) {
        var _this = this;
        var msg = "Failed to parse number " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + '): "' + value + '"');
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return NumberParsingError2;
    }(Error)
  );
  var PDFParsingError = (
    /** @class */
    function(_super) {
      __extends(PDFParsingError2, _super);
      function PDFParsingError2(pos, details) {
        var _this = this;
        var msg = "Failed to parse PDF document " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + "): " + details);
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return PDFParsingError2;
    }(Error)
  );
  var NextByteAssertionError = (
    /** @class */
    function(_super) {
      __extends(NextByteAssertionError2, _super);
      function NextByteAssertionError2(pos, expectedByte, actualByte) {
        var _this = this;
        var msg = "Expected next byte to be " + expectedByte + " but it was actually " + actualByte;
        _this = _super.call(this, pos, msg) || this;
        return _this;
      }
      return NextByteAssertionError2;
    }(PDFParsingError)
  );
  var PDFObjectParsingError = (
    /** @class */
    function(_super) {
      __extends(PDFObjectParsingError2, _super);
      function PDFObjectParsingError2(pos, byte) {
        var _this = this;
        var msg = "Failed to parse PDF object starting with the following byte: " + byte;
        _this = _super.call(this, pos, msg) || this;
        return _this;
      }
      return PDFObjectParsingError2;
    }(PDFParsingError)
  );
  var PDFInvalidObjectParsingError = (
    /** @class */
    function(_super) {
      __extends(PDFInvalidObjectParsingError2, _super);
      function PDFInvalidObjectParsingError2(pos) {
        var _this = this;
        var msg = "Failed to parse invalid PDF object";
        _this = _super.call(this, pos, msg) || this;
        return _this;
      }
      return PDFInvalidObjectParsingError2;
    }(PDFParsingError)
  );
  var PDFStreamParsingError = (
    /** @class */
    function(_super) {
      __extends(PDFStreamParsingError2, _super);
      function PDFStreamParsingError2(pos) {
        var _this = this;
        var msg = "Failed to parse PDF stream";
        _this = _super.call(this, pos, msg) || this;
        return _this;
      }
      return PDFStreamParsingError2;
    }(PDFParsingError)
  );
  var UnbalancedParenthesisError = (
    /** @class */
    function(_super) {
      __extends(UnbalancedParenthesisError2, _super);
      function UnbalancedParenthesisError2(pos) {
        var _this = this;
        var msg = "Failed to parse PDF literal string due to unbalanced parenthesis";
        _this = _super.call(this, pos, msg) || this;
        return _this;
      }
      return UnbalancedParenthesisError2;
    }(PDFParsingError)
  );
  var StalledParserError = (
    /** @class */
    function(_super) {
      __extends(StalledParserError2, _super);
      function StalledParserError2(pos) {
        var _this = this;
        var msg = "Parser stalled";
        _this = _super.call(this, pos, msg) || this;
        return _this;
      }
      return StalledParserError2;
    }(PDFParsingError)
  );
  var MissingPDFHeaderError = (
    /** @class */
    function(_super) {
      __extends(MissingPDFHeaderError2, _super);
      function MissingPDFHeaderError2(pos) {
        var _this = this;
        var msg = "No PDF header found";
        _this = _super.call(this, pos, msg) || this;
        return _this;
      }
      return MissingPDFHeaderError2;
    }(PDFParsingError)
  );
  var MissingKeywordError = (
    /** @class */
    function(_super) {
      __extends(MissingKeywordError2, _super);
      function MissingKeywordError2(pos, keyword) {
        var _this = this;
        var msg = "Did not find expected keyword '" + arrayAsString(keyword) + "'";
        _this = _super.call(this, pos, msg) || this;
        return _this;
      }
      return MissingKeywordError2;
    }(PDFParsingError)
  );

  // node_modules/@pdfme/pdf-lib/es/core/syntax/CharCodes.js
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["Null"] = 0] = "Null";
    CharCodes2[CharCodes2["Backspace"] = 8] = "Backspace";
    CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
    CharCodes2[CharCodes2["Newline"] = 10] = "Newline";
    CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
    CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes2[CharCodes2["Space"] = 32] = "Space";
    CharCodes2[CharCodes2["ExclamationPoint"] = 33] = "ExclamationPoint";
    CharCodes2[CharCodes2["Hash"] = 35] = "Hash";
    CharCodes2[CharCodes2["Percent"] = 37] = "Percent";
    CharCodes2[CharCodes2["LeftParen"] = 40] = "LeftParen";
    CharCodes2[CharCodes2["RightParen"] = 41] = "RightParen";
    CharCodes2[CharCodes2["Plus"] = 43] = "Plus";
    CharCodes2[CharCodes2["Minus"] = 45] = "Minus";
    CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
    CharCodes2[CharCodes2["Period"] = 46] = "Period";
    CharCodes2[CharCodes2["ForwardSlash"] = 47] = "ForwardSlash";
    CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
    CharCodes2[CharCodes2["One"] = 49] = "One";
    CharCodes2[CharCodes2["Two"] = 50] = "Two";
    CharCodes2[CharCodes2["Three"] = 51] = "Three";
    CharCodes2[CharCodes2["Four"] = 52] = "Four";
    CharCodes2[CharCodes2["Five"] = 53] = "Five";
    CharCodes2[CharCodes2["Six"] = 54] = "Six";
    CharCodes2[CharCodes2["Seven"] = 55] = "Seven";
    CharCodes2[CharCodes2["Eight"] = 56] = "Eight";
    CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
    CharCodes2[CharCodes2["LessThan"] = 60] = "LessThan";
    CharCodes2[CharCodes2["GreaterThan"] = 62] = "GreaterThan";
    CharCodes2[CharCodes2["A"] = 65] = "A";
    CharCodes2[CharCodes2["D"] = 68] = "D";
    CharCodes2[CharCodes2["E"] = 69] = "E";
    CharCodes2[CharCodes2["F"] = 70] = "F";
    CharCodes2[CharCodes2["O"] = 79] = "O";
    CharCodes2[CharCodes2["P"] = 80] = "P";
    CharCodes2[CharCodes2["R"] = 82] = "R";
    CharCodes2[CharCodes2["LeftSquareBracket"] = 91] = "LeftSquareBracket";
    CharCodes2[CharCodes2["BackSlash"] = 92] = "BackSlash";
    CharCodes2[CharCodes2["RightSquareBracket"] = 93] = "RightSquareBracket";
    CharCodes2[CharCodes2["a"] = 97] = "a";
    CharCodes2[CharCodes2["b"] = 98] = "b";
    CharCodes2[CharCodes2["d"] = 100] = "d";
    CharCodes2[CharCodes2["e"] = 101] = "e";
    CharCodes2[CharCodes2["f"] = 102] = "f";
    CharCodes2[CharCodes2["i"] = 105] = "i";
    CharCodes2[CharCodes2["j"] = 106] = "j";
    CharCodes2[CharCodes2["l"] = 108] = "l";
    CharCodes2[CharCodes2["m"] = 109] = "m";
    CharCodes2[CharCodes2["n"] = 110] = "n";
    CharCodes2[CharCodes2["o"] = 111] = "o";
    CharCodes2[CharCodes2["r"] = 114] = "r";
    CharCodes2[CharCodes2["s"] = 115] = "s";
    CharCodes2[CharCodes2["t"] = 116] = "t";
    CharCodes2[CharCodes2["u"] = 117] = "u";
    CharCodes2[CharCodes2["x"] = 120] = "x";
    CharCodes2[CharCodes2["LeftCurly"] = 123] = "LeftCurly";
    CharCodes2[CharCodes2["RightCurly"] = 125] = "RightCurly";
    CharCodes2[CharCodes2["Tilde"] = 126] = "Tilde";
  })(CharCodes || (CharCodes = {}));
  var CharCodes_default = CharCodes;

  // node_modules/@pdfme/pdf-lib/es/core/document/PDFHeader.js
  var PDFHeader = (
    /** @class */
    function() {
      function PDFHeader2(major, minor) {
        this.major = String(major);
        this.minor = String(minor);
      }
      PDFHeader2.prototype.toString = function() {
        var bc = charFromCode(129);
        return "%PDF-" + this.major + "." + this.minor + "\n%" + bc + bc + bc + bc;
      };
      PDFHeader2.prototype.sizeInBytes = function() {
        return 12 + this.major.length + this.minor.length;
      };
      PDFHeader2.prototype.copyBytesInto = function(buffer, offset) {
        var initialOffset = offset;
        buffer[offset++] = CharCodes_default.Percent;
        buffer[offset++] = CharCodes_default.P;
        buffer[offset++] = CharCodes_default.D;
        buffer[offset++] = CharCodes_default.F;
        buffer[offset++] = CharCodes_default.Dash;
        offset += copyStringIntoBuffer(this.major, buffer, offset);
        buffer[offset++] = CharCodes_default.Period;
        offset += copyStringIntoBuffer(this.minor, buffer, offset);
        buffer[offset++] = CharCodes_default.Newline;
        buffer[offset++] = CharCodes_default.Percent;
        buffer[offset++] = 129;
        buffer[offset++] = 129;
        buffer[offset++] = 129;
        buffer[offset++] = 129;
        return offset - initialOffset;
      };
      PDFHeader2.forVersion = function(major, minor) {
        return new PDFHeader2(major, minor);
      };
      return PDFHeader2;
    }()
  );
  var PDFHeader_default = PDFHeader;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFObject.js
  var PDFObject = (
    /** @class */
    function() {
      function PDFObject2() {
      }
      PDFObject2.prototype.clone = function(_context) {
        throw new MethodNotImplementedError(this.constructor.name, "clone");
      };
      PDFObject2.prototype.toString = function() {
        throw new MethodNotImplementedError(this.constructor.name, "toString");
      };
      PDFObject2.prototype.sizeInBytes = function() {
        throw new MethodNotImplementedError(this.constructor.name, "sizeInBytes");
      };
      PDFObject2.prototype.copyBytesInto = function(_buffer, _offset) {
        throw new MethodNotImplementedError(this.constructor.name, "copyBytesInto");
      };
      return PDFObject2;
    }()
  );
  var PDFObject_default = PDFObject;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFNumber.js
  var PDFNumber = (
    /** @class */
    function(_super) {
      __extends(PDFNumber2, _super);
      function PDFNumber2(value) {
        var _this = _super.call(this) || this;
        _this.numberValue = value;
        _this.stringValue = numberToString(value);
        return _this;
      }
      PDFNumber2.prototype.asNumber = function() {
        return this.numberValue;
      };
      PDFNumber2.prototype.value = function() {
        return this.numberValue;
      };
      PDFNumber2.prototype.clone = function() {
        return PDFNumber2.of(this.numberValue);
      };
      PDFNumber2.prototype.toString = function() {
        return this.stringValue;
      };
      PDFNumber2.prototype.sizeInBytes = function() {
        return this.stringValue.length;
      };
      PDFNumber2.prototype.copyBytesInto = function(buffer, offset) {
        offset += copyStringIntoBuffer(this.stringValue, buffer, offset);
        return this.stringValue.length;
      };
      PDFNumber2.of = function(value) {
        return new PDFNumber2(value);
      };
      return PDFNumber2;
    }(PDFObject_default)
  );
  var PDFNumber_default = PDFNumber;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFArray.js
  var PDFArray = (
    /** @class */
    function(_super) {
      __extends(PDFArray2, _super);
      function PDFArray2(context) {
        var _this = _super.call(this) || this;
        _this.array = [];
        _this.context = context;
        return _this;
      }
      PDFArray2.prototype.size = function() {
        return this.array.length;
      };
      PDFArray2.prototype.push = function(object) {
        this.array.push(object);
      };
      PDFArray2.prototype.insert = function(index, object) {
        this.array.splice(index, 0, object);
      };
      PDFArray2.prototype.indexOf = function(object) {
        var index = this.array.indexOf(object);
        return index === -1 ? void 0 : index;
      };
      PDFArray2.prototype.remove = function(index) {
        this.array.splice(index, 1);
      };
      PDFArray2.prototype.set = function(idx, object) {
        this.array[idx] = object;
      };
      PDFArray2.prototype.get = function(index) {
        return this.array[index];
      };
      PDFArray2.prototype.lookupMaybe = function(index) {
        var _a;
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          types[_i - 1] = arguments[_i];
        }
        return (_a = this.context).lookupMaybe.apply(_a, __spreadArrays([this.get(index)], types));
      };
      PDFArray2.prototype.lookup = function(index) {
        var _a;
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          types[_i - 1] = arguments[_i];
        }
        return (_a = this.context).lookup.apply(_a, __spreadArrays([this.get(index)], types));
      };
      PDFArray2.prototype.asRectangle = function() {
        if (this.size() !== 4)
          throw new PDFArrayIsNotRectangleError(this.size());
        var lowerLeftX = this.lookup(0, PDFNumber_default).asNumber();
        var lowerLeftY = this.lookup(1, PDFNumber_default).asNumber();
        var upperRightX = this.lookup(2, PDFNumber_default).asNumber();
        var upperRightY = this.lookup(3, PDFNumber_default).asNumber();
        var x = lowerLeftX;
        var y = lowerLeftY;
        var width = upperRightX - lowerLeftX;
        var height = upperRightY - lowerLeftY;
        return { x, y, width, height };
      };
      PDFArray2.prototype.asArray = function() {
        return this.array.slice();
      };
      PDFArray2.prototype.clone = function(context) {
        var clone = PDFArray2.withContext(context || this.context);
        for (var idx = 0, len = this.size(); idx < len; idx++) {
          clone.push(this.array[idx]);
        }
        return clone;
      };
      PDFArray2.prototype.toString = function() {
        var arrayString = "[ ";
        for (var idx = 0, len = this.size(); idx < len; idx++) {
          arrayString += this.get(idx).toString();
          arrayString += " ";
        }
        arrayString += "]";
        return arrayString;
      };
      PDFArray2.prototype.sizeInBytes = function() {
        var size = 3;
        for (var idx = 0, len = this.size(); idx < len; idx++) {
          size += this.get(idx).sizeInBytes() + 1;
        }
        return size;
      };
      PDFArray2.prototype.copyBytesInto = function(buffer, offset) {
        var initialOffset = offset;
        buffer[offset++] = CharCodes_default.LeftSquareBracket;
        buffer[offset++] = CharCodes_default.Space;
        for (var idx = 0, len = this.size(); idx < len; idx++) {
          offset += this.get(idx).copyBytesInto(buffer, offset);
          buffer[offset++] = CharCodes_default.Space;
        }
        buffer[offset++] = CharCodes_default.RightSquareBracket;
        return offset - initialOffset;
      };
      PDFArray2.prototype.scalePDFNumbers = function(x, y) {
        for (var idx = 0, len = this.size(); idx < len; idx++) {
          var el = this.lookup(idx);
          if (el instanceof PDFNumber_default) {
            var factor = idx % 2 === 0 ? x : y;
            this.set(idx, PDFNumber_default.of(el.asNumber() * factor));
          }
        }
      };
      PDFArray2.withContext = function(context) {
        return new PDFArray2(context);
      };
      return PDFArray2;
    }(PDFObject_default)
  );
  var PDFArray_default = PDFArray;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFBool.js
  var ENFORCER = {};
  var PDFBool = (
    /** @class */
    function(_super) {
      __extends(PDFBool2, _super);
      function PDFBool2(enforcer, value) {
        var _this = this;
        if (enforcer !== ENFORCER)
          throw new PrivateConstructorError("PDFBool");
        _this = _super.call(this) || this;
        _this.value = value;
        return _this;
      }
      PDFBool2.prototype.asBoolean = function() {
        return this.value;
      };
      PDFBool2.prototype.clone = function() {
        return this;
      };
      PDFBool2.prototype.toString = function() {
        return String(this.value);
      };
      PDFBool2.prototype.sizeInBytes = function() {
        return this.value ? 4 : 5;
      };
      PDFBool2.prototype.copyBytesInto = function(buffer, offset) {
        if (this.value) {
          buffer[offset++] = CharCodes_default.t;
          buffer[offset++] = CharCodes_default.r;
          buffer[offset++] = CharCodes_default.u;
          buffer[offset++] = CharCodes_default.e;
          return 4;
        } else {
          buffer[offset++] = CharCodes_default.f;
          buffer[offset++] = CharCodes_default.a;
          buffer[offset++] = CharCodes_default.l;
          buffer[offset++] = CharCodes_default.s;
          buffer[offset++] = CharCodes_default.e;
          return 5;
        }
      };
      PDFBool2.True = new PDFBool2(ENFORCER, true);
      PDFBool2.False = new PDFBool2(ENFORCER, false);
      return PDFBool2;
    }(PDFObject_default)
  );
  var PDFBool_default = PDFBool;

  // node_modules/@pdfme/pdf-lib/es/core/syntax/Delimiters.js
  var IsDelimiter = new Uint8Array(256);
  IsDelimiter[CharCodes_default.LeftParen] = 1;
  IsDelimiter[CharCodes_default.RightParen] = 1;
  IsDelimiter[CharCodes_default.LessThan] = 1;
  IsDelimiter[CharCodes_default.GreaterThan] = 1;
  IsDelimiter[CharCodes_default.LeftSquareBracket] = 1;
  IsDelimiter[CharCodes_default.RightSquareBracket] = 1;
  IsDelimiter[CharCodes_default.LeftCurly] = 1;
  IsDelimiter[CharCodes_default.RightCurly] = 1;
  IsDelimiter[CharCodes_default.ForwardSlash] = 1;
  IsDelimiter[CharCodes_default.Percent] = 1;

  // node_modules/@pdfme/pdf-lib/es/core/syntax/Whitespace.js
  var IsWhitespace = new Uint8Array(256);
  IsWhitespace[CharCodes_default.Null] = 1;
  IsWhitespace[CharCodes_default.Tab] = 1;
  IsWhitespace[CharCodes_default.Newline] = 1;
  IsWhitespace[CharCodes_default.FormFeed] = 1;
  IsWhitespace[CharCodes_default.CarriageReturn] = 1;
  IsWhitespace[CharCodes_default.Space] = 1;

  // node_modules/@pdfme/pdf-lib/es/core/syntax/Irregular.js
  var IsIrregular = new Uint8Array(256);
  for (idx = 0, len = 256; idx < len; idx++) {
    IsIrregular[idx] = IsWhitespace[idx] || IsDelimiter[idx] ? 1 : 0;
  }
  IsIrregular[CharCodes_default.Hash] = 1;
  var idx;
  var len;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFName.js
  var decodeName = function(name) {
    return name.replace(/#([\dABCDEF]{2})/g, function(_, hex) {
      return charFromHexCode(hex);
    });
  };
  var isRegularChar = function(charCode) {
    return charCode >= CharCodes_default.ExclamationPoint && charCode <= CharCodes_default.Tilde && !IsIrregular[charCode];
  };
  var ENFORCER2 = {};
  var pool = /* @__PURE__ */ new Map();
  var PDFName = (
    /** @class */
    function(_super) {
      __extends(PDFName2, _super);
      function PDFName2(enforcer, name) {
        var _this = this;
        if (enforcer !== ENFORCER2)
          throw new PrivateConstructorError("PDFName");
        _this = _super.call(this) || this;
        var encodedName = "/";
        for (var idx = 0, len = name.length; idx < len; idx++) {
          var character = name[idx];
          var code = toCharCode(character);
          encodedName += isRegularChar(code) ? character : "#" + toHexString(code);
        }
        _this.encodedName = encodedName;
        return _this;
      }
      PDFName2.prototype.asBytes = function() {
        var bytes = [];
        var hex = "";
        var escaped = false;
        var pushByte = function(byte2) {
          if (byte2 !== void 0)
            bytes.push(byte2);
          escaped = false;
        };
        for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {
          var char = this.encodedName[idx];
          var byte = toCharCode(char);
          var nextChar = this.encodedName[idx + 1];
          if (!escaped) {
            if (byte === CharCodes_default.Hash)
              escaped = true;
            else
              pushByte(byte);
          } else {
            if (byte >= CharCodes_default.Zero && byte <= CharCodes_default.Nine || byte >= CharCodes_default.a && byte <= CharCodes_default.f || byte >= CharCodes_default.A && byte <= CharCodes_default.F) {
              hex += char;
              if (hex.length === 2 || !(nextChar >= "0" && nextChar <= "9" || nextChar >= "a" && nextChar <= "f" || nextChar >= "A" && nextChar <= "F")) {
                pushByte(parseInt(hex, 16));
                hex = "";
              }
            } else {
              pushByte(byte);
            }
          }
        }
        return new Uint8Array(bytes);
      };
      PDFName2.prototype.decodeText = function() {
        var bytes = this.asBytes();
        return String.fromCharCode.apply(String, Array.from(bytes));
      };
      PDFName2.prototype.asString = function() {
        return this.encodedName;
      };
      PDFName2.prototype.value = function() {
        return this.encodedName;
      };
      PDFName2.prototype.clone = function() {
        return this;
      };
      PDFName2.prototype.toString = function() {
        return this.encodedName;
      };
      PDFName2.prototype.sizeInBytes = function() {
        return this.encodedName.length;
      };
      PDFName2.prototype.copyBytesInto = function(buffer, offset) {
        offset += copyStringIntoBuffer(this.encodedName, buffer, offset);
        return this.encodedName.length;
      };
      PDFName2.of = function(name) {
        var decodedValue = decodeName(name);
        var instance = pool.get(decodedValue);
        if (!instance) {
          instance = new PDFName2(ENFORCER2, decodedValue);
          pool.set(decodedValue, instance);
        }
        return instance;
      };
      PDFName2.Length = PDFName2.of("Length");
      PDFName2.FlateDecode = PDFName2.of("FlateDecode");
      PDFName2.Resources = PDFName2.of("Resources");
      PDFName2.Font = PDFName2.of("Font");
      PDFName2.XObject = PDFName2.of("XObject");
      PDFName2.ExtGState = PDFName2.of("ExtGState");
      PDFName2.Contents = PDFName2.of("Contents");
      PDFName2.Type = PDFName2.of("Type");
      PDFName2.Parent = PDFName2.of("Parent");
      PDFName2.MediaBox = PDFName2.of("MediaBox");
      PDFName2.Page = PDFName2.of("Page");
      PDFName2.Annots = PDFName2.of("Annots");
      PDFName2.TrimBox = PDFName2.of("TrimBox");
      PDFName2.ArtBox = PDFName2.of("ArtBox");
      PDFName2.BleedBox = PDFName2.of("BleedBox");
      PDFName2.CropBox = PDFName2.of("CropBox");
      PDFName2.Rotate = PDFName2.of("Rotate");
      PDFName2.Title = PDFName2.of("Title");
      PDFName2.Author = PDFName2.of("Author");
      PDFName2.Subject = PDFName2.of("Subject");
      PDFName2.Creator = PDFName2.of("Creator");
      PDFName2.Keywords = PDFName2.of("Keywords");
      PDFName2.Producer = PDFName2.of("Producer");
      PDFName2.CreationDate = PDFName2.of("CreationDate");
      PDFName2.ModDate = PDFName2.of("ModDate");
      return PDFName2;
    }(PDFObject_default)
  );
  var PDFName_default = PDFName;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFNull.js
  var PDFNull = (
    /** @class */
    function(_super) {
      __extends(PDFNull2, _super);
      function PDFNull2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFNull2.prototype.asNull = function() {
        return null;
      };
      PDFNull2.prototype.clone = function() {
        return this;
      };
      PDFNull2.prototype.toString = function() {
        return "null";
      };
      PDFNull2.prototype.sizeInBytes = function() {
        return 4;
      };
      PDFNull2.prototype.copyBytesInto = function(buffer, offset) {
        buffer[offset++] = CharCodes_default.n;
        buffer[offset++] = CharCodes_default.u;
        buffer[offset++] = CharCodes_default.l;
        buffer[offset++] = CharCodes_default.l;
        return 4;
      };
      return PDFNull2;
    }(PDFObject_default)
  );
  var PDFNull_default = new PDFNull();

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFDict.js
  var PDFDict = (
    /** @class */
    function(_super) {
      __extends(PDFDict2, _super);
      function PDFDict2(map, context) {
        var _this = _super.call(this) || this;
        _this.dict = map;
        _this.context = context;
        return _this;
      }
      PDFDict2.prototype.keys = function() {
        return Array.from(this.dict.keys());
      };
      PDFDict2.prototype.values = function() {
        return Array.from(this.dict.values());
      };
      PDFDict2.prototype.entries = function() {
        return Array.from(this.dict.entries());
      };
      PDFDict2.prototype.set = function(key, value) {
        this.dict.set(key, value);
      };
      PDFDict2.prototype.get = function(key, preservePDFNull) {
        if (preservePDFNull === void 0) {
          preservePDFNull = false;
        }
        var value = this.dict.get(key);
        if (value === PDFNull_default && !preservePDFNull)
          return void 0;
        return value;
      };
      PDFDict2.prototype.has = function(key) {
        var value = this.dict.get(key);
        return value !== void 0 && value !== PDFNull_default;
      };
      PDFDict2.prototype.lookupMaybe = function(key) {
        var _a;
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          types[_i - 1] = arguments[_i];
        }
        var preservePDFNull = types.includes(PDFNull_default);
        var value = (_a = this.context).lookupMaybe.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));
        if (value === PDFNull_default && !preservePDFNull)
          return void 0;
        return value;
      };
      PDFDict2.prototype.lookup = function(key) {
        var _a;
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          types[_i - 1] = arguments[_i];
        }
        var preservePDFNull = types.includes(PDFNull_default);
        var value = (_a = this.context).lookup.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));
        if (value === PDFNull_default && !preservePDFNull)
          return void 0;
        return value;
      };
      PDFDict2.prototype.delete = function(key) {
        return this.dict.delete(key);
      };
      PDFDict2.prototype.asMap = function() {
        return new Map(this.dict);
      };
      PDFDict2.prototype.uniqueKey = function(tag) {
        if (tag === void 0) {
          tag = "";
        }
        var existingKeys = this.keys();
        var key = PDFName_default.of(this.context.addRandomSuffix(tag, 10));
        while (existingKeys.includes(key)) {
          key = PDFName_default.of(this.context.addRandomSuffix(tag, 10));
        }
        return key;
      };
      PDFDict2.prototype.clone = function(context) {
        var clone = PDFDict2.withContext(context || this.context);
        var entries = this.entries();
        for (var idx = 0, len = entries.length; idx < len; idx++) {
          var _a = entries[idx], key = _a[0], value = _a[1];
          clone.set(key, value);
        }
        return clone;
      };
      PDFDict2.prototype.toString = function() {
        var dictString = "<<\n";
        var entries = this.entries();
        for (var idx = 0, len = entries.length; idx < len; idx++) {
          var _a = entries[idx], key = _a[0], value = _a[1];
          dictString += key.toString() + " " + value.toString() + "\n";
        }
        dictString += ">>";
        return dictString;
      };
      PDFDict2.prototype.sizeInBytes = function() {
        var size = 5;
        var entries = this.entries();
        for (var idx = 0, len = entries.length; idx < len; idx++) {
          var _a = entries[idx], key = _a[0], value = _a[1];
          size += key.sizeInBytes() + value.sizeInBytes() + 2;
        }
        return size;
      };
      PDFDict2.prototype.copyBytesInto = function(buffer, offset) {
        var initialOffset = offset;
        buffer[offset++] = CharCodes_default.LessThan;
        buffer[offset++] = CharCodes_default.LessThan;
        buffer[offset++] = CharCodes_default.Newline;
        var entries = this.entries();
        for (var idx = 0, len = entries.length; idx < len; idx++) {
          var _a = entries[idx], key = _a[0], value = _a[1];
          offset += key.copyBytesInto(buffer, offset);
          buffer[offset++] = CharCodes_default.Space;
          offset += value.copyBytesInto(buffer, offset);
          buffer[offset++] = CharCodes_default.Newline;
        }
        buffer[offset++] = CharCodes_default.GreaterThan;
        buffer[offset++] = CharCodes_default.GreaterThan;
        return offset - initialOffset;
      };
      PDFDict2.withContext = function(context) {
        return new PDFDict2(/* @__PURE__ */ new Map(), context);
      };
      PDFDict2.fromMapWithContext = function(map, context) {
        return new PDFDict2(map, context);
      };
      return PDFDict2;
    }(PDFObject_default)
  );
  var PDFDict_default = PDFDict;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFStream.js
  var PDFStream = (
    /** @class */
    function(_super) {
      __extends(PDFStream2, _super);
      function PDFStream2(dict) {
        var _this = _super.call(this) || this;
        _this.dict = dict;
        return _this;
      }
      PDFStream2.prototype.clone = function(_context) {
        throw new MethodNotImplementedError(this.constructor.name, "clone");
      };
      PDFStream2.prototype.getContentsString = function() {
        throw new MethodNotImplementedError(this.constructor.name, "getContentsString");
      };
      PDFStream2.prototype.getContents = function() {
        throw new MethodNotImplementedError(this.constructor.name, "getContents");
      };
      PDFStream2.prototype.getContentsSize = function() {
        throw new MethodNotImplementedError(this.constructor.name, "getContentsSize");
      };
      PDFStream2.prototype.updateDict = function() {
        var contentsSize = this.getContentsSize();
        this.dict.set(PDFName_default.Length, PDFNumber_default.of(contentsSize));
      };
      PDFStream2.prototype.sizeInBytes = function() {
        this.updateDict();
        return this.dict.sizeInBytes() + this.getContentsSize() + 18;
      };
      PDFStream2.prototype.toString = function() {
        this.updateDict();
        var streamString = this.dict.toString();
        streamString += "\nstream\n";
        streamString += this.getContentsString();
        streamString += "\nendstream";
        return streamString;
      };
      PDFStream2.prototype.copyBytesInto = function(buffer, offset) {
        this.updateDict();
        var initialOffset = offset;
        offset += this.dict.copyBytesInto(buffer, offset);
        buffer[offset++] = CharCodes_default.Newline;
        buffer[offset++] = CharCodes_default.s;
        buffer[offset++] = CharCodes_default.t;
        buffer[offset++] = CharCodes_default.r;
        buffer[offset++] = CharCodes_default.e;
        buffer[offset++] = CharCodes_default.a;
        buffer[offset++] = CharCodes_default.m;
        buffer[offset++] = CharCodes_default.Newline;
        var contents = this.getContents();
        for (var idx = 0, len = contents.length; idx < len; idx++) {
          buffer[offset++] = contents[idx];
        }
        buffer[offset++] = CharCodes_default.Newline;
        buffer[offset++] = CharCodes_default.e;
        buffer[offset++] = CharCodes_default.n;
        buffer[offset++] = CharCodes_default.d;
        buffer[offset++] = CharCodes_default.s;
        buffer[offset++] = CharCodes_default.t;
        buffer[offset++] = CharCodes_default.r;
        buffer[offset++] = CharCodes_default.e;
        buffer[offset++] = CharCodes_default.a;
        buffer[offset++] = CharCodes_default.m;
        return offset - initialOffset;
      };
      return PDFStream2;
    }(PDFObject_default)
  );
  var PDFStream_default = PDFStream;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFRawStream.js
  var PDFRawStream = (
    /** @class */
    function(_super) {
      __extends(PDFRawStream2, _super);
      function PDFRawStream2(dict, contents) {
        var _this = _super.call(this, dict) || this;
        _this.contents = contents;
        return _this;
      }
      PDFRawStream2.prototype.asUint8Array = function() {
        return this.contents.slice();
      };
      PDFRawStream2.prototype.clone = function(context) {
        return PDFRawStream2.of(this.dict.clone(context), this.contents.slice());
      };
      PDFRawStream2.prototype.getContentsString = function() {
        return arrayAsString(this.contents);
      };
      PDFRawStream2.prototype.getContents = function() {
        return this.contents;
      };
      PDFRawStream2.prototype.getContentsSize = function() {
        return this.contents.length;
      };
      PDFRawStream2.of = function(dict, contents) {
        return new PDFRawStream2(dict, contents);
      };
      return PDFRawStream2;
    }(PDFStream_default)
  );
  var PDFRawStream_default = PDFRawStream;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFRef.js
  var ENFORCER3 = {};
  var pool2 = /* @__PURE__ */ new Map();
  var PDFRef = (
    /** @class */
    function(_super) {
      __extends(PDFRef2, _super);
      function PDFRef2(enforcer, objectNumber, generationNumber) {
        var _this = this;
        if (enforcer !== ENFORCER3)
          throw new PrivateConstructorError("PDFRef");
        _this = _super.call(this) || this;
        _this.objectNumber = objectNumber;
        _this.generationNumber = generationNumber;
        _this.tag = objectNumber + " " + generationNumber + " R";
        return _this;
      }
      PDFRef2.prototype.clone = function() {
        return this;
      };
      PDFRef2.prototype.toString = function() {
        return this.tag;
      };
      PDFRef2.prototype.sizeInBytes = function() {
        return this.tag.length;
      };
      PDFRef2.prototype.copyBytesInto = function(buffer, offset) {
        offset += copyStringIntoBuffer(this.tag, buffer, offset);
        return this.tag.length;
      };
      PDFRef2.of = function(objectNumber, generationNumber) {
        if (generationNumber === void 0) {
          generationNumber = 0;
        }
        var tag = objectNumber + " " + generationNumber + " R";
        var instance = pool2.get(tag);
        if (!instance) {
          instance = new PDFRef2(ENFORCER3, objectNumber, generationNumber);
          pool2.set(tag, instance);
        }
        return instance;
      };
      return PDFRef2;
    }(PDFObject_default)
  );
  var PDFRef_default = PDFRef;

  // node_modules/@pdfme/pdf-lib/es/core/operators/PDFOperator.js
  var PDFOperator = (
    /** @class */
    function() {
      function PDFOperator2(name, args) {
        this.name = name;
        this.args = args || [];
      }
      PDFOperator2.prototype.clone = function(context) {
        var args = new Array(this.args.length);
        for (var idx = 0, len = args.length; idx < len; idx++) {
          var arg = this.args[idx];
          args[idx] = arg instanceof PDFObject_default ? arg.clone(context) : arg;
        }
        return PDFOperator2.of(this.name, args);
      };
      PDFOperator2.prototype.toString = function() {
        var value = "";
        for (var idx = 0, len = this.args.length; idx < len; idx++) {
          value += String(this.args[idx]) + " ";
        }
        value += this.name;
        return value;
      };
      PDFOperator2.prototype.sizeInBytes = function() {
        var size = 0;
        for (var idx = 0, len = this.args.length; idx < len; idx++) {
          var arg = this.args[idx];
          size += (arg instanceof PDFObject_default ? arg.sizeInBytes() : arg.length) + 1;
        }
        size += this.name.length;
        return size;
      };
      PDFOperator2.prototype.copyBytesInto = function(buffer, offset) {
        var initialOffset = offset;
        for (var idx = 0, len = this.args.length; idx < len; idx++) {
          var arg = this.args[idx];
          if (arg instanceof PDFObject_default) {
            offset += arg.copyBytesInto(buffer, offset);
          } else {
            offset += copyStringIntoBuffer(arg, buffer, offset);
          }
          buffer[offset++] = CharCodes_default.Space;
        }
        offset += copyStringIntoBuffer(this.name, buffer, offset);
        return offset - initialOffset;
      };
      PDFOperator2.of = function(name, args) {
        return new PDFOperator2(name, args);
      };
      return PDFOperator2;
    }()
  );
  var PDFOperator_default = PDFOperator;

  // node_modules/@pdfme/pdf-lib/es/core/operators/PDFOperatorNames.js
  var PDFOperatorNames;
  (function(PDFOperatorNames2) {
    PDFOperatorNames2["NonStrokingColor"] = "sc";
    PDFOperatorNames2["NonStrokingColorN"] = "scn";
    PDFOperatorNames2["NonStrokingColorRgb"] = "rg";
    PDFOperatorNames2["NonStrokingColorGray"] = "g";
    PDFOperatorNames2["NonStrokingColorCmyk"] = "k";
    PDFOperatorNames2["NonStrokingColorspace"] = "cs";
    PDFOperatorNames2["StrokingColor"] = "SC";
    PDFOperatorNames2["StrokingColorN"] = "SCN";
    PDFOperatorNames2["StrokingColorRgb"] = "RG";
    PDFOperatorNames2["StrokingColorGray"] = "G";
    PDFOperatorNames2["StrokingColorCmyk"] = "K";
    PDFOperatorNames2["StrokingColorspace"] = "CS";
    PDFOperatorNames2["BeginMarkedContentSequence"] = "BDC";
    PDFOperatorNames2["BeginMarkedContent"] = "BMC";
    PDFOperatorNames2["EndMarkedContent"] = "EMC";
    PDFOperatorNames2["MarkedContentPointWithProps"] = "DP";
    PDFOperatorNames2["MarkedContentPoint"] = "MP";
    PDFOperatorNames2["DrawObject"] = "Do";
    PDFOperatorNames2["ConcatTransformationMatrix"] = "cm";
    PDFOperatorNames2["PopGraphicsState"] = "Q";
    PDFOperatorNames2["PushGraphicsState"] = "q";
    PDFOperatorNames2["SetFlatness"] = "i";
    PDFOperatorNames2["SetGraphicsStateParams"] = "gs";
    PDFOperatorNames2["SetLineCapStyle"] = "J";
    PDFOperatorNames2["SetLineDashPattern"] = "d";
    PDFOperatorNames2["SetLineJoinStyle"] = "j";
    PDFOperatorNames2["SetLineMiterLimit"] = "M";
    PDFOperatorNames2["SetLineWidth"] = "w";
    PDFOperatorNames2["SetTextMatrix"] = "Tm";
    PDFOperatorNames2["SetRenderingIntent"] = "ri";
    PDFOperatorNames2["AppendRectangle"] = "re";
    PDFOperatorNames2["BeginInlineImage"] = "BI";
    PDFOperatorNames2["BeginInlineImageData"] = "ID";
    PDFOperatorNames2["EndInlineImage"] = "EI";
    PDFOperatorNames2["ClipEvenOdd"] = "W*";
    PDFOperatorNames2["ClipNonZero"] = "W";
    PDFOperatorNames2["CloseAndStroke"] = "s";
    PDFOperatorNames2["CloseFillEvenOddAndStroke"] = "b*";
    PDFOperatorNames2["CloseFillNonZeroAndStroke"] = "b";
    PDFOperatorNames2["ClosePath"] = "h";
    PDFOperatorNames2["AppendBezierCurve"] = "c";
    PDFOperatorNames2["CurveToReplicateFinalPoint"] = "y";
    PDFOperatorNames2["CurveToReplicateInitialPoint"] = "v";
    PDFOperatorNames2["EndPath"] = "n";
    PDFOperatorNames2["FillEvenOddAndStroke"] = "B*";
    PDFOperatorNames2["FillEvenOdd"] = "f*";
    PDFOperatorNames2["FillNonZeroAndStroke"] = "B";
    PDFOperatorNames2["FillNonZero"] = "f";
    PDFOperatorNames2["LegacyFillNonZero"] = "F";
    PDFOperatorNames2["LineTo"] = "l";
    PDFOperatorNames2["MoveTo"] = "m";
    PDFOperatorNames2["ShadingFill"] = "sh";
    PDFOperatorNames2["StrokePath"] = "S";
    PDFOperatorNames2["BeginText"] = "BT";
    PDFOperatorNames2["EndText"] = "ET";
    PDFOperatorNames2["MoveText"] = "Td";
    PDFOperatorNames2["MoveTextSetLeading"] = "TD";
    PDFOperatorNames2["NextLine"] = "T*";
    PDFOperatorNames2["SetCharacterSpacing"] = "Tc";
    PDFOperatorNames2["SetFontAndSize"] = "Tf";
    PDFOperatorNames2["SetTextHorizontalScaling"] = "Tz";
    PDFOperatorNames2["SetTextLineHeight"] = "TL";
    PDFOperatorNames2["SetTextRenderingMode"] = "Tr";
    PDFOperatorNames2["SetTextRise"] = "Ts";
    PDFOperatorNames2["SetWordSpacing"] = "Tw";
    PDFOperatorNames2["ShowText"] = "Tj";
    PDFOperatorNames2["ShowTextAdjusted"] = "TJ";
    PDFOperatorNames2["ShowTextLine"] = "'";
    PDFOperatorNames2["ShowTextLineAndSpace"] = '"';
    PDFOperatorNames2["Type3D0"] = "d0";
    PDFOperatorNames2["Type3D1"] = "d1";
    PDFOperatorNames2["BeginCompatibilitySection"] = "BX";
    PDFOperatorNames2["EndCompatibilitySection"] = "EX";
  })(PDFOperatorNames || (PDFOperatorNames = {}));
  var PDFOperatorNames_default = PDFOperatorNames;

  // node_modules/@pdfme/pdf-lib/es/core/structures/PDFFlateStream.js
  var import_pako2 = __toESM(require_pako());
  var PDFFlateStream = (
    /** @class */
    function(_super) {
      __extends(PDFFlateStream2, _super);
      function PDFFlateStream2(dict, encode) {
        var _this = _super.call(this, dict) || this;
        _this.computeContents = function() {
          var unencodedContents = _this.getUnencodedContents();
          return _this.encode ? import_pako2.default.deflate(unencodedContents) : unencodedContents;
        };
        _this.encode = encode;
        if (encode)
          dict.set(PDFName_default.of("Filter"), PDFName_default.of("FlateDecode"));
        _this.contentsCache = Cache_default.populatedBy(_this.computeContents);
        return _this;
      }
      PDFFlateStream2.prototype.getContents = function() {
        return this.contentsCache.access();
      };
      PDFFlateStream2.prototype.getContentsSize = function() {
        return this.contentsCache.access().length;
      };
      PDFFlateStream2.prototype.getUnencodedContents = function() {
        throw new MethodNotImplementedError(this.constructor.name, "getUnencodedContents");
      };
      return PDFFlateStream2;
    }(PDFStream_default)
  );
  var PDFFlateStream_default = PDFFlateStream;

  // node_modules/@pdfme/pdf-lib/es/core/structures/PDFContentStream.js
  var PDFContentStream = (
    /** @class */
    function(_super) {
      __extends(PDFContentStream2, _super);
      function PDFContentStream2(dict, operators, encode) {
        if (encode === void 0) {
          encode = true;
        }
        var _this = _super.call(this, dict, encode) || this;
        _this.operators = operators;
        return _this;
      }
      PDFContentStream2.prototype.push = function() {
        var _a;
        var operators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operators[_i] = arguments[_i];
        }
        (_a = this.operators).push.apply(_a, operators);
      };
      PDFContentStream2.prototype.clone = function(context) {
        var operators = new Array(this.operators.length);
        for (var idx = 0, len = this.operators.length; idx < len; idx++) {
          operators[idx] = this.operators[idx].clone(context);
        }
        var _a = this, dict = _a.dict, encode = _a.encode;
        return PDFContentStream2.of(dict.clone(context), operators, encode);
      };
      PDFContentStream2.prototype.getContentsString = function() {
        var value = "";
        for (var idx = 0, len = this.operators.length; idx < len; idx++) {
          value += this.operators[idx] + "\n";
        }
        return value;
      };
      PDFContentStream2.prototype.getUnencodedContents = function() {
        var buffer = new Uint8Array(this.getUnencodedContentsSize());
        var offset = 0;
        for (var idx = 0, len = this.operators.length; idx < len; idx++) {
          offset += this.operators[idx].copyBytesInto(buffer, offset);
          buffer[offset++] = CharCodes_default.Newline;
        }
        return buffer;
      };
      PDFContentStream2.prototype.getUnencodedContentsSize = function() {
        var size = 0;
        for (var idx = 0, len = this.operators.length; idx < len; idx++) {
          size += this.operators[idx].sizeInBytes() + 1;
        }
        return size;
      };
      PDFContentStream2.of = function(dict, operators, encode) {
        if (encode === void 0) {
          encode = true;
        }
        return new PDFContentStream2(dict, operators, encode);
      };
      return PDFContentStream2;
    }(PDFFlateStream_default)
  );
  var PDFContentStream_default = PDFContentStream;

  // node_modules/@pdfme/pdf-lib/es/utils/rng.js
  var SimpleRNG = (
    /** @class */
    function() {
      function SimpleRNG2(seed) {
        this.seed = seed;
      }
      SimpleRNG2.prototype.nextInt = function() {
        var x = Math.sin(this.seed++) * 1e4;
        return x - Math.floor(x);
      };
      SimpleRNG2.withSeed = function(seed) {
        return new SimpleRNG2(seed);
      };
      return SimpleRNG2;
    }()
  );

  // node_modules/@pdfme/pdf-lib/es/core/PDFContext.js
  var import_pako3 = __toESM(require_pako());
  var byAscendingObjectNumber = function(_a, _b) {
    var a = _a[0];
    var b = _b[0];
    return a.objectNumber - b.objectNumber;
  };
  var PDFContext = (
    /** @class */
    function() {
      function PDFContext2() {
        this.largestObjectNumber = 0;
        this.header = PDFHeader_default.forVersion(1, 7);
        this.trailerInfo = {};
        this.indirectObjects = /* @__PURE__ */ new Map();
        this.rng = SimpleRNG.withSeed(1);
      }
      PDFContext2.prototype.assign = function(ref, object) {
        this.indirectObjects.set(ref, object);
        if (ref.objectNumber > this.largestObjectNumber) {
          this.largestObjectNumber = ref.objectNumber;
        }
      };
      PDFContext2.prototype.nextRef = function() {
        this.largestObjectNumber += 1;
        return PDFRef_default.of(this.largestObjectNumber);
      };
      PDFContext2.prototype.register = function(object) {
        var ref = this.nextRef();
        this.assign(ref, object);
        return ref;
      };
      PDFContext2.prototype.delete = function(ref) {
        return this.indirectObjects.delete(ref);
      };
      PDFContext2.prototype.lookupMaybe = function(ref) {
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          types[_i - 1] = arguments[_i];
        }
        var preservePDFNull = types.includes(PDFNull_default);
        var result = ref instanceof PDFRef_default ? this.indirectObjects.get(ref) : ref;
        if (!result || result === PDFNull_default && !preservePDFNull)
          return void 0;
        for (var idx = 0, len = types.length; idx < len; idx++) {
          var type = types[idx];
          if (type === PDFNull_default) {
            if (result === PDFNull_default)
              return result;
          } else {
            if (result instanceof type)
              return result;
          }
        }
        throw new UnexpectedObjectTypeError(types, result);
      };
      PDFContext2.prototype.lookup = function(ref) {
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          types[_i - 1] = arguments[_i];
        }
        var result = ref instanceof PDFRef_default ? this.indirectObjects.get(ref) : ref;
        if (types.length === 0)
          return result;
        for (var idx = 0, len = types.length; idx < len; idx++) {
          var type = types[idx];
          if (type === PDFNull_default) {
            if (result === PDFNull_default)
              return result;
          } else {
            if (result instanceof type)
              return result;
          }
        }
        throw new UnexpectedObjectTypeError(types, result);
      };
      PDFContext2.prototype.getObjectRef = function(pdfObject) {
        var entries = Array.from(this.indirectObjects.entries());
        for (var idx = 0, len = entries.length; idx < len; idx++) {
          var _a = entries[idx], ref = _a[0], object = _a[1];
          if (object === pdfObject) {
            return ref;
          }
        }
        return void 0;
      };
      PDFContext2.prototype.enumerateIndirectObjects = function() {
        return Array.from(this.indirectObjects.entries()).sort(byAscendingObjectNumber);
      };
      PDFContext2.prototype.obj = function(literal) {
        if (literal instanceof PDFObject_default) {
          return literal;
        } else if (literal === null || literal === void 0) {
          return PDFNull_default;
        } else if (typeof literal === "string") {
          return PDFName_default.of(literal);
        } else if (typeof literal === "number") {
          return PDFNumber_default.of(literal);
        } else if (typeof literal === "boolean") {
          return literal ? PDFBool_default.True : PDFBool_default.False;
        } else if (Array.isArray(literal)) {
          var array = PDFArray_default.withContext(this);
          for (var idx = 0, len = literal.length; idx < len; idx++) {
            array.push(this.obj(literal[idx]));
          }
          return array;
        } else {
          var dict = PDFDict_default.withContext(this);
          var keys = Object.keys(literal);
          for (var idx = 0, len = keys.length; idx < len; idx++) {
            var key = keys[idx];
            var value = literal[key];
            if (value !== void 0)
              dict.set(PDFName_default.of(key), this.obj(value));
          }
          return dict;
        }
      };
      PDFContext2.prototype.stream = function(contents, dict) {
        if (dict === void 0) {
          dict = {};
        }
        return PDFRawStream_default.of(this.obj(dict), typedArrayFor(contents));
      };
      PDFContext2.prototype.flateStream = function(contents, dict) {
        if (dict === void 0) {
          dict = {};
        }
        return this.stream(import_pako3.default.deflate(typedArrayFor(contents)), __assign(__assign({}, dict), { Filter: "FlateDecode" }));
      };
      PDFContext2.prototype.contentStream = function(operators, dict) {
        if (dict === void 0) {
          dict = {};
        }
        return PDFContentStream_default.of(this.obj(dict), operators);
      };
      PDFContext2.prototype.formXObject = function(operators, dict) {
        if (dict === void 0) {
          dict = {};
        }
        return this.contentStream(operators, __assign(__assign({ BBox: this.obj([0, 0, 0, 0]), Matrix: this.obj([1, 0, 0, 1, 0, 0]) }, dict), { Type: "XObject", Subtype: "Form" }));
      };
      PDFContext2.prototype.getPushGraphicsStateContentStream = function() {
        if (this.pushGraphicsStateContentStreamRef) {
          return this.pushGraphicsStateContentStreamRef;
        }
        var dict = this.obj({});
        var op = PDFOperator_default.of(PDFOperatorNames_default.PushGraphicsState);
        var stream2 = PDFContentStream_default.of(dict, [op]);
        this.pushGraphicsStateContentStreamRef = this.register(stream2);
        return this.pushGraphicsStateContentStreamRef;
      };
      PDFContext2.prototype.getPopGraphicsStateContentStream = function() {
        if (this.popGraphicsStateContentStreamRef) {
          return this.popGraphicsStateContentStreamRef;
        }
        var dict = this.obj({});
        var op = PDFOperator_default.of(PDFOperatorNames_default.PopGraphicsState);
        var stream2 = PDFContentStream_default.of(dict, [op]);
        this.popGraphicsStateContentStreamRef = this.register(stream2);
        return this.popGraphicsStateContentStreamRef;
      };
      PDFContext2.prototype.addRandomSuffix = function(prefix, suffixLength) {
        if (suffixLength === void 0) {
          suffixLength = 4;
        }
        return prefix + "-" + Math.floor(this.rng.nextInt() * Math.pow(10, suffixLength));
      };
      PDFContext2.create = function() {
        return new PDFContext2();
      };
      return PDFContext2;
    }()
  );
  var PDFContext_default = PDFContext;

  // node_modules/@pdfme/pdf-lib/es/core/structures/PDFPageLeaf.js
  var PDFPageLeaf = (
    /** @class */
    function(_super) {
      __extends(PDFPageLeaf2, _super);
      function PDFPageLeaf2(map, context, autoNormalizeCTM) {
        if (autoNormalizeCTM === void 0) {
          autoNormalizeCTM = true;
        }
        var _this = _super.call(this, map, context) || this;
        _this.normalized = false;
        _this.autoNormalizeCTM = autoNormalizeCTM;
        return _this;
      }
      PDFPageLeaf2.prototype.clone = function(context) {
        var clone = PDFPageLeaf2.fromMapWithContext(/* @__PURE__ */ new Map(), context || this.context, this.autoNormalizeCTM);
        var entries = this.entries();
        for (var idx = 0, len = entries.length; idx < len; idx++) {
          var _a = entries[idx], key = _a[0], value = _a[1];
          clone.set(key, value);
        }
        return clone;
      };
      PDFPageLeaf2.prototype.Parent = function() {
        return this.lookupMaybe(PDFName_default.Parent, PDFDict_default);
      };
      PDFPageLeaf2.prototype.Contents = function() {
        return this.lookup(PDFName_default.of("Contents"));
      };
      PDFPageLeaf2.prototype.Annots = function() {
        return this.lookupMaybe(PDFName_default.Annots, PDFArray_default);
      };
      PDFPageLeaf2.prototype.BleedBox = function() {
        return this.lookupMaybe(PDFName_default.BleedBox, PDFArray_default);
      };
      PDFPageLeaf2.prototype.TrimBox = function() {
        return this.lookupMaybe(PDFName_default.TrimBox, PDFArray_default);
      };
      PDFPageLeaf2.prototype.ArtBox = function() {
        return this.lookupMaybe(PDFName_default.ArtBox, PDFArray_default);
      };
      PDFPageLeaf2.prototype.Resources = function() {
        var dictOrRef = this.getInheritableAttribute(PDFName_default.Resources);
        return this.context.lookupMaybe(dictOrRef, PDFDict_default);
      };
      PDFPageLeaf2.prototype.MediaBox = function() {
        var arrayOrRef = this.getInheritableAttribute(PDFName_default.MediaBox);
        return this.context.lookup(arrayOrRef, PDFArray_default);
      };
      PDFPageLeaf2.prototype.CropBox = function() {
        var arrayOrRef = this.getInheritableAttribute(PDFName_default.CropBox);
        return this.context.lookupMaybe(arrayOrRef, PDFArray_default);
      };
      PDFPageLeaf2.prototype.Rotate = function() {
        var numberOrRef = this.getInheritableAttribute(PDFName_default.Rotate);
        return this.context.lookupMaybe(numberOrRef, PDFNumber_default);
      };
      PDFPageLeaf2.prototype.getInheritableAttribute = function(name) {
        var attribute;
        this.ascend(function(node) {
          if (!attribute)
            attribute = node.get(name);
        });
        return attribute;
      };
      PDFPageLeaf2.prototype.setParent = function(parentRef) {
        this.set(PDFName_default.Parent, parentRef);
      };
      PDFPageLeaf2.prototype.addContentStream = function(contentStreamRef) {
        var Contents = this.normalizedEntries().Contents || this.context.obj([]);
        this.set(PDFName_default.Contents, Contents);
        Contents.push(contentStreamRef);
      };
      PDFPageLeaf2.prototype.wrapContentStreams = function(startStream, endStream) {
        var Contents = this.Contents();
        if (Contents instanceof PDFArray_default) {
          Contents.insert(0, startStream);
          Contents.push(endStream);
          return true;
        }
        return false;
      };
      PDFPageLeaf2.prototype.addAnnot = function(annotRef) {
        var Annots = this.normalizedEntries().Annots;
        Annots.push(annotRef);
      };
      PDFPageLeaf2.prototype.removeAnnot = function(annotRef) {
        var Annots = this.normalizedEntries().Annots;
        var index = Annots.indexOf(annotRef);
        if (index !== void 0) {
          Annots.remove(index);
        }
      };
      PDFPageLeaf2.prototype.setFontDictionary = function(name, fontDictRef) {
        var Font3 = this.normalizedEntries().Font;
        Font3.set(name, fontDictRef);
      };
      PDFPageLeaf2.prototype.newFontDictionaryKey = function(tag) {
        var Font3 = this.normalizedEntries().Font;
        return Font3.uniqueKey(tag);
      };
      PDFPageLeaf2.prototype.newFontDictionary = function(tag, fontDictRef) {
        var key = this.newFontDictionaryKey(tag);
        this.setFontDictionary(key, fontDictRef);
        return key;
      };
      PDFPageLeaf2.prototype.setXObject = function(name, xObjectRef) {
        var XObject = this.normalizedEntries().XObject;
        XObject.set(name, xObjectRef);
      };
      PDFPageLeaf2.prototype.newXObjectKey = function(tag) {
        var XObject = this.normalizedEntries().XObject;
        return XObject.uniqueKey(tag);
      };
      PDFPageLeaf2.prototype.newXObject = function(tag, xObjectRef) {
        var key = this.newXObjectKey(tag);
        this.setXObject(key, xObjectRef);
        return key;
      };
      PDFPageLeaf2.prototype.setExtGState = function(name, extGStateRef) {
        var ExtGState = this.normalizedEntries().ExtGState;
        ExtGState.set(name, extGStateRef);
      };
      PDFPageLeaf2.prototype.newExtGStateKey = function(tag) {
        var ExtGState = this.normalizedEntries().ExtGState;
        return ExtGState.uniqueKey(tag);
      };
      PDFPageLeaf2.prototype.newExtGState = function(tag, extGStateRef) {
        var key = this.newExtGStateKey(tag);
        this.setExtGState(key, extGStateRef);
        return key;
      };
      PDFPageLeaf2.prototype.ascend = function(visitor) {
        visitor(this);
        var Parent = this.Parent();
        if (Parent)
          Parent.ascend(visitor);
      };
      PDFPageLeaf2.prototype.normalize = function() {
        if (this.normalized)
          return;
        var context = this.context;
        var contentsRef = this.get(PDFName_default.Contents);
        var contents = this.context.lookup(contentsRef);
        if (contents instanceof PDFStream_default) {
          this.set(PDFName_default.Contents, context.obj([contentsRef]));
        }
        if (this.autoNormalizeCTM) {
          this.wrapContentStreams(this.context.getPushGraphicsStateContentStream(), this.context.getPopGraphicsStateContentStream());
        }
        var dictOrRef = this.getInheritableAttribute(PDFName_default.Resources);
        var Resources = context.lookupMaybe(dictOrRef, PDFDict_default) || context.obj({});
        this.set(PDFName_default.Resources, Resources);
        var Font3 = Resources.lookupMaybe(PDFName_default.Font, PDFDict_default) || context.obj({});
        Resources.set(PDFName_default.Font, Font3);
        var XObject = Resources.lookupMaybe(PDFName_default.XObject, PDFDict_default) || context.obj({});
        Resources.set(PDFName_default.XObject, XObject);
        var ExtGState = Resources.lookupMaybe(PDFName_default.ExtGState, PDFDict_default) || context.obj({});
        Resources.set(PDFName_default.ExtGState, ExtGState);
        var Annots = this.Annots() || context.obj([]);
        this.set(PDFName_default.Annots, Annots);
        this.normalized = true;
      };
      PDFPageLeaf2.prototype.normalizedEntries = function() {
        this.normalize();
        var Annots = this.Annots();
        var Resources = this.Resources();
        var Contents = this.Contents();
        return {
          Annots,
          Resources,
          Contents,
          Font: Resources.lookup(PDFName_default.Font, PDFDict_default),
          XObject: Resources.lookup(PDFName_default.XObject, PDFDict_default),
          ExtGState: Resources.lookup(PDFName_default.ExtGState, PDFDict_default)
        };
      };
      PDFPageLeaf2.InheritableEntries = [
        "Resources",
        "MediaBox",
        "CropBox",
        "Rotate"
      ];
      PDFPageLeaf2.withContextAndParent = function(context, parent) {
        var dict = /* @__PURE__ */ new Map();
        dict.set(PDFName_default.Type, PDFName_default.Page);
        dict.set(PDFName_default.Parent, parent);
        dict.set(PDFName_default.Resources, context.obj({}));
        dict.set(PDFName_default.MediaBox, context.obj([0, 0, 612, 792]));
        return new PDFPageLeaf2(dict, context, false);
      };
      PDFPageLeaf2.fromMapWithContext = function(map, context, autoNormalizeCTM) {
        if (autoNormalizeCTM === void 0) {
          autoNormalizeCTM = true;
        }
        return new PDFPageLeaf2(map, context, autoNormalizeCTM);
      };
      return PDFPageLeaf2;
    }(PDFDict_default)
  );
  var PDFPageLeaf_default = PDFPageLeaf;

  // node_modules/@pdfme/pdf-lib/es/core/PDFObjectCopier.js
  var PDFObjectCopier = (
    /** @class */
    function() {
      function PDFObjectCopier2(src, dest) {
        var _this = this;
        this.traversedObjects = /* @__PURE__ */ new Map();
        this.copy = function(object) {
          return object instanceof PDFPageLeaf_default ? _this.copyPDFPage(object) : object instanceof PDFDict_default ? _this.copyPDFDict(object) : object instanceof PDFArray_default ? _this.copyPDFArray(object) : object instanceof PDFStream_default ? _this.copyPDFStream(object) : object instanceof PDFRef_default ? _this.copyPDFIndirectObject(object) : object.clone();
        };
        this.copyPDFPage = function(originalPage) {
          var clonedPage = originalPage.clone();
          var InheritableEntries = PDFPageLeaf_default.InheritableEntries;
          for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {
            var key = PDFName_default.of(InheritableEntries[idx]);
            var value = clonedPage.getInheritableAttribute(key);
            if (!clonedPage.get(key) && value)
              clonedPage.set(key, value);
          }
          clonedPage.delete(PDFName_default.of("Parent"));
          return _this.copyPDFDict(clonedPage);
        };
        this.copyPDFDict = function(originalDict) {
          if (_this.traversedObjects.has(originalDict)) {
            return _this.traversedObjects.get(originalDict);
          }
          var clonedDict = originalDict.clone(_this.dest);
          _this.traversedObjects.set(originalDict, clonedDict);
          var entries = originalDict.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            clonedDict.set(key, _this.copy(value));
          }
          return clonedDict;
        };
        this.copyPDFArray = function(originalArray) {
          if (_this.traversedObjects.has(originalArray)) {
            return _this.traversedObjects.get(originalArray);
          }
          var clonedArray = originalArray.clone(_this.dest);
          _this.traversedObjects.set(originalArray, clonedArray);
          for (var idx = 0, len = originalArray.size(); idx < len; idx++) {
            var value = originalArray.get(idx);
            clonedArray.set(idx, _this.copy(value));
          }
          return clonedArray;
        };
        this.copyPDFStream = function(originalStream) {
          if (_this.traversedObjects.has(originalStream)) {
            return _this.traversedObjects.get(originalStream);
          }
          var clonedStream = originalStream.clone(_this.dest);
          _this.traversedObjects.set(originalStream, clonedStream);
          var entries = originalStream.dict.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            clonedStream.dict.set(key, _this.copy(value));
          }
          return clonedStream;
        };
        this.copyPDFIndirectObject = function(ref) {
          var alreadyMapped = _this.traversedObjects.has(ref);
          if (!alreadyMapped) {
            var newRef = _this.dest.nextRef();
            _this.traversedObjects.set(ref, newRef);
            var dereferencedValue = _this.src.lookup(ref);
            if (dereferencedValue) {
              var cloned = _this.copy(dereferencedValue);
              _this.dest.assign(newRef, cloned);
            }
          }
          return _this.traversedObjects.get(ref);
        };
        this.src = src;
        this.dest = dest;
      }
      PDFObjectCopier2.for = function(src, dest) {
        return new PDFObjectCopier2(src, dest);
      };
      return PDFObjectCopier2;
    }()
  );
  var PDFObjectCopier_default = PDFObjectCopier;

  // node_modules/@pdfme/pdf-lib/es/core/document/PDFCrossRefSection.js
  var PDFCrossRefSection = (
    /** @class */
    function() {
      function PDFCrossRefSection2(firstEntry) {
        this.subsections = firstEntry ? [[firstEntry]] : [];
        this.chunkIdx = 0;
        this.chunkLength = firstEntry ? 1 : 0;
      }
      PDFCrossRefSection2.prototype.addEntry = function(ref, offset) {
        this.append({ ref, offset, deleted: false });
      };
      PDFCrossRefSection2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
        this.append({ ref, offset: nextFreeObjectNumber, deleted: true });
      };
      PDFCrossRefSection2.prototype.toString = function() {
        var section = "xref\n";
        for (var rangeIdx = 0, rangeLen = this.subsections.length; rangeIdx < rangeLen; rangeIdx++) {
          var range2 = this.subsections[rangeIdx];
          section += range2[0].ref.objectNumber + " " + range2.length + "\n";
          for (var entryIdx = 0, entryLen = range2.length; entryIdx < entryLen; entryIdx++) {
            var entry = range2[entryIdx];
            section += padStart(String(entry.offset), 10, "0");
            section += " ";
            section += padStart(String(entry.ref.generationNumber), 5, "0");
            section += " ";
            section += entry.deleted ? "f" : "n";
            section += " \n";
          }
        }
        return section;
      };
      PDFCrossRefSection2.prototype.sizeInBytes = function() {
        var size = 5;
        for (var idx = 0, len = this.subsections.length; idx < len; idx++) {
          var subsection = this.subsections[idx];
          var subsectionLength = subsection.length;
          var firstEntry = subsection[0];
          size += 2;
          size += String(firstEntry.ref.objectNumber).length;
          size += String(subsectionLength).length;
          size += 20 * subsectionLength;
        }
        return size;
      };
      PDFCrossRefSection2.prototype.copyBytesInto = function(buffer, offset) {
        var initialOffset = offset;
        buffer[offset++] = CharCodes_default.x;
        buffer[offset++] = CharCodes_default.r;
        buffer[offset++] = CharCodes_default.e;
        buffer[offset++] = CharCodes_default.f;
        buffer[offset++] = CharCodes_default.Newline;
        offset += this.copySubsectionsIntoBuffer(this.subsections, buffer, offset);
        return offset - initialOffset;
      };
      PDFCrossRefSection2.prototype.copySubsectionsIntoBuffer = function(subsections, buffer, offset) {
        var initialOffset = offset;
        var length = subsections.length;
        for (var idx = 0; idx < length; idx++) {
          var subsection = this.subsections[idx];
          var firstObjectNumber = String(subsection[0].ref.objectNumber);
          offset += copyStringIntoBuffer(firstObjectNumber, buffer, offset);
          buffer[offset++] = CharCodes_default.Space;
          var rangeLength = String(subsection.length);
          offset += copyStringIntoBuffer(rangeLength, buffer, offset);
          buffer[offset++] = CharCodes_default.Newline;
          offset += this.copyEntriesIntoBuffer(subsection, buffer, offset);
        }
        return offset - initialOffset;
      };
      PDFCrossRefSection2.prototype.copyEntriesIntoBuffer = function(entries, buffer, offset) {
        var length = entries.length;
        for (var idx = 0; idx < length; idx++) {
          var entry = entries[idx];
          var entryOffset = padStart(String(entry.offset), 10, "0");
          offset += copyStringIntoBuffer(entryOffset, buffer, offset);
          buffer[offset++] = CharCodes_default.Space;
          var entryGen = padStart(String(entry.ref.generationNumber), 5, "0");
          offset += copyStringIntoBuffer(entryGen, buffer, offset);
          buffer[offset++] = CharCodes_default.Space;
          buffer[offset++] = entry.deleted ? CharCodes_default.f : CharCodes_default.n;
          buffer[offset++] = CharCodes_default.Space;
          buffer[offset++] = CharCodes_default.Newline;
        }
        return 20 * length;
      };
      PDFCrossRefSection2.prototype.append = function(currEntry) {
        if (this.chunkLength === 0) {
          this.subsections.push([currEntry]);
          this.chunkIdx = 0;
          this.chunkLength = 1;
          return;
        }
        var chunk = this.subsections[this.chunkIdx];
        var prevEntry = chunk[this.chunkLength - 1];
        if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
          this.subsections.push([currEntry]);
          this.chunkIdx += 1;
          this.chunkLength = 1;
        } else {
          chunk.push(currEntry);
          this.chunkLength += 1;
        }
      };
      PDFCrossRefSection2.create = function() {
        return new PDFCrossRefSection2({
          ref: PDFRef_default.of(0, 65535),
          offset: 0,
          deleted: true
        });
      };
      PDFCrossRefSection2.createEmpty = function() {
        return new PDFCrossRefSection2();
      };
      return PDFCrossRefSection2;
    }()
  );
  var PDFCrossRefSection_default = PDFCrossRefSection;

  // node_modules/@pdfme/pdf-lib/es/core/document/PDFTrailer.js
  var PDFTrailer = (
    /** @class */
    function() {
      function PDFTrailer2(lastXRefOffset) {
        this.lastXRefOffset = String(lastXRefOffset);
      }
      PDFTrailer2.prototype.toString = function() {
        return "startxref\n" + this.lastXRefOffset + "\n%%EOF";
      };
      PDFTrailer2.prototype.sizeInBytes = function() {
        return 16 + this.lastXRefOffset.length;
      };
      PDFTrailer2.prototype.copyBytesInto = function(buffer, offset) {
        var initialOffset = offset;
        buffer[offset++] = CharCodes_default.s;
        buffer[offset++] = CharCodes_default.t;
        buffer[offset++] = CharCodes_default.a;
        buffer[offset++] = CharCodes_default.r;
        buffer[offset++] = CharCodes_default.t;
        buffer[offset++] = CharCodes_default.x;
        buffer[offset++] = CharCodes_default.r;
        buffer[offset++] = CharCodes_default.e;
        buffer[offset++] = CharCodes_default.f;
        buffer[offset++] = CharCodes_default.Newline;
        offset += copyStringIntoBuffer(this.lastXRefOffset, buffer, offset);
        buffer[offset++] = CharCodes_default.Newline;
        buffer[offset++] = CharCodes_default.Percent;
        buffer[offset++] = CharCodes_default.Percent;
        buffer[offset++] = CharCodes_default.E;
        buffer[offset++] = CharCodes_default.O;
        buffer[offset++] = CharCodes_default.F;
        return offset - initialOffset;
      };
      PDFTrailer2.forLastCrossRefSectionOffset = function(offset) {
        return new PDFTrailer2(offset);
      };
      return PDFTrailer2;
    }()
  );
  var PDFTrailer_default = PDFTrailer;

  // node_modules/@pdfme/pdf-lib/es/core/document/PDFTrailerDict.js
  var PDFTrailerDict = (
    /** @class */
    function() {
      function PDFTrailerDict2(dict) {
        this.dict = dict;
      }
      PDFTrailerDict2.prototype.toString = function() {
        return "trailer\n" + this.dict.toString();
      };
      PDFTrailerDict2.prototype.sizeInBytes = function() {
        return 8 + this.dict.sizeInBytes();
      };
      PDFTrailerDict2.prototype.copyBytesInto = function(buffer, offset) {
        var initialOffset = offset;
        buffer[offset++] = CharCodes_default.t;
        buffer[offset++] = CharCodes_default.r;
        buffer[offset++] = CharCodes_default.a;
        buffer[offset++] = CharCodes_default.i;
        buffer[offset++] = CharCodes_default.l;
        buffer[offset++] = CharCodes_default.e;
        buffer[offset++] = CharCodes_default.r;
        buffer[offset++] = CharCodes_default.Newline;
        offset += this.dict.copyBytesInto(buffer, offset);
        return offset - initialOffset;
      };
      PDFTrailerDict2.of = function(dict) {
        return new PDFTrailerDict2(dict);
      };
      return PDFTrailerDict2;
    }()
  );
  var PDFTrailerDict_default = PDFTrailerDict;

  // node_modules/@pdfme/pdf-lib/es/core/structures/PDFObjectStream.js
  var PDFObjectStream = (
    /** @class */
    function(_super) {
      __extends(PDFObjectStream2, _super);
      function PDFObjectStream2(context, objects, encode) {
        if (encode === void 0) {
          encode = true;
        }
        var _this = _super.call(this, context.obj({}), encode) || this;
        _this.objects = objects;
        _this.offsets = _this.computeObjectOffsets();
        _this.offsetsString = _this.computeOffsetsString();
        _this.dict.set(PDFName_default.of("Type"), PDFName_default.of("ObjStm"));
        _this.dict.set(PDFName_default.of("N"), PDFNumber_default.of(_this.objects.length));
        _this.dict.set(PDFName_default.of("First"), PDFNumber_default.of(_this.offsetsString.length));
        return _this;
      }
      PDFObjectStream2.prototype.getObjectsCount = function() {
        return this.objects.length;
      };
      PDFObjectStream2.prototype.clone = function(context) {
        return PDFObjectStream2.withContextAndObjects(context || this.dict.context, this.objects.slice(), this.encode);
      };
      PDFObjectStream2.prototype.getContentsString = function() {
        var value = this.offsetsString;
        for (var idx = 0, len = this.objects.length; idx < len; idx++) {
          var _a = this.objects[idx], object = _a[1];
          value += object + "\n";
        }
        return value;
      };
      PDFObjectStream2.prototype.getUnencodedContents = function() {
        var buffer = new Uint8Array(this.getUnencodedContentsSize());
        var offset = copyStringIntoBuffer(this.offsetsString, buffer, 0);
        for (var idx = 0, len = this.objects.length; idx < len; idx++) {
          var _a = this.objects[idx], object = _a[1];
          offset += object.copyBytesInto(buffer, offset);
          buffer[offset++] = CharCodes_default.Newline;
        }
        return buffer;
      };
      PDFObjectStream2.prototype.getUnencodedContentsSize = function() {
        return this.offsetsString.length + last(this.offsets)[1] + last(this.objects)[1].sizeInBytes() + 1;
      };
      PDFObjectStream2.prototype.computeOffsetsString = function() {
        var offsetsString = "";
        for (var idx = 0, len = this.offsets.length; idx < len; idx++) {
          var _a = this.offsets[idx], objectNumber = _a[0], offset = _a[1];
          offsetsString += objectNumber + " " + offset + " ";
        }
        return offsetsString;
      };
      PDFObjectStream2.prototype.computeObjectOffsets = function() {
        var offset = 0;
        var offsets = new Array(this.objects.length);
        for (var idx = 0, len = this.objects.length; idx < len; idx++) {
          var _a = this.objects[idx], ref = _a[0], object = _a[1];
          offsets[idx] = [ref.objectNumber, offset];
          offset += object.sizeInBytes() + 1;
        }
        return offsets;
      };
      PDFObjectStream2.withContextAndObjects = function(context, objects, encode) {
        if (encode === void 0) {
          encode = true;
        }
        return new PDFObjectStream2(context, objects, encode);
      };
      return PDFObjectStream2;
    }(PDFFlateStream_default)
  );
  var PDFObjectStream_default = PDFObjectStream;

  // node_modules/@pdfme/pdf-lib/es/core/writers/PDFWriter.js
  var PDFWriter = (
    /** @class */
    function() {
      function PDFWriter2(context, objectsPerTick) {
        var _this = this;
        this.parsedObjects = 0;
        this.shouldWaitForTick = function(n) {
          _this.parsedObjects += n;
          return _this.parsedObjects % _this.objectsPerTick === 0;
        };
        this.context = context;
        this.objectsPerTick = objectsPerTick;
      }
      PDFWriter2.prototype.serializeToBuffer = function() {
        return __awaiter(this, void 0, void 0, function() {
          var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, this.computeBufferSize()];
              case 1:
                _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;
                offset = 0;
                buffer = new Uint8Array(size);
                offset += header.copyBytesInto(buffer, offset);
                buffer[offset++] = CharCodes_default.Newline;
                buffer[offset++] = CharCodes_default.Newline;
                idx = 0, len = indirectObjects.length;
                _c.label = 2;
              case 2:
                if (!(idx < len))
                  return [3, 5];
                _b = indirectObjects[idx], ref = _b[0], object = _b[1];
                objectNumber = String(ref.objectNumber);
                offset += copyStringIntoBuffer(objectNumber, buffer, offset);
                buffer[offset++] = CharCodes_default.Space;
                generationNumber = String(ref.generationNumber);
                offset += copyStringIntoBuffer(generationNumber, buffer, offset);
                buffer[offset++] = CharCodes_default.Space;
                buffer[offset++] = CharCodes_default.o;
                buffer[offset++] = CharCodes_default.b;
                buffer[offset++] = CharCodes_default.j;
                buffer[offset++] = CharCodes_default.Newline;
                offset += object.copyBytesInto(buffer, offset);
                buffer[offset++] = CharCodes_default.Newline;
                buffer[offset++] = CharCodes_default.e;
                buffer[offset++] = CharCodes_default.n;
                buffer[offset++] = CharCodes_default.d;
                buffer[offset++] = CharCodes_default.o;
                buffer[offset++] = CharCodes_default.b;
                buffer[offset++] = CharCodes_default.j;
                buffer[offset++] = CharCodes_default.Newline;
                buffer[offset++] = CharCodes_default.Newline;
                n = object instanceof PDFObjectStream_default ? object.getObjectsCount() : 1;
                if (!this.shouldWaitForTick(n))
                  return [3, 4];
                return [4, waitForTick()];
              case 3:
                _c.sent();
                _c.label = 4;
              case 4:
                idx++;
                return [3, 2];
              case 5:
                if (xref) {
                  offset += xref.copyBytesInto(buffer, offset);
                  buffer[offset++] = CharCodes_default.Newline;
                }
                if (trailerDict) {
                  offset += trailerDict.copyBytesInto(buffer, offset);
                  buffer[offset++] = CharCodes_default.Newline;
                  buffer[offset++] = CharCodes_default.Newline;
                }
                offset += trailer.copyBytesInto(buffer, offset);
                return [2, buffer];
            }
          });
        });
      };
      PDFWriter2.prototype.computeIndirectObjectSize = function(_a) {
        var ref = _a[0], object = _a[1];
        var refSize = ref.sizeInBytes() + 3;
        var objectSize = object.sizeInBytes() + 9;
        return refSize + objectSize;
      };
      PDFWriter2.prototype.createTrailerDict = function() {
        return this.context.obj({
          Size: this.context.largestObjectNumber + 1,
          Root: this.context.trailerInfo.Root,
          Encrypt: this.context.trailerInfo.Encrypt,
          Info: this.context.trailerInfo.Info,
          ID: this.context.trailerInfo.ID
        });
      };
      PDFWriter2.prototype.computeBufferSize = function() {
        return __awaiter(this, void 0, void 0, function() {
          var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                header = PDFHeader_default.forVersion(1, 7);
                size = header.sizeInBytes() + 2;
                xref = PDFCrossRefSection_default.create();
                indirectObjects = this.context.enumerateIndirectObjects();
                idx = 0, len = indirectObjects.length;
                _a.label = 1;
              case 1:
                if (!(idx < len))
                  return [3, 4];
                indirectObject = indirectObjects[idx];
                ref = indirectObject[0];
                xref.addEntry(ref, size);
                size += this.computeIndirectObjectSize(indirectObject);
                if (!this.shouldWaitForTick(1))
                  return [3, 3];
                return [4, waitForTick()];
              case 2:
                _a.sent();
                _a.label = 3;
              case 3:
                idx++;
                return [3, 1];
              case 4:
                xrefOffset = size;
                size += xref.sizeInBytes() + 1;
                trailerDict = PDFTrailerDict_default.of(this.createTrailerDict());
                size += trailerDict.sizeInBytes() + 2;
                trailer = PDFTrailer_default.forLastCrossRefSectionOffset(xrefOffset);
                size += trailer.sizeInBytes();
                return [2, { size, header, indirectObjects, xref, trailerDict, trailer }];
            }
          });
        });
      };
      PDFWriter2.forContext = function(context, objectsPerTick) {
        return new PDFWriter2(context, objectsPerTick);
      };
      return PDFWriter2;
    }()
  );
  var PDFWriter_default = PDFWriter;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFInvalidObject.js
  var PDFInvalidObject = (
    /** @class */
    function(_super) {
      __extends(PDFInvalidObject2, _super);
      function PDFInvalidObject2(data) {
        var _this = _super.call(this) || this;
        _this.data = data;
        return _this;
      }
      PDFInvalidObject2.prototype.clone = function() {
        return PDFInvalidObject2.of(this.data.slice());
      };
      PDFInvalidObject2.prototype.toString = function() {
        return "PDFInvalidObject(" + this.data.length + " bytes)";
      };
      PDFInvalidObject2.prototype.sizeInBytes = function() {
        return this.data.length;
      };
      PDFInvalidObject2.prototype.copyBytesInto = function(buffer, offset) {
        var length = this.data.length;
        for (var idx = 0; idx < length; idx++) {
          buffer[offset++] = this.data[idx];
        }
        return length;
      };
      PDFInvalidObject2.of = function(data) {
        return new PDFInvalidObject2(data);
      };
      return PDFInvalidObject2;
    }(PDFObject_default)
  );
  var PDFInvalidObject_default = PDFInvalidObject;

  // node_modules/@pdfme/pdf-lib/es/core/structures/PDFCrossRefStream.js
  var EntryType;
  (function(EntryType2) {
    EntryType2[EntryType2["Deleted"] = 0] = "Deleted";
    EntryType2[EntryType2["Uncompressed"] = 1] = "Uncompressed";
    EntryType2[EntryType2["Compressed"] = 2] = "Compressed";
  })(EntryType || (EntryType = {}));
  var PDFCrossRefStream = (
    /** @class */
    function(_super) {
      __extends(PDFCrossRefStream2, _super);
      function PDFCrossRefStream2(dict, entries, encode) {
        if (encode === void 0) {
          encode = true;
        }
        var _this = _super.call(this, dict, encode) || this;
        _this.computeIndex = function() {
          var subsections = [];
          var subsectionLength = 0;
          for (var idx = 0, len = _this.entries.length; idx < len; idx++) {
            var currEntry = _this.entries[idx];
            var prevEntry = _this.entries[idx - 1];
            if (idx === 0) {
              subsections.push(currEntry.ref.objectNumber);
            } else if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
              subsections.push(subsectionLength);
              subsections.push(currEntry.ref.objectNumber);
              subsectionLength = 0;
            }
            subsectionLength += 1;
          }
          subsections.push(subsectionLength);
          return subsections;
        };
        _this.computeEntryTuples = function() {
          var entryTuples = new Array(_this.entries.length);
          for (var idx = 0, len = _this.entries.length; idx < len; idx++) {
            var entry = _this.entries[idx];
            if (entry.type === EntryType.Deleted) {
              var type = entry.type, nextFreeObjectNumber = entry.nextFreeObjectNumber, ref = entry.ref;
              entryTuples[idx] = [type, nextFreeObjectNumber, ref.generationNumber];
            }
            if (entry.type === EntryType.Uncompressed) {
              var type = entry.type, offset = entry.offset, ref = entry.ref;
              entryTuples[idx] = [type, offset, ref.generationNumber];
            }
            if (entry.type === EntryType.Compressed) {
              var type = entry.type, objectStreamRef = entry.objectStreamRef, index = entry.index;
              entryTuples[idx] = [type, objectStreamRef.objectNumber, index];
            }
          }
          return entryTuples;
        };
        _this.computeMaxEntryByteWidths = function() {
          var entryTuples = _this.entryTuplesCache.access();
          var widths = [0, 0, 0];
          for (var idx = 0, len = entryTuples.length; idx < len; idx++) {
            var _a = entryTuples[idx], first = _a[0], second = _a[1], third = _a[2];
            var firstSize = sizeInBytes(first);
            var secondSize = sizeInBytes(second);
            var thirdSize = sizeInBytes(third);
            if (firstSize > widths[0])
              widths[0] = firstSize;
            if (secondSize > widths[1])
              widths[1] = secondSize;
            if (thirdSize > widths[2])
              widths[2] = thirdSize;
          }
          return widths;
        };
        _this.entries = entries || [];
        _this.entryTuplesCache = Cache_default.populatedBy(_this.computeEntryTuples);
        _this.maxByteWidthsCache = Cache_default.populatedBy(_this.computeMaxEntryByteWidths);
        _this.indexCache = Cache_default.populatedBy(_this.computeIndex);
        dict.set(PDFName_default.of("Type"), PDFName_default.of("XRef"));
        return _this;
      }
      PDFCrossRefStream2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
        var type = EntryType.Deleted;
        this.entries.push({ type, ref, nextFreeObjectNumber });
        this.entryTuplesCache.invalidate();
        this.maxByteWidthsCache.invalidate();
        this.indexCache.invalidate();
        this.contentsCache.invalidate();
      };
      PDFCrossRefStream2.prototype.addUncompressedEntry = function(ref, offset) {
        var type = EntryType.Uncompressed;
        this.entries.push({ type, ref, offset });
        this.entryTuplesCache.invalidate();
        this.maxByteWidthsCache.invalidate();
        this.indexCache.invalidate();
        this.contentsCache.invalidate();
      };
      PDFCrossRefStream2.prototype.addCompressedEntry = function(ref, objectStreamRef, index) {
        var type = EntryType.Compressed;
        this.entries.push({ type, ref, objectStreamRef, index });
        this.entryTuplesCache.invalidate();
        this.maxByteWidthsCache.invalidate();
        this.indexCache.invalidate();
        this.contentsCache.invalidate();
      };
      PDFCrossRefStream2.prototype.clone = function(context) {
        var _a = this, dict = _a.dict, entries = _a.entries, encode = _a.encode;
        return PDFCrossRefStream2.of(dict.clone(context), entries.slice(), encode);
      };
      PDFCrossRefStream2.prototype.getContentsString = function() {
        var entryTuples = this.entryTuplesCache.access();
        var byteWidths = this.maxByteWidthsCache.access();
        var value = "";
        for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
          var _a = entryTuples[entryIdx], first = _a[0], second = _a[1], third = _a[2];
          var firstBytes = reverseArray(bytesFor(first));
          var secondBytes = reverseArray(bytesFor(second));
          var thirdBytes = reverseArray(bytesFor(third));
          for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
            value += (firstBytes[idx] || 0).toString(2);
          }
          for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
            value += (secondBytes[idx] || 0).toString(2);
          }
          for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
            value += (thirdBytes[idx] || 0).toString(2);
          }
        }
        return value;
      };
      PDFCrossRefStream2.prototype.getUnencodedContents = function() {
        var entryTuples = this.entryTuplesCache.access();
        var byteWidths = this.maxByteWidthsCache.access();
        var buffer = new Uint8Array(this.getUnencodedContentsSize());
        var offset = 0;
        for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
          var _a = entryTuples[entryIdx], first = _a[0], second = _a[1], third = _a[2];
          var firstBytes = reverseArray(bytesFor(first));
          var secondBytes = reverseArray(bytesFor(second));
          var thirdBytes = reverseArray(bytesFor(third));
          for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
            buffer[offset++] = firstBytes[idx] || 0;
          }
          for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
            buffer[offset++] = secondBytes[idx] || 0;
          }
          for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
            buffer[offset++] = thirdBytes[idx] || 0;
          }
        }
        return buffer;
      };
      PDFCrossRefStream2.prototype.getUnencodedContentsSize = function() {
        var byteWidths = this.maxByteWidthsCache.access();
        var entryWidth = sum(byteWidths);
        return entryWidth * this.entries.length;
      };
      PDFCrossRefStream2.prototype.updateDict = function() {
        _super.prototype.updateDict.call(this);
        var byteWidths = this.maxByteWidthsCache.access();
        var index = this.indexCache.access();
        var context = this.dict.context;
        this.dict.set(PDFName_default.of("W"), context.obj(byteWidths));
        this.dict.set(PDFName_default.of("Index"), context.obj(index));
      };
      PDFCrossRefStream2.create = function(dict, encode) {
        if (encode === void 0) {
          encode = true;
        }
        var stream2 = new PDFCrossRefStream2(dict, [], encode);
        stream2.addDeletedEntry(PDFRef_default.of(0, 65535), 0);
        return stream2;
      };
      PDFCrossRefStream2.of = function(dict, entries, encode) {
        if (encode === void 0) {
          encode = true;
        }
        return new PDFCrossRefStream2(dict, entries, encode);
      };
      return PDFCrossRefStream2;
    }(PDFFlateStream_default)
  );
  var PDFCrossRefStream_default = PDFCrossRefStream;

  // node_modules/@pdfme/pdf-lib/es/core/writers/PDFStreamWriter.js
  var PDFStreamWriter = (
    /** @class */
    function(_super) {
      __extends(PDFStreamWriter2, _super);
      function PDFStreamWriter2(context, objectsPerTick, encodeStreams, objectsPerStream) {
        var _this = _super.call(this, context, objectsPerTick) || this;
        _this.encodeStreams = encodeStreams;
        _this.objectsPerStream = objectsPerStream;
        return _this;
      }
      PDFStreamWriter2.prototype.computeBufferSize = function() {
        return __awaiter(this, void 0, void 0, function() {
          var objectNumber, header, size, xrefStream, uncompressedObjects, compressedObjects, objectStreamRefs, indirectObjects, idx, len, indirectObject, ref, object, shouldNotCompress, chunk, objectStreamRef, idx, len, chunk, ref, objectStream, xrefStreamRef, xrefOffset, trailer;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                objectNumber = this.context.largestObjectNumber + 1;
                header = PDFHeader_default.forVersion(1, 7);
                size = header.sizeInBytes() + 2;
                xrefStream = PDFCrossRefStream_default.create(this.createTrailerDict(), this.encodeStreams);
                uncompressedObjects = [];
                compressedObjects = [];
                objectStreamRefs = [];
                indirectObjects = this.context.enumerateIndirectObjects();
                idx = 0, len = indirectObjects.length;
                _a.label = 1;
              case 1:
                if (!(idx < len))
                  return [3, 6];
                indirectObject = indirectObjects[idx];
                ref = indirectObject[0], object = indirectObject[1];
                shouldNotCompress = ref === this.context.trailerInfo.Encrypt || object instanceof PDFStream_default || object instanceof PDFInvalidObject_default || ref.generationNumber !== 0;
                if (!shouldNotCompress)
                  return [3, 4];
                uncompressedObjects.push(indirectObject);
                xrefStream.addUncompressedEntry(ref, size);
                size += this.computeIndirectObjectSize(indirectObject);
                if (!this.shouldWaitForTick(1))
                  return [3, 3];
                return [4, waitForTick()];
              case 2:
                _a.sent();
                _a.label = 3;
              case 3:
                return [3, 5];
              case 4:
                chunk = last(compressedObjects);
                objectStreamRef = last(objectStreamRefs);
                if (!chunk || chunk.length % this.objectsPerStream === 0) {
                  chunk = [];
                  compressedObjects.push(chunk);
                  objectStreamRef = PDFRef_default.of(objectNumber++);
                  objectStreamRefs.push(objectStreamRef);
                }
                xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);
                chunk.push(indirectObject);
                _a.label = 5;
              case 5:
                idx++;
                return [3, 1];
              case 6:
                idx = 0, len = compressedObjects.length;
                _a.label = 7;
              case 7:
                if (!(idx < len))
                  return [3, 10];
                chunk = compressedObjects[idx];
                ref = objectStreamRefs[idx];
                objectStream = PDFObjectStream_default.withContextAndObjects(this.context, chunk, this.encodeStreams);
                xrefStream.addUncompressedEntry(ref, size);
                size += this.computeIndirectObjectSize([ref, objectStream]);
                uncompressedObjects.push([ref, objectStream]);
                if (!this.shouldWaitForTick(chunk.length))
                  return [3, 9];
                return [4, waitForTick()];
              case 8:
                _a.sent();
                _a.label = 9;
              case 9:
                idx++;
                return [3, 7];
              case 10:
                xrefStreamRef = PDFRef_default.of(objectNumber++);
                xrefStream.dict.set(PDFName_default.of("Size"), PDFNumber_default.of(objectNumber));
                xrefStream.addUncompressedEntry(xrefStreamRef, size);
                xrefOffset = size;
                size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);
                uncompressedObjects.push([xrefStreamRef, xrefStream]);
                trailer = PDFTrailer_default.forLastCrossRefSectionOffset(xrefOffset);
                size += trailer.sizeInBytes();
                return [2, { size, header, indirectObjects: uncompressedObjects, trailer }];
            }
          });
        });
      };
      PDFStreamWriter2.forContext = function(context, objectsPerTick, encodeStreams, objectsPerStream) {
        if (encodeStreams === void 0) {
          encodeStreams = true;
        }
        if (objectsPerStream === void 0) {
          objectsPerStream = 50;
        }
        return new PDFStreamWriter2(context, objectsPerTick, encodeStreams, objectsPerStream);
      };
      return PDFStreamWriter2;
    }(PDFWriter_default)
  );
  var PDFStreamWriter_default = PDFStreamWriter;

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFHexString.js
  var PDFHexString = (
    /** @class */
    function(_super) {
      __extends(PDFHexString2, _super);
      function PDFHexString2(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        return _this;
      }
      PDFHexString2.prototype.asBytes = function() {
        var hex = this.value + (this.value.length % 2 === 1 ? "0" : "");
        var hexLength = hex.length;
        var bytes = new Uint8Array(hex.length / 2);
        var hexOffset = 0;
        var bytesOffset = 0;
        while (hexOffset < hexLength) {
          var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);
          bytes[bytesOffset] = byte;
          hexOffset += 2;
          bytesOffset += 1;
        }
        return bytes;
      };
      PDFHexString2.prototype.decodeText = function() {
        var bytes = this.asBytes();
        if (hasUtf16BOM(bytes))
          return utf16Decode(bytes);
        return pdfDocEncodingDecode(bytes);
      };
      PDFHexString2.prototype.decodeDate = function() {
        var text = this.decodeText();
        var date = parseDate(text);
        if (!date)
          throw new InvalidPDFDateStringError(text);
        return date;
      };
      PDFHexString2.prototype.asString = function() {
        return this.value;
      };
      PDFHexString2.prototype.clone = function() {
        return PDFHexString2.of(this.value);
      };
      PDFHexString2.prototype.toString = function() {
        return "<" + this.value + ">";
      };
      PDFHexString2.prototype.sizeInBytes = function() {
        return this.value.length + 2;
      };
      PDFHexString2.prototype.copyBytesInto = function(buffer, offset) {
        buffer[offset++] = CharCodes_default.LessThan;
        offset += copyStringIntoBuffer(this.value, buffer, offset);
        buffer[offset++] = CharCodes_default.GreaterThan;
        return this.value.length + 2;
      };
      PDFHexString2.of = function(value) {
        return new PDFHexString2(value);
      };
      PDFHexString2.fromText = function(value) {
        var encoded = utf16Encode(value);
        var hex = "";
        for (var idx = 0, len = encoded.length; idx < len; idx++) {
          hex += toHexStringOfMinLength(encoded[idx], 4);
        }
        return new PDFHexString2(hex);
      };
      return PDFHexString2;
    }(PDFObject_default)
  );
  var PDFHexString_default = PDFHexString;

  // node_modules/@pdfme/pdf-lib/es/core/embedders/StandardFontEmbedder.js
  var StandardFontEmbedder = (
    /** @class */
    function() {
      function StandardFontEmbedder2(fontName, customName) {
        this.encoding = fontName === FontNames.ZapfDingbats ? Encodings.ZapfDingbats : fontName === FontNames.Symbol ? Encodings.Symbol : Encodings.WinAnsi;
        this.font = Font.load(fontName);
        this.fontName = this.font.FontName;
        this.customName = customName;
      }
      StandardFontEmbedder2.prototype.encodeText = function(text) {
        var glyphs = this.encodeTextAsGlyphs(text);
        var hexCodes = new Array(glyphs.length);
        for (var idx = 0, len = glyphs.length; idx < len; idx++) {
          hexCodes[idx] = toHexString(glyphs[idx].code);
        }
        return PDFHexString_default.of(hexCodes.join(""));
      };
      StandardFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
        var glyphs = this.encodeTextAsGlyphs(text);
        var totalWidth = 0;
        for (var idx = 0, len = glyphs.length; idx < len; idx++) {
          var left = glyphs[idx].name;
          var right = (glyphs[idx + 1] || {}).name;
          var kernAmount = this.font.getXAxisKerningForPair(left, right) || 0;
          totalWidth += this.widthOfGlyph(left) + kernAmount;
        }
        var scale2 = size / 1e3;
        return totalWidth * scale2;
      };
      StandardFontEmbedder2.prototype.heightOfFontAtSize = function(size, options) {
        if (options === void 0) {
          options = {};
        }
        var _a = options.descender, descender = _a === void 0 ? true : _a;
        var _b = this.font, Ascender = _b.Ascender, Descender = _b.Descender, FontBBox = _b.FontBBox;
        var yTop = Ascender || FontBBox[3];
        var yBottom = Descender || FontBBox[1];
        var height = yTop - yBottom;
        if (!descender)
          height += Descender || 0;
        return height / 1e3 * size;
      };
      StandardFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
        var _a = this.font, Ascender = _a.Ascender, Descender = _a.Descender, FontBBox = _a.FontBBox;
        var yTop = Ascender || FontBBox[3];
        var yBottom = Descender || FontBBox[1];
        return 1e3 * height / (yTop - yBottom);
      };
      StandardFontEmbedder2.prototype.embedIntoContext = function(context, ref) {
        var fontDict = context.obj({
          Type: "Font",
          Subtype: "Type1",
          BaseFont: this.customName || this.fontName,
          Encoding: this.encoding === Encodings.WinAnsi ? "WinAnsiEncoding" : void 0
        });
        if (ref) {
          context.assign(ref, fontDict);
          return ref;
        } else {
          return context.register(fontDict);
        }
      };
      StandardFontEmbedder2.prototype.widthOfGlyph = function(glyphName) {
        return this.font.getWidthOfGlyph(glyphName) || 250;
      };
      StandardFontEmbedder2.prototype.encodeTextAsGlyphs = function(text) {
        var codePoints = Array.from(text);
        var glyphs = new Array(codePoints.length);
        for (var idx = 0, len = codePoints.length; idx < len; idx++) {
          var codePoint = toCodePoint(codePoints[idx]);
          glyphs[idx] = this.encoding.encodeUnicodeCodePoint(codePoint);
        }
        return glyphs;
      };
      StandardFontEmbedder2.for = function(fontName, customName) {
        return new StandardFontEmbedder2(fontName, customName);
      };
      return StandardFontEmbedder2;
    }()
  );
  var StandardFontEmbedder_default = StandardFontEmbedder;

  // node_modules/@pdfme/pdf-lib/es/core/embedders/CMap.js
  var createCmap = function(glyphs, glyphId) {
    var bfChars = new Array(glyphs.length);
    for (var idx = 0, len = glyphs.length; idx < len; idx++) {
      var glyph = glyphs[idx];
      var id = cmapHexFormat(cmapHexString(glyphId(glyph)));
      var unicode = cmapHexFormat.apply(void 0, glyph.codePoints.map(cmapCodePointFormat));
      bfChars[idx] = [id, unicode];
    }
    return fillCmapTemplate(bfChars);
  };
  var fillCmapTemplate = function(bfChars) {
    return "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n" + bfChars.length + " beginbfchar\n" + bfChars.map(function(_a) {
      var glyphId = _a[0], codePoint = _a[1];
      return glyphId + " " + codePoint;
    }).join("\n") + "\nendbfchar\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  var cmapHexFormat = function() {
    var values2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values2[_i] = arguments[_i];
    }
    return "<" + values2.join("") + ">";
  };
  var cmapHexString = function(value) {
    return toHexStringOfMinLength(value, 4);
  };
  var cmapCodePointFormat = function(codePoint) {
    if (isWithinBMP(codePoint))
      return cmapHexString(codePoint);
    if (hasSurrogates(codePoint)) {
      var hs = highSurrogate(codePoint);
      var ls = lowSurrogate(codePoint);
      return "" + cmapHexString(hs) + cmapHexString(ls);
    }
    var hex = toHexString(codePoint);
    var msg = "0x" + hex + " is not a valid UTF-8 or UTF-16 codepoint.";
    throw new Error(msg);
  };

  // node_modules/@pdfme/pdf-lib/es/core/embedders/FontFlags.js
  var makeFontFlags = function(options) {
    var flags = 0;
    var flipBit = function(bit) {
      flags |= 1 << bit - 1;
    };
    if (options.fixedPitch)
      flipBit(1);
    if (options.serif)
      flipBit(2);
    if (options.symbolic)
      flipBit(3);
    if (options.script)
      flipBit(4);
    if (options.nonsymbolic)
      flipBit(6);
    if (options.italic)
      flipBit(7);
    if (options.allCap)
      flipBit(17);
    if (options.smallCap)
      flipBit(18);
    if (options.forceBold)
      flipBit(19);
    return flags;
  };
  var deriveFontFlags = function(font) {
    var familyClass = font["OS/2"] ? font["OS/2"].sFamilyClass : 0;
    var flags = makeFontFlags({
      fixedPitch: font.post.isFixedPitch,
      serif: 1 <= familyClass && familyClass <= 7,
      symbolic: true,
      script: familyClass === 10,
      italic: font.head.macStyle.italic
    });
    return flags;
  };

  // node_modules/@pdfme/pdf-lib/es/core/objects/PDFString.js
  var PDFString = (
    /** @class */
    function(_super) {
      __extends(PDFString2, _super);
      function PDFString2(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        return _this;
      }
      PDFString2.prototype.asBytes = function() {
        var bytes = [];
        var octal = "";
        var escaped = false;
        var pushByte = function(byte2) {
          if (byte2 !== void 0)
            bytes.push(byte2);
          escaped = false;
        };
        for (var idx = 0, len = this.value.length; idx < len; idx++) {
          var char = this.value[idx];
          var byte = toCharCode(char);
          var nextChar = this.value[idx + 1];
          if (!escaped) {
            if (byte === CharCodes_default.BackSlash)
              escaped = true;
            else
              pushByte(byte);
          } else {
            if (byte === CharCodes_default.Newline)
              pushByte();
            else if (byte === CharCodes_default.CarriageReturn)
              pushByte();
            else if (byte === CharCodes_default.n)
              pushByte(CharCodes_default.Newline);
            else if (byte === CharCodes_default.r)
              pushByte(CharCodes_default.CarriageReturn);
            else if (byte === CharCodes_default.t)
              pushByte(CharCodes_default.Tab);
            else if (byte === CharCodes_default.b)
              pushByte(CharCodes_default.Backspace);
            else if (byte === CharCodes_default.f)
              pushByte(CharCodes_default.FormFeed);
            else if (byte === CharCodes_default.LeftParen)
              pushByte(CharCodes_default.LeftParen);
            else if (byte === CharCodes_default.RightParen)
              pushByte(CharCodes_default.RightParen);
            else if (byte === CharCodes_default.Backspace)
              pushByte(CharCodes_default.BackSlash);
            else if (byte >= CharCodes_default.Zero && byte <= CharCodes_default.Seven) {
              octal += char;
              if (octal.length === 3 || !(nextChar >= "0" && nextChar <= "7")) {
                pushByte(parseInt(octal, 8));
                octal = "";
              }
            } else {
              pushByte(byte);
            }
          }
        }
        return new Uint8Array(bytes);
      };
      PDFString2.prototype.decodeText = function() {
        var bytes = this.asBytes();
        if (hasUtf16BOM(bytes))
          return utf16Decode(bytes);
        return pdfDocEncodingDecode(bytes);
      };
      PDFString2.prototype.decodeDate = function() {
        var text = this.decodeText();
        var date = parseDate(text);
        if (!date)
          throw new InvalidPDFDateStringError(text);
        return date;
      };
      PDFString2.prototype.asString = function() {
        return this.value;
      };
      PDFString2.prototype.clone = function() {
        return PDFString2.of(this.value);
      };
      PDFString2.prototype.toString = function() {
        return "(" + this.value + ")";
      };
      PDFString2.prototype.sizeInBytes = function() {
        return this.value.length + 2;
      };
      PDFString2.prototype.copyBytesInto = function(buffer, offset) {
        buffer[offset++] = CharCodes_default.LeftParen;
        offset += copyStringIntoBuffer(this.value, buffer, offset);
        buffer[offset++] = CharCodes_default.RightParen;
        return this.value.length + 2;
      };
      PDFString2.of = function(value) {
        return new PDFString2(value);
      };
      PDFString2.fromDate = function(date) {
        var year = padStart(String(date.getUTCFullYear()), 4, "0");
        var month = padStart(String(date.getUTCMonth() + 1), 2, "0");
        var day = padStart(String(date.getUTCDate()), 2, "0");
        var hours = padStart(String(date.getUTCHours()), 2, "0");
        var mins = padStart(String(date.getUTCMinutes()), 2, "0");
        var secs = padStart(String(date.getUTCSeconds()), 2, "0");
        return new PDFString2("D:" + year + month + day + hours + mins + secs + "Z");
      };
      return PDFString2;
    }(PDFObject_default)
  );
  var PDFString_default = PDFString;

  // node_modules/@pdfme/pdf-lib/es/core/embedders/CustomFontEmbedder.js
  var CustomFontEmbedder = (
    /** @class */
    function() {
      function CustomFontEmbedder2(font, fontData, customName, fontFeatures) {
        var _this = this;
        this.allGlyphsInFontSortedById = function() {
          var glyphs = new Array(_this.font.characterSet.length);
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            var codePoint = _this.font.characterSet[idx];
            glyphs[idx] = _this.font.glyphForCodePoint(codePoint);
          }
          return sortedUniq(glyphs.sort(byAscendingId), function(g) {
            return g.id;
          });
        };
        this.font = font;
        this.scale = 1e3 / this.font.unitsPerEm;
        this.fontData = fontData;
        this.fontName = this.font.postscriptName || "Font";
        this.customName = customName;
        this.fontFeatures = fontFeatures;
        this.baseFontName = "";
        this.glyphCache = Cache_default.populatedBy(this.allGlyphsInFontSortedById);
      }
      CustomFontEmbedder2.for = function(fontkit, fontData, customName, fontFeatures) {
        return __awaiter(this, void 0, void 0, function() {
          var font;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, fontkit.create(fontData)];
              case 1:
                font = _a.sent();
                return [2, new CustomFontEmbedder2(font, fontData, customName, fontFeatures)];
            }
          });
        });
      };
      CustomFontEmbedder2.prototype.encodeText = function(text) {
        var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
        var hexCodes = new Array(glyphs.length);
        for (var idx = 0, len = glyphs.length; idx < len; idx++) {
          hexCodes[idx] = toHexStringOfMinLength(glyphs[idx].id, 4);
        }
        return PDFHexString_default.of(hexCodes.join(""));
      };
      CustomFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
        var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
        var totalWidth = 0;
        for (var idx = 0, len = glyphs.length; idx < len; idx++) {
          totalWidth += glyphs[idx].advanceWidth * this.scale;
        }
        var scale2 = size / 1e3;
        return totalWidth * scale2;
      };
      CustomFontEmbedder2.prototype.heightOfFontAtSize = function(size, options) {
        if (options === void 0) {
          options = {};
        }
        var _a = options.descender, descender = _a === void 0 ? true : _a;
        var _b = this.font, ascent = _b.ascent, descent = _b.descent, bbox = _b.bbox;
        var yTop = (ascent || bbox.maxY) * this.scale;
        var yBottom = (descent || bbox.minY) * this.scale;
        var height = yTop - yBottom;
        if (!descender)
          height -= Math.abs(descent) || 0;
        return height / 1e3 * size;
      };
      CustomFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
        var _a = this.font, ascent = _a.ascent, descent = _a.descent, bbox = _a.bbox;
        var yTop = (ascent || bbox.maxY) * this.scale;
        var yBottom = (descent || bbox.minY) * this.scale;
        return 1e3 * height / (yTop - yBottom);
      };
      CustomFontEmbedder2.prototype.embedIntoContext = function(context, ref) {
        this.baseFontName = this.customName || context.addRandomSuffix(this.fontName);
        return this.embedFontDict(context, ref);
      };
      CustomFontEmbedder2.prototype.embedFontDict = function(context, ref) {
        return __awaiter(this, void 0, void 0, function() {
          var cidFontDictRef, unicodeCMapRef, fontDict;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.embedCIDFontDict(context)];
              case 1:
                cidFontDictRef = _a.sent();
                unicodeCMapRef = this.embedUnicodeCmap(context);
                fontDict = context.obj({
                  Type: "Font",
                  Subtype: "Type0",
                  BaseFont: this.baseFontName,
                  Encoding: "Identity-H",
                  DescendantFonts: [cidFontDictRef],
                  ToUnicode: unicodeCMapRef
                });
                if (ref) {
                  context.assign(ref, fontDict);
                  return [2, ref];
                } else {
                  return [2, context.register(fontDict)];
                }
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CustomFontEmbedder2.prototype.isCFF = function() {
        return this.font.cff;
      };
      CustomFontEmbedder2.prototype.embedCIDFontDict = function(context) {
        return __awaiter(this, void 0, void 0, function() {
          var fontDescriptorRef, cidFontDict;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.embedFontDescriptor(context)];
              case 1:
                fontDescriptorRef = _a.sent();
                cidFontDict = context.obj({
                  Type: "Font",
                  Subtype: this.isCFF() ? "CIDFontType0" : "CIDFontType2",
                  CIDToGIDMap: "Identity",
                  BaseFont: this.baseFontName,
                  CIDSystemInfo: {
                    Registry: PDFString_default.of("Adobe"),
                    Ordering: PDFString_default.of("Identity"),
                    Supplement: 0
                  },
                  FontDescriptor: fontDescriptorRef,
                  W: this.computeWidths()
                });
                return [2, context.register(cidFontDict)];
            }
          });
        });
      };
      CustomFontEmbedder2.prototype.embedFontDescriptor = function(context) {
        return __awaiter(this, void 0, void 0, function() {
          var fontStreamRef, scale2, _a, italicAngle, ascent, descent, capHeight, xHeight, _b, minX, minY, maxX, maxY, fontDescriptor;
          var _c;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, this.embedFontStream(context)];
              case 1:
                fontStreamRef = _d.sent();
                scale2 = this.scale;
                _a = this.font, italicAngle = _a.italicAngle, ascent = _a.ascent, descent = _a.descent, capHeight = _a.capHeight, xHeight = _a.xHeight;
                _b = this.font.bbox, minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
                fontDescriptor = context.obj((_c = {
                  Type: "FontDescriptor",
                  FontName: this.baseFontName,
                  Flags: deriveFontFlags(this.font),
                  FontBBox: [minX * scale2, minY * scale2, maxX * scale2, maxY * scale2],
                  ItalicAngle: italicAngle,
                  Ascent: ascent * scale2,
                  Descent: descent * scale2,
                  CapHeight: (capHeight || ascent) * scale2,
                  XHeight: (xHeight || 0) * scale2,
                  // Not sure how to compute/find this, nor is anybody else really:
                  // https://stackoverflow.com/questions/35485179/stemv-value-of-the-truetype-font
                  StemV: 0
                }, _c[this.isCFF() ? "FontFile3" : "FontFile2"] = fontStreamRef, _c));
                return [2, context.register(fontDescriptor)];
            }
          });
        });
      };
      CustomFontEmbedder2.prototype.serializeFont = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.fontData];
          });
        });
      };
      CustomFontEmbedder2.prototype.embedFontStream = function(context) {
        return __awaiter(this, void 0, void 0, function() {
          var fontStream, _a, _b;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                _b = (_a = context).flateStream;
                return [4, this.serializeFont()];
              case 1:
                fontStream = _b.apply(_a, [_c.sent(), {
                  Subtype: this.isCFF() ? "CIDFontType0C" : void 0
                }]);
                return [2, context.register(fontStream)];
            }
          });
        });
      };
      CustomFontEmbedder2.prototype.embedUnicodeCmap = function(context) {
        var cmap = createCmap(this.glyphCache.access(), this.glyphId.bind(this));
        var cmapStream = context.flateStream(cmap);
        return context.register(cmapStream);
      };
      CustomFontEmbedder2.prototype.glyphId = function(glyph) {
        return glyph ? glyph.id : -1;
      };
      CustomFontEmbedder2.prototype.computeWidths = function() {
        var glyphs = this.glyphCache.access();
        var widths = [];
        var currSection = [];
        for (var idx = 0, len = glyphs.length; idx < len; idx++) {
          var currGlyph = glyphs[idx];
          var prevGlyph = glyphs[idx - 1];
          var currGlyphId = this.glyphId(currGlyph);
          var prevGlyphId = this.glyphId(prevGlyph);
          if (idx === 0) {
            widths.push(currGlyphId);
          } else if (currGlyphId - prevGlyphId !== 1) {
            widths.push(currSection);
            widths.push(currGlyphId);
            currSection = [];
          }
          currSection.push(currGlyph.advanceWidth * this.scale);
        }
        widths.push(currSection);
        return widths;
      };
      return CustomFontEmbedder2;
    }()
  );
  var CustomFontEmbedder_default = CustomFontEmbedder;

  // node_modules/@pdfme/pdf-lib/es/core/embedders/CustomFontSubsetEmbedder.js
  var CustomFontSubsetEmbedder = (
    /** @class */
    function(_super) {
      __extends(CustomFontSubsetEmbedder2, _super);
      function CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures) {
        var _this = _super.call(this, font, fontData, customFontName, fontFeatures) || this;
        _this.subset = _this.font.createSubset();
        _this.glyphs = [];
        _this.glyphCache = Cache_default.populatedBy(function() {
          return _this.glyphs;
        });
        _this.glyphIdMap = /* @__PURE__ */ new Map();
        return _this;
      }
      CustomFontSubsetEmbedder2.for = function(fontkit, fontData, customFontName, fontFeatures) {
        return __awaiter(this, void 0, void 0, function() {
          var font;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, fontkit.create(fontData)];
              case 1:
                font = _a.sent();
                return [2, new CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures)];
            }
          });
        });
      };
      CustomFontSubsetEmbedder2.prototype.encodeText = function(text) {
        var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
        var hexCodes = new Array(glyphs.length);
        for (var idx = 0, len = glyphs.length; idx < len; idx++) {
          var glyph = glyphs[idx];
          var subsetGlyphId = this.subset.includeGlyph(glyph);
          this.glyphs[subsetGlyphId - 1] = glyph;
          this.glyphIdMap.set(glyph.id, subsetGlyphId);
          hexCodes[idx] = toHexStringOfMinLength(subsetGlyphId, 4);
        }
        this.glyphCache.invalidate();
        return PDFHexString_default.of(hexCodes.join(""));
      };
      CustomFontSubsetEmbedder2.prototype.isCFF = function() {
        return this.subset.cff;
      };
      CustomFontSubsetEmbedder2.prototype.glyphId = function(glyph) {
        return glyph ? this.glyphIdMap.get(glyph.id) : -1;
      };
      CustomFontSubsetEmbedder2.prototype.serializeFont = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          if ("encodeStream" in _this.subset) {
            var parts_1 = [];
            _this.subset.encodeStream().on("data", function(bytes) {
              return parts_1.push(bytes);
            }).on("end", function() {
              return resolve(mergeUint8Arrays(parts_1));
            }).on("error", function(err) {
              return reject(err);
            });
          } else if ("encode" in _this.subset) {
            try {
              resolve(_this.subset.encode());
            } catch (err) {
              reject(err);
            }
          } else {
            reject(new Error("Subset does not have an encode method"));
          }
        });
      };
      return CustomFontSubsetEmbedder2;
    }(CustomFontEmbedder_default)
  );
  var CustomFontSubsetEmbedder_default = CustomFontSubsetEmbedder;

  // node_modules/@pdfme/pdf-lib/es/core/embedders/FileEmbedder.js
  var AFRelationship;
  (function(AFRelationship2) {
    AFRelationship2["Source"] = "Source";
    AFRelationship2["Data"] = "Data";
    AFRelationship2["Alternative"] = "Alternative";
    AFRelationship2["Supplement"] = "Supplement";
    AFRelationship2["EncryptedPayload"] = "EncryptedPayload";
    AFRelationship2["FormData"] = "EncryptedPayload";
    AFRelationship2["Schema"] = "Schema";
    AFRelationship2["Unspecified"] = "Unspecified";
  })(AFRelationship || (AFRelationship = {}));
  var FileEmbedder = (
    /** @class */
    function() {
      function FileEmbedder2(fileData, fileName, options) {
        if (options === void 0) {
          options = {};
        }
        this.fileData = fileData;
        this.fileName = fileName;
        this.options = options;
      }
      FileEmbedder2.for = function(bytes, fileName, options) {
        if (options === void 0) {
          options = {};
        }
        return new FileEmbedder2(bytes, fileName, options);
      };
      FileEmbedder2.prototype.embedIntoContext = function(context, ref) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, mimeType, description, creationDate, modificationDate, afRelationship, embeddedFileStream, embeddedFileStreamRef, fileSpecDict;
          return __generator(this, function(_b) {
            _a = this.options, mimeType = _a.mimeType, description = _a.description, creationDate = _a.creationDate, modificationDate = _a.modificationDate, afRelationship = _a.afRelationship;
            embeddedFileStream = context.flateStream(this.fileData, {
              Type: "EmbeddedFile",
              Subtype: mimeType !== null && mimeType !== void 0 ? mimeType : void 0,
              Params: {
                Size: this.fileData.length,
                CreationDate: creationDate ? PDFString_default.fromDate(creationDate) : void 0,
                ModDate: modificationDate ? PDFString_default.fromDate(modificationDate) : void 0
              }
            });
            embeddedFileStreamRef = context.register(embeddedFileStream);
            fileSpecDict = context.obj({
              Type: "Filespec",
              F: PDFString_default.of(this.fileName),
              UF: PDFHexString_default.fromText(this.fileName),
              EF: { F: embeddedFileStreamRef },
              Desc: description ? PDFHexString_default.fromText(description) : void 0,
              AFRelationship: afRelationship !== null && afRelationship !== void 0 ? afRelationship : void 0
            });
            if (ref) {
              context.assign(ref, fileSpecDict);
              return [2, ref];
            } else {
              return [2, context.register(fileSpecDict)];
            }
            return [
              2
              /*return*/
            ];
          });
        });
      };
      return FileEmbedder2;
    }()
  );
  var FileEmbedder_default = FileEmbedder;

  // node_modules/@pdfme/pdf-lib/es/core/embedders/JpegEmbedder.js
  var MARKERS = [
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65480,
    65481,
    65482,
    65483,
    65484,
    65485,
    65486,
    65487
  ];
  var ColorSpace;
  (function(ColorSpace2) {
    ColorSpace2["DeviceGray"] = "DeviceGray";
    ColorSpace2["DeviceRGB"] = "DeviceRGB";
    ColorSpace2["DeviceCMYK"] = "DeviceCMYK";
  })(ColorSpace || (ColorSpace = {}));
  var ChannelToColorSpace = {
    1: ColorSpace.DeviceGray,
    3: ColorSpace.DeviceRGB,
    4: ColorSpace.DeviceCMYK
  };
  var JpegEmbedder = (
    /** @class */
    function() {
      function JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace) {
        this.imageData = imageData;
        this.bitsPerComponent = bitsPerComponent;
        this.width = width;
        this.height = height;
        this.colorSpace = colorSpace;
      }
      JpegEmbedder2.for = function(imageData) {
        return __awaiter(this, void 0, void 0, function() {
          var dataView, soi, pos, marker, bitsPerComponent, height, width, channelByte, channelName, colorSpace;
          return __generator(this, function(_a) {
            dataView = new DataView(imageData.buffer);
            soi = dataView.getUint16(0);
            if (soi !== 65496)
              throw new Error("SOI not found in JPEG");
            pos = 2;
            while (pos < dataView.byteLength) {
              marker = dataView.getUint16(pos);
              pos += 2;
              if (MARKERS.includes(marker))
                break;
              pos += dataView.getUint16(pos);
            }
            if (!MARKERS.includes(marker))
              throw new Error("Invalid JPEG");
            pos += 2;
            bitsPerComponent = dataView.getUint8(pos++);
            height = dataView.getUint16(pos);
            pos += 2;
            width = dataView.getUint16(pos);
            pos += 2;
            channelByte = dataView.getUint8(pos++);
            channelName = ChannelToColorSpace[channelByte];
            if (!channelName)
              throw new Error("Unknown JPEG channel.");
            colorSpace = channelName;
            return [2, new JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace)];
          });
        });
      };
      JpegEmbedder2.prototype.embedIntoContext = function(context, ref) {
        return __awaiter(this, void 0, void 0, function() {
          var xObject;
          return __generator(this, function(_a) {
            xObject = context.stream(this.imageData, {
              Type: "XObject",
              Subtype: "Image",
              BitsPerComponent: this.bitsPerComponent,
              Width: this.width,
              Height: this.height,
              ColorSpace: this.colorSpace,
              Filter: "DCTDecode",
              // CMYK JPEG streams in PDF are typically stored complemented,
              // with 1 as 'off' and 0 as 'on' (PDF 32000-1:2008, 8.6.4.4).
              //
              // Standalone CMYK JPEG (usually exported by Photoshop) are
              // stored inverse, with 0 as 'off' and 1 as 'on', like RGB.
              //
              // Applying a swap here as a hedge that most bytes passing
              // through this method will benefit from it.
              Decode: this.colorSpace === ColorSpace.DeviceCMYK ? [1, 0, 1, 0, 1, 0, 1, 0] : void 0
            });
            if (ref) {
              context.assign(ref, xObject);
              return [2, ref];
            } else {
              return [2, context.register(xObject)];
            }
            return [
              2
              /*return*/
            ];
          });
        });
      };
      return JpegEmbedder2;
    }()
  );
  var JpegEmbedder_default = JpegEmbedder;

  // node_modules/@pdf-lib/upng/UPNG.js
  var import_pako4 = __toESM(require_pako());
  var UPNG = {};
  UPNG.toRGBA8 = function(out) {
    var w = out.width, h = out.height;
    if (out.tabs.acTL == null)
      return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];
    var frms = [];
    if (out.frames[0].data == null)
      out.frames[0].data = out.data;
    var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
    for (var i = 0; i < out.frames.length; i++) {
      var frm = out.frames[i];
      var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
      var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);
      if (i != 0)
        for (var j = 0; j < len; j++)
          prev[j] = img[j];
      if (frm.blend == 0)
        UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
      else if (frm.blend == 1)
        UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
      frms.push(img.buffer.slice(0));
      if (frm.dispose == 0) {
      } else if (frm.dispose == 1)
        UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
      else if (frm.dispose == 2)
        for (var j = 0; j < len; j++)
          img[j] = prev[j];
    }
    return frms;
  };
  UPNG.toRGBA8.decodeImage = function(data, w, h, out) {
    var area = w * h, bpp = UPNG.decode._getBPP(out);
    var bpl = Math.ceil(w * bpp / 8);
    var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
    var ctype = out.ctype, depth = out.depth;
    var rs = UPNG._bin.readUshort;
    var time = Date.now();
    if (ctype == 6) {
      var qarea = area << 2;
      if (depth == 8)
        for (var i = 0; i < qarea; i += 4) {
          bf[i] = data[i];
          bf[i + 1] = data[i + 1];
          bf[i + 2] = data[i + 2];
          bf[i + 3] = data[i + 3];
        }
      if (depth == 16)
        for (var i = 0; i < qarea; i++) {
          bf[i] = data[i << 1];
        }
    } else if (ctype == 2) {
      var ts = out.tabs["tRNS"];
      if (ts == null) {
        if (depth == 8)
          for (var i = 0; i < area; i++) {
            var ti = i * 3;
            bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
          }
        if (depth == 16)
          for (var i = 0; i < area; i++) {
            var ti = i * 6;
            bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
          }
      } else {
        var tr = ts[0], tg = ts[1], tb = ts[2];
        if (depth == 8)
          for (var i = 0; i < area; i++) {
            var qi = i << 2, ti = i * 3;
            bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
            if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
              bf[qi + 3] = 0;
          }
        if (depth == 16)
          for (var i = 0; i < area; i++) {
            var qi = i << 2, ti = i * 6;
            bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
            if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
              bf[qi + 3] = 0;
          }
      }
    } else if (ctype == 3) {
      var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
      if (depth == 1)
        for (var y = 0; y < h; y++) {
          var s0 = y * bpl, t0 = y * w;
          for (var i = 0; i < w; i++) {
            var qi = t0 + i << 2, j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;
            bf[qi] = p[cj];
            bf[qi + 1] = p[cj + 1];
            bf[qi + 2] = p[cj + 2];
            bf[qi + 3] = j < tl ? ap[j] : 255;
          }
        }
      if (depth == 2)
        for (var y = 0; y < h; y++) {
          var s0 = y * bpl, t0 = y * w;
          for (var i = 0; i < w; i++) {
            var qi = t0 + i << 2, j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;
            bf[qi] = p[cj];
            bf[qi + 1] = p[cj + 1];
            bf[qi + 2] = p[cj + 2];
            bf[qi + 3] = j < tl ? ap[j] : 255;
          }
        }
      if (depth == 4)
        for (var y = 0; y < h; y++) {
          var s0 = y * bpl, t0 = y * w;
          for (var i = 0; i < w; i++) {
            var qi = t0 + i << 2, j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;
            bf[qi] = p[cj];
            bf[qi + 1] = p[cj + 1];
            bf[qi + 2] = p[cj + 2];
            bf[qi + 3] = j < tl ? ap[j] : 255;
          }
        }
      if (depth == 8)
        for (var i = 0; i < area; i++) {
          var qi = i << 2, j = data[i], cj = 3 * j;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j < tl ? ap[j] : 255;
        }
    } else if (ctype == 4) {
      if (depth == 8)
        for (var i = 0; i < area; i++) {
          var qi = i << 2, di = i << 1, gr = data[di];
          bf[qi] = gr;
          bf[qi + 1] = gr;
          bf[qi + 2] = gr;
          bf[qi + 3] = data[di + 1];
        }
      if (depth == 16)
        for (var i = 0; i < area; i++) {
          var qi = i << 2, di = i << 2, gr = data[di];
          bf[qi] = gr;
          bf[qi + 1] = gr;
          bf[qi + 2] = gr;
          bf[qi + 3] = data[di + 2];
        }
    } else if (ctype == 0) {
      var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
      for (var y = 0; y < h; y++) {
        var off = y * bpl, to = y * w;
        if (depth == 1)
          for (var x = 0; x < w; x++) {
            var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
          }
        else if (depth == 2)
          for (var x = 0; x < w; x++) {
            var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
          }
        else if (depth == 4)
          for (var x = 0; x < w; x++) {
            var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
          }
        else if (depth == 8)
          for (var x = 0; x < w; x++) {
            var gr = data[off + x], al = gr == tr ? 0 : 255;
            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
          }
        else if (depth == 16)
          for (var x = 0; x < w; x++) {
            var gr = data[off + (x << 1)], al = rs(data, off + (x << i)) == tr ? 0 : 255;
            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
          }
      }
    }
    return bf;
  };
  UPNG.decode = function(buff) {
    var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
    var out = { tabs: {}, frames: [] };
    var dd = new Uint8Array(data.length), doff = 0;
    var fd, foff = 0;
    var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
    for (var i = 0; i < 8; i++)
      if (data[i] != mgck[i])
        throw "The input is not a PNG file!";
    while (offset < data.length) {
      var len = bin.readUint(data, offset);
      offset += 4;
      var type = bin.readASCII(data, offset, 4);
      offset += 4;
      if (type == "IHDR") {
        UPNG.decode._IHDR(data, offset, out);
      } else if (type == "IDAT") {
        for (var i = 0; i < len; i++)
          dd[doff + i] = data[offset + i];
        doff += len;
      } else if (type == "acTL") {
        out.tabs[type] = { num_frames: rUi(data, offset), num_plays: rUi(data, offset + 4) };
        fd = new Uint8Array(data.length);
      } else if (type == "fcTL") {
        if (foff != 0) {
          var fr = out.frames[out.frames.length - 1];
          fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
          foff = 0;
        }
        var rct = { x: rUi(data, offset + 12), y: rUi(data, offset + 16), width: rUi(data, offset + 4), height: rUi(data, offset + 8) };
        var del = rUs(data, offset + 22);
        del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
        var frm = { rect: rct, delay: Math.round(del * 1e3), dispose: data[offset + 24], blend: data[offset + 25] };
        out.frames.push(frm);
      } else if (type == "fdAT") {
        for (var i = 0; i < len - 4; i++)
          fd[foff + i] = data[offset + i + 4];
        foff += len - 4;
      } else if (type == "pHYs") {
        out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];
      } else if (type == "cHRM") {
        out.tabs[type] = [];
        for (var i = 0; i < 8; i++)
          out.tabs[type].push(bin.readUint(data, offset + i * 4));
      } else if (type == "tEXt") {
        if (out.tabs[type] == null)
          out.tabs[type] = {};
        var nz = bin.nextZero(data, offset);
        var keyw = bin.readASCII(data, offset, nz - offset);
        var text = bin.readASCII(data, nz + 1, offset + len - nz - 1);
        out.tabs[type][keyw] = text;
      } else if (type == "iTXt") {
        if (out.tabs[type] == null)
          out.tabs[type] = {};
        var nz = 0, off = offset;
        nz = bin.nextZero(data, off);
        var keyw = bin.readASCII(data, off, nz - off);
        off = nz + 1;
        var cflag = data[off], cmeth = data[off + 1];
        off += 2;
        nz = bin.nextZero(data, off);
        var ltag = bin.readASCII(data, off, nz - off);
        off = nz + 1;
        nz = bin.nextZero(data, off);
        var tkeyw = bin.readUTF8(data, off, nz - off);
        off = nz + 1;
        var text = bin.readUTF8(data, off, len - (off - offset));
        out.tabs[type][keyw] = text;
      } else if (type == "PLTE") {
        out.tabs[type] = bin.readBytes(data, offset, len);
      } else if (type == "hIST") {
        var pl = out.tabs["PLTE"].length / 3;
        out.tabs[type] = [];
        for (var i = 0; i < pl; i++)
          out.tabs[type].push(rUs(data, offset + i * 2));
      } else if (type == "tRNS") {
        if (out.ctype == 3)
          out.tabs[type] = bin.readBytes(data, offset, len);
        else if (out.ctype == 0)
          out.tabs[type] = rUs(data, offset);
        else if (out.ctype == 2)
          out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
      } else if (type == "gAMA")
        out.tabs[type] = bin.readUint(data, offset) / 1e5;
      else if (type == "sRGB")
        out.tabs[type] = data[offset];
      else if (type == "bKGD") {
        if (out.ctype == 0 || out.ctype == 4)
          out.tabs[type] = [rUs(data, offset)];
        else if (out.ctype == 2 || out.ctype == 6)
          out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
        else if (out.ctype == 3)
          out.tabs[type] = data[offset];
      } else if (type == "IEND") {
        break;
      }
      offset += len;
      var crc = bin.readUint(data, offset);
      offset += 4;
    }
    if (foff != 0) {
      var fr = out.frames[out.frames.length - 1];
      fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
      foff = 0;
    }
    out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
    delete out.compress;
    delete out.interlace;
    delete out.filter;
    return out;
  };
  UPNG.decode._decompress = function(out, dd, w, h) {
    var time = Date.now();
    var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
    dd = UPNG.decode._inflate(dd, buff);
    var time = Date.now();
    if (out.interlace == 0)
      dd = UPNG.decode._filterZero(dd, out, 0, w, h);
    else if (out.interlace == 1)
      dd = UPNG.decode._readInterlace(dd, out);
    return dd;
  };
  UPNG.decode._inflate = function(data, buff) {
    var out = UPNG["inflateRaw"](new Uint8Array(data.buffer, 2, data.length - 6), buff);
    return out;
  };
  UPNG.inflateRaw = function() {
    var H = {};
    H.H = {};
    H.H.N = function(N, W) {
      var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C;
      if (N[0] == 3 && N[1] == 0)
        return W ? W : new R(0);
      var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null;
      if (Z)
        W = new R(N.length >>> 2 << 3);
      while (i == 0) {
        i = n(N, d, 1);
        m = n(N, d + 1, 2);
        d += 3;
        if (m == 0) {
          if ((d & 7) != 0)
            d += 8 - (d & 7);
          var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;
          if (Z)
            W = H.H.W(W, w + q);
          W.set(new R(N.buffer, N.byteOffset + D, q), w);
          d = D + q << 3;
          w += q;
          continue;
        }
        if (Z)
          W = H.H.W(W, w + (1 << 17));
        if (m == 1) {
          v = b.J;
          C = b.h;
          X = (1 << 9) - 1;
          u = (1 << 5) - 1;
        }
        if (m == 2) {
          J = A(N, d, 5) + 257;
          h = A(N, d + 5, 5) + 1;
          Q = A(N, d + 10, 4) + 4;
          d += 14;
          var E = d, j = 1;
          for (var c = 0; c < 38; c += 2) {
            b.Q[c] = 0;
            b.Q[c + 1] = 0;
          }
          for (var c = 0; c < Q; c++) {
            var K = A(N, d + c * 3, 3);
            b.Q[(b.X[c] << 1) + 1] = K;
            if (K > j)
              j = K;
          }
          d += 3 * Q;
          M(b.Q, j);
          I(b.Q, j, b.u);
          v = b.w;
          C = b.d;
          d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);
          var r = V.V(b.v, 0, J, b.C);
          X = (1 << r) - 1;
          var S = V.V(b.v, J, h, b.D);
          u = (1 << S) - 1;
          M(b.C, r);
          I(b.C, r, v);
          M(b.D, S);
          I(b.D, S, C);
        }
        while (true) {
          var T = v[e(N, d) & X];
          d += T & 15;
          var p = T >>> 4;
          if (p >>> 8 == 0) {
            W[w++] = p;
          } else if (p == 256) {
            break;
          } else {
            var z2 = w + p - 254;
            if (p > 264) {
              var _ = b.q[p - 257];
              z2 = w + (_ >>> 3) + A(N, d, _ & 7);
              d += _ & 7;
            }
            var $ = C[e(N, d) & u];
            d += $ & 15;
            var s = $ >>> 4, Y = b.c[s], a = (Y >>> 4) + n(N, d, Y & 15);
            d += Y & 15;
            while (w < z2) {
              W[w] = W[w++ - a];
              W[w] = W[w++ - a];
              W[w] = W[w++ - a];
              W[w] = W[w++ - a];
            }
            w = z2;
          }
        }
      }
      return W.length == w ? W : W.slice(0, w);
    };
    H.H.W = function(N, W) {
      var R = N.length;
      if (W <= R)
        return N;
      var V = new Uint8Array(R << 1);
      V.set(N, 0);
      return V;
    };
    H.H.R = function(N, W, R, V, n, A) {
      var l = H.H.e, M = H.H.Z, I = 0;
      while (I < R) {
        var e = N[M(V, n) & W];
        n += e & 15;
        var b = e >>> 4;
        if (b <= 15) {
          A[I] = b;
          I++;
        } else {
          var Z = 0, m = 0;
          if (b == 16) {
            m = 3 + l(V, n, 2);
            n += 2;
            Z = A[I - 1];
          } else if (b == 17) {
            m = 3 + l(V, n, 3);
            n += 3;
          } else if (b == 18) {
            m = 11 + l(V, n, 7);
            n += 7;
          }
          var J = I + m;
          while (I < J) {
            A[I] = Z;
            I++;
          }
        }
      }
      return n;
    };
    H.H.V = function(N, W, R, V) {
      var n = 0, A = 0, l = V.length >>> 1;
      while (A < R) {
        var M = N[A + W];
        V[A << 1] = 0;
        V[(A << 1) + 1] = M;
        if (M > n)
          n = M;
        A++;
      }
      while (A < l) {
        V[A << 1] = 0;
        V[(A << 1) + 1] = 0;
        A++;
      }
      return n;
    };
    H.H.n = function(N, W) {
      var R = H.H.m, V = N.length, n, A, l, M, I, e = R.j;
      for (var M = 0; M <= W; M++)
        e[M] = 0;
      for (M = 1; M < V; M += 2)
        e[N[M]]++;
      var b = R.K;
      n = 0;
      e[0] = 0;
      for (A = 1; A <= W; A++) {
        n = n + e[A - 1] << 1;
        b[A] = n;
      }
      for (l = 0; l < V; l += 2) {
        I = N[l + 1];
        if (I != 0) {
          N[l] = b[I];
          b[I]++;
        }
      }
    };
    H.H.A = function(N, W, R) {
      var V = N.length, n = H.H.m, A = n.r;
      for (var l = 0; l < V; l += 2)
        if (N[l + 1] != 0) {
          var M = l >> 1, I = N[l + 1], e = M << 4 | I, b = W - I, Z = N[l] << b, m = Z + (1 << b);
          while (Z != m) {
            var J = A[Z] >>> 15 - W;
            R[J] = e;
            Z++;
          }
        }
    };
    H.H.l = function(N, W) {
      var R = H.H.m.r, V = 15 - W;
      for (var n = 0; n < N.length; n += 2) {
        var A = N[n] << W - N[n + 1];
        N[n] = R[A] >>> V;
      }
    };
    H.H.M = function(N, W, R) {
      R = R << (W & 7);
      var V = W >>> 3;
      N[V] |= R;
      N[V + 1] |= R >>> 8;
    };
    H.H.I = function(N, W, R) {
      R = R << (W & 7);
      var V = W >>> 3;
      N[V] |= R;
      N[V + 1] |= R >>> 8;
      N[V + 2] |= R >>> 16;
    };
    H.H.e = function(N, W, R) {
      return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;
    };
    H.H.b = function(N, W, R) {
      return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;
    };
    H.H.Z = function(N, W) {
      return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);
    };
    H.H.i = function(N, W) {
      return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);
    };
    H.H.m = function() {
      var N = Uint16Array, W = Uint32Array;
      return { K: new N(16), j: new N(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new N(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new W(32), J: new N(512), _: [], h: new N(32), $: [], w: new N(32768), C: [], v: [], d: new N(32768), D: [], u: new N(512), Q: [], r: new N(1 << 15), s: new W(286), Y: new W(30), a: new W(19), t: new W(15e3), k: new N(1 << 16), g: new N(1 << 15) };
    }();
    (function() {
      var N = H.H.m, W = 1 << 15;
      for (var R = 0; R < W; R++) {
        var V = R;
        V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;
        V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;
        V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;
        V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;
        N.r[R] = (V >>> 16 | V << 16) >>> 17;
      }
      function n(A, l, M) {
        while (l-- != 0)
          A.push(0, M);
      }
      for (var R = 0; R < 32; R++) {
        N.q[R] = N.S[R] << 3 | N.T[R];
        N.c[R] = N.p[R] << 4 | N.z[R];
      }
      n(N._, 144, 8);
      n(N._, 255 - 143, 9);
      n(N._, 279 - 255, 7);
      n(N._, 287 - 279, 8);
      H.H.n(N._, 9);
      H.H.A(N._, 9, N.J);
      H.H.l(N._, 9);
      n(N.$, 32, 5);
      H.H.n(N.$, 5);
      H.H.A(N.$, 5, N.h);
      H.H.l(N.$, 5);
      n(N.Q, 19, 0);
      n(N.C, 286, 0);
      n(N.D, 30, 0);
      n(N.v, 320, 0);
    })();
    return H.H.N;
  }();
  UPNG.decode._readInterlace = function(data, out) {
    var w = out.width, h = out.height;
    var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
    var img = new Uint8Array(h * bpl);
    var di = 0;
    var starting_row = [0, 0, 4, 0, 2, 0, 1];
    var starting_col = [0, 4, 0, 2, 0, 1, 0];
    var row_increment = [8, 8, 8, 4, 4, 2, 2];
    var col_increment = [8, 8, 4, 4, 2, 2, 1];
    var pass = 0;
    while (pass < 7) {
      var ri = row_increment[pass], ci = col_increment[pass];
      var sw = 0, sh = 0;
      var cr = starting_row[pass];
      while (cr < h) {
        cr += ri;
        sh++;
      }
      var cc = starting_col[pass];
      while (cc < w) {
        cc += ci;
        sw++;
      }
      var bpll = Math.ceil(sw * bpp / 8);
      UPNG.decode._filterZero(data, out, di, sw, sh);
      var y = 0, row = starting_row[pass];
      while (row < h) {
        var col = starting_col[pass];
        var cdi = di + y * bpll << 3;
        while (col < w) {
          if (bpp == 1) {
            var val = data[cdi >> 3];
            val = val >> 7 - (cdi & 7) & 1;
            img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
          }
          if (bpp == 2) {
            var val = data[cdi >> 3];
            val = val >> 6 - (cdi & 7) & 3;
            img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
          }
          if (bpp == 4) {
            var val = data[cdi >> 3];
            val = val >> 4 - (cdi & 7) & 15;
            img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
          }
          if (bpp >= 8) {
            var ii = row * bpl + col * cbpp;
            for (var j = 0; j < cbpp; j++)
              img[ii + j] = data[(cdi >> 3) + j];
          }
          cdi += bpp;
          col += ci;
        }
        y++;
        row += ri;
      }
      if (sw * sh != 0)
        di += sh * (1 + bpll);
      pass = pass + 1;
    }
    return img;
  };
  UPNG.decode._getBPP = function(out) {
    var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
    return noc * out.depth;
  };
  UPNG.decode._filterZero = function(data, out, off, w, h) {
    var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;
    bpp = Math.ceil(bpp / 8);
    var i = 0, di = 1, type = data[off], x = 0;
    if (type > 1)
      data[off] = [0, 0, 1][type - 2];
    if (type == 3)
      for (x = bpp; x < bpl; x++)
        data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;
    for (var y = 0; y < h; y++) {
      i = off + y * bpl;
      di = i + y + 1;
      type = data[di - 1];
      x = 0;
      if (type == 0)
        for (; x < bpl; x++)
          data[i + x] = data[di + x];
      else if (type == 1) {
        for (; x < bpp; x++)
          data[i + x] = data[di + x];
        for (; x < bpl; x++)
          data[i + x] = data[di + x] + data[i + x - bpp];
      } else if (type == 2) {
        for (; x < bpl; x++)
          data[i + x] = data[di + x] + data[i + x - bpl];
      } else if (type == 3) {
        for (; x < bpp; x++)
          data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);
        for (; x < bpl; x++)
          data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);
      } else {
        for (; x < bpp; x++)
          data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);
        for (; x < bpl; x++)
          data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);
      }
    }
    return data;
  };
  UPNG.decode._paeth = function(a, b, c) {
    var p = a + b - c, pa = p - a, pb = p - b, pc = p - c;
    if (pa * pa <= pb * pb && pa * pa <= pc * pc)
      return a;
    else if (pb * pb <= pc * pc)
      return b;
    return c;
  };
  UPNG.decode._IHDR = function(data, offset, out) {
    var bin = UPNG._bin;
    out.width = bin.readUint(data, offset);
    offset += 4;
    out.height = bin.readUint(data, offset);
    offset += 4;
    out.depth = data[offset];
    offset++;
    out.ctype = data[offset];
    offset++;
    out.compress = data[offset];
    offset++;
    out.filter = data[offset];
    offset++;
    out.interlace = data[offset];
    offset++;
  };
  UPNG._bin = {
    nextZero: function(data, p) {
      while (data[p] != 0)
        p++;
      return p;
    },
    readUshort: function(buff, p) {
      return buff[p] << 8 | buff[p + 1];
    },
    writeUshort: function(buff, p, n) {
      buff[p] = n >> 8 & 255;
      buff[p + 1] = n & 255;
    },
    readUint: function(buff, p) {
      return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
    },
    writeUint: function(buff, p, n) {
      buff[p] = n >> 24 & 255;
      buff[p + 1] = n >> 16 & 255;
      buff[p + 2] = n >> 8 & 255;
      buff[p + 3] = n & 255;
    },
    readASCII: function(buff, p, l) {
      var s = "";
      for (var i = 0; i < l; i++)
        s += String.fromCharCode(buff[p + i]);
      return s;
    },
    writeASCII: function(data, p, s) {
      for (var i = 0; i < s.length; i++)
        data[p + i] = s.charCodeAt(i);
    },
    readBytes: function(buff, p, l) {
      var arr = [];
      for (var i = 0; i < l; i++)
        arr.push(buff[p + i]);
      return arr;
    },
    pad: function(n) {
      return n.length < 2 ? "0" + n : n;
    },
    readUTF8: function(buff, p, l) {
      var s = "", ns;
      for (var i = 0; i < l; i++)
        s += "%" + UPNG._bin.pad(buff[p + i].toString(16));
      try {
        ns = decodeURIComponent(s);
      } catch (e) {
        return UPNG._bin.readASCII(buff, p, l);
      }
      return ns;
    }
  };
  UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
    var w = Math.min(sw, tw), h = Math.min(sh, th);
    var si = 0, ti = 0;
    for (var y = 0; y < h; y++)
      for (var x = 0; x < w; x++) {
        if (xoff >= 0 && yoff >= 0) {
          si = y * sw + x << 2;
          ti = (yoff + y) * tw + xoff + x << 2;
        } else {
          si = (-yoff + y) * sw - xoff + x << 2;
          ti = y * tw + x << 2;
        }
        if (mode == 0) {
          tb[ti] = sb[si];
          tb[ti + 1] = sb[si + 1];
          tb[ti + 2] = sb[si + 2];
          tb[ti + 3] = sb[si + 3];
        } else if (mode == 1) {
          var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
          var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
          var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
          tb[ti + 3] = 255 * oa;
          tb[ti + 0] = (fr + br * ifa) * ioa;
          tb[ti + 1] = (fg + bg * ifa) * ioa;
          tb[ti + 2] = (fb + bb * ifa) * ioa;
        } else if (mode == 2) {
          var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
          var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
          if (fa == ba && fr == br && fg == bg && fb == bb) {
            tb[ti] = 0;
            tb[ti + 1] = 0;
            tb[ti + 2] = 0;
            tb[ti + 3] = 0;
          } else {
            tb[ti] = fr;
            tb[ti + 1] = fg;
            tb[ti + 2] = fb;
            tb[ti + 3] = fa;
          }
        } else if (mode == 3) {
          var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
          var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
          if (fa == ba && fr == br && fg == bg && fb == bb)
            continue;
          if (fa < 220 && ba > 20)
            return false;
        }
      }
    return true;
  };
  UPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte) {
    if (ps == null)
      ps = 0;
    if (forbidPlte == null)
      forbidPlte = false;
    var nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);
    UPNG.encode.compressPNG(nimg, -1);
    return UPNG.encode._main(nimg, w, h, dels, tabs);
  };
  UPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {
    var nimg = { ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4), depth, frames: [] };
    var time = Date.now();
    var bipp = (cc + ac) * depth, bipl = bipp * w;
    for (var i = 0; i < bufs.length; i++)
      nimg.frames.push({ rect: { x: 0, y: 0, width: w, height: h }, img: new Uint8Array(bufs[i]), blend: 0, dispose: 1, bpp: Math.ceil(bipp / 8), bpl: Math.ceil(bipl / 8) });
    UPNG.encode.compressPNG(nimg, 0, true);
    var out = UPNG.encode._main(nimg, w, h, dels, tabs);
    return out;
  };
  UPNG.encode._main = function(nimg, w, h, dels, tabs) {
    if (tabs == null)
      tabs = {};
    var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;
    var offset = 8, anim = nimg.frames.length > 1, pltAlpha = false;
    var leng = 8 + (16 + 5 + 4) + (anim ? 20 : 0);
    if (tabs["sRGB"] != null)
      leng += 8 + 1 + 4;
    if (tabs["pHYs"] != null)
      leng += 8 + 9 + 4;
    if (nimg.ctype == 3) {
      var dl = nimg.plte.length;
      for (var i = 0; i < dl; i++)
        if (nimg.plte[i] >>> 24 != 255)
          pltAlpha = true;
      leng += 8 + dl * 3 + 4 + (pltAlpha ? 8 + dl * 1 + 4 : 0);
    }
    for (var j = 0; j < nimg.frames.length; j++) {
      var fr = nimg.frames[j];
      if (anim)
        leng += 38;
      leng += fr.cimg.length + 12;
      if (j != 0)
        leng += 4;
    }
    leng += 12;
    var data = new Uint8Array(leng);
    var wr = [137, 80, 78, 71, 13, 10, 26, 10];
    for (var i = 0; i < 8; i++)
      data[i] = wr[i];
    wUi(data, offset, 13);
    offset += 4;
    wAs(data, offset, "IHDR");
    offset += 4;
    wUi(data, offset, w);
    offset += 4;
    wUi(data, offset, h);
    offset += 4;
    data[offset] = nimg.depth;
    offset++;
    data[offset] = nimg.ctype;
    offset++;
    data[offset] = 0;
    offset++;
    data[offset] = 0;
    offset++;
    data[offset] = 0;
    offset++;
    wUi(data, offset, crc(data, offset - 17, 17));
    offset += 4;
    if (tabs["sRGB"] != null) {
      wUi(data, offset, 1);
      offset += 4;
      wAs(data, offset, "sRGB");
      offset += 4;
      data[offset] = tabs["sRGB"];
      offset++;
      wUi(data, offset, crc(data, offset - 5, 5));
      offset += 4;
    }
    if (tabs["pHYs"] != null) {
      wUi(data, offset, 9);
      offset += 4;
      wAs(data, offset, "pHYs");
      offset += 4;
      wUi(data, offset, tabs["pHYs"][0]);
      offset += 4;
      wUi(data, offset, tabs["pHYs"][1]);
      offset += 4;
      data[offset] = tabs["pHYs"][2];
      offset++;
      wUi(data, offset, crc(data, offset - 13, 13));
      offset += 4;
    }
    if (anim) {
      wUi(data, offset, 8);
      offset += 4;
      wAs(data, offset, "acTL");
      offset += 4;
      wUi(data, offset, nimg.frames.length);
      offset += 4;
      wUi(data, offset, tabs["loop"] != null ? tabs["loop"] : 0);
      offset += 4;
      wUi(data, offset, crc(data, offset - 12, 12));
      offset += 4;
    }
    if (nimg.ctype == 3) {
      var dl = nimg.plte.length;
      wUi(data, offset, dl * 3);
      offset += 4;
      wAs(data, offset, "PLTE");
      offset += 4;
      for (var i = 0; i < dl; i++) {
        var ti = i * 3, c = nimg.plte[i], r = c & 255, g = c >>> 8 & 255, b = c >>> 16 & 255;
        data[offset + ti + 0] = r;
        data[offset + ti + 1] = g;
        data[offset + ti + 2] = b;
      }
      offset += dl * 3;
      wUi(data, offset, crc(data, offset - dl * 3 - 4, dl * 3 + 4));
      offset += 4;
      if (pltAlpha) {
        wUi(data, offset, dl);
        offset += 4;
        wAs(data, offset, "tRNS");
        offset += 4;
        for (var i = 0; i < dl; i++)
          data[offset + i] = nimg.plte[i] >>> 24 & 255;
        offset += dl;
        wUi(data, offset, crc(data, offset - dl - 4, dl + 4));
        offset += 4;
      }
    }
    var fi = 0;
    for (var j = 0; j < nimg.frames.length; j++) {
      var fr = nimg.frames[j];
      if (anim) {
        wUi(data, offset, 26);
        offset += 4;
        wAs(data, offset, "fcTL");
        offset += 4;
        wUi(data, offset, fi++);
        offset += 4;
        wUi(data, offset, fr.rect.width);
        offset += 4;
        wUi(data, offset, fr.rect.height);
        offset += 4;
        wUi(data, offset, fr.rect.x);
        offset += 4;
        wUi(data, offset, fr.rect.y);
        offset += 4;
        wUs(data, offset, dels[j]);
        offset += 2;
        wUs(data, offset, 1e3);
        offset += 2;
        data[offset] = fr.dispose;
        offset++;
        data[offset] = fr.blend;
        offset++;
        wUi(data, offset, crc(data, offset - 30, 30));
        offset += 4;
      }
      var imgd = fr.cimg, dl = imgd.length;
      wUi(data, offset, dl + (j == 0 ? 0 : 4));
      offset += 4;
      var ioff = offset;
      wAs(data, offset, j == 0 ? "IDAT" : "fdAT");
      offset += 4;
      if (j != 0) {
        wUi(data, offset, fi++);
        offset += 4;
      }
      data.set(imgd, offset);
      offset += dl;
      wUi(data, offset, crc(data, ioff, offset - ioff));
      offset += 4;
    }
    wUi(data, offset, 0);
    offset += 4;
    wAs(data, offset, "IEND");
    offset += 4;
    wUi(data, offset, crc(data, offset - 4, 4));
    offset += 4;
    return data.buffer;
  };
  UPNG.encode.compressPNG = function(out, filter, levelZero) {
    for (var i = 0; i < out.frames.length; i++) {
      var frm = out.frames[i], nw = frm.rect.width, nh = frm.rect.height;
      var fdata = new Uint8Array(nh * frm.bpl + nh);
      frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);
    }
  };
  UPNG.encode.compress = function(bufs, w, h, ps, prms) {
    var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];
    var ctype = 6, depth = 8, alphaAnd = 255;
    for (var j = 0; j < bufs.length; j++) {
      var img = new Uint8Array(bufs[j]), ilen = img.length;
      for (var i = 0; i < ilen; i += 4)
        alphaAnd &= img[i + 3];
    }
    var gotAlpha = alphaAnd != 255;
    var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);
    var cmap = {}, plte = [], inds = [];
    if (ps != 0) {
      var nbufs = [];
      for (var i = 0; i < frms.length; i++)
        nbufs.push(frms[i].img.buffer);
      var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);
      var cof = 0, bb = new Uint8Array(qres.abuf);
      for (var i = 0; i < frms.length; i++) {
        var ti = frms[i].img, bln = ti.length;
        inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));
        for (var j = 0; j < bln; j += 4) {
          ti[j] = bb[cof + j];
          ti[j + 1] = bb[cof + j + 1];
          ti[j + 2] = bb[cof + j + 2];
          ti[j + 3] = bb[cof + j + 3];
        }
        cof += bln;
      }
      for (var i = 0; i < qres.plte.length; i++)
        plte.push(qres.plte[i].est.rgba);
    } else {
      for (var j = 0; j < frms.length; j++) {
        var frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw = frm.rect.width, ilen = img32.length;
        var ind = new Uint8Array(ilen);
        inds.push(ind);
        for (var i = 0; i < ilen; i++) {
          var c = img32[i];
          if (i != 0 && c == img32[i - 1])
            ind[i] = ind[i - 1];
          else if (i > nw && c == img32[i - nw])
            ind[i] = ind[i - nw];
          else {
            var cmc = cmap[c];
            if (cmc == null) {
              cmap[c] = cmc = plte.length;
              plte.push(c);
              if (plte.length >= 300)
                break;
            }
            ind[i] = cmc;
          }
        }
      }
    }
    var cc = plte.length;
    if (cc <= 256 && forbidPlte == false) {
      if (cc <= 2)
        depth = 1;
      else if (cc <= 4)
        depth = 2;
      else if (cc <= 16)
        depth = 4;
      else
        depth = 8;
      depth = Math.max(depth, minBits);
    }
    for (var j = 0; j < frms.length; j++) {
      var frm = frms[j], nx = frm.rect.x, ny = frm.rect.y, nw = frm.rect.width, nh = frm.rect.height;
      var cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);
      var bpl = 4 * nw, bpp = 4;
      if (cc <= 256 && forbidPlte == false) {
        bpl = Math.ceil(depth * nw / 8);
        var nimg = new Uint8Array(bpl * nh);
        var inj = inds[j];
        for (var y = 0; y < nh; y++) {
          var i = y * bpl, ii = y * nw;
          if (depth == 8)
            for (var x = 0; x < nw; x++)
              nimg[i + x] = inj[ii + x];
          else if (depth == 4)
            for (var x = 0; x < nw; x++)
              nimg[i + (x >> 1)] |= inj[ii + x] << 4 - (x & 1) * 4;
          else if (depth == 2)
            for (var x = 0; x < nw; x++)
              nimg[i + (x >> 2)] |= inj[ii + x] << 6 - (x & 3) * 2;
          else if (depth == 1)
            for (var x = 0; x < nw; x++)
              nimg[i + (x >> 3)] |= inj[ii + x] << 7 - (x & 7) * 1;
        }
        cimg = nimg;
        ctype = 3;
        bpp = 1;
      } else if (gotAlpha == false && frms.length == 1) {
        var nimg = new Uint8Array(nw * nh * 3), area = nw * nh;
        for (var i = 0; i < area; i++) {
          var ti = i * 3, qi = i * 4;
          nimg[ti] = cimg[qi];
          nimg[ti + 1] = cimg[qi + 1];
          nimg[ti + 2] = cimg[qi + 2];
        }
        cimg = nimg;
        ctype = 2;
        bpp = 3;
        bpl = 3 * nw;
      }
      frm.img = cimg;
      frm.bpl = bpl;
      frm.bpp = bpp;
    }
    return { ctype, depth, plte, frames: frms };
  };
  UPNG.encode.framize = function(bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {
    var frms = [];
    for (var j = 0; j < bufs.length; j++) {
      var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);
      var nimg;
      var nx = 0, ny = 0, nw = w, nh = h, blend = alwaysBlend ? 1 : 0;
      if (j != 0) {
        var tlim = forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0 ? 1 : 2, tstp = 0, tarea = 1e9;
        for (var it = 0; it < tlim; it++) {
          var pimg = new Uint8Array(bufs[j - 1 - it]), p32 = new Uint32Array(bufs[j - 1 - it]);
          var mix = w, miy = h, max = -1, may = -1;
          for (var y = 0; y < h; y++)
            for (var x = 0; x < w; x++) {
              var i = y * w + x;
              if (cimg32[i] != p32[i]) {
                if (x < mix)
                  mix = x;
                if (x > max)
                  max = x;
                if (y < miy)
                  miy = y;
                if (y > may)
                  may = y;
              }
            }
          if (max == -1)
            mix = miy = max = may = 0;
          if (evenCrd) {
            if ((mix & 1) == 1)
              mix--;
            if ((miy & 1) == 1)
              miy--;
          }
          var sarea = (max - mix + 1) * (may - miy + 1);
          if (sarea < tarea) {
            tarea = sarea;
            tstp = it;
            nx = mix;
            ny = miy;
            nw = max - mix + 1;
            nh = may - miy + 1;
          }
        }
        var pimg = new Uint8Array(bufs[j - 1 - tstp]);
        if (tstp == 1)
          frms[j - 1].dispose = 2;
        nimg = new Uint8Array(nw * nh * 4);
        UPNG._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);
        blend = UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;
        if (blend == 1)
          UPNG.encode._prepareDiff(cimg, w, h, nimg, { x: nx, y: ny, width: nw, height: nh });
        else
          UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);
      } else
        nimg = cimg.slice(0);
      frms.push({ rect: { x: nx, y: ny, width: nw, height: nh }, img: nimg, blend, dispose: 0 });
    }
    if (alwaysBlend)
      for (var j = 0; j < frms.length; j++) {
        var frm = frms[j];
        if (frm.blend == 1)
          continue;
        var r0 = frm.rect, r1 = frms[j - 1].rect;
        var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);
        var maX = Math.max(r0.x + r0.width, r1.x + r1.width), maY = Math.max(r0.y + r0.height, r1.y + r1.height);
        var r = { x: miX, y: miY, width: maX - miX, height: maY - miY };
        frms[j - 1].dispose = 1;
        if (j - 1 != 0)
          UPNG.encode._updateFrame(bufs, w, h, frms, j - 1, r, evenCrd);
        UPNG.encode._updateFrame(bufs, w, h, frms, j, r, evenCrd);
      }
    var area = 0;
    if (bufs.length != 1)
      for (var i = 0; i < frms.length; i++) {
        var frm = frms[i];
        area += frm.rect.width * frm.rect.height;
      }
    return frms;
  };
  UPNG.encode._updateFrame = function(bufs, w, h, frms, i, r, evenCrd) {
    var U8 = Uint8Array, U32 = Uint32Array;
    var pimg = new U8(bufs[i - 1]), pimg32 = new U32(bufs[i - 1]), nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;
    var cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);
    var mix = w, miy = h, max = -1, may = -1;
    for (var y = 0; y < r.height; y++)
      for (var x = 0; x < r.width; x++) {
        var cx2 = r.x + x, cy2 = r.y + y;
        var j = cy2 * w + cx2, cc = cimg32[j];
        if (cc == 0 || frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0)) {
        } else {
          if (cx2 < mix)
            mix = cx2;
          if (cx2 > max)
            max = cx2;
          if (cy2 < miy)
            miy = cy2;
          if (cy2 > may)
            may = cy2;
        }
      }
    if (max == -1)
      mix = miy = max = may = 0;
    if (evenCrd) {
      if ((mix & 1) == 1)
        mix--;
      if ((miy & 1) == 1)
        miy--;
    }
    r = { x: mix, y: miy, width: max - mix + 1, height: may - miy + 1 };
    var fr = frms[i];
    fr.rect = r;
    fr.blend = 1;
    fr.img = new Uint8Array(r.width * r.height * 4);
    if (frms[i - 1].dispose == 0) {
      UPNG._copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);
      UPNG.encode._prepareDiff(cimg, w, h, fr.img, r);
    } else
      UPNG._copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);
  };
  UPNG.encode._prepareDiff = function(cimg, w, h, nimg, rec) {
    UPNG._copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);
  };
  UPNG.encode._filterZero = function(img, h, bpp, bpl, data, filter, levelZero) {
    var fls = [], ftry = [0, 1, 2, 3, 4];
    if (filter != -1)
      ftry = [filter];
    else if (h * bpl > 5e5 || bpp == 1)
      ftry = [0];
    var opts;
    if (levelZero)
      opts = { level: 0 };
    var CMPR = levelZero && UZIP != null ? UZIP : import_pako4.default;
    for (var i = 0; i < ftry.length; i++) {
      for (var y = 0; y < h; y++)
        UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);
      fls.push(CMPR["deflate"](data, opts));
    }
    var ti, tsize = 1e9;
    for (var i = 0; i < fls.length; i++)
      if (fls[i].length < tsize) {
        ti = i;
        tsize = fls[i].length;
      }
    return fls[ti];
  };
  UPNG.encode._filterLine = function(data, img, y, bpl, bpp, type) {
    var i = y * bpl, di = i + y, paeth = UPNG.decode._paeth;
    data[di] = type;
    di++;
    if (type == 0) {
      if (bpl < 500)
        for (var x = 0; x < bpl; x++)
          data[di + x] = img[i + x];
      else
        data.set(new Uint8Array(img.buffer, i, bpl), di);
    } else if (type == 1) {
      for (var x = 0; x < bpp; x++)
        data[di + x] = img[i + x];
      for (var x = bpp; x < bpl; x++)
        data[di + x] = img[i + x] - img[i + x - bpp] + 256 & 255;
    } else if (y == 0) {
      for (var x = 0; x < bpp; x++)
        data[di + x] = img[i + x];
      if (type == 2)
        for (var x = bpp; x < bpl; x++)
          data[di + x] = img[i + x];
      if (type == 3)
        for (var x = bpp; x < bpl; x++)
          data[di + x] = img[i + x] - (img[i + x - bpp] >> 1) + 256 & 255;
      if (type == 4)
        for (var x = bpp; x < bpl; x++)
          data[di + x] = img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256 & 255;
    } else {
      if (type == 2) {
        for (var x = 0; x < bpl; x++)
          data[di + x] = img[i + x] + 256 - img[i + x - bpl] & 255;
      }
      if (type == 3) {
        for (var x = 0; x < bpp; x++)
          data[di + x] = img[i + x] + 256 - (img[i + x - bpl] >> 1) & 255;
        for (var x = bpp; x < bpl; x++)
          data[di + x] = img[i + x] + 256 - (img[i + x - bpl] + img[i + x - bpp] >> 1) & 255;
      }
      if (type == 4) {
        for (var x = 0; x < bpp; x++)
          data[di + x] = img[i + x] + 256 - paeth(0, img[i + x - bpl], 0) & 255;
        for (var x = bpp; x < bpl; x++)
          data[di + x] = img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl]) & 255;
      }
    }
  };
  UPNG.crc = {
    table: function() {
      var tab = new Uint32Array(256);
      for (var n = 0; n < 256; n++) {
        var c = n;
        for (var k = 0; k < 8; k++) {
          if (c & 1)
            c = 3988292384 ^ c >>> 1;
          else
            c = c >>> 1;
        }
        tab[n] = c;
      }
      return tab;
    }(),
    update: function(c, buf, off, len) {
      for (var i = 0; i < len; i++)
        c = UPNG.crc.table[(c ^ buf[off + i]) & 255] ^ c >>> 8;
      return c;
    },
    crc: function(b, o, l) {
      return UPNG.crc.update(4294967295, b, o, l) ^ 4294967295;
    }
  };
  UPNG.quantize = function(abuf, ps) {
    var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);
    var KD = UPNG.quantize.getKDtree(nimg, ps);
    var root = KD[0], leafs = KD[1];
    var planeDst = UPNG.quantize.planeDst;
    var sb = oimg, tb = nimg32, len = sb.length;
    var inds = new Uint8Array(oimg.length >> 2);
    for (var i = 0; i < len; i += 4) {
      var r = sb[i] * (1 / 255), g = sb[i + 1] * (1 / 255), b = sb[i + 2] * (1 / 255), a = sb[i + 3] * (1 / 255);
      var nd = UPNG.quantize.getNearest(root, r, g, b, a);
      inds[i >> 2] = nd.ind;
      tb[i >> 2] = nd.est.rgba;
    }
    return { abuf: nimg.buffer, inds, plte: leafs };
  };
  UPNG.quantize.getKDtree = function(nimg, ps, err) {
    if (err == null)
      err = 1e-4;
    var nimg32 = new Uint32Array(nimg.buffer);
    var root = { i0: 0, i1: nimg.length, bst: null, est: null, tdst: 0, left: null, right: null };
    root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1);
    root.est = UPNG.quantize.estats(root.bst);
    var leafs = [root];
    while (leafs.length < ps) {
      var maxL = 0, mi = 0;
      for (var i = 0; i < leafs.length; i++)
        if (leafs[i].est.L > maxL) {
          maxL = leafs[i].est.L;
          mi = i;
        }
      if (maxL < err)
        break;
      var node = leafs[mi];
      var s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);
      var s0wrong = node.i0 >= s0 || node.i1 <= s0;
      if (s0wrong) {
        node.est.L = 0;
        continue;
      }
      var ln = { i0: node.i0, i1: s0, bst: null, est: null, tdst: 0, left: null, right: null };
      ln.bst = UPNG.quantize.stats(nimg, ln.i0, ln.i1);
      ln.est = UPNG.quantize.estats(ln.bst);
      var rn = { i0: s0, i1: node.i1, bst: null, est: null, tdst: 0, left: null, right: null };
      rn.bst = { R: [], m: [], N: node.bst.N - ln.bst.N };
      for (var i = 0; i < 16; i++)
        rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];
      for (var i = 0; i < 4; i++)
        rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];
      rn.est = UPNG.quantize.estats(rn.bst);
      node.left = ln;
      node.right = rn;
      leafs[mi] = ln;
      leafs.push(rn);
    }
    leafs.sort(function(a, b) {
      return b.bst.N - a.bst.N;
    });
    for (var i = 0; i < leafs.length; i++)
      leafs[i].ind = i;
    return [root, leafs];
  };
  UPNG.quantize.getNearest = function(nd, r, g, b, a) {
    if (nd.left == null) {
      nd.tdst = UPNG.quantize.dist(nd.est.q, r, g, b, a);
      return nd;
    }
    var planeDst = UPNG.quantize.planeDst(nd.est, r, g, b, a);
    var node0 = nd.left, node1 = nd.right;
    if (planeDst > 0) {
      node0 = nd.right;
      node1 = nd.left;
    }
    var ln = UPNG.quantize.getNearest(node0, r, g, b, a);
    if (ln.tdst <= planeDst * planeDst)
      return ln;
    var rn = UPNG.quantize.getNearest(node1, r, g, b, a);
    return rn.tdst < ln.tdst ? rn : ln;
  };
  UPNG.quantize.planeDst = function(est, r, g, b, a) {
    var e = est.e;
    return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq;
  };
  UPNG.quantize.dist = function(q, r, g, b, a) {
    var d0 = r - q[0], d1 = g - q[1], d2 = b - q[2], d3 = a - q[3];
    return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
  };
  UPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq) {
    var vecDot = UPNG.quantize.vecDot;
    i1 -= 4;
    var shfs = 0;
    while (i0 < i1) {
      while (vecDot(nimg, i0, e) <= eMq)
        i0 += 4;
      while (vecDot(nimg, i1, e) > eMq)
        i1 -= 4;
      if (i0 >= i1)
        break;
      var t = nimg32[i0 >> 2];
      nimg32[i0 >> 2] = nimg32[i1 >> 2];
      nimg32[i1 >> 2] = t;
      i0 += 4;
      i1 -= 4;
    }
    while (vecDot(nimg, i0, e) > eMq)
      i0 -= 4;
    return i0 + 4;
  };
  UPNG.quantize.vecDot = function(nimg, i, e) {
    return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];
  };
  UPNG.quantize.stats = function(nimg, i0, i1) {
    var R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var m = [0, 0, 0, 0];
    var N = i1 - i0 >> 2;
    for (var i = i0; i < i1; i += 4) {
      var r = nimg[i] * (1 / 255), g = nimg[i + 1] * (1 / 255), b = nimg[i + 2] * (1 / 255), a = nimg[i + 3] * (1 / 255);
      m[0] += r;
      m[1] += g;
      m[2] += b;
      m[3] += a;
      R[0] += r * r;
      R[1] += r * g;
      R[2] += r * b;
      R[3] += r * a;
      R[5] += g * g;
      R[6] += g * b;
      R[7] += g * a;
      R[10] += b * b;
      R[11] += b * a;
      R[15] += a * a;
    }
    R[4] = R[1];
    R[8] = R[2];
    R[9] = R[6];
    R[12] = R[3];
    R[13] = R[7];
    R[14] = R[11];
    return { R, m, N };
  };
  UPNG.quantize.estats = function(stats) {
    var R = stats.R, m = stats.m, N = stats.N;
    var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = N == 0 ? 0 : 1 / N;
    var Rj = [
      R[0] - m0 * m0 * iN,
      R[1] - m0 * m1 * iN,
      R[2] - m0 * m2 * iN,
      R[3] - m0 * m3 * iN,
      R[4] - m1 * m0 * iN,
      R[5] - m1 * m1 * iN,
      R[6] - m1 * m2 * iN,
      R[7] - m1 * m3 * iN,
      R[8] - m2 * m0 * iN,
      R[9] - m2 * m1 * iN,
      R[10] - m2 * m2 * iN,
      R[11] - m2 * m3 * iN,
      R[12] - m3 * m0 * iN,
      R[13] - m3 * m1 * iN,
      R[14] - m3 * m2 * iN,
      R[15] - m3 * m3 * iN
    ];
    var A = Rj, M = UPNG.M4;
    var b = [0.5, 0.5, 0.5, 0.5], mi = 0, tmi = 0;
    if (N != 0)
      for (var i = 0; i < 10; i++) {
        b = M.multVec(A, b);
        tmi = Math.sqrt(M.dot(b, b));
        b = M.sml(1 / tmi, b);
        if (Math.abs(tmi - mi) < 1e-9)
          break;
        mi = tmi;
      }
    var q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];
    var eMq255 = M.dot(M.sml(255, q), b);
    return {
      Cov: Rj,
      q,
      e: b,
      L: mi,
      eMq255,
      eMq: M.dot(b, q),
      rgba: (Math.round(255 * q[3]) << 24 | Math.round(255 * q[2]) << 16 | Math.round(255 * q[1]) << 8 | Math.round(255 * q[0]) << 0) >>> 0
    };
  };
  UPNG.M4 = {
    multVec: function(m, v) {
      return [
        m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],
        m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],
        m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],
        m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]
      ];
    },
    dot: function(x, y) {
      return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
    },
    sml: function(a, y) {
      return [a * y[0], a * y[1], a * y[2], a * y[3]];
    }
  };
  UPNG.encode.concatRGBA = function(bufs) {
    var tlen = 0;
    for (var i = 0; i < bufs.length; i++)
      tlen += bufs[i].byteLength;
    var nimg = new Uint8Array(tlen), noff = 0;
    for (var i = 0; i < bufs.length; i++) {
      var img = new Uint8Array(bufs[i]), il = img.length;
      for (var j = 0; j < il; j += 4) {
        var r = img[j], g = img[j + 1], b = img[j + 2], a = img[j + 3];
        if (a == 0)
          r = g = b = 0;
        nimg[noff + j] = r;
        nimg[noff + j + 1] = g;
        nimg[noff + j + 2] = b;
        nimg[noff + j + 3] = a;
      }
      noff += il;
    }
    return nimg.buffer;
  };
  var UPNG_default = UPNG;

  // node_modules/@pdfme/pdf-lib/es/utils/png.js
  var getImageType = function(ctype) {
    if (ctype === 0)
      return PngType.Greyscale;
    if (ctype === 2)
      return PngType.Truecolour;
    if (ctype === 3)
      return PngType.IndexedColour;
    if (ctype === 4)
      return PngType.GreyscaleWithAlpha;
    if (ctype === 6)
      return PngType.TruecolourWithAlpha;
    throw new Error("Unknown color type: " + ctype);
  };
  var splitAlphaChannel = function(rgbaChannel) {
    var pixelCount = Math.floor(rgbaChannel.length / 4);
    var rgbChannel = new Uint8Array(pixelCount * 3);
    var alphaChannel = new Uint8Array(pixelCount * 1);
    var rgbaOffset = 0;
    var rgbOffset = 0;
    var alphaOffset = 0;
    while (rgbaOffset < rgbaChannel.length) {
      rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
      rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
      rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
      alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];
    }
    return { rgbChannel, alphaChannel };
  };
  var PngType;
  (function(PngType2) {
    PngType2["Greyscale"] = "Greyscale";
    PngType2["Truecolour"] = "Truecolour";
    PngType2["IndexedColour"] = "IndexedColour";
    PngType2["GreyscaleWithAlpha"] = "GreyscaleWithAlpha";
    PngType2["TruecolourWithAlpha"] = "TruecolourWithAlpha";
  })(PngType || (PngType = {}));
  var PNG = (
    /** @class */
    function() {
      function PNG2(pngData) {
        var upng = UPNG_default.decode(pngData);
        var frames = UPNG_default.toRGBA8(upng);
        if (frames.length > 1)
          throw new Error("Animated PNGs are not supported");
        var frame = new Uint8Array(frames[0]);
        var _a = splitAlphaChannel(frame), rgbChannel = _a.rgbChannel, alphaChannel = _a.alphaChannel;
        this.rgbChannel = rgbChannel;
        var hasAlphaValues = alphaChannel.some(function(a) {
          return a < 255;
        });
        if (hasAlphaValues)
          this.alphaChannel = alphaChannel;
        this.type = getImageType(upng.ctype);
        this.width = upng.width;
        this.height = upng.height;
        this.bitsPerComponent = 8;
      }
      PNG2.load = function(pngData) {
        return new PNG2(pngData);
      };
      return PNG2;
    }()
  );

  // node_modules/@pdfme/pdf-lib/es/core/embedders/PngEmbedder.js
  var PngEmbedder = (
    /** @class */
    function() {
      function PngEmbedder2(png) {
        this.image = png;
        this.bitsPerComponent = png.bitsPerComponent;
        this.width = png.width;
        this.height = png.height;
        this.colorSpace = "DeviceRGB";
      }
      PngEmbedder2.for = function(imageData) {
        return __awaiter(this, void 0, void 0, function() {
          var png;
          return __generator(this, function(_a) {
            png = PNG.load(imageData);
            return [2, new PngEmbedder2(png)];
          });
        });
      };
      PngEmbedder2.prototype.embedIntoContext = function(context, ref) {
        return __awaiter(this, void 0, void 0, function() {
          var SMask, xObject;
          return __generator(this, function(_a) {
            SMask = this.embedAlphaChannel(context);
            xObject = context.flateStream(this.image.rgbChannel, {
              Type: "XObject",
              Subtype: "Image",
              BitsPerComponent: this.image.bitsPerComponent,
              Width: this.image.width,
              Height: this.image.height,
              ColorSpace: this.colorSpace,
              SMask
            });
            if (ref) {
              context.assign(ref, xObject);
              return [2, ref];
            } else {
              return [2, context.register(xObject)];
            }
            return [
              2
              /*return*/
            ];
          });
        });
      };
      PngEmbedder2.prototype.embedAlphaChannel = function(context) {
        if (!this.image.alphaChannel)
          return void 0;
        var xObject = context.flateStream(this.image.alphaChannel, {
          Type: "XObject",
          Subtype: "Image",
          Height: this.image.height,
          Width: this.image.width,
          BitsPerComponent: this.image.bitsPerComponent,
          ColorSpace: "DeviceGray",
          Decode: [0, 1]
        });
        return context.register(xObject);
      };
      return PngEmbedder2;
    }()
  );
  var PngEmbedder_default = PngEmbedder;

  // node_modules/@pdfme/pdf-lib/es/core/streams/Stream.js
  var Stream = (
    /** @class */
    function() {
      function Stream2(buffer, start, length) {
        this.bytes = buffer;
        this.start = start || 0;
        this.pos = this.start;
        this.end = !!start && !!length ? start + length : this.bytes.length;
      }
      Object.defineProperty(Stream2.prototype, "length", {
        get: function() {
          return this.end - this.start;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Stream2.prototype, "isEmpty", {
        get: function() {
          return this.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Stream2.prototype.getByte = function() {
        if (this.pos >= this.end) {
          return -1;
        }
        return this.bytes[this.pos++];
      };
      Stream2.prototype.getUint16 = function() {
        var b0 = this.getByte();
        var b1 = this.getByte();
        if (b0 === -1 || b1 === -1) {
          return -1;
        }
        return (b0 << 8) + b1;
      };
      Stream2.prototype.getInt32 = function() {
        var b0 = this.getByte();
        var b1 = this.getByte();
        var b2 = this.getByte();
        var b3 = this.getByte();
        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
      };
      Stream2.prototype.getBytes = function(length, forceClamped) {
        if (forceClamped === void 0) {
          forceClamped = false;
        }
        var bytes = this.bytes;
        var pos = this.pos;
        var strEnd = this.end;
        if (!length) {
          var subarray = bytes.subarray(pos, strEnd);
          return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
        } else {
          var end = pos + length;
          if (end > strEnd) {
            end = strEnd;
          }
          this.pos = end;
          var subarray = bytes.subarray(pos, end);
          return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
        }
      };
      Stream2.prototype.peekByte = function() {
        var peekedByte = this.getByte();
        this.pos--;
        return peekedByte;
      };
      Stream2.prototype.peekBytes = function(length, forceClamped) {
        if (forceClamped === void 0) {
          forceClamped = false;
        }
        var bytes = this.getBytes(length, forceClamped);
        this.pos -= bytes.length;
        return bytes;
      };
      Stream2.prototype.skip = function(n) {
        if (!n) {
          n = 1;
        }
        this.pos += n;
      };
      Stream2.prototype.reset = function() {
        this.pos = this.start;
      };
      Stream2.prototype.moveStart = function() {
        this.start = this.pos;
      };
      Stream2.prototype.makeSubStream = function(start, length) {
        return new Stream2(this.bytes, start, length);
      };
      Stream2.prototype.decode = function() {
        return this.bytes;
      };
      return Stream2;
    }()
  );
  var Stream_default = Stream;

  // node_modules/@pdfme/pdf-lib/es/core/streams/DecodeStream.js
  var emptyBuffer = new Uint8Array(0);
  var DecodeStream = (
    /** @class */
    function() {
      function DecodeStream3(maybeMinBufferLength) {
        this.pos = 0;
        this.bufferLength = 0;
        this.eof = false;
        this.buffer = emptyBuffer;
        this.minBufferLength = 512;
        if (maybeMinBufferLength) {
          while (this.minBufferLength < maybeMinBufferLength) {
            this.minBufferLength *= 2;
          }
        }
      }
      Object.defineProperty(DecodeStream3.prototype, "isEmpty", {
        get: function() {
          while (!this.eof && this.bufferLength === 0) {
            this.readBlock();
          }
          return this.bufferLength === 0;
        },
        enumerable: false,
        configurable: true
      });
      DecodeStream3.prototype.getByte = function() {
        var pos = this.pos;
        while (this.bufferLength <= pos) {
          if (this.eof) {
            return -1;
          }
          this.readBlock();
        }
        return this.buffer[this.pos++];
      };
      DecodeStream3.prototype.getUint16 = function() {
        var b0 = this.getByte();
        var b1 = this.getByte();
        if (b0 === -1 || b1 === -1) {
          return -1;
        }
        return (b0 << 8) + b1;
      };
      DecodeStream3.prototype.getInt32 = function() {
        var b0 = this.getByte();
        var b1 = this.getByte();
        var b2 = this.getByte();
        var b3 = this.getByte();
        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
      };
      DecodeStream3.prototype.getBytes = function(length, forceClamped) {
        if (forceClamped === void 0) {
          forceClamped = false;
        }
        var end;
        var pos = this.pos;
        if (length) {
          this.ensureBuffer(pos + length);
          end = pos + length;
          while (!this.eof && this.bufferLength < end) {
            this.readBlock();
          }
          var bufEnd = this.bufferLength;
          if (end > bufEnd) {
            end = bufEnd;
          }
        } else {
          while (!this.eof) {
            this.readBlock();
          }
          end = this.bufferLength;
        }
        this.pos = end;
        var subarray = this.buffer.subarray(pos, end);
        return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
      };
      DecodeStream3.prototype.peekByte = function() {
        var peekedByte = this.getByte();
        this.pos--;
        return peekedByte;
      };
      DecodeStream3.prototype.peekBytes = function(length, forceClamped) {
        if (forceClamped === void 0) {
          forceClamped = false;
        }
        var bytes = this.getBytes(length, forceClamped);
        this.pos -= bytes.length;
        return bytes;
      };
      DecodeStream3.prototype.skip = function(n) {
        if (!n) {
          n = 1;
        }
        this.pos += n;
      };
      DecodeStream3.prototype.reset = function() {
        this.pos = 0;
      };
      DecodeStream3.prototype.makeSubStream = function(start, length) {
        var end = start + length;
        while (this.bufferLength <= end && !this.eof) {
          this.readBlock();
        }
        return new Stream_default(
          this.buffer,
          start,
          length
          /* dict */
        );
      };
      DecodeStream3.prototype.decode = function() {
        while (!this.eof)
          this.readBlock();
        return this.buffer.subarray(0, this.bufferLength);
      };
      DecodeStream3.prototype.readBlock = function() {
        throw new MethodNotImplementedError(this.constructor.name, "readBlock");
      };
      DecodeStream3.prototype.ensureBuffer = function(requested) {
        var buffer = this.buffer;
        if (requested <= buffer.byteLength) {
          return buffer;
        }
        var size = this.minBufferLength;
        while (size < requested) {
          size *= 2;
        }
        var buffer2 = new Uint8Array(size);
        buffer2.set(buffer);
        return this.buffer = buffer2;
      };
      return DecodeStream3;
    }()
  );
  var DecodeStream_default = DecodeStream;

  // node_modules/@pdfme/pdf-lib/es/core/streams/Ascii85Stream.js
  var isSpace = function(ch) {
    return ch === 32 || ch === 9 || ch === 13 || ch === 10;
  };
  var Ascii85Stream = (
    /** @class */
    function(_super) {
      __extends(Ascii85Stream2, _super);
      function Ascii85Stream2(stream2, maybeLength) {
        var _this = _super.call(this, maybeLength) || this;
        _this.stream = stream2;
        _this.input = new Uint8Array(5);
        if (maybeLength) {
          maybeLength = 0.8 * maybeLength;
        }
        return _this;
      }
      Ascii85Stream2.prototype.readBlock = function() {
        var TILDA_CHAR = 126;
        var Z_LOWER_CHAR = 122;
        var EOF = -1;
        var stream2 = this.stream;
        var c = stream2.getByte();
        while (isSpace(c)) {
          c = stream2.getByte();
        }
        if (c === EOF || c === TILDA_CHAR) {
          this.eof = true;
          return;
        }
        var bufferLength = this.bufferLength;
        var buffer;
        var i;
        if (c === Z_LOWER_CHAR) {
          buffer = this.ensureBuffer(bufferLength + 4);
          for (i = 0; i < 4; ++i) {
            buffer[bufferLength + i] = 0;
          }
          this.bufferLength += 4;
        } else {
          var input = this.input;
          input[0] = c;
          for (i = 1; i < 5; ++i) {
            c = stream2.getByte();
            while (isSpace(c)) {
              c = stream2.getByte();
            }
            input[i] = c;
            if (c === EOF || c === TILDA_CHAR) {
              break;
            }
          }
          buffer = this.ensureBuffer(bufferLength + i - 1);
          this.bufferLength += i - 1;
          if (i < 5) {
            for (; i < 5; ++i) {
              input[i] = 33 + 84;
            }
            this.eof = true;
          }
          var t = 0;
          for (i = 0; i < 5; ++i) {
            t = t * 85 + (input[i] - 33);
          }
          for (i = 3; i >= 0; --i) {
            buffer[bufferLength + i] = t & 255;
            t >>= 8;
          }
        }
      };
      return Ascii85Stream2;
    }(DecodeStream_default)
  );
  var Ascii85Stream_default = Ascii85Stream;

  // node_modules/@pdfme/pdf-lib/es/core/streams/AsciiHexStream.js
  var AsciiHexStream = (
    /** @class */
    function(_super) {
      __extends(AsciiHexStream2, _super);
      function AsciiHexStream2(stream2, maybeLength) {
        var _this = _super.call(this, maybeLength) || this;
        _this.stream = stream2;
        _this.firstDigit = -1;
        if (maybeLength) {
          maybeLength = 0.5 * maybeLength;
        }
        return _this;
      }
      AsciiHexStream2.prototype.readBlock = function() {
        var UPSTREAM_BLOCK_SIZE = 8e3;
        var bytes = this.stream.getBytes(UPSTREAM_BLOCK_SIZE);
        if (!bytes.length) {
          this.eof = true;
          return;
        }
        var maxDecodeLength = bytes.length + 1 >> 1;
        var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
        var bufferLength = this.bufferLength;
        var firstDigit = this.firstDigit;
        for (var i = 0, ii = bytes.length; i < ii; i++) {
          var ch = bytes[i];
          var digit = void 0;
          if (ch >= 48 && ch <= 57) {
            digit = ch & 15;
          } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
            digit = (ch & 15) + 9;
          } else if (ch === 62) {
            this.eof = true;
            break;
          } else {
            continue;
          }
          if (firstDigit < 0) {
            firstDigit = digit;
          } else {
            buffer[bufferLength++] = firstDigit << 4 | digit;
            firstDigit = -1;
          }
        }
        if (firstDigit >= 0 && this.eof) {
          buffer[bufferLength++] = firstDigit << 4;
          firstDigit = -1;
        }
        this.firstDigit = firstDigit;
        this.bufferLength = bufferLength;
      };
      return AsciiHexStream2;
    }(DecodeStream_default)
  );
  var AsciiHexStream_default = AsciiHexStream;

  // node_modules/@pdfme/pdf-lib/es/core/streams/FlateStream.js
  var codeLenCodeMap = new Int32Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
  ]);
  var lengthDecode = new Int32Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    65547,
    65549,
    65551,
    65553,
    131091,
    131095,
    131099,
    131103,
    196643,
    196651,
    196659,
    196667,
    262211,
    262227,
    262243,
    262259,
    327811,
    327843,
    327875,
    327907,
    258,
    258,
    258
  ]);
  var distDecode = new Int32Array([
    1,
    2,
    3,
    4,
    65541,
    65543,
    131081,
    131085,
    196625,
    196633,
    262177,
    262193,
    327745,
    327777,
    393345,
    393409,
    459009,
    459137,
    524801,
    525057,
    590849,
    591361,
    657409,
    658433,
    724993,
    727041,
    794625,
    798721,
    868353,
    876545
  ]);
  var fixedLitCodeTab = [new Int32Array([
    459008,
    524368,
    524304,
    524568,
    459024,
    524400,
    524336,
    590016,
    459016,
    524384,
    524320,
    589984,
    524288,
    524416,
    524352,
    590048,
    459012,
    524376,
    524312,
    589968,
    459028,
    524408,
    524344,
    590032,
    459020,
    524392,
    524328,
    59e4,
    524296,
    524424,
    524360,
    590064,
    459010,
    524372,
    524308,
    524572,
    459026,
    524404,
    524340,
    590024,
    459018,
    524388,
    524324,
    589992,
    524292,
    524420,
    524356,
    590056,
    459014,
    524380,
    524316,
    589976,
    459030,
    524412,
    524348,
    590040,
    459022,
    524396,
    524332,
    590008,
    524300,
    524428,
    524364,
    590072,
    459009,
    524370,
    524306,
    524570,
    459025,
    524402,
    524338,
    590020,
    459017,
    524386,
    524322,
    589988,
    524290,
    524418,
    524354,
    590052,
    459013,
    524378,
    524314,
    589972,
    459029,
    524410,
    524346,
    590036,
    459021,
    524394,
    524330,
    590004,
    524298,
    524426,
    524362,
    590068,
    459011,
    524374,
    524310,
    524574,
    459027,
    524406,
    524342,
    590028,
    459019,
    524390,
    524326,
    589996,
    524294,
    524422,
    524358,
    590060,
    459015,
    524382,
    524318,
    589980,
    459031,
    524414,
    524350,
    590044,
    459023,
    524398,
    524334,
    590012,
    524302,
    524430,
    524366,
    590076,
    459008,
    524369,
    524305,
    524569,
    459024,
    524401,
    524337,
    590018,
    459016,
    524385,
    524321,
    589986,
    524289,
    524417,
    524353,
    590050,
    459012,
    524377,
    524313,
    589970,
    459028,
    524409,
    524345,
    590034,
    459020,
    524393,
    524329,
    590002,
    524297,
    524425,
    524361,
    590066,
    459010,
    524373,
    524309,
    524573,
    459026,
    524405,
    524341,
    590026,
    459018,
    524389,
    524325,
    589994,
    524293,
    524421,
    524357,
    590058,
    459014,
    524381,
    524317,
    589978,
    459030,
    524413,
    524349,
    590042,
    459022,
    524397,
    524333,
    590010,
    524301,
    524429,
    524365,
    590074,
    459009,
    524371,
    524307,
    524571,
    459025,
    524403,
    524339,
    590022,
    459017,
    524387,
    524323,
    589990,
    524291,
    524419,
    524355,
    590054,
    459013,
    524379,
    524315,
    589974,
    459029,
    524411,
    524347,
    590038,
    459021,
    524395,
    524331,
    590006,
    524299,
    524427,
    524363,
    590070,
    459011,
    524375,
    524311,
    524575,
    459027,
    524407,
    524343,
    590030,
    459019,
    524391,
    524327,
    589998,
    524295,
    524423,
    524359,
    590062,
    459015,
    524383,
    524319,
    589982,
    459031,
    524415,
    524351,
    590046,
    459023,
    524399,
    524335,
    590014,
    524303,
    524431,
    524367,
    590078,
    459008,
    524368,
    524304,
    524568,
    459024,
    524400,
    524336,
    590017,
    459016,
    524384,
    524320,
    589985,
    524288,
    524416,
    524352,
    590049,
    459012,
    524376,
    524312,
    589969,
    459028,
    524408,
    524344,
    590033,
    459020,
    524392,
    524328,
    590001,
    524296,
    524424,
    524360,
    590065,
    459010,
    524372,
    524308,
    524572,
    459026,
    524404,
    524340,
    590025,
    459018,
    524388,
    524324,
    589993,
    524292,
    524420,
    524356,
    590057,
    459014,
    524380,
    524316,
    589977,
    459030,
    524412,
    524348,
    590041,
    459022,
    524396,
    524332,
    590009,
    524300,
    524428,
    524364,
    590073,
    459009,
    524370,
    524306,
    524570,
    459025,
    524402,
    524338,
    590021,
    459017,
    524386,
    524322,
    589989,
    524290,
    524418,
    524354,
    590053,
    459013,
    524378,
    524314,
    589973,
    459029,
    524410,
    524346,
    590037,
    459021,
    524394,
    524330,
    590005,
    524298,
    524426,
    524362,
    590069,
    459011,
    524374,
    524310,
    524574,
    459027,
    524406,
    524342,
    590029,
    459019,
    524390,
    524326,
    589997,
    524294,
    524422,
    524358,
    590061,
    459015,
    524382,
    524318,
    589981,
    459031,
    524414,
    524350,
    590045,
    459023,
    524398,
    524334,
    590013,
    524302,
    524430,
    524366,
    590077,
    459008,
    524369,
    524305,
    524569,
    459024,
    524401,
    524337,
    590019,
    459016,
    524385,
    524321,
    589987,
    524289,
    524417,
    524353,
    590051,
    459012,
    524377,
    524313,
    589971,
    459028,
    524409,
    524345,
    590035,
    459020,
    524393,
    524329,
    590003,
    524297,
    524425,
    524361,
    590067,
    459010,
    524373,
    524309,
    524573,
    459026,
    524405,
    524341,
    590027,
    459018,
    524389,
    524325,
    589995,
    524293,
    524421,
    524357,
    590059,
    459014,
    524381,
    524317,
    589979,
    459030,
    524413,
    524349,
    590043,
    459022,
    524397,
    524333,
    590011,
    524301,
    524429,
    524365,
    590075,
    459009,
    524371,
    524307,
    524571,
    459025,
    524403,
    524339,
    590023,
    459017,
    524387,
    524323,
    589991,
    524291,
    524419,
    524355,
    590055,
    459013,
    524379,
    524315,
    589975,
    459029,
    524411,
    524347,
    590039,
    459021,
    524395,
    524331,
    590007,
    524299,
    524427,
    524363,
    590071,
    459011,
    524375,
    524311,
    524575,
    459027,
    524407,
    524343,
    590031,
    459019,
    524391,
    524327,
    589999,
    524295,
    524423,
    524359,
    590063,
    459015,
    524383,
    524319,
    589983,
    459031,
    524415,
    524351,
    590047,
    459023,
    524399,
    524335,
    590015,
    524303,
    524431,
    524367,
    590079
  ]), 9];
  var fixedDistCodeTab = [new Int32Array([
    327680,
    327696,
    327688,
    327704,
    327684,
    327700,
    327692,
    327708,
    327682,
    327698,
    327690,
    327706,
    327686,
    327702,
    327694,
    0,
    327681,
    327697,
    327689,
    327705,
    327685,
    327701,
    327693,
    327709,
    327683,
    327699,
    327691,
    327707,
    327687,
    327703,
    327695,
    0
  ]), 5];
  var FlateStream = (
    /** @class */
    function(_super) {
      __extends(FlateStream2, _super);
      function FlateStream2(stream2, maybeLength) {
        var _this = _super.call(this, maybeLength) || this;
        _this.stream = stream2;
        var cmf = stream2.getByte();
        var flg = stream2.getByte();
        if (cmf === -1 || flg === -1) {
          throw new Error("Invalid header in flate stream: " + cmf + ", " + flg);
        }
        if ((cmf & 15) !== 8) {
          throw new Error("Unknown compression method in flate stream: " + cmf + ", " + flg);
        }
        if (((cmf << 8) + flg) % 31 !== 0) {
          throw new Error("Bad FCHECK in flate stream: " + cmf + ", " + flg);
        }
        if (flg & 32) {
          throw new Error("FDICT bit set in flate stream: " + cmf + ", " + flg);
        }
        _this.codeSize = 0;
        _this.codeBuf = 0;
        return _this;
      }
      FlateStream2.prototype.readBlock = function() {
        var buffer;
        var len;
        var str = this.stream;
        var hdr = this.getBits(3);
        if (hdr & 1) {
          this.eof = true;
        }
        hdr >>= 1;
        if (hdr === 0) {
          var b = void 0;
          if ((b = str.getByte()) === -1) {
            throw new Error("Bad block header in flate stream");
          }
          var blockLen = b;
          if ((b = str.getByte()) === -1) {
            throw new Error("Bad block header in flate stream");
          }
          blockLen |= b << 8;
          if ((b = str.getByte()) === -1) {
            throw new Error("Bad block header in flate stream");
          }
          var check = b;
          if ((b = str.getByte()) === -1) {
            throw new Error("Bad block header in flate stream");
          }
          check |= b << 8;
          if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
            throw new Error("Bad uncompressed block length in flate stream");
          }
          this.codeBuf = 0;
          this.codeSize = 0;
          var bufferLength = this.bufferLength;
          buffer = this.ensureBuffer(bufferLength + blockLen);
          var end = bufferLength + blockLen;
          this.bufferLength = end;
          if (blockLen === 0) {
            if (str.peekByte() === -1) {
              this.eof = true;
            }
          } else {
            for (var n = bufferLength; n < end; ++n) {
              if ((b = str.getByte()) === -1) {
                this.eof = true;
                break;
              }
              buffer[n] = b;
            }
          }
          return;
        }
        var litCodeTable;
        var distCodeTable;
        if (hdr === 1) {
          litCodeTable = fixedLitCodeTab;
          distCodeTable = fixedDistCodeTab;
        } else if (hdr === 2) {
          var numLitCodes = this.getBits(5) + 257;
          var numDistCodes = this.getBits(5) + 1;
          var numCodeLenCodes = this.getBits(4) + 4;
          var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
          var i = void 0;
          for (i = 0; i < numCodeLenCodes; ++i) {
            codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
          }
          var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
          len = 0;
          i = 0;
          var codes = numLitCodes + numDistCodes;
          var codeLengths = new Uint8Array(codes);
          var bitsLength = void 0;
          var bitsOffset = void 0;
          var what = void 0;
          while (i < codes) {
            var code = this.getCode(codeLenCodeTab);
            if (code === 16) {
              bitsLength = 2;
              bitsOffset = 3;
              what = len;
            } else if (code === 17) {
              bitsLength = 3;
              bitsOffset = 3;
              what = len = 0;
            } else if (code === 18) {
              bitsLength = 7;
              bitsOffset = 11;
              what = len = 0;
            } else {
              codeLengths[i++] = len = code;
              continue;
            }
            var repeatLength = this.getBits(bitsLength) + bitsOffset;
            while (repeatLength-- > 0) {
              codeLengths[i++] = what;
            }
          }
          litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
          distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
        } else {
          throw new Error("Unknown block type in flate stream");
        }
        buffer = this.buffer;
        var limit = buffer ? buffer.length : 0;
        var pos = this.bufferLength;
        while (true) {
          var code1 = this.getCode(litCodeTable);
          if (code1 < 256) {
            if (pos + 1 >= limit) {
              buffer = this.ensureBuffer(pos + 1);
              limit = buffer.length;
            }
            buffer[pos++] = code1;
            continue;
          }
          if (code1 === 256) {
            this.bufferLength = pos;
            return;
          }
          code1 -= 257;
          code1 = lengthDecode[code1];
          var code2 = code1 >> 16;
          if (code2 > 0) {
            code2 = this.getBits(code2);
          }
          len = (code1 & 65535) + code2;
          code1 = this.getCode(distCodeTable);
          code1 = distDecode[code1];
          code2 = code1 >> 16;
          if (code2 > 0) {
            code2 = this.getBits(code2);
          }
          var dist = (code1 & 65535) + code2;
          if (pos + len >= limit) {
            buffer = this.ensureBuffer(pos + len);
            limit = buffer.length;
          }
          for (var k = 0; k < len; ++k, ++pos) {
            buffer[pos] = buffer[pos - dist];
          }
        }
      };
      FlateStream2.prototype.getBits = function(bits) {
        var str = this.stream;
        var codeSize = this.codeSize;
        var codeBuf = this.codeBuf;
        var b;
        while (codeSize < bits) {
          if ((b = str.getByte()) === -1) {
            throw new Error("Bad encoding in flate stream");
          }
          codeBuf |= b << codeSize;
          codeSize += 8;
        }
        b = codeBuf & (1 << bits) - 1;
        this.codeBuf = codeBuf >> bits;
        this.codeSize = codeSize -= bits;
        return b;
      };
      FlateStream2.prototype.getCode = function(table) {
        var str = this.stream;
        var codes = table[0];
        var maxLen = table[1];
        var codeSize = this.codeSize;
        var codeBuf = this.codeBuf;
        var b;
        while (codeSize < maxLen) {
          if ((b = str.getByte()) === -1) {
            break;
          }
          codeBuf |= b << codeSize;
          codeSize += 8;
        }
        var code = codes[codeBuf & (1 << maxLen) - 1];
        if (typeof codes === "number") {
          console.log("FLATE:", code);
        }
        var codeLen = code >> 16;
        var codeVal = code & 65535;
        if (codeLen < 1 || codeSize < codeLen) {
          throw new Error("Bad encoding in flate stream");
        }
        this.codeBuf = codeBuf >> codeLen;
        this.codeSize = codeSize - codeLen;
        return codeVal;
      };
      FlateStream2.prototype.generateHuffmanTable = function(lengths) {
        var n = lengths.length;
        var maxLen = 0;
        var i;
        for (i = 0; i < n; ++i) {
          if (lengths[i] > maxLen) {
            maxLen = lengths[i];
          }
        }
        var size = 1 << maxLen;
        var codes = new Int32Array(size);
        for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
          for (var val = 0; val < n; ++val) {
            if (lengths[val] === len) {
              var code2 = 0;
              var t = code;
              for (i = 0; i < len; ++i) {
                code2 = code2 << 1 | t & 1;
                t >>= 1;
              }
              for (i = code2; i < size; i += skip) {
                codes[i] = len << 16 | val;
              }
              ++code;
            }
          }
        }
        return [codes, maxLen];
      };
      return FlateStream2;
    }(DecodeStream_default)
  );
  var FlateStream_default = FlateStream;

  // node_modules/@pdfme/pdf-lib/es/core/streams/LZWStream.js
  var LZWStream = (
    /** @class */
    function(_super) {
      __extends(LZWStream2, _super);
      function LZWStream2(stream2, maybeLength, earlyChange) {
        var _this = _super.call(this, maybeLength) || this;
        _this.stream = stream2;
        _this.cachedData = 0;
        _this.bitsCached = 0;
        var maxLzwDictionarySize = 4096;
        var lzwState = {
          earlyChange,
          codeLength: 9,
          nextCode: 258,
          dictionaryValues: new Uint8Array(maxLzwDictionarySize),
          dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
          dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
          currentSequence: new Uint8Array(maxLzwDictionarySize),
          currentSequenceLength: 0
        };
        for (var i = 0; i < 256; ++i) {
          lzwState.dictionaryValues[i] = i;
          lzwState.dictionaryLengths[i] = 1;
        }
        _this.lzwState = lzwState;
        return _this;
      }
      LZWStream2.prototype.readBlock = function() {
        var blockSize = 512;
        var estimatedDecodedSize = blockSize * 2;
        var decodedSizeDelta = blockSize;
        var i;
        var j;
        var q;
        var lzwState = this.lzwState;
        if (!lzwState) {
          return;
        }
        var earlyChange = lzwState.earlyChange;
        var nextCode = lzwState.nextCode;
        var dictionaryValues = lzwState.dictionaryValues;
        var dictionaryLengths = lzwState.dictionaryLengths;
        var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
        var codeLength = lzwState.codeLength;
        var prevCode = lzwState.prevCode;
        var currentSequence = lzwState.currentSequence;
        var currentSequenceLength = lzwState.currentSequenceLength;
        var decodedLength = 0;
        var currentBufferLength = this.bufferLength;
        var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
        for (i = 0; i < blockSize; i++) {
          var code = this.readBits(codeLength);
          var hasPrev = currentSequenceLength > 0;
          if (!code || code < 256) {
            currentSequence[0] = code;
            currentSequenceLength = 1;
          } else if (code >= 258) {
            if (code < nextCode) {
              currentSequenceLength = dictionaryLengths[code];
              for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                currentSequence[j] = dictionaryValues[q];
                q = dictionaryPrevCodes[q];
              }
            } else {
              currentSequence[currentSequenceLength++] = currentSequence[0];
            }
          } else if (code === 256) {
            codeLength = 9;
            nextCode = 258;
            currentSequenceLength = 0;
            continue;
          } else {
            this.eof = true;
            delete this.lzwState;
            break;
          }
          if (hasPrev) {
            dictionaryPrevCodes[nextCode] = prevCode;
            dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
            dictionaryValues[nextCode] = currentSequence[0];
            nextCode++;
            codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
          }
          prevCode = code;
          decodedLength += currentSequenceLength;
          if (estimatedDecodedSize < decodedLength) {
            do {
              estimatedDecodedSize += decodedSizeDelta;
            } while (estimatedDecodedSize < decodedLength);
            buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
          }
          for (j = 0; j < currentSequenceLength; j++) {
            buffer[currentBufferLength++] = currentSequence[j];
          }
        }
        lzwState.nextCode = nextCode;
        lzwState.codeLength = codeLength;
        lzwState.prevCode = prevCode;
        lzwState.currentSequenceLength = currentSequenceLength;
        this.bufferLength = currentBufferLength;
      };
      LZWStream2.prototype.readBits = function(n) {
        var bitsCached = this.bitsCached;
        var cachedData = this.cachedData;
        while (bitsCached < n) {
          var c = this.stream.getByte();
          if (c === -1) {
            this.eof = true;
            return null;
          }
          cachedData = cachedData << 8 | c;
          bitsCached += 8;
        }
        this.bitsCached = bitsCached -= n;
        this.cachedData = cachedData;
        return cachedData >>> bitsCached & (1 << n) - 1;
      };
      return LZWStream2;
    }(DecodeStream_default)
  );
  var LZWStream_default = LZWStream;

  // node_modules/@pdfme/pdf-lib/es/core/streams/RunLengthStream.js
  var RunLengthStream = (
    /** @class */
    function(_super) {
      __extends(RunLengthStream2, _super);
      function RunLengthStream2(stream2, maybeLength) {
        var _this = _super.call(this, maybeLength) || this;
        _this.stream = stream2;
        return _this;
      }
      RunLengthStream2.prototype.readBlock = function() {
        var repeatHeader = this.stream.getBytes(2);
        if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
          this.eof = true;
          return;
        }
        var buffer;
        var bufferLength = this.bufferLength;
        var n = repeatHeader[0];
        if (n < 128) {
          buffer = this.ensureBuffer(bufferLength + n + 1);
          buffer[bufferLength++] = repeatHeader[1];
          if (n > 0) {
            var source = this.stream.getBytes(n);
            buffer.set(source, bufferLength);
            bufferLength += n;
          }
        } else {
          n = 257 - n;
          var b = repeatHeader[1];
          buffer = this.ensureBuffer(bufferLength + n + 1);
          for (var i = 0; i < n; i++) {
            buffer[bufferLength++] = b;
          }
        }
        this.bufferLength = bufferLength;
      };
      return RunLengthStream2;
    }(DecodeStream_default)
  );
  var RunLengthStream_default = RunLengthStream;

  // node_modules/@pdfme/pdf-lib/es/core/streams/decode.js
  var decodeStream = function(stream2, encoding, params) {
    if (encoding === PDFName_default.of("FlateDecode")) {
      return new FlateStream_default(stream2);
    }
    if (encoding === PDFName_default.of("LZWDecode")) {
      var earlyChange = 1;
      if (params instanceof PDFDict_default) {
        var EarlyChange = params.lookup(PDFName_default.of("EarlyChange"));
        if (EarlyChange instanceof PDFNumber_default) {
          earlyChange = EarlyChange.asNumber();
        }
      }
      return new LZWStream_default(stream2, void 0, earlyChange);
    }
    if (encoding === PDFName_default.of("ASCII85Decode")) {
      return new Ascii85Stream_default(stream2);
    }
    if (encoding === PDFName_default.of("ASCIIHexDecode")) {
      return new AsciiHexStream_default(stream2);
    }
    if (encoding === PDFName_default.of("RunLengthDecode")) {
      return new RunLengthStream_default(stream2);
    }
    throw new UnsupportedEncodingError(encoding.asString());
  };
  var decodePDFRawStream = function(_a) {
    var dict = _a.dict, contents = _a.contents;
    var stream2 = new Stream_default(contents);
    var Filter = dict.lookup(PDFName_default.of("Filter"));
    var DecodeParms = dict.lookup(PDFName_default.of("DecodeParms"));
    if (Filter instanceof PDFName_default) {
      stream2 = decodeStream(stream2, Filter, DecodeParms);
    } else if (Filter instanceof PDFArray_default) {
      for (var idx = 0, len = Filter.size(); idx < len; idx++) {
        stream2 = decodeStream(stream2, Filter.lookup(idx, PDFName_default), DecodeParms && DecodeParms.lookupMaybe(idx, PDFDict_default));
      }
    } else if (!!Filter) {
      throw new UnexpectedObjectTypeError([PDFName_default, PDFArray_default], Filter);
    }
    return stream2;
  };

  // node_modules/@pdfme/pdf-lib/es/core/embedders/PDFPageEmbedder.js
  var fullPageBoundingBox = function(page) {
    var mediaBox = page.MediaBox();
    var width = mediaBox.lookup(2, PDFNumber_default).asNumber() - mediaBox.lookup(0, PDFNumber_default).asNumber();
    var height = mediaBox.lookup(3, PDFNumber_default).asNumber() - mediaBox.lookup(1, PDFNumber_default).asNumber();
    return { left: 0, bottom: 0, right: width, top: height };
  };
  var boundingBoxAdjustedMatrix = function(bb) {
    return [1, 0, 0, 1, -bb.left, -bb.bottom];
  };
  var PDFPageEmbedder = (
    /** @class */
    function() {
      function PDFPageEmbedder2(page, boundingBox, transformationMatrix) {
        this.page = page;
        var bb = boundingBox !== null && boundingBox !== void 0 ? boundingBox : fullPageBoundingBox(page);
        this.width = bb.right - bb.left;
        this.height = bb.top - bb.bottom;
        this.boundingBox = bb;
        this.transformationMatrix = transformationMatrix !== null && transformationMatrix !== void 0 ? transformationMatrix : boundingBoxAdjustedMatrix(bb);
      }
      PDFPageEmbedder2.for = function(page, boundingBox, transformationMatrix) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, new PDFPageEmbedder2(page, boundingBox, transformationMatrix)];
          });
        });
      };
      PDFPageEmbedder2.prototype.embedIntoContext = function(context, ref) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, Contents, Resources, decodedContents, _b, left, bottom, right, top, xObject;
          return __generator(this, function(_c) {
            _a = this.page.normalizedEntries(), Contents = _a.Contents, Resources = _a.Resources;
            if (!Contents)
              throw new MissingPageContentsEmbeddingError();
            decodedContents = this.decodeContents(Contents);
            _b = this.boundingBox, left = _b.left, bottom = _b.bottom, right = _b.right, top = _b.top;
            xObject = context.flateStream(decodedContents, {
              Type: "XObject",
              Subtype: "Form",
              FormType: 1,
              BBox: [left, bottom, right, top],
              Matrix: this.transformationMatrix,
              Resources
            });
            if (ref) {
              context.assign(ref, xObject);
              return [2, ref];
            } else {
              return [2, context.register(xObject)];
            }
            return [
              2
              /*return*/
            ];
          });
        });
      };
      PDFPageEmbedder2.prototype.decodeContents = function(contents) {
        var newline = Uint8Array.of(CharCodes_default.Newline);
        var decodedContents = [];
        for (var idx = 0, len = contents.size(); idx < len; idx++) {
          var stream2 = contents.lookup(idx, PDFStream_default);
          var content = void 0;
          if (stream2 instanceof PDFRawStream_default) {
            content = decodePDFRawStream(stream2).decode();
          } else if (stream2 instanceof PDFContentStream_default) {
            content = stream2.getUnencodedContents();
          } else {
            throw new UnrecognizedStreamTypeError(stream2);
          }
          decodedContents.push(content, newline);
        }
        return mergeIntoTypedArray.apply(void 0, decodedContents);
      };
      return PDFPageEmbedder2;
    }()
  );
  var PDFPageEmbedder_default = PDFPageEmbedder;

  // node_modules/@pdfme/pdf-lib/es/core/interactive/ViewerPreferences.js
  var asEnum = function(rawValue, enumType2) {
    if (rawValue === void 0)
      return void 0;
    return enumType2[rawValue];
  };
  var NonFullScreenPageMode;
  (function(NonFullScreenPageMode2) {
    NonFullScreenPageMode2["UseNone"] = "UseNone";
    NonFullScreenPageMode2["UseOutlines"] = "UseOutlines";
    NonFullScreenPageMode2["UseThumbs"] = "UseThumbs";
    NonFullScreenPageMode2["UseOC"] = "UseOC";
  })(NonFullScreenPageMode || (NonFullScreenPageMode = {}));
  var ReadingDirection;
  (function(ReadingDirection2) {
    ReadingDirection2["L2R"] = "L2R";
    ReadingDirection2["R2L"] = "R2L";
  })(ReadingDirection || (ReadingDirection = {}));
  var PrintScaling;
  (function(PrintScaling2) {
    PrintScaling2["None"] = "None";
    PrintScaling2["AppDefault"] = "AppDefault";
  })(PrintScaling || (PrintScaling = {}));
  var Duplex;
  (function(Duplex2) {
    Duplex2["Simplex"] = "Simplex";
    Duplex2["DuplexFlipShortEdge"] = "DuplexFlipShortEdge";
    Duplex2["DuplexFlipLongEdge"] = "DuplexFlipLongEdge";
  })(Duplex || (Duplex = {}));
  var ViewerPreferences = (
    /** @class */
    function() {
      function ViewerPreferences2(dict) {
        this.dict = dict;
      }
      ViewerPreferences2.prototype.lookupBool = function(key) {
        var returnObj = this.dict.lookup(PDFName_default.of(key));
        if (returnObj instanceof PDFBool_default)
          return returnObj;
        return void 0;
      };
      ViewerPreferences2.prototype.lookupName = function(key) {
        var returnObj = this.dict.lookup(PDFName_default.of(key));
        if (returnObj instanceof PDFName_default)
          return returnObj;
        return void 0;
      };
      ViewerPreferences2.prototype.HideToolbar = function() {
        return this.lookupBool("HideToolbar");
      };
      ViewerPreferences2.prototype.HideMenubar = function() {
        return this.lookupBool("HideMenubar");
      };
      ViewerPreferences2.prototype.HideWindowUI = function() {
        return this.lookupBool("HideWindowUI");
      };
      ViewerPreferences2.prototype.FitWindow = function() {
        return this.lookupBool("FitWindow");
      };
      ViewerPreferences2.prototype.CenterWindow = function() {
        return this.lookupBool("CenterWindow");
      };
      ViewerPreferences2.prototype.DisplayDocTitle = function() {
        return this.lookupBool("DisplayDocTitle");
      };
      ViewerPreferences2.prototype.NonFullScreenPageMode = function() {
        return this.lookupName("NonFullScreenPageMode");
      };
      ViewerPreferences2.prototype.Direction = function() {
        return this.lookupName("Direction");
      };
      ViewerPreferences2.prototype.PrintScaling = function() {
        return this.lookupName("PrintScaling");
      };
      ViewerPreferences2.prototype.Duplex = function() {
        return this.lookupName("Duplex");
      };
      ViewerPreferences2.prototype.PickTrayByPDFSize = function() {
        return this.lookupBool("PickTrayByPDFSize");
      };
      ViewerPreferences2.prototype.PrintPageRange = function() {
        var PrintPageRange = this.dict.lookup(PDFName_default.of("PrintPageRange"));
        if (PrintPageRange instanceof PDFArray_default)
          return PrintPageRange;
        return void 0;
      };
      ViewerPreferences2.prototype.NumCopies = function() {
        var NumCopies = this.dict.lookup(PDFName_default.of("NumCopies"));
        if (NumCopies instanceof PDFNumber_default)
          return NumCopies;
        return void 0;
      };
      ViewerPreferences2.prototype.getHideToolbar = function() {
        var _a, _b;
        return (_b = (_a = this.HideToolbar()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
      };
      ViewerPreferences2.prototype.getHideMenubar = function() {
        var _a, _b;
        return (_b = (_a = this.HideMenubar()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
      };
      ViewerPreferences2.prototype.getHideWindowUI = function() {
        var _a, _b;
        return (_b = (_a = this.HideWindowUI()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
      };
      ViewerPreferences2.prototype.getFitWindow = function() {
        var _a, _b;
        return (_b = (_a = this.FitWindow()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
      };
      ViewerPreferences2.prototype.getCenterWindow = function() {
        var _a, _b;
        return (_b = (_a = this.CenterWindow()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
      };
      ViewerPreferences2.prototype.getDisplayDocTitle = function() {
        var _a, _b;
        return (_b = (_a = this.DisplayDocTitle()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
      };
      ViewerPreferences2.prototype.getNonFullScreenPageMode = function() {
        var _a, _b;
        var mode = (_a = this.NonFullScreenPageMode()) === null || _a === void 0 ? void 0 : _a.decodeText();
        return (_b = asEnum(mode, NonFullScreenPageMode)) !== null && _b !== void 0 ? _b : NonFullScreenPageMode.UseNone;
      };
      ViewerPreferences2.prototype.getReadingDirection = function() {
        var _a, _b;
        var direction = (_a = this.Direction()) === null || _a === void 0 ? void 0 : _a.decodeText();
        return (_b = asEnum(direction, ReadingDirection)) !== null && _b !== void 0 ? _b : ReadingDirection.L2R;
      };
      ViewerPreferences2.prototype.getPrintScaling = function() {
        var _a, _b;
        var scaling = (_a = this.PrintScaling()) === null || _a === void 0 ? void 0 : _a.decodeText();
        return (_b = asEnum(scaling, PrintScaling)) !== null && _b !== void 0 ? _b : PrintScaling.AppDefault;
      };
      ViewerPreferences2.prototype.getDuplex = function() {
        var _a;
        var duplex = (_a = this.Duplex()) === null || _a === void 0 ? void 0 : _a.decodeText();
        return asEnum(duplex, Duplex);
      };
      ViewerPreferences2.prototype.getPickTrayByPDFSize = function() {
        var _a;
        return (_a = this.PickTrayByPDFSize()) === null || _a === void 0 ? void 0 : _a.asBoolean();
      };
      ViewerPreferences2.prototype.getPrintPageRange = function() {
        var rng = this.PrintPageRange();
        if (!rng)
          return [];
        var pageRanges = [];
        for (var i = 0; i < rng.size(); i += 2) {
          var start = rng.lookup(i, PDFNumber_default).asNumber();
          var end = rng.lookup(i + 1, PDFNumber_default).asNumber();
          pageRanges.push({ start, end });
        }
        return pageRanges;
      };
      ViewerPreferences2.prototype.getNumCopies = function() {
        var _a, _b;
        return (_b = (_a = this.NumCopies()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 1;
      };
      ViewerPreferences2.prototype.setHideToolbar = function(hideToolbar) {
        var HideToolbar = this.dict.context.obj(hideToolbar);
        this.dict.set(PDFName_default.of("HideToolbar"), HideToolbar);
      };
      ViewerPreferences2.prototype.setHideMenubar = function(hideMenubar) {
        var HideMenubar = this.dict.context.obj(hideMenubar);
        this.dict.set(PDFName_default.of("HideMenubar"), HideMenubar);
      };
      ViewerPreferences2.prototype.setHideWindowUI = function(hideWindowUI) {
        var HideWindowUI = this.dict.context.obj(hideWindowUI);
        this.dict.set(PDFName_default.of("HideWindowUI"), HideWindowUI);
      };
      ViewerPreferences2.prototype.setFitWindow = function(fitWindow) {
        var FitWindow = this.dict.context.obj(fitWindow);
        this.dict.set(PDFName_default.of("FitWindow"), FitWindow);
      };
      ViewerPreferences2.prototype.setCenterWindow = function(centerWindow) {
        var CenterWindow = this.dict.context.obj(centerWindow);
        this.dict.set(PDFName_default.of("CenterWindow"), CenterWindow);
      };
      ViewerPreferences2.prototype.setDisplayDocTitle = function(displayTitle) {
        var DisplayDocTitle = this.dict.context.obj(displayTitle);
        this.dict.set(PDFName_default.of("DisplayDocTitle"), DisplayDocTitle);
      };
      ViewerPreferences2.prototype.setNonFullScreenPageMode = function(nonFullScreenPageMode) {
        assertIsOneOf(nonFullScreenPageMode, "nonFullScreenPageMode", NonFullScreenPageMode);
        var mode = PDFName_default.of(nonFullScreenPageMode);
        this.dict.set(PDFName_default.of("NonFullScreenPageMode"), mode);
      };
      ViewerPreferences2.prototype.setReadingDirection = function(readingDirection) {
        assertIsOneOf(readingDirection, "readingDirection", ReadingDirection);
        var direction = PDFName_default.of(readingDirection);
        this.dict.set(PDFName_default.of("Direction"), direction);
      };
      ViewerPreferences2.prototype.setPrintScaling = function(printScaling) {
        assertIsOneOf(printScaling, "printScaling", PrintScaling);
        var scaling = PDFName_default.of(printScaling);
        this.dict.set(PDFName_default.of("PrintScaling"), scaling);
      };
      ViewerPreferences2.prototype.setDuplex = function(duplex) {
        assertIsOneOf(duplex, "duplex", Duplex);
        var dup = PDFName_default.of(duplex);
        this.dict.set(PDFName_default.of("Duplex"), dup);
      };
      ViewerPreferences2.prototype.setPickTrayByPDFSize = function(pickTrayByPDFSize) {
        var PickTrayByPDFSize = this.dict.context.obj(pickTrayByPDFSize);
        this.dict.set(PDFName_default.of("PickTrayByPDFSize"), PickTrayByPDFSize);
      };
      ViewerPreferences2.prototype.setPrintPageRange = function(printPageRange) {
        if (!Array.isArray(printPageRange))
          printPageRange = [printPageRange];
        var flatRange = [];
        for (var idx = 0, len = printPageRange.length; idx < len; idx++) {
          flatRange.push(printPageRange[idx].start);
          flatRange.push(printPageRange[idx].end);
        }
        assertEachIs(flatRange, "printPageRange", ["number"]);
        var pageRanges = this.dict.context.obj(flatRange);
        this.dict.set(PDFName_default.of("PrintPageRange"), pageRanges);
      };
      ViewerPreferences2.prototype.setNumCopies = function(numCopies) {
        assertRange(numCopies, "numCopies", 1, Number.MAX_VALUE);
        assertInteger(numCopies, "numCopies");
        var NumCopies = this.dict.context.obj(numCopies);
        this.dict.set(PDFName_default.of("NumCopies"), NumCopies);
      };
      ViewerPreferences2.fromDict = function(dict) {
        return new ViewerPreferences2(dict);
      };
      ViewerPreferences2.create = function(context) {
        var dict = context.obj({});
        return new ViewerPreferences2(dict);
      };
      return ViewerPreferences2;
    }()
  );
  var ViewerPreferences_default = ViewerPreferences;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroField.js
  var tfRegex = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+Tf/;
  var PDFAcroField = (
    /** @class */
    function() {
      function PDFAcroField2(dict, ref) {
        this.dict = dict;
        this.ref = ref;
      }
      PDFAcroField2.prototype.T = function() {
        return this.dict.lookupMaybe(PDFName_default.of("T"), PDFString_default, PDFHexString_default);
      };
      PDFAcroField2.prototype.Ff = function() {
        var numberOrRef = this.getInheritableAttribute(PDFName_default.of("Ff"));
        return this.dict.context.lookupMaybe(numberOrRef, PDFNumber_default);
      };
      PDFAcroField2.prototype.V = function() {
        var valueOrRef = this.getInheritableAttribute(PDFName_default.of("V"));
        return this.dict.context.lookup(valueOrRef);
      };
      PDFAcroField2.prototype.Kids = function() {
        return this.dict.lookupMaybe(PDFName_default.of("Kids"), PDFArray_default);
      };
      PDFAcroField2.prototype.DA = function() {
        var da = this.dict.lookup(PDFName_default.of("DA"));
        if (da instanceof PDFString_default || da instanceof PDFHexString_default)
          return da;
        return void 0;
      };
      PDFAcroField2.prototype.setKids = function(kids) {
        this.dict.set(PDFName_default.of("Kids"), this.dict.context.obj(kids));
      };
      PDFAcroField2.prototype.getParent = function() {
        var parentRef = this.dict.get(PDFName_default.of("Parent"));
        if (parentRef instanceof PDFRef_default) {
          var parent_1 = this.dict.lookup(PDFName_default.of("Parent"), PDFDict_default);
          return new PDFAcroField2(parent_1, parentRef);
        }
        return void 0;
      };
      PDFAcroField2.prototype.setParent = function(parent) {
        if (!parent)
          this.dict.delete(PDFName_default.of("Parent"));
        else
          this.dict.set(PDFName_default.of("Parent"), parent);
      };
      PDFAcroField2.prototype.getFullyQualifiedName = function() {
        var parent = this.getParent();
        if (!parent)
          return this.getPartialName();
        return parent.getFullyQualifiedName() + "." + this.getPartialName();
      };
      PDFAcroField2.prototype.getPartialName = function() {
        var _a;
        return (_a = this.T()) === null || _a === void 0 ? void 0 : _a.decodeText();
      };
      PDFAcroField2.prototype.setPartialName = function(partialName) {
        if (!partialName)
          this.dict.delete(PDFName_default.of("T"));
        else
          this.dict.set(PDFName_default.of("T"), PDFHexString_default.fromText(partialName));
      };
      PDFAcroField2.prototype.setDefaultAppearance = function(appearance) {
        this.dict.set(PDFName_default.of("DA"), PDFString_default.of(appearance));
      };
      PDFAcroField2.prototype.getDefaultAppearance = function() {
        var DA = this.DA();
        if (DA instanceof PDFHexString_default) {
          return DA.decodeText();
        }
        return DA === null || DA === void 0 ? void 0 : DA.asString();
      };
      PDFAcroField2.prototype.setFontSize = function(fontSize) {
        var _a;
        var name = (_a = this.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : "";
        var da = this.getDefaultAppearance();
        if (!da)
          throw new MissingDAEntryError(name);
        var daMatch = findLastMatch(da, tfRegex);
        if (!daMatch.match)
          throw new MissingTfOperatorError(name);
        var daStart = da.slice(0, daMatch.pos - daMatch.match[0].length);
        var daEnd = daMatch.pos <= da.length ? da.slice(daMatch.pos) : "";
        var fontName = daMatch.match[1];
        var modifiedDa = daStart + " /" + fontName + " " + fontSize + " Tf " + daEnd;
        this.setDefaultAppearance(modifiedDa);
      };
      PDFAcroField2.prototype.getFlags = function() {
        var _a, _b;
        return (_b = (_a = this.Ff()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 0;
      };
      PDFAcroField2.prototype.setFlags = function(flags) {
        this.dict.set(PDFName_default.of("Ff"), PDFNumber_default.of(flags));
      };
      PDFAcroField2.prototype.hasFlag = function(flag3) {
        var flags = this.getFlags();
        return (flags & flag3) !== 0;
      };
      PDFAcroField2.prototype.setFlag = function(flag3) {
        var flags = this.getFlags();
        this.setFlags(flags | flag3);
      };
      PDFAcroField2.prototype.clearFlag = function(flag3) {
        var flags = this.getFlags();
        this.setFlags(flags & ~flag3);
      };
      PDFAcroField2.prototype.setFlagTo = function(flag3, enable) {
        if (enable)
          this.setFlag(flag3);
        else
          this.clearFlag(flag3);
      };
      PDFAcroField2.prototype.getInheritableAttribute = function(name) {
        var attribute;
        this.ascend(function(node) {
          if (!attribute)
            attribute = node.dict.get(name);
        });
        return attribute;
      };
      PDFAcroField2.prototype.ascend = function(visitor) {
        visitor(this);
        var parent = this.getParent();
        if (parent)
          parent.ascend(visitor);
      };
      return PDFAcroField2;
    }()
  );
  var PDFAcroField_default = PDFAcroField;

  // node_modules/@pdfme/pdf-lib/es/core/annotation/BorderStyle.js
  var BorderStyle = (
    /** @class */
    function() {
      function BorderStyle2(dict) {
        this.dict = dict;
      }
      BorderStyle2.prototype.W = function() {
        var W = this.dict.lookup(PDFName_default.of("W"));
        if (W instanceof PDFNumber_default)
          return W;
        return void 0;
      };
      BorderStyle2.prototype.getWidth = function() {
        var _a, _b;
        return (_b = (_a = this.W()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 1;
      };
      BorderStyle2.prototype.setWidth = function(width) {
        var W = this.dict.context.obj(width);
        this.dict.set(PDFName_default.of("W"), W);
      };
      BorderStyle2.fromDict = function(dict) {
        return new BorderStyle2(dict);
      };
      return BorderStyle2;
    }()
  );
  var BorderStyle_default = BorderStyle;

  // node_modules/@pdfme/pdf-lib/es/core/annotation/PDFAnnotation.js
  var PDFAnnotation = (
    /** @class */
    function() {
      function PDFAnnotation2(dict) {
        this.dict = dict;
      }
      PDFAnnotation2.prototype.Rect = function() {
        return this.dict.lookup(PDFName_default.of("Rect"), PDFArray_default);
      };
      PDFAnnotation2.prototype.AP = function() {
        return this.dict.lookupMaybe(PDFName_default.of("AP"), PDFDict_default);
      };
      PDFAnnotation2.prototype.F = function() {
        var numberOrRef = this.dict.lookup(PDFName_default.of("F"));
        return this.dict.context.lookupMaybe(numberOrRef, PDFNumber_default);
      };
      PDFAnnotation2.prototype.getRectangle = function() {
        var _a;
        var Rect = this.Rect();
        return (_a = Rect === null || Rect === void 0 ? void 0 : Rect.asRectangle()) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: 0, height: 0 };
      };
      PDFAnnotation2.prototype.setRectangle = function(rect) {
        var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
        var Rect = this.dict.context.obj([x, y, x + width, y + height]);
        this.dict.set(PDFName_default.of("Rect"), Rect);
      };
      PDFAnnotation2.prototype.getAppearanceState = function() {
        var AS = this.dict.lookup(PDFName_default.of("AS"));
        if (AS instanceof PDFName_default)
          return AS;
        return void 0;
      };
      PDFAnnotation2.prototype.setAppearanceState = function(state) {
        this.dict.set(PDFName_default.of("AS"), state);
      };
      PDFAnnotation2.prototype.setAppearances = function(appearances) {
        this.dict.set(PDFName_default.of("AP"), appearances);
      };
      PDFAnnotation2.prototype.ensureAP = function() {
        var AP = this.AP();
        if (!AP) {
          AP = this.dict.context.obj({});
          this.dict.set(PDFName_default.of("AP"), AP);
        }
        return AP;
      };
      PDFAnnotation2.prototype.getNormalAppearance = function() {
        var AP = this.ensureAP();
        var N = AP.get(PDFName_default.of("N"));
        if (N instanceof PDFRef_default || N instanceof PDFDict_default)
          return N;
        throw new Error("Unexpected N type: " + (N === null || N === void 0 ? void 0 : N.constructor.name));
      };
      PDFAnnotation2.prototype.setNormalAppearance = function(appearance) {
        var AP = this.ensureAP();
        AP.set(PDFName_default.of("N"), appearance);
      };
      PDFAnnotation2.prototype.setRolloverAppearance = function(appearance) {
        var AP = this.ensureAP();
        AP.set(PDFName_default.of("R"), appearance);
      };
      PDFAnnotation2.prototype.setDownAppearance = function(appearance) {
        var AP = this.ensureAP();
        AP.set(PDFName_default.of("D"), appearance);
      };
      PDFAnnotation2.prototype.removeRolloverAppearance = function() {
        var AP = this.AP();
        AP === null || AP === void 0 ? void 0 : AP.delete(PDFName_default.of("R"));
      };
      PDFAnnotation2.prototype.removeDownAppearance = function() {
        var AP = this.AP();
        AP === null || AP === void 0 ? void 0 : AP.delete(PDFName_default.of("D"));
      };
      PDFAnnotation2.prototype.getAppearances = function() {
        var AP = this.AP();
        if (!AP)
          return void 0;
        var N = AP.lookup(PDFName_default.of("N"), PDFDict_default, PDFStream_default);
        var R = AP.lookupMaybe(PDFName_default.of("R"), PDFDict_default, PDFStream_default);
        var D = AP.lookupMaybe(PDFName_default.of("D"), PDFDict_default, PDFStream_default);
        return { normal: N, rollover: R, down: D };
      };
      PDFAnnotation2.prototype.getFlags = function() {
        var _a, _b;
        return (_b = (_a = this.F()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 0;
      };
      PDFAnnotation2.prototype.setFlags = function(flags) {
        this.dict.set(PDFName_default.of("F"), PDFNumber_default.of(flags));
      };
      PDFAnnotation2.prototype.hasFlag = function(flag3) {
        var flags = this.getFlags();
        return (flags & flag3) !== 0;
      };
      PDFAnnotation2.prototype.setFlag = function(flag3) {
        var flags = this.getFlags();
        this.setFlags(flags | flag3);
      };
      PDFAnnotation2.prototype.clearFlag = function(flag3) {
        var flags = this.getFlags();
        this.setFlags(flags & ~flag3);
      };
      PDFAnnotation2.prototype.setFlagTo = function(flag3, enable) {
        if (enable)
          this.setFlag(flag3);
        else
          this.clearFlag(flag3);
      };
      PDFAnnotation2.fromDict = function(dict) {
        return new PDFAnnotation2(dict);
      };
      return PDFAnnotation2;
    }()
  );
  var PDFAnnotation_default = PDFAnnotation;

  // node_modules/@pdfme/pdf-lib/es/core/annotation/AppearanceCharacteristics.js
  var AppearanceCharacteristics = (
    /** @class */
    function() {
      function AppearanceCharacteristics2(dict) {
        this.dict = dict;
      }
      AppearanceCharacteristics2.prototype.R = function() {
        var R = this.dict.lookup(PDFName_default.of("R"));
        if (R instanceof PDFNumber_default)
          return R;
        return void 0;
      };
      AppearanceCharacteristics2.prototype.BC = function() {
        var BC = this.dict.lookup(PDFName_default.of("BC"));
        if (BC instanceof PDFArray_default)
          return BC;
        return void 0;
      };
      AppearanceCharacteristics2.prototype.BG = function() {
        var BG = this.dict.lookup(PDFName_default.of("BG"));
        if (BG instanceof PDFArray_default)
          return BG;
        return void 0;
      };
      AppearanceCharacteristics2.prototype.CA = function() {
        var CA = this.dict.lookup(PDFName_default.of("CA"));
        if (CA instanceof PDFHexString_default || CA instanceof PDFString_default)
          return CA;
        return void 0;
      };
      AppearanceCharacteristics2.prototype.RC = function() {
        var RC = this.dict.lookup(PDFName_default.of("RC"));
        if (RC instanceof PDFHexString_default || RC instanceof PDFString_default)
          return RC;
        return void 0;
      };
      AppearanceCharacteristics2.prototype.AC = function() {
        var AC = this.dict.lookup(PDFName_default.of("AC"));
        if (AC instanceof PDFHexString_default || AC instanceof PDFString_default)
          return AC;
        return void 0;
      };
      AppearanceCharacteristics2.prototype.getRotation = function() {
        var _a;
        return (_a = this.R()) === null || _a === void 0 ? void 0 : _a.asNumber();
      };
      AppearanceCharacteristics2.prototype.getBorderColor = function() {
        var BC = this.BC();
        if (!BC)
          return void 0;
        var components = [];
        for (var idx = 0, len = BC === null || BC === void 0 ? void 0 : BC.size(); idx < len; idx++) {
          var component = BC.get(idx);
          if (component instanceof PDFNumber_default)
            components.push(component.asNumber());
        }
        return components;
      };
      AppearanceCharacteristics2.prototype.getBackgroundColor = function() {
        var BG = this.BG();
        if (!BG)
          return void 0;
        var components = [];
        for (var idx = 0, len = BG === null || BG === void 0 ? void 0 : BG.size(); idx < len; idx++) {
          var component = BG.get(idx);
          if (component instanceof PDFNumber_default)
            components.push(component.asNumber());
        }
        return components;
      };
      AppearanceCharacteristics2.prototype.getCaptions = function() {
        var CA = this.CA();
        var RC = this.RC();
        var AC = this.AC();
        return {
          normal: CA === null || CA === void 0 ? void 0 : CA.decodeText(),
          rollover: RC === null || RC === void 0 ? void 0 : RC.decodeText(),
          down: AC === null || AC === void 0 ? void 0 : AC.decodeText()
        };
      };
      AppearanceCharacteristics2.prototype.setRotation = function(rotation) {
        var R = this.dict.context.obj(rotation);
        this.dict.set(PDFName_default.of("R"), R);
      };
      AppearanceCharacteristics2.prototype.setBorderColor = function(color) {
        var BC = this.dict.context.obj(color);
        this.dict.set(PDFName_default.of("BC"), BC);
      };
      AppearanceCharacteristics2.prototype.setBackgroundColor = function(color) {
        var BG = this.dict.context.obj(color);
        this.dict.set(PDFName_default.of("BG"), BG);
      };
      AppearanceCharacteristics2.prototype.setCaptions = function(captions) {
        var CA = PDFHexString_default.fromText(captions.normal);
        this.dict.set(PDFName_default.of("CA"), CA);
        if (captions.rollover) {
          var RC = PDFHexString_default.fromText(captions.rollover);
          this.dict.set(PDFName_default.of("RC"), RC);
        } else {
          this.dict.delete(PDFName_default.of("RC"));
        }
        if (captions.down) {
          var AC = PDFHexString_default.fromText(captions.down);
          this.dict.set(PDFName_default.of("AC"), AC);
        } else {
          this.dict.delete(PDFName_default.of("AC"));
        }
      };
      AppearanceCharacteristics2.fromDict = function(dict) {
        return new AppearanceCharacteristics2(dict);
      };
      return AppearanceCharacteristics2;
    }()
  );
  var AppearanceCharacteristics_default = AppearanceCharacteristics;

  // node_modules/@pdfme/pdf-lib/es/core/annotation/PDFWidgetAnnotation.js
  var PDFWidgetAnnotation = (
    /** @class */
    function(_super) {
      __extends(PDFWidgetAnnotation2, _super);
      function PDFWidgetAnnotation2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFWidgetAnnotation2.prototype.MK = function() {
        var MK = this.dict.lookup(PDFName_default.of("MK"));
        if (MK instanceof PDFDict_default)
          return MK;
        return void 0;
      };
      PDFWidgetAnnotation2.prototype.BS = function() {
        var BS = this.dict.lookup(PDFName_default.of("BS"));
        if (BS instanceof PDFDict_default)
          return BS;
        return void 0;
      };
      PDFWidgetAnnotation2.prototype.DA = function() {
        var da = this.dict.lookup(PDFName_default.of("DA"));
        if (da instanceof PDFString_default || da instanceof PDFHexString_default)
          return da;
        return void 0;
      };
      PDFWidgetAnnotation2.prototype.P = function() {
        var P = this.dict.get(PDFName_default.of("P"));
        if (P instanceof PDFRef_default)
          return P;
        return void 0;
      };
      PDFWidgetAnnotation2.prototype.setP = function(page) {
        this.dict.set(PDFName_default.of("P"), page);
      };
      PDFWidgetAnnotation2.prototype.setDefaultAppearance = function(appearance) {
        this.dict.set(PDFName_default.of("DA"), PDFString_default.of(appearance));
      };
      PDFWidgetAnnotation2.prototype.getDefaultAppearance = function() {
        var DA = this.DA();
        if (DA instanceof PDFHexString_default) {
          return DA.decodeText();
        }
        return DA === null || DA === void 0 ? void 0 : DA.asString();
      };
      PDFWidgetAnnotation2.prototype.getAppearanceCharacteristics = function() {
        var MK = this.MK();
        if (MK)
          return AppearanceCharacteristics_default.fromDict(MK);
        return void 0;
      };
      PDFWidgetAnnotation2.prototype.getOrCreateAppearanceCharacteristics = function() {
        var MK = this.MK();
        if (MK)
          return AppearanceCharacteristics_default.fromDict(MK);
        var ac = AppearanceCharacteristics_default.fromDict(this.dict.context.obj({}));
        this.dict.set(PDFName_default.of("MK"), ac.dict);
        return ac;
      };
      PDFWidgetAnnotation2.prototype.getBorderStyle = function() {
        var BS = this.BS();
        if (BS)
          return BorderStyle_default.fromDict(BS);
        return void 0;
      };
      PDFWidgetAnnotation2.prototype.getOrCreateBorderStyle = function() {
        var BS = this.BS();
        if (BS)
          return BorderStyle_default.fromDict(BS);
        var bs = BorderStyle_default.fromDict(this.dict.context.obj({}));
        this.dict.set(PDFName_default.of("BS"), bs.dict);
        return bs;
      };
      PDFWidgetAnnotation2.prototype.getOnValue = function() {
        var _a;
        var normal = (_a = this.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
        if (normal instanceof PDFDict_default) {
          var keys = normal.keys();
          for (var idx = 0, len = keys.length; idx < len; idx++) {
            var key = keys[idx];
            if (key !== PDFName_default.of("Off"))
              return key;
          }
        }
        return void 0;
      };
      PDFWidgetAnnotation2.fromDict = function(dict) {
        return new PDFWidgetAnnotation2(dict);
      };
      PDFWidgetAnnotation2.create = function(context, parent) {
        var dict = context.obj({
          Type: "Annot",
          Subtype: "Widget",
          Rect: [0, 0, 0, 0],
          Parent: parent
        });
        return new PDFWidgetAnnotation2(dict);
      };
      return PDFWidgetAnnotation2;
    }(PDFAnnotation_default)
  );
  var PDFWidgetAnnotation_default = PDFWidgetAnnotation;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroTerminal.js
  var PDFAcroTerminal = (
    /** @class */
    function(_super) {
      __extends(PDFAcroTerminal2, _super);
      function PDFAcroTerminal2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroTerminal2.prototype.FT = function() {
        var nameOrRef = this.getInheritableAttribute(PDFName_default.of("FT"));
        return this.dict.context.lookup(nameOrRef, PDFName_default);
      };
      PDFAcroTerminal2.prototype.getWidgets = function() {
        var kidDicts = this.Kids();
        if (!kidDicts)
          return [PDFWidgetAnnotation_default.fromDict(this.dict)];
        var widgets = new Array(kidDicts.size());
        for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {
          var dict = kidDicts.lookup(idx, PDFDict_default);
          widgets[idx] = PDFWidgetAnnotation_default.fromDict(dict);
        }
        return widgets;
      };
      PDFAcroTerminal2.prototype.addWidget = function(ref) {
        var Kids = this.normalizedEntries().Kids;
        Kids.push(ref);
      };
      PDFAcroTerminal2.prototype.removeWidget = function(idx) {
        var kidDicts = this.Kids();
        if (!kidDicts) {
          if (idx !== 0)
            throw new IndexOutOfBoundsError(idx, 0, 0);
          this.setKids([]);
        } else {
          if (idx < 0 || idx > kidDicts.size()) {
            throw new IndexOutOfBoundsError(idx, 0, kidDicts.size());
          }
          kidDicts.remove(idx);
        }
      };
      PDFAcroTerminal2.prototype.normalizedEntries = function() {
        var Kids = this.Kids();
        if (!Kids) {
          Kids = this.dict.context.obj([this.ref]);
          this.dict.set(PDFName_default.of("Kids"), Kids);
        }
        return { Kids };
      };
      PDFAcroTerminal2.fromDict = function(dict, ref) {
        return new PDFAcroTerminal2(dict, ref);
      };
      return PDFAcroTerminal2;
    }(PDFAcroField_default)
  );
  var PDFAcroTerminal_default = PDFAcroTerminal;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroButton.js
  var PDFAcroButton = (
    /** @class */
    function(_super) {
      __extends(PDFAcroButton2, _super);
      function PDFAcroButton2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroButton2.prototype.Opt = function() {
        return this.dict.lookupMaybe(PDFName_default.of("Opt"), PDFString_default, PDFHexString_default, PDFArray_default);
      };
      PDFAcroButton2.prototype.setOpt = function(opt) {
        this.dict.set(PDFName_default.of("Opt"), this.dict.context.obj(opt));
      };
      PDFAcroButton2.prototype.getExportValues = function() {
        var opt = this.Opt();
        if (!opt)
          return void 0;
        if (opt instanceof PDFString_default || opt instanceof PDFHexString_default) {
          return [opt];
        }
        var values2 = [];
        for (var idx = 0, len = opt.size(); idx < len; idx++) {
          var value = opt.lookup(idx);
          if (value instanceof PDFString_default || value instanceof PDFHexString_default) {
            values2.push(value);
          }
        }
        return values2;
      };
      PDFAcroButton2.prototype.removeExportValue = function(idx) {
        var opt = this.Opt();
        if (!opt)
          return;
        if (opt instanceof PDFString_default || opt instanceof PDFHexString_default) {
          if (idx !== 0)
            throw new IndexOutOfBoundsError(idx, 0, 0);
          this.setOpt([]);
        } else {
          if (idx < 0 || idx > opt.size()) {
            throw new IndexOutOfBoundsError(idx, 0, opt.size());
          }
          opt.remove(idx);
        }
      };
      PDFAcroButton2.prototype.normalizeExportValues = function() {
        var _a, _b, _c, _d;
        var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];
        var Opt = [];
        var widgets = this.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var exportVal = (_b = exportValues[idx]) !== null && _b !== void 0 ? _b : PDFHexString_default.fromText((_d = (_c = widget.getOnValue()) === null || _c === void 0 ? void 0 : _c.decodeText()) !== null && _d !== void 0 ? _d : "");
          Opt.push(exportVal);
        }
        this.setOpt(Opt);
      };
      PDFAcroButton2.prototype.addOpt = function(opt, useExistingOptIdx) {
        var _a;
        this.normalizeExportValues();
        var optText = opt.decodeText();
        var existingIdx;
        if (useExistingOptIdx) {
          var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];
          for (var idx = 0, len = exportValues.length; idx < len; idx++) {
            var exportVal = exportValues[idx];
            if (exportVal.decodeText() === optText)
              existingIdx = idx;
          }
        }
        var Opt = this.Opt();
        Opt.push(opt);
        return existingIdx !== null && existingIdx !== void 0 ? existingIdx : Opt.size() - 1;
      };
      PDFAcroButton2.prototype.addWidgetWithOpt = function(widget, opt, useExistingOptIdx) {
        var optIdx = this.addOpt(opt, useExistingOptIdx);
        var apStateValue = PDFName_default.of(String(optIdx));
        this.addWidget(widget);
        return apStateValue;
      };
      return PDFAcroButton2;
    }(PDFAcroTerminal_default)
  );
  var PDFAcroButton_default = PDFAcroButton;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroCheckBox.js
  var PDFAcroCheckBox = (
    /** @class */
    function(_super) {
      __extends(PDFAcroCheckBox2, _super);
      function PDFAcroCheckBox2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroCheckBox2.prototype.setValue = function(value) {
        var _a;
        var onValue = (_a = this.getOnValue()) !== null && _a !== void 0 ? _a : PDFName_default.of("Yes");
        if (value !== onValue && value !== PDFName_default.of("Off")) {
          throw new InvalidAcroFieldValueError();
        }
        this.dict.set(PDFName_default.of("V"), value);
        var widgets = this.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var state = widget.getOnValue() === value ? value : PDFName_default.of("Off");
          widget.setAppearanceState(state);
        }
      };
      PDFAcroCheckBox2.prototype.getValue = function() {
        var v = this.V();
        if (v instanceof PDFName_default)
          return v;
        return PDFName_default.of("Off");
      };
      PDFAcroCheckBox2.prototype.getOnValue = function() {
        var widget = this.getWidgets()[0];
        return widget === null || widget === void 0 ? void 0 : widget.getOnValue();
      };
      PDFAcroCheckBox2.fromDict = function(dict, ref) {
        return new PDFAcroCheckBox2(dict, ref);
      };
      PDFAcroCheckBox2.create = function(context) {
        var dict = context.obj({
          FT: "Btn",
          Kids: []
        });
        var ref = context.register(dict);
        return new PDFAcroCheckBox2(dict, ref);
      };
      return PDFAcroCheckBox2;
    }(PDFAcroButton_default)
  );
  var PDFAcroCheckBox_default = PDFAcroCheckBox;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/flags.js
  var flag = function(bitIndex) {
    return 1 << bitIndex;
  };
  var AcroFieldFlags;
  (function(AcroFieldFlags2) {
    AcroFieldFlags2[AcroFieldFlags2["ReadOnly"] = flag(1 - 1)] = "ReadOnly";
    AcroFieldFlags2[AcroFieldFlags2["Required"] = flag(2 - 1)] = "Required";
    AcroFieldFlags2[AcroFieldFlags2["NoExport"] = flag(3 - 1)] = "NoExport";
  })(AcroFieldFlags || (AcroFieldFlags = {}));
  var AcroButtonFlags;
  (function(AcroButtonFlags2) {
    AcroButtonFlags2[AcroButtonFlags2["NoToggleToOff"] = flag(15 - 1)] = "NoToggleToOff";
    AcroButtonFlags2[AcroButtonFlags2["Radio"] = flag(16 - 1)] = "Radio";
    AcroButtonFlags2[AcroButtonFlags2["PushButton"] = flag(17 - 1)] = "PushButton";
    AcroButtonFlags2[AcroButtonFlags2["RadiosInUnison"] = flag(26 - 1)] = "RadiosInUnison";
  })(AcroButtonFlags || (AcroButtonFlags = {}));
  var AcroTextFlags;
  (function(AcroTextFlags2) {
    AcroTextFlags2[AcroTextFlags2["Multiline"] = flag(13 - 1)] = "Multiline";
    AcroTextFlags2[AcroTextFlags2["Password"] = flag(14 - 1)] = "Password";
    AcroTextFlags2[AcroTextFlags2["FileSelect"] = flag(21 - 1)] = "FileSelect";
    AcroTextFlags2[AcroTextFlags2["DoNotSpellCheck"] = flag(23 - 1)] = "DoNotSpellCheck";
    AcroTextFlags2[AcroTextFlags2["DoNotScroll"] = flag(24 - 1)] = "DoNotScroll";
    AcroTextFlags2[AcroTextFlags2["Comb"] = flag(25 - 1)] = "Comb";
    AcroTextFlags2[AcroTextFlags2["RichText"] = flag(26 - 1)] = "RichText";
  })(AcroTextFlags || (AcroTextFlags = {}));
  var AcroChoiceFlags;
  (function(AcroChoiceFlags2) {
    AcroChoiceFlags2[AcroChoiceFlags2["Combo"] = flag(18 - 1)] = "Combo";
    AcroChoiceFlags2[AcroChoiceFlags2["Edit"] = flag(19 - 1)] = "Edit";
    AcroChoiceFlags2[AcroChoiceFlags2["Sort"] = flag(20 - 1)] = "Sort";
    AcroChoiceFlags2[AcroChoiceFlags2["MultiSelect"] = flag(22 - 1)] = "MultiSelect";
    AcroChoiceFlags2[AcroChoiceFlags2["DoNotSpellCheck"] = flag(23 - 1)] = "DoNotSpellCheck";
    AcroChoiceFlags2[AcroChoiceFlags2["CommitOnSelChange"] = flag(27 - 1)] = "CommitOnSelChange";
  })(AcroChoiceFlags || (AcroChoiceFlags = {}));

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroChoice.js
  var PDFAcroChoice = (
    /** @class */
    function(_super) {
      __extends(PDFAcroChoice2, _super);
      function PDFAcroChoice2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroChoice2.prototype.setValues = function(values2) {
        if (this.hasFlag(AcroChoiceFlags.Combo) && !this.hasFlag(AcroChoiceFlags.Edit) && !this.valuesAreValid(values2)) {
          throw new InvalidAcroFieldValueError();
        }
        if (values2.length === 0) {
          this.dict.delete(PDFName_default.of("V"));
        }
        if (values2.length === 1) {
          this.dict.set(PDFName_default.of("V"), values2[0]);
        }
        if (values2.length > 1) {
          if (!this.hasFlag(AcroChoiceFlags.MultiSelect)) {
            throw new MultiSelectValueError();
          }
          this.dict.set(PDFName_default.of("V"), this.dict.context.obj(values2));
        }
        this.updateSelectedIndices(values2);
      };
      PDFAcroChoice2.prototype.valuesAreValid = function(values2) {
        var options = this.getOptions();
        var _loop_1 = function(idx2, len2) {
          var val = values2[idx2].decodeText();
          if (!options.find(function(o) {
            return val === (o.display || o.value).decodeText();
          })) {
            return { value: false };
          }
        };
        for (var idx = 0, len = values2.length; idx < len; idx++) {
          var state_1 = _loop_1(idx, len);
          if (typeof state_1 === "object")
            return state_1.value;
        }
        return true;
      };
      PDFAcroChoice2.prototype.updateSelectedIndices = function(values2) {
        if (values2.length > 1) {
          var indices = new Array(values2.length);
          var options = this.getOptions();
          var _loop_2 = function(idx2, len2) {
            var val = values2[idx2].decodeText();
            indices[idx2] = options.findIndex(function(o) {
              return val === (o.display || o.value).decodeText();
            });
          };
          for (var idx = 0, len = values2.length; idx < len; idx++) {
            _loop_2(idx, len);
          }
          this.dict.set(PDFName_default.of("I"), this.dict.context.obj(indices.sort()));
        } else {
          this.dict.delete(PDFName_default.of("I"));
        }
      };
      PDFAcroChoice2.prototype.getValues = function() {
        var v = this.V();
        if (v instanceof PDFString_default || v instanceof PDFHexString_default)
          return [v];
        if (v instanceof PDFArray_default) {
          var values2 = [];
          for (var idx = 0, len = v.size(); idx < len; idx++) {
            var value = v.lookup(idx);
            if (value instanceof PDFString_default || value instanceof PDFHexString_default) {
              values2.push(value);
            }
          }
          return values2;
        }
        return [];
      };
      PDFAcroChoice2.prototype.Opt = function() {
        return this.dict.lookupMaybe(PDFName_default.of("Opt"), PDFString_default, PDFHexString_default, PDFArray_default);
      };
      PDFAcroChoice2.prototype.setOptions = function(options) {
        var newOpt = new Array(options.length);
        for (var idx = 0, len = options.length; idx < len; idx++) {
          var _a = options[idx], value = _a.value, display = _a.display;
          newOpt[idx] = this.dict.context.obj([value, display || value]);
        }
        this.dict.set(PDFName_default.of("Opt"), this.dict.context.obj(newOpt));
      };
      PDFAcroChoice2.prototype.getOptions = function() {
        var Opt = this.Opt();
        if (Opt instanceof PDFString_default || Opt instanceof PDFHexString_default) {
          return [{ value: Opt, display: Opt }];
        }
        if (Opt instanceof PDFArray_default) {
          var res = [];
          for (var idx = 0, len = Opt.size(); idx < len; idx++) {
            var item = Opt.lookup(idx);
            if (item instanceof PDFString_default || item instanceof PDFHexString_default) {
              res.push({ value: item, display: item });
            }
            if (item instanceof PDFArray_default) {
              if (item.size() > 0) {
                var first = item.lookup(0, PDFString_default, PDFHexString_default);
                var second = item.lookupMaybe(1, PDFString_default, PDFHexString_default);
                res.push({ value: first, display: second || first });
              }
            }
          }
          return res;
        }
        return [];
      };
      return PDFAcroChoice2;
    }(PDFAcroTerminal_default)
  );
  var PDFAcroChoice_default = PDFAcroChoice;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroComboBox.js
  var PDFAcroComboBox = (
    /** @class */
    function(_super) {
      __extends(PDFAcroComboBox2, _super);
      function PDFAcroComboBox2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroComboBox2.fromDict = function(dict, ref) {
        return new PDFAcroComboBox2(dict, ref);
      };
      PDFAcroComboBox2.create = function(context) {
        var dict = context.obj({
          FT: "Ch",
          Ff: AcroChoiceFlags.Combo,
          Kids: []
        });
        var ref = context.register(dict);
        return new PDFAcroComboBox2(dict, ref);
      };
      return PDFAcroComboBox2;
    }(PDFAcroChoice_default)
  );
  var PDFAcroComboBox_default = PDFAcroComboBox;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroNonTerminal.js
  var PDFAcroNonTerminal = (
    /** @class */
    function(_super) {
      __extends(PDFAcroNonTerminal2, _super);
      function PDFAcroNonTerminal2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroNonTerminal2.prototype.addField = function(field) {
        var Kids = this.normalizedEntries().Kids;
        Kids === null || Kids === void 0 ? void 0 : Kids.push(field);
      };
      PDFAcroNonTerminal2.prototype.normalizedEntries = function() {
        var Kids = this.Kids();
        if (!Kids) {
          Kids = this.dict.context.obj([]);
          this.dict.set(PDFName_default.of("Kids"), Kids);
        }
        return { Kids };
      };
      PDFAcroNonTerminal2.fromDict = function(dict, ref) {
        return new PDFAcroNonTerminal2(dict, ref);
      };
      PDFAcroNonTerminal2.create = function(context) {
        var dict = context.obj({});
        var ref = context.register(dict);
        return new PDFAcroNonTerminal2(dict, ref);
      };
      return PDFAcroNonTerminal2;
    }(PDFAcroField_default)
  );
  var PDFAcroNonTerminal_default = PDFAcroNonTerminal;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroSignature.js
  var PDFAcroSignature = (
    /** @class */
    function(_super) {
      __extends(PDFAcroSignature2, _super);
      function PDFAcroSignature2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroSignature2.fromDict = function(dict, ref) {
        return new PDFAcroSignature2(dict, ref);
      };
      return PDFAcroSignature2;
    }(PDFAcroTerminal_default)
  );
  var PDFAcroSignature_default = PDFAcroSignature;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroText.js
  var PDFAcroText = (
    /** @class */
    function(_super) {
      __extends(PDFAcroText2, _super);
      function PDFAcroText2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroText2.prototype.MaxLen = function() {
        var maxLen = this.dict.lookup(PDFName_default.of("MaxLen"));
        if (maxLen instanceof PDFNumber_default)
          return maxLen;
        return void 0;
      };
      PDFAcroText2.prototype.Q = function() {
        var q = this.dict.lookup(PDFName_default.of("Q"));
        if (q instanceof PDFNumber_default)
          return q;
        return void 0;
      };
      PDFAcroText2.prototype.setMaxLength = function(maxLength) {
        this.dict.set(PDFName_default.of("MaxLen"), PDFNumber_default.of(maxLength));
      };
      PDFAcroText2.prototype.removeMaxLength = function() {
        this.dict.delete(PDFName_default.of("MaxLen"));
      };
      PDFAcroText2.prototype.getMaxLength = function() {
        var _a;
        return (_a = this.MaxLen()) === null || _a === void 0 ? void 0 : _a.asNumber();
      };
      PDFAcroText2.prototype.setQuadding = function(quadding) {
        this.dict.set(PDFName_default.of("Q"), PDFNumber_default.of(quadding));
      };
      PDFAcroText2.prototype.getQuadding = function() {
        var _a;
        return (_a = this.Q()) === null || _a === void 0 ? void 0 : _a.asNumber();
      };
      PDFAcroText2.prototype.setValue = function(value) {
        this.dict.set(PDFName_default.of("V"), value);
      };
      PDFAcroText2.prototype.removeValue = function() {
        this.dict.delete(PDFName_default.of("V"));
      };
      PDFAcroText2.prototype.getValue = function() {
        var v = this.V();
        if (v instanceof PDFString_default || v instanceof PDFHexString_default)
          return v;
        return void 0;
      };
      PDFAcroText2.fromDict = function(dict, ref) {
        return new PDFAcroText2(dict, ref);
      };
      PDFAcroText2.create = function(context) {
        var dict = context.obj({
          FT: "Tx",
          Kids: []
        });
        var ref = context.register(dict);
        return new PDFAcroText2(dict, ref);
      };
      return PDFAcroText2;
    }(PDFAcroTerminal_default)
  );
  var PDFAcroText_default = PDFAcroText;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroPushButton.js
  var PDFAcroPushButton = (
    /** @class */
    function(_super) {
      __extends(PDFAcroPushButton2, _super);
      function PDFAcroPushButton2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroPushButton2.fromDict = function(dict, ref) {
        return new PDFAcroPushButton2(dict, ref);
      };
      PDFAcroPushButton2.create = function(context) {
        var dict = context.obj({
          FT: "Btn",
          Ff: AcroButtonFlags.PushButton,
          Kids: []
        });
        var ref = context.register(dict);
        return new PDFAcroPushButton2(dict, ref);
      };
      return PDFAcroPushButton2;
    }(PDFAcroButton_default)
  );
  var PDFAcroPushButton_default = PDFAcroPushButton;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroRadioButton.js
  var PDFAcroRadioButton = (
    /** @class */
    function(_super) {
      __extends(PDFAcroRadioButton2, _super);
      function PDFAcroRadioButton2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroRadioButton2.prototype.setValue = function(value) {
        var onValues = this.getOnValues();
        if (!onValues.includes(value) && value !== PDFName_default.of("Off")) {
          throw new InvalidAcroFieldValueError();
        }
        this.dict.set(PDFName_default.of("V"), value);
        var widgets = this.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var state = widget.getOnValue() === value ? value : PDFName_default.of("Off");
          widget.setAppearanceState(state);
        }
      };
      PDFAcroRadioButton2.prototype.getValue = function() {
        var v = this.V();
        if (v instanceof PDFName_default)
          return v;
        return PDFName_default.of("Off");
      };
      PDFAcroRadioButton2.prototype.getOnValues = function() {
        var widgets = this.getWidgets();
        var onValues = [];
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var onValue = widgets[idx].getOnValue();
          if (onValue)
            onValues.push(onValue);
        }
        return onValues;
      };
      PDFAcroRadioButton2.fromDict = function(dict, ref) {
        return new PDFAcroRadioButton2(dict, ref);
      };
      PDFAcroRadioButton2.create = function(context) {
        var dict = context.obj({
          FT: "Btn",
          Ff: AcroButtonFlags.Radio,
          Kids: []
        });
        var ref = context.register(dict);
        return new PDFAcroRadioButton2(dict, ref);
      };
      return PDFAcroRadioButton2;
    }(PDFAcroButton_default)
  );
  var PDFAcroRadioButton_default = PDFAcroRadioButton;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroListBox.js
  var PDFAcroListBox = (
    /** @class */
    function(_super) {
      __extends(PDFAcroListBox2, _super);
      function PDFAcroListBox2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFAcroListBox2.fromDict = function(dict, ref) {
        return new PDFAcroListBox2(dict, ref);
      };
      PDFAcroListBox2.create = function(context) {
        var dict = context.obj({
          FT: "Ch",
          Kids: []
        });
        var ref = context.register(dict);
        return new PDFAcroListBox2(dict, ref);
      };
      return PDFAcroListBox2;
    }(PDFAcroChoice_default)
  );
  var PDFAcroListBox_default = PDFAcroListBox;

  // node_modules/@pdfme/pdf-lib/es/core/acroform/utils.js
  var createPDFAcroFields = function(kidDicts) {
    if (!kidDicts)
      return [];
    var kids = [];
    for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {
      var ref = kidDicts.get(idx);
      var dict = kidDicts.lookup(idx);
      if (ref instanceof PDFRef_default && dict instanceof PDFDict_default) {
        kids.push([createPDFAcroField(dict, ref), ref]);
      }
    }
    return kids;
  };
  var createPDFAcroField = function(dict, ref) {
    var isNonTerminal = isNonTerminalAcroField(dict);
    if (isNonTerminal)
      return PDFAcroNonTerminal_default.fromDict(dict, ref);
    return createPDFAcroTerminal(dict, ref);
  };
  var isNonTerminalAcroField = function(dict) {
    var kids = dict.lookup(PDFName_default.of("Kids"));
    if (kids instanceof PDFArray_default) {
      for (var idx = 0, len = kids.size(); idx < len; idx++) {
        var kid = kids.lookup(idx);
        var kidIsField = kid instanceof PDFDict_default && kid.has(PDFName_default.of("T"));
        if (kidIsField)
          return true;
      }
    }
    return false;
  };
  var createPDFAcroTerminal = function(dict, ref) {
    var ftNameOrRef = getInheritableAttribute(dict, PDFName_default.of("FT"));
    var type = dict.context.lookup(ftNameOrRef, PDFName_default);
    if (type === PDFName_default.of("Btn"))
      return createPDFAcroButton(dict, ref);
    if (type === PDFName_default.of("Ch"))
      return createPDFAcroChoice(dict, ref);
    if (type === PDFName_default.of("Tx"))
      return PDFAcroText_default.fromDict(dict, ref);
    if (type === PDFName_default.of("Sig"))
      return PDFAcroSignature_default.fromDict(dict, ref);
    return PDFAcroTerminal_default.fromDict(dict, ref);
  };
  var createPDFAcroButton = function(dict, ref) {
    var _a;
    var ffNumberOrRef = getInheritableAttribute(dict, PDFName_default.of("Ff"));
    var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_default);
    var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;
    if (flagIsSet(flags, AcroButtonFlags.PushButton)) {
      return PDFAcroPushButton_default.fromDict(dict, ref);
    } else if (flagIsSet(flags, AcroButtonFlags.Radio)) {
      return PDFAcroRadioButton_default.fromDict(dict, ref);
    } else {
      return PDFAcroCheckBox_default.fromDict(dict, ref);
    }
  };
  var createPDFAcroChoice = function(dict, ref) {
    var _a;
    var ffNumberOrRef = getInheritableAttribute(dict, PDFName_default.of("Ff"));
    var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_default);
    var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;
    if (flagIsSet(flags, AcroChoiceFlags.Combo)) {
      return PDFAcroComboBox_default.fromDict(dict, ref);
    } else {
      return PDFAcroListBox_default.fromDict(dict, ref);
    }
  };
  var flagIsSet = function(flags, flag3) {
    return (flags & flag3) !== 0;
  };
  var getInheritableAttribute = function(startNode, name) {
    var attribute;
    ascend(startNode, function(node) {
      if (!attribute)
        attribute = node.get(name);
    });
    return attribute;
  };
  var ascend = function(startNode, visitor) {
    visitor(startNode);
    var Parent = startNode.lookupMaybe(PDFName_default.of("Parent"), PDFDict_default);
    if (Parent)
      ascend(Parent, visitor);
  };

  // node_modules/@pdfme/pdf-lib/es/core/acroform/PDFAcroForm.js
  var PDFAcroForm = (
    /** @class */
    function() {
      function PDFAcroForm2(dict) {
        this.dict = dict;
      }
      PDFAcroForm2.prototype.Fields = function() {
        var fields = this.dict.lookup(PDFName_default.of("Fields"));
        if (fields instanceof PDFArray_default)
          return fields;
        return void 0;
      };
      PDFAcroForm2.prototype.getFields = function() {
        var Fields = this.normalizedEntries().Fields;
        var fields = new Array(Fields.size());
        for (var idx = 0, len = Fields.size(); idx < len; idx++) {
          var ref = Fields.get(idx);
          var dict = Fields.lookup(idx, PDFDict_default);
          fields[idx] = [createPDFAcroField(dict, ref), ref];
        }
        return fields;
      };
      PDFAcroForm2.prototype.getAllFields = function() {
        var allFields = [];
        var pushFields = function(fields) {
          if (!fields)
            return;
          for (var idx = 0, len = fields.length; idx < len; idx++) {
            var field = fields[idx];
            allFields.push(field);
            var fieldModel = field[0];
            if (fieldModel instanceof PDFAcroNonTerminal_default) {
              pushFields(createPDFAcroFields(fieldModel.Kids()));
            }
          }
        };
        pushFields(this.getFields());
        return allFields;
      };
      PDFAcroForm2.prototype.addField = function(field) {
        var Fields = this.normalizedEntries().Fields;
        Fields === null || Fields === void 0 ? void 0 : Fields.push(field);
      };
      PDFAcroForm2.prototype.removeField = function(field) {
        var parent = field.getParent();
        var fields = parent === void 0 ? this.normalizedEntries().Fields : parent.Kids();
        var index = fields === null || fields === void 0 ? void 0 : fields.indexOf(field.ref);
        if (fields === void 0 || index === void 0) {
          throw new Error("Tried to remove inexistent field " + field.getFullyQualifiedName());
        }
        fields.remove(index);
        if (parent !== void 0 && fields.size() === 0) {
          this.removeField(parent);
        }
      };
      PDFAcroForm2.prototype.normalizedEntries = function() {
        var Fields = this.Fields();
        if (!Fields) {
          Fields = this.dict.context.obj([]);
          this.dict.set(PDFName_default.of("Fields"), Fields);
        }
        return { Fields };
      };
      PDFAcroForm2.fromDict = function(dict) {
        return new PDFAcroForm2(dict);
      };
      PDFAcroForm2.create = function(context) {
        var dict = context.obj({ Fields: [] });
        return new PDFAcroForm2(dict);
      };
      return PDFAcroForm2;
    }()
  );
  var PDFAcroForm_default = PDFAcroForm;

  // node_modules/@pdfme/pdf-lib/es/core/structures/PDFCatalog.js
  var PDFCatalog = (
    /** @class */
    function(_super) {
      __extends(PDFCatalog2, _super);
      function PDFCatalog2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFCatalog2.prototype.Pages = function() {
        return this.lookup(PDFName_default.of("Pages"), PDFDict_default);
      };
      PDFCatalog2.prototype.AcroForm = function() {
        return this.lookupMaybe(PDFName_default.of("AcroForm"), PDFDict_default);
      };
      PDFCatalog2.prototype.getAcroForm = function() {
        var dict = this.AcroForm();
        if (!dict)
          return void 0;
        return PDFAcroForm_default.fromDict(dict);
      };
      PDFCatalog2.prototype.getOrCreateAcroForm = function() {
        var acroForm = this.getAcroForm();
        if (!acroForm) {
          acroForm = PDFAcroForm_default.create(this.context);
          var acroFormRef = this.context.register(acroForm.dict);
          this.set(PDFName_default.of("AcroForm"), acroFormRef);
        }
        return acroForm;
      };
      PDFCatalog2.prototype.ViewerPreferences = function() {
        return this.lookupMaybe(PDFName_default.of("ViewerPreferences"), PDFDict_default);
      };
      PDFCatalog2.prototype.getViewerPreferences = function() {
        var dict = this.ViewerPreferences();
        if (!dict)
          return void 0;
        return ViewerPreferences_default.fromDict(dict);
      };
      PDFCatalog2.prototype.getOrCreateViewerPreferences = function() {
        var viewerPrefs = this.getViewerPreferences();
        if (!viewerPrefs) {
          viewerPrefs = ViewerPreferences_default.create(this.context);
          var viewerPrefsRef = this.context.register(viewerPrefs.dict);
          this.set(PDFName_default.of("ViewerPreferences"), viewerPrefsRef);
        }
        return viewerPrefs;
      };
      PDFCatalog2.prototype.insertLeafNode = function(leafRef, index) {
        var pagesRef = this.get(PDFName_default.of("Pages"));
        var maybeParentRef = this.Pages().insertLeafNode(leafRef, index);
        return maybeParentRef || pagesRef;
      };
      PDFCatalog2.prototype.removeLeafNode = function(index) {
        this.Pages().removeLeafNode(index);
      };
      PDFCatalog2.withContextAndPages = function(context, pages) {
        var dict = /* @__PURE__ */ new Map();
        dict.set(PDFName_default.of("Type"), PDFName_default.of("Catalog"));
        dict.set(PDFName_default.of("Pages"), pages);
        return new PDFCatalog2(dict, context);
      };
      PDFCatalog2.fromMapWithContext = function(map, context) {
        return new PDFCatalog2(map, context);
      };
      return PDFCatalog2;
    }(PDFDict_default)
  );
  var PDFCatalog_default = PDFCatalog;

  // node_modules/@pdfme/pdf-lib/es/core/structures/PDFPageTree.js
  var PDFPageTree = (
    /** @class */
    function(_super) {
      __extends(PDFPageTree2, _super);
      function PDFPageTree2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PDFPageTree2.prototype.Parent = function() {
        return this.lookup(PDFName_default.of("Parent"));
      };
      PDFPageTree2.prototype.Kids = function() {
        return this.lookup(PDFName_default.of("Kids"), PDFArray_default);
      };
      PDFPageTree2.prototype.Count = function() {
        return this.lookup(PDFName_default.of("Count"), PDFNumber_default);
      };
      PDFPageTree2.prototype.pushTreeNode = function(treeRef) {
        var Kids = this.Kids();
        Kids.push(treeRef);
      };
      PDFPageTree2.prototype.pushLeafNode = function(leafRef) {
        var Kids = this.Kids();
        this.insertLeafKid(Kids.size(), leafRef);
      };
      PDFPageTree2.prototype.insertLeafNode = function(leafRef, targetIndex) {
        var Kids = this.Kids();
        var Count = this.Count().asNumber();
        if (targetIndex > Count) {
          throw new InvalidTargetIndexError(targetIndex, Count);
        }
        var leafsRemainingUntilTarget = targetIndex;
        for (var idx = 0, len = Kids.size(); idx < len; idx++) {
          if (leafsRemainingUntilTarget === 0) {
            this.insertLeafKid(idx, leafRef);
            return void 0;
          }
          var kidRef = Kids.get(idx);
          var kid = this.context.lookup(kidRef);
          if (kid instanceof PDFPageTree2) {
            if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
              return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;
            } else {
              leafsRemainingUntilTarget -= kid.Count().asNumber();
            }
          }
          if (kid instanceof PDFPageLeaf_default) {
            leafsRemainingUntilTarget -= 1;
          }
        }
        if (leafsRemainingUntilTarget === 0) {
          this.insertLeafKid(Kids.size(), leafRef);
          return void 0;
        }
        throw new CorruptPageTreeError(targetIndex, "insertLeafNode");
      };
      PDFPageTree2.prototype.removeLeafNode = function(targetIndex, prune) {
        if (prune === void 0) {
          prune = true;
        }
        var Kids = this.Kids();
        var Count = this.Count().asNumber();
        if (targetIndex >= Count) {
          throw new InvalidTargetIndexError(targetIndex, Count);
        }
        var leafsRemainingUntilTarget = targetIndex;
        for (var idx = 0, len = Kids.size(); idx < len; idx++) {
          var kidRef = Kids.get(idx);
          var kid = this.context.lookup(kidRef);
          if (kid instanceof PDFPageTree2) {
            if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
              kid.removeLeafNode(leafsRemainingUntilTarget, prune);
              if (prune && kid.Kids().size() === 0)
                Kids.remove(idx);
              return;
            } else {
              leafsRemainingUntilTarget -= kid.Count().asNumber();
            }
          }
          if (kid instanceof PDFPageLeaf_default) {
            if (leafsRemainingUntilTarget === 0) {
              this.removeKid(idx);
              return;
            } else {
              leafsRemainingUntilTarget -= 1;
            }
          }
        }
        throw new CorruptPageTreeError(targetIndex, "removeLeafNode");
      };
      PDFPageTree2.prototype.ascend = function(visitor) {
        visitor(this);
        var Parent = this.Parent();
        if (Parent)
          Parent.ascend(visitor);
      };
      PDFPageTree2.prototype.traverse = function(visitor) {
        var Kids = this.Kids();
        for (var idx = 0, len = Kids.size(); idx < len; idx++) {
          var kidRef = Kids.get(idx);
          var kid = this.context.lookup(kidRef);
          if (kid instanceof PDFPageTree2)
            kid.traverse(visitor);
          visitor(kid, kidRef);
        }
      };
      PDFPageTree2.prototype.insertLeafKid = function(kidIdx, leafRef) {
        var Kids = this.Kids();
        this.ascend(function(node) {
          var newCount = node.Count().asNumber() + 1;
          node.set(PDFName_default.of("Count"), PDFNumber_default.of(newCount));
        });
        Kids.insert(kidIdx, leafRef);
      };
      PDFPageTree2.prototype.removeKid = function(kidIdx) {
        var Kids = this.Kids();
        var kid = Kids.lookup(kidIdx);
        if (kid instanceof PDFPageLeaf_default) {
          this.ascend(function(node) {
            var newCount = node.Count().asNumber() - 1;
            node.set(PDFName_default.of("Count"), PDFNumber_default.of(newCount));
          });
        }
        Kids.remove(kidIdx);
      };
      PDFPageTree2.withContext = function(context, parent) {
        var dict = /* @__PURE__ */ new Map();
        dict.set(PDFName_default.of("Type"), PDFName_default.of("Pages"));
        dict.set(PDFName_default.of("Kids"), context.obj([]));
        dict.set(PDFName_default.of("Count"), context.obj(0));
        if (parent)
          dict.set(PDFName_default.of("Parent"), parent);
        return new PDFPageTree2(dict, context);
      };
      PDFPageTree2.fromMapWithContext = function(map, context) {
        return new PDFPageTree2(map, context);
      };
      return PDFPageTree2;
    }(PDFDict_default)
  );
  var PDFPageTree_default = PDFPageTree;

  // node_modules/@pdfme/pdf-lib/es/core/syntax/Numeric.js
  var IsDigit = new Uint8Array(256);
  IsDigit[CharCodes_default.Zero] = 1;
  IsDigit[CharCodes_default.One] = 1;
  IsDigit[CharCodes_default.Two] = 1;
  IsDigit[CharCodes_default.Three] = 1;
  IsDigit[CharCodes_default.Four] = 1;
  IsDigit[CharCodes_default.Five] = 1;
  IsDigit[CharCodes_default.Six] = 1;
  IsDigit[CharCodes_default.Seven] = 1;
  IsDigit[CharCodes_default.Eight] = 1;
  IsDigit[CharCodes_default.Nine] = 1;
  var IsNumericPrefix = new Uint8Array(256);
  IsNumericPrefix[CharCodes_default.Period] = 1;
  IsNumericPrefix[CharCodes_default.Plus] = 1;
  IsNumericPrefix[CharCodes_default.Minus] = 1;
  var IsNumeric = new Uint8Array(256);
  for (idx = 0, len = 256; idx < len; idx++) {
    IsNumeric[idx] = IsDigit[idx] || IsNumericPrefix[idx] ? 1 : 0;
  }
  var idx;
  var len;

  // node_modules/@pdfme/pdf-lib/es/core/parser/BaseParser.js
  var Newline = CharCodes_default.Newline, CarriageReturn = CharCodes_default.CarriageReturn;
  var BaseParser = (
    /** @class */
    function() {
      function BaseParser2(bytes, capNumbers) {
        if (capNumbers === void 0) {
          capNumbers = false;
        }
        this.bytes = bytes;
        this.capNumbers = capNumbers;
      }
      BaseParser2.prototype.parseRawInt = function() {
        var value = "";
        while (!this.bytes.done()) {
          var byte = this.bytes.peek();
          if (!IsDigit[byte])
            break;
          value += charFromCode(this.bytes.next());
        }
        var numberValue = Number(value);
        if (!value || !isFinite(numberValue)) {
          throw new NumberParsingError(this.bytes.position(), value);
        }
        return numberValue;
      };
      BaseParser2.prototype.parseRawNumber = function() {
        var value = "";
        while (!this.bytes.done()) {
          var byte = this.bytes.peek();
          if (!IsNumeric[byte])
            break;
          value += charFromCode(this.bytes.next());
          if (byte === CharCodes_default.Period)
            break;
        }
        while (!this.bytes.done()) {
          var byte = this.bytes.peek();
          if (!IsDigit[byte])
            break;
          value += charFromCode(this.bytes.next());
        }
        var numberValue = Number(value);
        if (!value || !isFinite(numberValue)) {
          throw new NumberParsingError(this.bytes.position(), value);
        }
        if (numberValue > Number.MAX_SAFE_INTEGER) {
          if (this.capNumbers) {
            var msg = "Parsed number that is too large for some PDF readers: " + value + ", using Number.MAX_SAFE_INTEGER instead.";
            console.warn(msg);
            return Number.MAX_SAFE_INTEGER;
          } else {
            var msg = "Parsed number that is too large for some PDF readers: " + value + ", not capping.";
            console.warn(msg);
          }
        }
        return numberValue;
      };
      BaseParser2.prototype.skipWhitespace = function() {
        while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {
          this.bytes.next();
        }
      };
      BaseParser2.prototype.skipLine = function() {
        while (!this.bytes.done()) {
          var byte = this.bytes.peek();
          if (byte === Newline || byte === CarriageReturn)
            return;
          this.bytes.next();
        }
      };
      BaseParser2.prototype.skipComment = function() {
        if (this.bytes.peek() !== CharCodes_default.Percent)
          return false;
        while (!this.bytes.done()) {
          var byte = this.bytes.peek();
          if (byte === Newline || byte === CarriageReturn)
            return true;
          this.bytes.next();
        }
        return true;
      };
      BaseParser2.prototype.skipWhitespaceAndComments = function() {
        this.skipWhitespace();
        while (this.skipComment())
          this.skipWhitespace();
      };
      BaseParser2.prototype.matchKeyword = function(keyword) {
        var initialOffset = this.bytes.offset();
        for (var idx = 0, len = keyword.length; idx < len; idx++) {
          if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {
            this.bytes.moveTo(initialOffset);
            return false;
          }
        }
        return true;
      };
      return BaseParser2;
    }()
  );
  var BaseParser_default = BaseParser;

  // node_modules/@pdfme/pdf-lib/es/core/parser/ByteStream.js
  var ByteStream = (
    /** @class */
    function() {
      function ByteStream2(bytes) {
        this.idx = 0;
        this.line = 0;
        this.column = 0;
        this.bytes = bytes;
        this.length = this.bytes.length;
      }
      ByteStream2.prototype.moveTo = function(offset) {
        this.idx = offset;
      };
      ByteStream2.prototype.next = function() {
        var byte = this.bytes[this.idx++];
        if (byte === CharCodes_default.Newline) {
          this.line += 1;
          this.column = 0;
        } else {
          this.column += 1;
        }
        return byte;
      };
      ByteStream2.prototype.assertNext = function(expected) {
        if (this.peek() !== expected) {
          throw new NextByteAssertionError(this.position(), expected, this.peek());
        }
        return this.next();
      };
      ByteStream2.prototype.peek = function() {
        return this.bytes[this.idx];
      };
      ByteStream2.prototype.peekAhead = function(steps) {
        return this.bytes[this.idx + steps];
      };
      ByteStream2.prototype.peekAt = function(offset) {
        return this.bytes[offset];
      };
      ByteStream2.prototype.done = function() {
        return this.idx >= this.length;
      };
      ByteStream2.prototype.offset = function() {
        return this.idx;
      };
      ByteStream2.prototype.slice = function(start, end) {
        return this.bytes.slice(start, end);
      };
      ByteStream2.prototype.position = function() {
        return { line: this.line, column: this.column, offset: this.idx };
      };
      ByteStream2.of = function(bytes) {
        return new ByteStream2(bytes);
      };
      ByteStream2.fromPDFRawStream = function(rawStream) {
        return ByteStream2.of(decodePDFRawStream(rawStream).decode());
      };
      return ByteStream2;
    }()
  );
  var ByteStream_default = ByteStream;

  // node_modules/@pdfme/pdf-lib/es/core/syntax/Keywords.js
  var Space = CharCodes_default.Space, CarriageReturn2 = CharCodes_default.CarriageReturn, Newline2 = CharCodes_default.Newline;
  var stream = [
    CharCodes_default.s,
    CharCodes_default.t,
    CharCodes_default.r,
    CharCodes_default.e,
    CharCodes_default.a,
    CharCodes_default.m
  ];
  var endstream = [
    CharCodes_default.e,
    CharCodes_default.n,
    CharCodes_default.d,
    CharCodes_default.s,
    CharCodes_default.t,
    CharCodes_default.r,
    CharCodes_default.e,
    CharCodes_default.a,
    CharCodes_default.m
  ];
  var Keywords = {
    header: [
      CharCodes_default.Percent,
      CharCodes_default.P,
      CharCodes_default.D,
      CharCodes_default.F,
      CharCodes_default.Dash
    ],
    eof: [
      CharCodes_default.Percent,
      CharCodes_default.Percent,
      CharCodes_default.E,
      CharCodes_default.O,
      CharCodes_default.F
    ],
    obj: [CharCodes_default.o, CharCodes_default.b, CharCodes_default.j],
    endobj: [
      CharCodes_default.e,
      CharCodes_default.n,
      CharCodes_default.d,
      CharCodes_default.o,
      CharCodes_default.b,
      CharCodes_default.j
    ],
    xref: [CharCodes_default.x, CharCodes_default.r, CharCodes_default.e, CharCodes_default.f],
    trailer: [
      CharCodes_default.t,
      CharCodes_default.r,
      CharCodes_default.a,
      CharCodes_default.i,
      CharCodes_default.l,
      CharCodes_default.e,
      CharCodes_default.r
    ],
    startxref: [
      CharCodes_default.s,
      CharCodes_default.t,
      CharCodes_default.a,
      CharCodes_default.r,
      CharCodes_default.t,
      CharCodes_default.x,
      CharCodes_default.r,
      CharCodes_default.e,
      CharCodes_default.f
    ],
    true: [CharCodes_default.t, CharCodes_default.r, CharCodes_default.u, CharCodes_default.e],
    false: [CharCodes_default.f, CharCodes_default.a, CharCodes_default.l, CharCodes_default.s, CharCodes_default.e],
    null: [CharCodes_default.n, CharCodes_default.u, CharCodes_default.l, CharCodes_default.l],
    stream,
    streamEOF1: __spreadArrays(stream, [Space, CarriageReturn2, Newline2]),
    streamEOF2: __spreadArrays(stream, [CarriageReturn2, Newline2]),
    streamEOF3: __spreadArrays(stream, [CarriageReturn2]),
    streamEOF4: __spreadArrays(stream, [Newline2]),
    endstream,
    EOF1endstream: __spreadArrays([CarriageReturn2, Newline2], endstream),
    EOF2endstream: __spreadArrays([CarriageReturn2], endstream),
    EOF3endstream: __spreadArrays([Newline2], endstream)
  };

  // node_modules/@pdfme/pdf-lib/es/core/parser/PDFObjectParser.js
  var PDFObjectParser = (
    /** @class */
    function(_super) {
      __extends(PDFObjectParser2, _super);
      function PDFObjectParser2(byteStream, context, capNumbers) {
        if (capNumbers === void 0) {
          capNumbers = false;
        }
        var _this = _super.call(this, byteStream, capNumbers) || this;
        _this.context = context;
        return _this;
      }
      PDFObjectParser2.prototype.parseObject = function() {
        this.skipWhitespaceAndComments();
        if (this.matchKeyword(Keywords.true))
          return PDFBool_default.True;
        if (this.matchKeyword(Keywords.false))
          return PDFBool_default.False;
        if (this.matchKeyword(Keywords.null))
          return PDFNull_default;
        var byte = this.bytes.peek();
        if (byte === CharCodes_default.LessThan && this.bytes.peekAhead(1) === CharCodes_default.LessThan) {
          return this.parseDictOrStream();
        }
        if (byte === CharCodes_default.LessThan)
          return this.parseHexString();
        if (byte === CharCodes_default.LeftParen)
          return this.parseString();
        if (byte === CharCodes_default.ForwardSlash)
          return this.parseName();
        if (byte === CharCodes_default.LeftSquareBracket)
          return this.parseArray();
        if (IsNumeric[byte])
          return this.parseNumberOrRef();
        throw new PDFObjectParsingError(this.bytes.position(), byte);
      };
      PDFObjectParser2.prototype.parseNumberOrRef = function() {
        var firstNum = this.parseRawNumber();
        this.skipWhitespaceAndComments();
        var lookaheadStart = this.bytes.offset();
        if (IsDigit[this.bytes.peek()]) {
          var secondNum = this.parseRawNumber();
          this.skipWhitespaceAndComments();
          if (this.bytes.peek() === CharCodes_default.R) {
            this.bytes.assertNext(CharCodes_default.R);
            return PDFRef_default.of(firstNum, secondNum);
          }
        }
        this.bytes.moveTo(lookaheadStart);
        return PDFNumber_default.of(firstNum);
      };
      PDFObjectParser2.prototype.parseHexString = function() {
        var value = "";
        this.bytes.assertNext(CharCodes_default.LessThan);
        while (!this.bytes.done() && this.bytes.peek() !== CharCodes_default.GreaterThan) {
          value += charFromCode(this.bytes.next());
        }
        this.bytes.assertNext(CharCodes_default.GreaterThan);
        return PDFHexString_default.of(value);
      };
      PDFObjectParser2.prototype.parseString = function() {
        var nestingLvl = 0;
        var isEscaped = false;
        var value = "";
        while (!this.bytes.done()) {
          var byte = this.bytes.next();
          value += charFromCode(byte);
          if (!isEscaped) {
            if (byte === CharCodes_default.LeftParen)
              nestingLvl += 1;
            if (byte === CharCodes_default.RightParen)
              nestingLvl -= 1;
          }
          if (byte === CharCodes_default.BackSlash) {
            isEscaped = !isEscaped;
          } else if (isEscaped) {
            isEscaped = false;
          }
          if (nestingLvl === 0) {
            return PDFString_default.of(value.substring(1, value.length - 1));
          }
        }
        throw new UnbalancedParenthesisError(this.bytes.position());
      };
      PDFObjectParser2.prototype.parseName = function() {
        this.bytes.assertNext(CharCodes_default.ForwardSlash);
        var name = "";
        while (!this.bytes.done()) {
          var byte = this.bytes.peek();
          if (IsWhitespace[byte] || IsDelimiter[byte])
            break;
          name += charFromCode(byte);
          this.bytes.next();
        }
        return PDFName_default.of(name);
      };
      PDFObjectParser2.prototype.parseArray = function() {
        this.bytes.assertNext(CharCodes_default.LeftSquareBracket);
        this.skipWhitespaceAndComments();
        var pdfArray = PDFArray_default.withContext(this.context);
        while (this.bytes.peek() !== CharCodes_default.RightSquareBracket) {
          var element = this.parseObject();
          pdfArray.push(element);
          this.skipWhitespaceAndComments();
        }
        this.bytes.assertNext(CharCodes_default.RightSquareBracket);
        return pdfArray;
      };
      PDFObjectParser2.prototype.parseDict = function() {
        this.bytes.assertNext(CharCodes_default.LessThan);
        this.bytes.assertNext(CharCodes_default.LessThan);
        this.skipWhitespaceAndComments();
        var dict = /* @__PURE__ */ new Map();
        while (!this.bytes.done() && this.bytes.peek() !== CharCodes_default.GreaterThan && this.bytes.peekAhead(1) !== CharCodes_default.GreaterThan) {
          var key = this.parseName();
          var value = this.parseObject();
          dict.set(key, value);
          this.skipWhitespaceAndComments();
        }
        this.skipWhitespaceAndComments();
        this.bytes.assertNext(CharCodes_default.GreaterThan);
        this.bytes.assertNext(CharCodes_default.GreaterThan);
        var Type = dict.get(PDFName_default.of("Type"));
        if (Type === PDFName_default.of("Catalog")) {
          return PDFCatalog_default.fromMapWithContext(dict, this.context);
        } else if (Type === PDFName_default.of("Pages")) {
          return PDFPageTree_default.fromMapWithContext(dict, this.context);
        } else if (Type === PDFName_default.of("Page")) {
          return PDFPageLeaf_default.fromMapWithContext(dict, this.context);
        } else {
          return PDFDict_default.fromMapWithContext(dict, this.context);
        }
      };
      PDFObjectParser2.prototype.parseDictOrStream = function() {
        var startPos = this.bytes.position();
        var dict = this.parseDict();
        this.skipWhitespaceAndComments();
        if (!this.matchKeyword(Keywords.streamEOF1) && !this.matchKeyword(Keywords.streamEOF2) && !this.matchKeyword(Keywords.streamEOF3) && !this.matchKeyword(Keywords.streamEOF4) && !this.matchKeyword(Keywords.stream)) {
          return dict;
        }
        var start = this.bytes.offset();
        var end;
        var Length = dict.get(PDFName_default.of("Length"));
        if (Length instanceof PDFNumber_default) {
          end = start + Length.asNumber();
          this.bytes.moveTo(end);
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords.endstream)) {
            this.bytes.moveTo(start);
            end = this.findEndOfStreamFallback(startPos);
          }
        } else {
          end = this.findEndOfStreamFallback(startPos);
        }
        var contents = this.bytes.slice(start, end);
        return PDFRawStream_default.of(dict, contents);
      };
      PDFObjectParser2.prototype.findEndOfStreamFallback = function(startPos) {
        var nestingLvl = 1;
        var end = this.bytes.offset();
        while (!this.bytes.done()) {
          end = this.bytes.offset();
          if (this.matchKeyword(Keywords.stream)) {
            nestingLvl += 1;
          } else if (this.matchKeyword(Keywords.EOF1endstream) || this.matchKeyword(Keywords.EOF2endstream) || this.matchKeyword(Keywords.EOF3endstream) || this.matchKeyword(Keywords.endstream)) {
            nestingLvl -= 1;
          } else {
            this.bytes.next();
          }
          if (nestingLvl === 0)
            break;
        }
        if (nestingLvl !== 0)
          throw new PDFStreamParsingError(startPos);
        return end;
      };
      PDFObjectParser2.forBytes = function(bytes, context, capNumbers) {
        return new PDFObjectParser2(ByteStream_default.of(bytes), context, capNumbers);
      };
      PDFObjectParser2.forByteStream = function(byteStream, context, capNumbers) {
        if (capNumbers === void 0) {
          capNumbers = false;
        }
        return new PDFObjectParser2(byteStream, context, capNumbers);
      };
      return PDFObjectParser2;
    }(BaseParser_default)
  );
  var PDFObjectParser_default = PDFObjectParser;

  // node_modules/@pdfme/pdf-lib/es/core/parser/PDFObjectStreamParser.js
  var PDFObjectStreamParser = (
    /** @class */
    function(_super) {
      __extends(PDFObjectStreamParser2, _super);
      function PDFObjectStreamParser2(rawStream, shouldWaitForTick) {
        var _this = _super.call(this, ByteStream_default.fromPDFRawStream(rawStream), rawStream.dict.context) || this;
        var dict = rawStream.dict;
        _this.alreadyParsed = false;
        _this.shouldWaitForTick = shouldWaitForTick || function() {
          return false;
        };
        _this.firstOffset = dict.lookup(PDFName_default.of("First"), PDFNumber_default).asNumber();
        _this.objectCount = dict.lookup(PDFName_default.of("N"), PDFNumber_default).asNumber();
        return _this;
      }
      PDFObjectStreamParser2.prototype.parseIntoContext = function() {
        return __awaiter(this, void 0, void 0, function() {
          var offsetsAndObjectNumbers, idx, len, _a, objectNumber, offset, object, ref;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (this.alreadyParsed) {
                  throw new ReparseError("PDFObjectStreamParser", "parseIntoContext");
                }
                this.alreadyParsed = true;
                offsetsAndObjectNumbers = this.parseOffsetsAndObjectNumbers();
                idx = 0, len = offsetsAndObjectNumbers.length;
                _b.label = 1;
              case 1:
                if (!(idx < len))
                  return [3, 4];
                _a = offsetsAndObjectNumbers[idx], objectNumber = _a.objectNumber, offset = _a.offset;
                this.bytes.moveTo(this.firstOffset + offset);
                object = this.parseObject();
                ref = PDFRef_default.of(objectNumber, 0);
                this.context.assign(ref, object);
                if (!this.shouldWaitForTick())
                  return [3, 3];
                return [4, waitForTick()];
              case 2:
                _b.sent();
                _b.label = 3;
              case 3:
                idx++;
                return [3, 1];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFObjectStreamParser2.prototype.parseOffsetsAndObjectNumbers = function() {
        var offsetsAndObjectNumbers = [];
        for (var idx = 0, len = this.objectCount; idx < len; idx++) {
          this.skipWhitespaceAndComments();
          var objectNumber = this.parseRawInt();
          this.skipWhitespaceAndComments();
          var offset = this.parseRawInt();
          offsetsAndObjectNumbers.push({ objectNumber, offset });
        }
        return offsetsAndObjectNumbers;
      };
      PDFObjectStreamParser2.forStream = function(rawStream, shouldWaitForTick) {
        return new PDFObjectStreamParser2(rawStream, shouldWaitForTick);
      };
      return PDFObjectStreamParser2;
    }(PDFObjectParser_default)
  );
  var PDFObjectStreamParser_default = PDFObjectStreamParser;

  // node_modules/@pdfme/pdf-lib/es/core/parser/PDFXRefStreamParser.js
  var PDFXRefStreamParser = (
    /** @class */
    function() {
      function PDFXRefStreamParser2(rawStream) {
        this.alreadyParsed = false;
        this.dict = rawStream.dict;
        this.bytes = ByteStream_default.fromPDFRawStream(rawStream);
        this.context = this.dict.context;
        var Size2 = this.dict.lookup(PDFName_default.of("Size"), PDFNumber_default);
        var Index2 = this.dict.lookup(PDFName_default.of("Index"));
        if (Index2 instanceof PDFArray_default) {
          this.subsections = [];
          for (var idx = 0, len = Index2.size(); idx < len; idx += 2) {
            var firstObjectNumber = Index2.lookup(idx + 0, PDFNumber_default).asNumber();
            var length_1 = Index2.lookup(idx + 1, PDFNumber_default).asNumber();
            this.subsections.push({ firstObjectNumber, length: length_1 });
          }
        } else {
          this.subsections = [{ firstObjectNumber: 0, length: Size2.asNumber() }];
        }
        var W = this.dict.lookup(PDFName_default.of("W"), PDFArray_default);
        this.byteWidths = [-1, -1, -1];
        for (var idx = 0, len = W.size(); idx < len; idx++) {
          this.byteWidths[idx] = W.lookup(idx, PDFNumber_default).asNumber();
        }
      }
      PDFXRefStreamParser2.prototype.parseIntoContext = function() {
        if (this.alreadyParsed) {
          throw new ReparseError("PDFXRefStreamParser", "parseIntoContext");
        }
        this.alreadyParsed = true;
        this.context.trailerInfo = {
          Root: this.dict.get(PDFName_default.of("Root")),
          Encrypt: this.dict.get(PDFName_default.of("Encrypt")),
          Info: this.dict.get(PDFName_default.of("Info")),
          ID: this.dict.get(PDFName_default.of("ID"))
        };
        var entries = this.parseEntries();
        return entries;
      };
      PDFXRefStreamParser2.prototype.parseEntries = function() {
        var entries = [];
        var _a = this.byteWidths, typeFieldWidth = _a[0], offsetFieldWidth = _a[1], genFieldWidth = _a[2];
        for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {
          var _b = this.subsections[subsectionIdx], firstObjectNumber = _b.firstObjectNumber, length_2 = _b.length;
          for (var objIdx = 0; objIdx < length_2; objIdx++) {
            var type = 0;
            for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {
              type = type << 8 | this.bytes.next();
            }
            var offset = 0;
            for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {
              offset = offset << 8 | this.bytes.next();
            }
            var generationNumber = 0;
            for (var idx = 0, len = genFieldWidth; idx < len; idx++) {
              generationNumber = generationNumber << 8 | this.bytes.next();
            }
            if (typeFieldWidth === 0)
              type = 1;
            var objectNumber = firstObjectNumber + objIdx;
            var entry = {
              ref: PDFRef_default.of(objectNumber, generationNumber),
              offset,
              deleted: type === 0,
              inObjectStream: type === 2
            };
            entries.push(entry);
          }
        }
        return entries;
      };
      PDFXRefStreamParser2.forStream = function(rawStream) {
        return new PDFXRefStreamParser2(rawStream);
      };
      return PDFXRefStreamParser2;
    }()
  );
  var PDFXRefStreamParser_default = PDFXRefStreamParser;

  // node_modules/@pdfme/pdf-lib/es/core/parser/PDFParser.js
  var PDFParser = (
    /** @class */
    function(_super) {
      __extends(PDFParser2, _super);
      function PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
        if (objectsPerTick === void 0) {
          objectsPerTick = Infinity;
        }
        if (throwOnInvalidObject === void 0) {
          throwOnInvalidObject = false;
        }
        if (capNumbers === void 0) {
          capNumbers = false;
        }
        var _this = _super.call(this, ByteStream_default.of(pdfBytes), PDFContext_default.create(), capNumbers) || this;
        _this.alreadyParsed = false;
        _this.parsedObjects = 0;
        _this.shouldWaitForTick = function() {
          _this.parsedObjects += 1;
          return _this.parsedObjects % _this.objectsPerTick === 0;
        };
        _this.objectsPerTick = objectsPerTick;
        _this.throwOnInvalidObject = throwOnInvalidObject;
        return _this;
      }
      PDFParser2.prototype.parseDocument = function() {
        return __awaiter(this, void 0, void 0, function() {
          var prevOffset, offset;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (this.alreadyParsed) {
                  throw new ReparseError("PDFParser", "parseDocument");
                }
                this.alreadyParsed = true;
                this.context.header = this.parseHeader();
                _a.label = 1;
              case 1:
                if (!!this.bytes.done())
                  return [3, 3];
                return [4, this.parseDocumentSection()];
              case 2:
                _a.sent();
                offset = this.bytes.offset();
                if (offset === prevOffset) {
                  throw new StalledParserError(this.bytes.position());
                }
                prevOffset = offset;
                return [3, 1];
              case 3:
                this.maybeRecoverRoot();
                if (this.context.lookup(PDFRef_default.of(0))) {
                  console.warn("Removing parsed object: 0 0 R");
                  this.context.delete(PDFRef_default.of(0));
                }
                return [2, this.context];
            }
          });
        });
      };
      PDFParser2.prototype.maybeRecoverRoot = function() {
        var isValidCatalog = function(obj) {
          return obj instanceof PDFDict_default && obj.lookup(PDFName_default.of("Type")) === PDFName_default.of("Catalog");
        };
        var catalog = this.context.lookup(this.context.trailerInfo.Root);
        if (!isValidCatalog(catalog)) {
          var indirectObjects = this.context.enumerateIndirectObjects();
          for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {
            var _a = indirectObjects[idx], ref = _a[0], object = _a[1];
            if (isValidCatalog(object)) {
              this.context.trailerInfo.Root = ref;
            }
          }
        }
      };
      PDFParser2.prototype.parseHeader = function() {
        while (!this.bytes.done()) {
          if (this.matchKeyword(Keywords.header)) {
            var major = this.parseRawInt();
            this.bytes.assertNext(CharCodes_default.Period);
            var minor = this.parseRawInt();
            var header = PDFHeader_default.forVersion(major, minor);
            this.skipBinaryHeaderComment();
            return header;
          }
          this.bytes.next();
        }
        throw new MissingPDFHeaderError(this.bytes.position());
      };
      PDFParser2.prototype.parseIndirectObjectHeader = function() {
        this.skipWhitespaceAndComments();
        var objectNumber = this.parseRawInt();
        this.skipWhitespaceAndComments();
        var generationNumber = this.parseRawInt();
        this.skipWhitespaceAndComments();
        if (!this.matchKeyword(Keywords.obj)) {
          throw new MissingKeywordError(this.bytes.position(), Keywords.obj);
        }
        return PDFRef_default.of(objectNumber, generationNumber);
      };
      PDFParser2.prototype.matchIndirectObjectHeader = function() {
        var initialOffset = this.bytes.offset();
        try {
          this.parseIndirectObjectHeader();
          return true;
        } catch (e) {
          this.bytes.moveTo(initialOffset);
          return false;
        }
      };
      PDFParser2.prototype.parseIndirectObject = function() {
        return __awaiter(this, void 0, void 0, function() {
          var ref, object;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                ref = this.parseIndirectObjectHeader();
                this.skipWhitespaceAndComments();
                object = this.parseObject();
                this.skipWhitespaceAndComments();
                this.matchKeyword(Keywords.endobj);
                if (!(object instanceof PDFRawStream_default && object.dict.lookup(PDFName_default.of("Type")) === PDFName_default.of("ObjStm")))
                  return [3, 2];
                return [4, PDFObjectStreamParser_default.forStream(object, this.shouldWaitForTick).parseIntoContext()];
              case 1:
                _a.sent();
                return [3, 3];
              case 2:
                if (object instanceof PDFRawStream_default && object.dict.lookup(PDFName_default.of("Type")) === PDFName_default.of("XRef")) {
                  PDFXRefStreamParser_default.forStream(object).parseIntoContext();
                } else {
                  this.context.assign(ref, object);
                }
                _a.label = 3;
              case 3:
                return [2, ref];
            }
          });
        });
      };
      PDFParser2.prototype.tryToParseInvalidIndirectObject = function() {
        var startPos = this.bytes.position();
        var msg = "Trying to parse invalid object: " + JSON.stringify(startPos) + ")";
        if (this.throwOnInvalidObject)
          throw new Error(msg);
        console.warn(msg);
        var ref = this.parseIndirectObjectHeader();
        console.warn("Invalid object ref: " + ref);
        this.skipWhitespaceAndComments();
        var start = this.bytes.offset();
        var failed = true;
        while (!this.bytes.done()) {
          if (this.matchKeyword(Keywords.endobj)) {
            failed = false;
          }
          if (!failed)
            break;
          this.bytes.next();
        }
        if (failed)
          throw new PDFInvalidObjectParsingError(startPos);
        var end = this.bytes.offset() - Keywords.endobj.length;
        var object = PDFInvalidObject_default.of(this.bytes.slice(start, end));
        this.context.assign(ref, object);
        return ref;
      };
      PDFParser2.prototype.parseIndirectObjects = function() {
        return __awaiter(this, void 0, void 0, function() {
          var initialOffset, e_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.skipWhitespaceAndComments();
                _a.label = 1;
              case 1:
                if (!(!this.bytes.done() && IsDigit[this.bytes.peek()]))
                  return [3, 8];
                initialOffset = this.bytes.offset();
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.parseIndirectObject()];
              case 3:
                _a.sent();
                return [3, 5];
              case 4:
                e_1 = _a.sent();
                this.bytes.moveTo(initialOffset);
                this.tryToParseInvalidIndirectObject();
                return [3, 5];
              case 5:
                this.skipWhitespaceAndComments();
                this.skipJibberish();
                if (!this.shouldWaitForTick())
                  return [3, 7];
                return [4, waitForTick()];
              case 6:
                _a.sent();
                _a.label = 7;
              case 7:
                return [3, 1];
              case 8:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFParser2.prototype.maybeParseCrossRefSection = function() {
        this.skipWhitespaceAndComments();
        if (!this.matchKeyword(Keywords.xref))
          return;
        this.skipWhitespaceAndComments();
        var objectNumber = -1;
        var xref = PDFCrossRefSection_default.createEmpty();
        while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {
          var firstInt = this.parseRawInt();
          this.skipWhitespaceAndComments();
          var secondInt = this.parseRawInt();
          this.skipWhitespaceAndComments();
          var byte = this.bytes.peek();
          if (byte === CharCodes_default.n || byte === CharCodes_default.f) {
            var ref = PDFRef_default.of(objectNumber, secondInt);
            if (this.bytes.next() === CharCodes_default.n) {
              xref.addEntry(ref, firstInt);
            } else {
              xref.addDeletedEntry(ref, firstInt);
            }
            objectNumber += 1;
          } else {
            objectNumber = firstInt;
          }
          this.skipWhitespaceAndComments();
        }
        return xref;
      };
      PDFParser2.prototype.maybeParseTrailerDict = function() {
        this.skipWhitespaceAndComments();
        if (!this.matchKeyword(Keywords.trailer))
          return;
        this.skipWhitespaceAndComments();
        var dict = this.parseDict();
        var context = this.context;
        context.trailerInfo = {
          Root: dict.get(PDFName_default.of("Root")) || context.trailerInfo.Root,
          Encrypt: dict.get(PDFName_default.of("Encrypt")) || context.trailerInfo.Encrypt,
          Info: dict.get(PDFName_default.of("Info")) || context.trailerInfo.Info,
          ID: dict.get(PDFName_default.of("ID")) || context.trailerInfo.ID
        };
      };
      PDFParser2.prototype.maybeParseTrailer = function() {
        this.skipWhitespaceAndComments();
        if (!this.matchKeyword(Keywords.startxref))
          return;
        this.skipWhitespaceAndComments();
        var offset = this.parseRawInt();
        this.skipWhitespace();
        this.matchKeyword(Keywords.eof);
        this.skipWhitespaceAndComments();
        this.matchKeyword(Keywords.eof);
        this.skipWhitespaceAndComments();
        return PDFTrailer_default.forLastCrossRefSectionOffset(offset);
      };
      PDFParser2.prototype.parseDocumentSection = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.parseIndirectObjects()];
              case 1:
                _a.sent();
                this.maybeParseCrossRefSection();
                this.maybeParseTrailerDict();
                this.maybeParseTrailer();
                this.skipJibberish();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFParser2.prototype.skipJibberish = function() {
        this.skipWhitespaceAndComments();
        while (!this.bytes.done()) {
          var initialOffset = this.bytes.offset();
          var byte = this.bytes.peek();
          var isAlphaNumeric = byte >= CharCodes_default.Space && byte <= CharCodes_default.Tilde;
          if (isAlphaNumeric) {
            if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {
              this.bytes.moveTo(initialOffset);
              break;
            }
          }
          this.bytes.next();
        }
      };
      PDFParser2.prototype.skipBinaryHeaderComment = function() {
        this.skipWhitespaceAndComments();
        try {
          var initialOffset = this.bytes.offset();
          this.parseIndirectObjectHeader();
          this.bytes.moveTo(initialOffset);
        } catch (e) {
          this.bytes.next();
          this.skipWhitespaceAndComments();
        }
      };
      PDFParser2.forBytesWithOptions = function(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
        return new PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);
      };
      return PDFParser2;
    }(PDFObjectParser_default)
  );
  var PDFParser_default = PDFParser;

  // node_modules/@pdfme/pdf-lib/es/core/annotation/flags.js
  var flag2 = function(bitIndex) {
    return 1 << bitIndex;
  };
  var AnnotationFlags;
  (function(AnnotationFlags2) {
    AnnotationFlags2[AnnotationFlags2["Invisible"] = flag2(1 - 1)] = "Invisible";
    AnnotationFlags2[AnnotationFlags2["Hidden"] = flag2(2 - 1)] = "Hidden";
    AnnotationFlags2[AnnotationFlags2["Print"] = flag2(3 - 1)] = "Print";
    AnnotationFlags2[AnnotationFlags2["NoZoom"] = flag2(4 - 1)] = "NoZoom";
    AnnotationFlags2[AnnotationFlags2["NoRotate"] = flag2(5 - 1)] = "NoRotate";
    AnnotationFlags2[AnnotationFlags2["NoView"] = flag2(6 - 1)] = "NoView";
    AnnotationFlags2[AnnotationFlags2["ReadOnly"] = flag2(7 - 1)] = "ReadOnly";
    AnnotationFlags2[AnnotationFlags2["Locked"] = flag2(8 - 1)] = "Locked";
    AnnotationFlags2[AnnotationFlags2["ToggleNoView"] = flag2(9 - 1)] = "ToggleNoView";
    AnnotationFlags2[AnnotationFlags2["LockedContents"] = flag2(10 - 1)] = "LockedContents";
  })(AnnotationFlags || (AnnotationFlags = {}));

  // node_modules/@pdfme/pdf-lib/es/api/objects.js
  var asPDFName = function(name) {
    return name instanceof PDFName_default ? name : PDFName_default.of(name);
  };
  var asPDFNumber = function(num) {
    return num instanceof PDFNumber_default ? num : PDFNumber_default.of(num);
  };
  var asNumber = function(num) {
    return num instanceof PDFNumber_default ? num.asNumber() : num;
  };

  // node_modules/@pdfme/pdf-lib/es/api/rotations.js
  var RotationTypes;
  (function(RotationTypes2) {
    RotationTypes2["Degrees"] = "degrees";
    RotationTypes2["Radians"] = "radians";
  })(RotationTypes || (RotationTypes = {}));
  var radians = function(radianAngle) {
    assertIs(radianAngle, "radianAngle", ["number"]);
    return { type: RotationTypes.Radians, angle: radianAngle };
  };
  var degrees = function(degreeAngle) {
    assertIs(degreeAngle, "degreeAngle", ["number"]);
    return { type: RotationTypes.Degrees, angle: degreeAngle };
  };
  var Radians = RotationTypes.Radians, Degrees = RotationTypes.Degrees;
  var degreesToRadians = function(degree) {
    return degree * Math.PI / 180;
  };
  var radiansToDegrees = function(radian) {
    return radian * 180 / Math.PI;
  };
  var toRadians = function(rotation) {
    return rotation.type === Radians ? rotation.angle : rotation.type === Degrees ? degreesToRadians(rotation.angle) : error("Invalid rotation: " + JSON.stringify(rotation));
  };
  var toDegrees = function(rotation) {
    return rotation.type === Radians ? radiansToDegrees(rotation.angle) : rotation.type === Degrees ? rotation.angle : error("Invalid rotation: " + JSON.stringify(rotation));
  };
  var reduceRotation = function(degreeAngle) {
    if (degreeAngle === void 0) {
      degreeAngle = 0;
    }
    var quadrants = degreeAngle / 90 % 4;
    if (quadrants === 0)
      return 0;
    if (quadrants === 1)
      return 90;
    if (quadrants === 2)
      return 180;
    if (quadrants === 3)
      return 270;
    return 0;
  };
  var adjustDimsForRotation = function(dims, degreeAngle) {
    if (degreeAngle === void 0) {
      degreeAngle = 0;
    }
    var rotation = reduceRotation(degreeAngle);
    return rotation === 90 || rotation === 270 ? { width: dims.height, height: dims.width } : { width: dims.width, height: dims.height };
  };
  var rotateRectangle = function(rectangle2, borderWidth, degreeAngle) {
    if (borderWidth === void 0) {
      borderWidth = 0;
    }
    if (degreeAngle === void 0) {
      degreeAngle = 0;
    }
    var x = rectangle2.x, y = rectangle2.y, w = rectangle2.width, h = rectangle2.height;
    var r = reduceRotation(degreeAngle);
    var b = borderWidth / 2;
    if (r === 0)
      return { x: x - b, y: y - b, width: w, height: h };
    else if (r === 90)
      return { x: x - h + b, y: y - b, width: h, height: w };
    else if (r === 180)
      return { x: x - w + b, y: y - h + b, width: w, height: h };
    else if (r === 270)
      return { x: x - b, y: y - w + b, width: h, height: w };
    else
      return { x: x - b, y: y - b, width: w, height: h };
  };

  // node_modules/@pdfme/pdf-lib/es/api/operators.js
  var clip = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.ClipNonZero);
  };
  var clipEvenOdd = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.ClipEvenOdd);
  };
  var cos = Math.cos, sin = Math.sin, tan = Math.tan;
  var concatTransformationMatrix = function(a, b, c, d, e, f) {
    return PDFOperator_default.of(PDFOperatorNames_default.ConcatTransformationMatrix, [
      asPDFNumber(a),
      asPDFNumber(b),
      asPDFNumber(c),
      asPDFNumber(d),
      asPDFNumber(e),
      asPDFNumber(f)
    ]);
  };
  var translate = function(xPos, yPos) {
    return concatTransformationMatrix(1, 0, 0, 1, xPos, yPos);
  };
  var scale = function(xPos, yPos) {
    return concatTransformationMatrix(xPos, 0, 0, yPos, 0, 0);
  };
  var rotateRadians = function(angle) {
    return concatTransformationMatrix(cos(asNumber(angle)), sin(asNumber(angle)), -sin(asNumber(angle)), cos(asNumber(angle)), 0, 0);
  };
  var rotateDegrees = function(angle) {
    return rotateRadians(degreesToRadians(asNumber(angle)));
  };
  var skewRadians = function(xSkewAngle, ySkewAngle) {
    return concatTransformationMatrix(1, tan(asNumber(xSkewAngle)), tan(asNumber(ySkewAngle)), 1, 0, 0);
  };
  var skewDegrees = function(xSkewAngle, ySkewAngle) {
    return skewRadians(degreesToRadians(asNumber(xSkewAngle)), degreesToRadians(asNumber(ySkewAngle)));
  };
  var setDashPattern = function(dashArray, dashPhase) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetLineDashPattern, [
      "[" + dashArray.map(asPDFNumber).join(" ") + "]",
      asPDFNumber(dashPhase)
    ]);
  };
  var restoreDashPattern = function() {
    return setDashPattern([], 0);
  };
  var LineCapStyle;
  (function(LineCapStyle2) {
    LineCapStyle2[LineCapStyle2["Butt"] = 0] = "Butt";
    LineCapStyle2[LineCapStyle2["Round"] = 1] = "Round";
    LineCapStyle2[LineCapStyle2["Projecting"] = 2] = "Projecting";
  })(LineCapStyle || (LineCapStyle = {}));
  var setLineCap = function(style2) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetLineCapStyle, [asPDFNumber(style2)]);
  };
  var LineJoinStyle;
  (function(LineJoinStyle2) {
    LineJoinStyle2[LineJoinStyle2["Miter"] = 0] = "Miter";
    LineJoinStyle2[LineJoinStyle2["Round"] = 1] = "Round";
    LineJoinStyle2[LineJoinStyle2["Bevel"] = 2] = "Bevel";
  })(LineJoinStyle || (LineJoinStyle = {}));
  var setLineJoin = function(style2) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetLineJoinStyle, [asPDFNumber(style2)]);
  };
  var setGraphicsState = function(state) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetGraphicsStateParams, [asPDFName(state)]);
  };
  var pushGraphicsState = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.PushGraphicsState);
  };
  var popGraphicsState = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.PopGraphicsState);
  };
  var setLineWidth = function(width) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetLineWidth, [asPDFNumber(width)]);
  };
  var appendBezierCurve = function(x1, y1, x2, y2, x3, y3) {
    return PDFOperator_default.of(PDFOperatorNames_default.AppendBezierCurve, [
      asPDFNumber(x1),
      asPDFNumber(y1),
      asPDFNumber(x2),
      asPDFNumber(y2),
      asPDFNumber(x3),
      asPDFNumber(y3)
    ]);
  };
  var appendQuadraticCurve = function(x1, y1, x2, y2) {
    return PDFOperator_default.of(PDFOperatorNames_default.CurveToReplicateInitialPoint, [
      asPDFNumber(x1),
      asPDFNumber(y1),
      asPDFNumber(x2),
      asPDFNumber(y2)
    ]);
  };
  var closePath = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.ClosePath);
  };
  var moveTo = function(xPos, yPos) {
    return PDFOperator_default.of(PDFOperatorNames_default.MoveTo, [asPDFNumber(xPos), asPDFNumber(yPos)]);
  };
  var lineTo = function(xPos, yPos) {
    return PDFOperator_default.of(PDFOperatorNames_default.LineTo, [asPDFNumber(xPos), asPDFNumber(yPos)]);
  };
  var rectangle = function(xPos, yPos, width, height) {
    return PDFOperator_default.of(PDFOperatorNames_default.AppendRectangle, [
      asPDFNumber(xPos),
      asPDFNumber(yPos),
      asPDFNumber(width),
      asPDFNumber(height)
    ]);
  };
  var square = function(xPos, yPos, size) {
    return rectangle(xPos, yPos, size, size);
  };
  var stroke = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.StrokePath);
  };
  var fill = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.FillNonZero);
  };
  var fillAndStroke = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.FillNonZeroAndStroke);
  };
  var endPath = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.EndPath);
  };
  var nextLine = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.NextLine);
  };
  var moveText = function(x, y) {
    return PDFOperator_default.of(PDFOperatorNames_default.MoveText, [asPDFNumber(x), asPDFNumber(y)]);
  };
  var showText = function(text) {
    return PDFOperator_default.of(PDFOperatorNames_default.ShowText, [text]);
  };
  var beginText = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.BeginText);
  };
  var endText = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.EndText);
  };
  var setFontAndSize = function(name, size) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetFontAndSize, [asPDFName(name), asPDFNumber(size)]);
  };
  var setCharacterSpacing = function(spacing) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetCharacterSpacing, [asPDFNumber(spacing)]);
  };
  var setWordSpacing = function(spacing) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetWordSpacing, [asPDFNumber(spacing)]);
  };
  var setCharacterSqueeze = function(squeeze) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetTextHorizontalScaling, [asPDFNumber(squeeze)]);
  };
  var setLineHeight = function(lineHeight) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetTextLineHeight, [asPDFNumber(lineHeight)]);
  };
  var setTextRise = function(rise) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetTextRise, [asPDFNumber(rise)]);
  };
  var TextRenderingMode;
  (function(TextRenderingMode2) {
    TextRenderingMode2[TextRenderingMode2["Fill"] = 0] = "Fill";
    TextRenderingMode2[TextRenderingMode2["Outline"] = 1] = "Outline";
    TextRenderingMode2[TextRenderingMode2["FillAndOutline"] = 2] = "FillAndOutline";
    TextRenderingMode2[TextRenderingMode2["Invisible"] = 3] = "Invisible";
    TextRenderingMode2[TextRenderingMode2["FillAndClip"] = 4] = "FillAndClip";
    TextRenderingMode2[TextRenderingMode2["OutlineAndClip"] = 5] = "OutlineAndClip";
    TextRenderingMode2[TextRenderingMode2["FillAndOutlineAndClip"] = 6] = "FillAndOutlineAndClip";
    TextRenderingMode2[TextRenderingMode2["Clip"] = 7] = "Clip";
  })(TextRenderingMode || (TextRenderingMode = {}));
  var setTextRenderingMode = function(mode) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetTextRenderingMode, [asPDFNumber(mode)]);
  };
  var setTextMatrix = function(a, b, c, d, e, f) {
    return PDFOperator_default.of(PDFOperatorNames_default.SetTextMatrix, [
      asPDFNumber(a),
      asPDFNumber(b),
      asPDFNumber(c),
      asPDFNumber(d),
      asPDFNumber(e),
      asPDFNumber(f)
    ]);
  };
  var rotateAndSkewTextRadiansAndTranslate = function(rotationAngle, xSkewAngle, ySkewAngle, x, y) {
    return setTextMatrix(cos(asNumber(rotationAngle)), sin(asNumber(rotationAngle)) + tan(asNumber(xSkewAngle)), -sin(asNumber(rotationAngle)) + tan(asNumber(ySkewAngle)), cos(asNumber(rotationAngle)), x, y);
  };
  var rotateAndSkewTextDegreesAndTranslate = function(rotationAngle, xSkewAngle, ySkewAngle, x, y) {
    return rotateAndSkewTextRadiansAndTranslate(degreesToRadians(asNumber(rotationAngle)), degreesToRadians(asNumber(xSkewAngle)), degreesToRadians(asNumber(ySkewAngle)), x, y);
  };
  var drawObject = function(name) {
    return PDFOperator_default.of(PDFOperatorNames_default.DrawObject, [asPDFName(name)]);
  };
  var setFillingGrayscaleColor = function(gray) {
    return PDFOperator_default.of(PDFOperatorNames_default.NonStrokingColorGray, [asPDFNumber(gray)]);
  };
  var setStrokingGrayscaleColor = function(gray) {
    return PDFOperator_default.of(PDFOperatorNames_default.StrokingColorGray, [asPDFNumber(gray)]);
  };
  var setFillingRgbColor = function(red, green, blue) {
    return PDFOperator_default.of(PDFOperatorNames_default.NonStrokingColorRgb, [
      asPDFNumber(red),
      asPDFNumber(green),
      asPDFNumber(blue)
    ]);
  };
  var setStrokingRgbColor = function(red, green, blue) {
    return PDFOperator_default.of(PDFOperatorNames_default.StrokingColorRgb, [
      asPDFNumber(red),
      asPDFNumber(green),
      asPDFNumber(blue)
    ]);
  };
  var setFillingCmykColor = function(cyan, magenta, yellow, key) {
    return PDFOperator_default.of(PDFOperatorNames_default.NonStrokingColorCmyk, [
      asPDFNumber(cyan),
      asPDFNumber(magenta),
      asPDFNumber(yellow),
      asPDFNumber(key)
    ]);
  };
  var setStrokingCmykColor = function(cyan, magenta, yellow, key) {
    return PDFOperator_default.of(PDFOperatorNames_default.StrokingColorCmyk, [
      asPDFNumber(cyan),
      asPDFNumber(magenta),
      asPDFNumber(yellow),
      asPDFNumber(key)
    ]);
  };
  var beginMarkedContent = function(tag) {
    return PDFOperator_default.of(PDFOperatorNames_default.BeginMarkedContent, [asPDFName(tag)]);
  };
  var endMarkedContent = function() {
    return PDFOperator_default.of(PDFOperatorNames_default.EndMarkedContent);
  };

  // node_modules/@pdfme/pdf-lib/es/api/colors.js
  var ColorTypes;
  (function(ColorTypes2) {
    ColorTypes2["Grayscale"] = "Grayscale";
    ColorTypes2["RGB"] = "RGB";
    ColorTypes2["CMYK"] = "CMYK";
  })(ColorTypes || (ColorTypes = {}));
  var grayscale = function(gray) {
    assertRange(gray, "gray", 0, 1);
    return { type: ColorTypes.Grayscale, gray };
  };
  var rgb = function(red, green, blue) {
    assertRange(red, "red", 0, 1);
    assertRange(green, "green", 0, 1);
    assertRange(blue, "blue", 0, 1);
    return { type: ColorTypes.RGB, red, green, blue };
  };
  var cmyk = function(cyan, magenta, yellow, key) {
    assertRange(cyan, "cyan", 0, 1);
    assertRange(magenta, "magenta", 0, 1);
    assertRange(yellow, "yellow", 0, 1);
    assertRange(key, "key", 0, 1);
    return { type: ColorTypes.CMYK, cyan, magenta, yellow, key };
  };
  var Grayscale = ColorTypes.Grayscale, RGB = ColorTypes.RGB, CMYK = ColorTypes.CMYK;
  var setFillingColor = function(color) {
    return color.type === Grayscale ? setFillingGrayscaleColor(color.gray) : color.type === RGB ? setFillingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? setFillingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : error("Invalid color: " + JSON.stringify(color));
  };
  var setStrokingColor = function(color) {
    return color.type === Grayscale ? setStrokingGrayscaleColor(color.gray) : color.type === RGB ? setStrokingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? setStrokingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : error("Invalid color: " + JSON.stringify(color));
  };
  var componentsToColor = function(comps, scale2) {
    if (scale2 === void 0) {
      scale2 = 1;
    }
    return (comps === null || comps === void 0 ? void 0 : comps.length) === 1 ? grayscale(comps[0] * scale2) : (comps === null || comps === void 0 ? void 0 : comps.length) === 3 ? rgb(comps[0] * scale2, comps[1] * scale2, comps[2] * scale2) : (comps === null || comps === void 0 ? void 0 : comps.length) === 4 ? cmyk(comps[0] * scale2, comps[1] * scale2, comps[2] * scale2, comps[3] * scale2) : void 0;
  };
  var colorToComponents = function(color) {
    return color.type === Grayscale ? [color.gray] : color.type === RGB ? [color.red, color.green, color.blue] : color.type === CMYK ? [color.cyan, color.magenta, color.yellow, color.key] : error("Invalid color: " + JSON.stringify(color));
  };

  // node_modules/@pdfme/pdf-lib/es/api/svgPath.js
  var cx = 0;
  var cy = 0;
  var px = 0;
  var py = 0;
  var sx = 0;
  var sy = 0;
  var parameters = /* @__PURE__ */ new Map([
    ["A", 7],
    ["a", 7],
    ["C", 6],
    ["c", 6],
    ["H", 1],
    ["h", 1],
    ["L", 2],
    ["l", 2],
    ["M", 2],
    ["m", 2],
    ["Q", 4],
    ["q", 4],
    ["S", 4],
    ["s", 4],
    ["T", 2],
    ["t", 2],
    ["V", 1],
    ["v", 1],
    ["Z", 0],
    ["z", 0]
  ]);
  var parse = function(path) {
    var cmd;
    var ret = [];
    var args = [];
    var curArg = "";
    var foundDecimal = false;
    var params = 0;
    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
      var c = path_1[_i];
      if (parameters.has(c)) {
        params = parameters.get(c);
        if (cmd) {
          if (curArg.length > 0) {
            args[args.length] = +curArg;
          }
          ret[ret.length] = { cmd, args };
          args = [];
          curArg = "";
          foundDecimal = false;
        }
        cmd = c;
      } else if ([" ", ","].includes(c) || c === "-" && curArg.length > 0 && curArg[curArg.length - 1] !== "e" || c === "." && foundDecimal) {
        if (curArg.length === 0) {
          continue;
        }
        if (args.length === params) {
          ret[ret.length] = { cmd, args };
          args = [+curArg];
          if (cmd === "M") {
            cmd = "L";
          }
          if (cmd === "m") {
            cmd = "l";
          }
        } else {
          args[args.length] = +curArg;
        }
        foundDecimal = c === ".";
        curArg = ["-", "."].includes(c) ? c : "";
      } else {
        curArg += c;
        if (c === ".") {
          foundDecimal = true;
        }
      }
    }
    if (curArg.length > 0) {
      if (args.length === params) {
        ret[ret.length] = { cmd, args };
        args = [+curArg];
        if (cmd === "M") {
          cmd = "L";
        }
        if (cmd === "m") {
          cmd = "l";
        }
      } else {
        args[args.length] = +curArg;
      }
    }
    ret[ret.length] = { cmd, args };
    return ret;
  };
  var apply = function(commands) {
    cx = cy = px = py = sx = sy = 0;
    var cmds = [];
    for (var i = 0; i < commands.length; i++) {
      var c = commands[i];
      if (c.cmd && typeof runners[c.cmd] === "function") {
        var cmd = runners[c.cmd](c.args);
        if (Array.isArray(cmd)) {
          cmds = cmds.concat(cmd);
        } else {
          cmds.push(cmd);
        }
      }
    }
    return cmds;
  };
  var runners = {
    M: function(a) {
      cx = a[0];
      cy = a[1];
      px = py = null;
      sx = cx;
      sy = cy;
      return moveTo(cx, cy);
    },
    m: function(a) {
      cx += a[0];
      cy += a[1];
      px = py = null;
      sx = cx;
      sy = cy;
      return moveTo(cx, cy);
    },
    C: function(a) {
      cx = a[4];
      cy = a[5];
      px = a[2];
      py = a[3];
      return appendBezierCurve(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    c: function(a) {
      var cmd = appendBezierCurve(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);
      px = cx + a[2];
      py = cy + a[3];
      cx += a[4];
      cy += a[5];
      return cmd;
    },
    S: function(a) {
      if (px === null || py === null) {
        px = cx;
        py = cy;
      }
      var cmd = appendBezierCurve(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);
      px = a[0];
      py = a[1];
      cx = a[2];
      cy = a[3];
      return cmd;
    },
    s: function(a) {
      if (px === null || py === null) {
        px = cx;
        py = cy;
      }
      var cmd = appendBezierCurve(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);
      px = cx + a[0];
      py = cy + a[1];
      cx += a[2];
      cy += a[3];
      return cmd;
    },
    Q: function(a) {
      px = a[0];
      py = a[1];
      cx = a[2];
      cy = a[3];
      return appendQuadraticCurve(a[0], a[1], cx, cy);
    },
    q: function(a) {
      var cmd = appendQuadraticCurve(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);
      px = cx + a[0];
      py = cy + a[1];
      cx += a[2];
      cy += a[3];
      return cmd;
    },
    T: function(a) {
      if (px === null || py === null) {
        px = cx;
        py = cy;
      } else {
        px = cx - (px - cx);
        py = cy - (py - cy);
      }
      var cmd = appendQuadraticCurve(px, py, a[0], a[1]);
      px = cx - (px - cx);
      py = cy - (py - cy);
      cx = a[0];
      cy = a[1];
      return cmd;
    },
    t: function(a) {
      if (px === null || py === null) {
        px = cx;
        py = cy;
      } else {
        px = cx - (px - cx);
        py = cy - (py - cy);
      }
      var cmd = appendQuadraticCurve(px, py, cx + a[0], cy + a[1]);
      cx += a[0];
      cy += a[1];
      return cmd;
    },
    A: function(a) {
      var cmds = solveArc(cx, cy, a);
      cx = a[5];
      cy = a[6];
      return cmds;
    },
    a: function(a) {
      a[5] += cx;
      a[6] += cy;
      var cmds = solveArc(cx, cy, a);
      cx = a[5];
      cy = a[6];
      return cmds;
    },
    L: function(a) {
      cx = a[0];
      cy = a[1];
      px = py = null;
      return lineTo(cx, cy);
    },
    l: function(a) {
      cx += a[0];
      cy += a[1];
      px = py = null;
      return lineTo(cx, cy);
    },
    H: function(a) {
      cx = a[0];
      px = py = null;
      return lineTo(cx, cy);
    },
    h: function(a) {
      cx += a[0];
      px = py = null;
      return lineTo(cx, cy);
    },
    V: function(a) {
      cy = a[0];
      px = py = null;
      return lineTo(cx, cy);
    },
    v: function(a) {
      cy += a[0];
      px = py = null;
      return lineTo(cx, cy);
    },
    Z: function() {
      var cmd = closePath();
      cx = sx;
      cy = sy;
      return cmd;
    },
    z: function() {
      var cmd = closePath();
      cx = sx;
      cy = sy;
      return cmd;
    }
  };
  var solveArc = function(x, y, coords) {
    var rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];
    var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
    var cmds = [];
    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
      var seg = segs_1[_i];
      var bez = segmentToBezier.apply(void 0, seg);
      cmds.push(appendBezierCurve.apply(void 0, bez));
    }
    return cmds;
  };
  var arcToSegments = function(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
    var th = rotateX * (Math.PI / 180);
    var sinTh = Math.sin(th);
    var cosTh = Math.cos(th);
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    px = cosTh * (ox - x) * 0.5 + sinTh * (oy - y) * 0.5;
    py = cosTh * (oy - y) * 0.5 - sinTh * (ox - x) * 0.5;
    var pl = px * px / (rx * rx) + py * py / (ry * ry);
    if (pl > 1) {
      pl = Math.sqrt(pl);
      rx *= pl;
      ry *= pl;
    }
    var a00 = cosTh / rx;
    var a01 = sinTh / rx;
    var a10 = -sinTh / ry;
    var a11 = cosTh / ry;
    var x0 = a00 * ox + a01 * oy;
    var y0 = a10 * ox + a11 * oy;
    var x1 = a00 * x + a01 * y;
    var y1 = a10 * x + a11 * y;
    var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
    var sfactorSq = 1 / d - 0.25;
    if (sfactorSq < 0) {
      sfactorSq = 0;
    }
    var sfactor = Math.sqrt(sfactorSq);
    if (sweep === large) {
      sfactor = -sfactor;
    }
    var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
    var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
    var th0 = Math.atan2(y0 - yc, x0 - xc);
    var th1 = Math.atan2(y1 - yc, x1 - xc);
    var thArc = th1 - th0;
    if (thArc < 0 && sweep === 1) {
      thArc += 2 * Math.PI;
    } else if (thArc > 0 && sweep === 0) {
      thArc -= 2 * Math.PI;
    }
    var segments = Math.ceil(Math.abs(thArc / (Math.PI * 0.5 + 1e-3)));
    var result = [];
    for (var i = 0; i < segments; i++) {
      var th2 = th0 + i * thArc / segments;
      var th3 = th0 + (i + 1) * thArc / segments;
      result[i] = [xc, yc, th2, th3, rx, ry, sinTh, cosTh];
    }
    return result;
  };
  var segmentToBezier = function(cx1, cy1, th0, th1, rx, ry, sinTh, cosTh) {
    var a00 = cosTh * rx;
    var a01 = -sinTh * ry;
    var a10 = sinTh * rx;
    var a11 = cosTh * ry;
    var thHalf = 0.5 * (th1 - th0);
    var t = 8 / 3 * Math.sin(thHalf * 0.5) * Math.sin(thHalf * 0.5) / Math.sin(thHalf);
    var x1 = cx1 + Math.cos(th0) - t * Math.sin(th0);
    var y1 = cy1 + Math.sin(th0) + t * Math.cos(th0);
    var x3 = cx1 + Math.cos(th1);
    var y3 = cy1 + Math.sin(th1);
    var x2 = x3 + t * Math.sin(th1);
    var y2 = y3 - t * Math.cos(th1);
    var result = [
      a00 * x1 + a01 * y1,
      a10 * x1 + a11 * y1,
      a00 * x2 + a01 * y2,
      a10 * x2 + a11 * y2,
      a00 * x3 + a01 * y3,
      a10 * x3 + a11 * y3
    ];
    return result;
  };
  var svgPathToOperators = function(path) {
    return apply(parse(path));
  };

  // node_modules/@pdfme/pdf-lib/es/api/operations.js
  var drawText = function(line, options) {
    return [
      pushGraphicsState(),
      options.graphicsState && setGraphicsState(options.graphicsState),
      beginText(),
      setFillingColor(options.color),
      setFontAndSize(options.font, options.size),
      rotateAndSkewTextRadiansAndTranslate(toRadians(options.rotate), toRadians(options.xSkew), toRadians(options.ySkew), options.x, options.y),
      showText(line),
      endText(),
      popGraphicsState()
    ].filter(Boolean);
  };
  var drawLinesOfText = function(lines, options) {
    var operators = [
      pushGraphicsState(),
      options.graphicsState && setGraphicsState(options.graphicsState),
      beginText(),
      setFillingColor(options.color),
      setFontAndSize(options.font, options.size),
      setLineHeight(options.lineHeight),
      rotateAndSkewTextRadiansAndTranslate(toRadians(options.rotate), toRadians(options.xSkew), toRadians(options.ySkew), options.x, options.y)
    ].filter(Boolean);
    for (var idx = 0, len = lines.length; idx < len; idx++) {
      operators.push(showText(lines[idx]), nextLine());
    }
    operators.push(endText(), popGraphicsState());
    return operators;
  };
  var drawImage = function(name, options) {
    return [
      pushGraphicsState(),
      options.graphicsState && setGraphicsState(options.graphicsState),
      translate(options.x, options.y),
      rotateRadians(toRadians(options.rotate)),
      scale(options.width, options.height),
      skewRadians(toRadians(options.xSkew), toRadians(options.ySkew)),
      drawObject(name),
      popGraphicsState()
    ].filter(Boolean);
  };
  var drawPage = function(name, options) {
    return [
      pushGraphicsState(),
      options.graphicsState && setGraphicsState(options.graphicsState),
      translate(options.x, options.y),
      rotateRadians(toRadians(options.rotate)),
      scale(options.xScale, options.yScale),
      skewRadians(toRadians(options.xSkew), toRadians(options.ySkew)),
      drawObject(name),
      popGraphicsState()
    ].filter(Boolean);
  };
  var drawLine = function(options) {
    var _a, _b;
    return [
      pushGraphicsState(),
      options.graphicsState && setGraphicsState(options.graphicsState),
      options.color && setStrokingColor(options.color),
      setLineWidth(options.thickness),
      setDashPattern((_a = options.dashArray) !== null && _a !== void 0 ? _a : [], (_b = options.dashPhase) !== null && _b !== void 0 ? _b : 0),
      moveTo(options.start.x, options.start.y),
      options.lineCap && setLineCap(options.lineCap),
      moveTo(options.start.x, options.start.y),
      lineTo(options.end.x, options.end.y),
      stroke(),
      popGraphicsState()
    ].filter(Boolean);
  };
  var drawRectangle = function(options) {
    var _a, _b;
    return [
      pushGraphicsState(),
      options.graphicsState && setGraphicsState(options.graphicsState),
      options.color && setFillingColor(options.color),
      options.borderColor && setStrokingColor(options.borderColor),
      setLineWidth(options.borderWidth),
      options.borderLineCap && setLineCap(options.borderLineCap),
      setDashPattern((_a = options.borderDashArray) !== null && _a !== void 0 ? _a : [], (_b = options.borderDashPhase) !== null && _b !== void 0 ? _b : 0),
      translate(options.x, options.y),
      rotateRadians(toRadians(options.rotate)),
      skewRadians(toRadians(options.xSkew), toRadians(options.ySkew)),
      moveTo(0, 0),
      lineTo(0, options.height),
      lineTo(options.width, options.height),
      lineTo(options.width, 0),
      closePath(),
      // prettier-ignore
      options.color && options.borderWidth ? fillAndStroke() : options.color ? fill() : options.borderColor ? stroke() : closePath(),
      popGraphicsState()
    ].filter(Boolean);
  };
  var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
  var drawEllipsePath = function(config) {
    var x = asNumber(config.x);
    var y = asNumber(config.y);
    var xScale = asNumber(config.xScale);
    var yScale = asNumber(config.yScale);
    x -= xScale;
    y -= yScale;
    var ox = xScale * KAPPA;
    var oy = yScale * KAPPA;
    var xe = x + xScale * 2;
    var ye = y + yScale * 2;
    var xm = x + xScale;
    var ym = y + yScale;
    return [
      pushGraphicsState(),
      moveTo(x, ym),
      appendBezierCurve(x, ym - oy, xm - ox, y, xm, y),
      appendBezierCurve(xm + ox, y, xe, ym - oy, xe, ym),
      appendBezierCurve(xe, ym + oy, xm + ox, ye, xm, ye),
      appendBezierCurve(xm - ox, ye, x, ym + oy, x, ym),
      popGraphicsState()
    ];
  };
  var drawEllipseCurves = function(config) {
    var centerX = asNumber(config.x);
    var centerY = asNumber(config.y);
    var xScale = asNumber(config.xScale);
    var yScale = asNumber(config.yScale);
    var x = -xScale;
    var y = -yScale;
    var ox = xScale * KAPPA;
    var oy = yScale * KAPPA;
    var xe = x + xScale * 2;
    var ye = y + yScale * 2;
    var xm = x + xScale;
    var ym = y + yScale;
    return [
      translate(centerX, centerY),
      rotateRadians(toRadians(config.rotate)),
      moveTo(x, ym),
      appendBezierCurve(x, ym - oy, xm - ox, y, xm, y),
      appendBezierCurve(xm + ox, y, xe, ym - oy, xe, ym),
      appendBezierCurve(xe, ym + oy, xm + ox, ye, xm, ye),
      appendBezierCurve(xm - ox, ye, x, ym + oy, x, ym)
    ];
  };
  var drawEllipse = function(options) {
    var _a, _b, _c;
    return __spreadArrays([
      pushGraphicsState(),
      options.graphicsState && setGraphicsState(options.graphicsState),
      options.color && setFillingColor(options.color),
      options.borderColor && setStrokingColor(options.borderColor),
      setLineWidth(options.borderWidth),
      options.borderLineCap && setLineCap(options.borderLineCap),
      setDashPattern((_a = options.borderDashArray) !== null && _a !== void 0 ? _a : [], (_b = options.borderDashPhase) !== null && _b !== void 0 ? _b : 0)
    ], options.rotate === void 0 ? drawEllipsePath({
      x: options.x,
      y: options.y,
      xScale: options.xScale,
      yScale: options.yScale
    }) : drawEllipseCurves({
      x: options.x,
      y: options.y,
      xScale: options.xScale,
      yScale: options.yScale,
      rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : degrees(0)
    }), [
      // prettier-ignore
      options.color && options.borderWidth ? fillAndStroke() : options.color ? fill() : options.borderColor ? stroke() : closePath(),
      popGraphicsState()
    ]).filter(Boolean);
  };
  var drawSvgPath = function(path, options) {
    var _a, _b, _c;
    return __spreadArrays([
      pushGraphicsState(),
      options.graphicsState && setGraphicsState(options.graphicsState),
      translate(options.x, options.y),
      rotateRadians(toRadians((_a = options.rotate) !== null && _a !== void 0 ? _a : degrees(0))),
      // SVG path Y axis is opposite pdf-lib's
      options.scale ? scale(options.scale, -options.scale) : scale(1, -1),
      options.color && setFillingColor(options.color),
      options.borderColor && setStrokingColor(options.borderColor),
      options.borderWidth && setLineWidth(options.borderWidth),
      options.borderLineCap && setLineCap(options.borderLineCap),
      setDashPattern((_b = options.borderDashArray) !== null && _b !== void 0 ? _b : [], (_c = options.borderDashPhase) !== null && _c !== void 0 ? _c : 0)
    ], svgPathToOperators(path), [
      // prettier-ignore
      options.color && options.borderWidth ? fillAndStroke() : options.color ? fill() : options.borderColor ? stroke() : closePath(),
      popGraphicsState()
    ]).filter(Boolean);
  };
  var drawCheckMark = function(options) {
    var size = asNumber(options.size);
    var p2x = -1 + 0.75;
    var p2y = -1 + 0.51;
    var p3y = 1 - 0.525;
    var p3x = 1 - 0.31;
    var p1x = -1 + 0.325;
    var p1y = -((p1x - p2x) * (p3x - p2x)) / (p3y - p2y) + p2y;
    return [
      pushGraphicsState(),
      options.color && setStrokingColor(options.color),
      setLineWidth(options.thickness),
      translate(options.x, options.y),
      moveTo(p1x * size, p1y * size),
      lineTo(p2x * size, p2y * size),
      lineTo(p3x * size, p3y * size),
      stroke(),
      popGraphicsState()
    ].filter(Boolean);
  };
  var rotateInPlace = function(options) {
    return options.rotation === 0 ? [
      translate(0, 0),
      rotateDegrees(0)
    ] : options.rotation === 90 ? [
      translate(options.width, 0),
      rotateDegrees(90)
    ] : options.rotation === 180 ? [
      translate(options.width, options.height),
      rotateDegrees(180)
    ] : options.rotation === 270 ? [
      translate(0, options.height),
      rotateDegrees(270)
    ] : [];
  };
  var drawCheckBox = function(options) {
    var outline = drawRectangle({
      x: options.x,
      y: options.y,
      width: options.width,
      height: options.height,
      borderWidth: options.borderWidth,
      color: options.color,
      borderColor: options.borderColor,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    });
    if (!options.filled)
      return outline;
    var width = asNumber(options.width);
    var height = asNumber(options.height);
    var checkMarkSize = Math.min(width, height) / 2;
    var checkMark = drawCheckMark({
      x: width / 2,
      y: height / 2,
      size: checkMarkSize,
      thickness: options.thickness,
      color: options.markColor
    });
    return __spreadArrays([pushGraphicsState()], outline, checkMark, [popGraphicsState()]);
  };
  var drawRadioButton = function(options) {
    var width = asNumber(options.width);
    var height = asNumber(options.height);
    var outlineScale = Math.min(width, height) / 2;
    var outline = drawEllipse({
      x: options.x,
      y: options.y,
      xScale: outlineScale,
      yScale: outlineScale,
      color: options.color,
      borderColor: options.borderColor,
      borderWidth: options.borderWidth
    });
    if (!options.filled)
      return outline;
    var dot = drawEllipse({
      x: options.x,
      y: options.y,
      xScale: outlineScale * 0.45,
      yScale: outlineScale * 0.45,
      color: options.dotColor,
      borderColor: void 0,
      borderWidth: 0
    });
    return __spreadArrays([pushGraphicsState()], outline, dot, [popGraphicsState()]);
  };
  var drawButton = function(options) {
    var x = asNumber(options.x);
    var y = asNumber(options.y);
    var width = asNumber(options.width);
    var height = asNumber(options.height);
    var background = drawRectangle({
      x,
      y,
      width,
      height,
      borderWidth: options.borderWidth,
      color: options.color,
      borderColor: options.borderColor,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    });
    var lines = drawTextLines(options.textLines, {
      color: options.textColor,
      font: options.font,
      size: options.fontSize,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    });
    return __spreadArrays([pushGraphicsState()], background, lines, [popGraphicsState()]);
  };
  var drawTextLines = function(lines, options) {
    var operators = [
      beginText(),
      setFillingColor(options.color),
      setFontAndSize(options.font, options.size)
    ];
    for (var idx = 0, len = lines.length; idx < len; idx++) {
      var _a = lines[idx], encoded = _a.encoded, x = _a.x, y = _a.y;
      operators.push(rotateAndSkewTextRadiansAndTranslate(toRadians(options.rotate), toRadians(options.xSkew), toRadians(options.ySkew), x, y), showText(encoded));
    }
    operators.push(endText());
    return operators;
  };
  var drawTextField = function(options) {
    var x = asNumber(options.x);
    var y = asNumber(options.y);
    var width = asNumber(options.width);
    var height = asNumber(options.height);
    var borderWidth = asNumber(options.borderWidth);
    var padding = asNumber(options.padding);
    var clipX = x + borderWidth / 2 + padding;
    var clipY = y + borderWidth / 2 + padding;
    var clipWidth = width - (borderWidth / 2 + padding) * 2;
    var clipHeight = height - (borderWidth / 2 + padding) * 2;
    var clippingArea = [
      moveTo(clipX, clipY),
      lineTo(clipX, clipY + clipHeight),
      lineTo(clipX + clipWidth, clipY + clipHeight),
      lineTo(clipX + clipWidth, clipY),
      closePath(),
      clip(),
      endPath()
    ];
    var background = drawRectangle({
      x,
      y,
      width,
      height,
      borderWidth: options.borderWidth,
      color: options.color,
      borderColor: options.borderColor,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    });
    var lines = drawTextLines(options.textLines, {
      color: options.textColor,
      font: options.font,
      size: options.fontSize,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    });
    var markedContent = __spreadArrays([
      beginMarkedContent("Tx"),
      pushGraphicsState()
    ], lines, [
      popGraphicsState(),
      endMarkedContent()
    ]);
    return __spreadArrays([
      pushGraphicsState()
    ], background, clippingArea, markedContent, [
      popGraphicsState()
    ]);
  };
  var drawOptionList = function(options) {
    var x = asNumber(options.x);
    var y = asNumber(options.y);
    var width = asNumber(options.width);
    var height = asNumber(options.height);
    var lineHeight = asNumber(options.lineHeight);
    var borderWidth = asNumber(options.borderWidth);
    var padding = asNumber(options.padding);
    var clipX = x + borderWidth / 2 + padding;
    var clipY = y + borderWidth / 2 + padding;
    var clipWidth = width - (borderWidth / 2 + padding) * 2;
    var clipHeight = height - (borderWidth / 2 + padding) * 2;
    var clippingArea = [
      moveTo(clipX, clipY),
      lineTo(clipX, clipY + clipHeight),
      lineTo(clipX + clipWidth, clipY + clipHeight),
      lineTo(clipX + clipWidth, clipY),
      closePath(),
      clip(),
      endPath()
    ];
    var background = drawRectangle({
      x,
      y,
      width,
      height,
      borderWidth: options.borderWidth,
      color: options.color,
      borderColor: options.borderColor,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    });
    var highlights = [];
    for (var idx = 0, len = options.selectedLines.length; idx < len; idx++) {
      var line = options.textLines[options.selectedLines[idx]];
      highlights.push.apply(highlights, drawRectangle({
        x: line.x - padding,
        y: line.y - (lineHeight - line.height) / 2,
        width: width - borderWidth,
        height: line.height + (lineHeight - line.height) / 2,
        borderWidth: 0,
        color: options.selectedColor,
        borderColor: void 0,
        rotate: degrees(0),
        xSkew: degrees(0),
        ySkew: degrees(0)
      }));
    }
    var lines = drawTextLines(options.textLines, {
      color: options.textColor,
      font: options.font,
      size: options.fontSize,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    });
    var markedContent = __spreadArrays([
      beginMarkedContent("Tx"),
      pushGraphicsState()
    ], lines, [
      popGraphicsState(),
      endMarkedContent()
    ]);
    return __spreadArrays([
      pushGraphicsState()
    ], background, highlights, clippingArea, markedContent, [
      popGraphicsState()
    ]);
  };

  // node_modules/@pdfme/pdf-lib/es/api/errors.js
  var EncryptedPDFError = (
    /** @class */
    function(_super) {
      __extends(EncryptedPDFError2, _super);
      function EncryptedPDFError2() {
        var _this = this;
        var msg = "Input document to `PDFDocument.load` is encrypted. You can use `PDFDocument.load(..., { ignoreEncryption: true })` if you wish to load the document anyways.";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return EncryptedPDFError2;
    }(Error)
  );
  var FontkitNotRegisteredError = (
    /** @class */
    function(_super) {
      __extends(FontkitNotRegisteredError2, _super);
      function FontkitNotRegisteredError2() {
        var _this = this;
        var msg = "Input to `PDFDocument.embedFont` was a custom font, but no `fontkit` instance was found. You must register a `fontkit` instance with `PDFDocument.registerFontkit(...)` before embedding custom fonts.";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return FontkitNotRegisteredError2;
    }(Error)
  );
  var ForeignPageError = (
    /** @class */
    function(_super) {
      __extends(ForeignPageError2, _super);
      function ForeignPageError2() {
        var _this = this;
        var msg = "A `page` passed to `PDFDocument.addPage` or `PDFDocument.insertPage` was from a different (foreign) PDF document. If you want to copy pages from one PDFDocument to another, you must use `PDFDocument.copyPages(...)` to copy the pages before adding or inserting them.";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return ForeignPageError2;
    }(Error)
  );
  var RemovePageFromEmptyDocumentError = (
    /** @class */
    function(_super) {
      __extends(RemovePageFromEmptyDocumentError2, _super);
      function RemovePageFromEmptyDocumentError2() {
        var _this = this;
        var msg = "PDFDocument has no pages so `PDFDocument.removePage` cannot be called";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return RemovePageFromEmptyDocumentError2;
    }(Error)
  );
  var NoSuchFieldError = (
    /** @class */
    function(_super) {
      __extends(NoSuchFieldError2, _super);
      function NoSuchFieldError2(name) {
        var _this = this;
        var msg = 'PDFDocument has no form field with the name "' + name + '"';
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return NoSuchFieldError2;
    }(Error)
  );
  var UnexpectedFieldTypeError = (
    /** @class */
    function(_super) {
      __extends(UnexpectedFieldTypeError2, _super);
      function UnexpectedFieldTypeError2(name, expected, actual) {
        var _a, _b;
        var _this = this;
        var expectedType = expected === null || expected === void 0 ? void 0 : expected.name;
        var actualType = (_b = (_a = actual === null || actual === void 0 ? void 0 : actual.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : actual;
        var msg = 'Expected field "' + name + '" to be of type ' + expectedType + ", " + ("but it is actually of type " + actualType);
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return UnexpectedFieldTypeError2;
    }(Error)
  );
  var MissingOnValueCheckError = (
    /** @class */
    function(_super) {
      __extends(MissingOnValueCheckError2, _super);
      function MissingOnValueCheckError2(onValue) {
        var _this = this;
        var msg = 'Failed to select check box due to missing onValue: "' + onValue + '"';
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return MissingOnValueCheckError2;
    }(Error)
  );
  var FieldAlreadyExistsError = (
    /** @class */
    function(_super) {
      __extends(FieldAlreadyExistsError2, _super);
      function FieldAlreadyExistsError2(name) {
        var _this = this;
        var msg = 'A field already exists with the specified name: "' + name + '"';
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return FieldAlreadyExistsError2;
    }(Error)
  );
  var InvalidFieldNamePartError = (
    /** @class */
    function(_super) {
      __extends(InvalidFieldNamePartError2, _super);
      function InvalidFieldNamePartError2(namePart) {
        var _this = this;
        var msg = 'Field name contains invalid component: "' + namePart + '"';
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return InvalidFieldNamePartError2;
    }(Error)
  );
  var FieldExistsAsNonTerminalError = (
    /** @class */
    function(_super) {
      __extends(FieldExistsAsNonTerminalError2, _super);
      function FieldExistsAsNonTerminalError2(name) {
        var _this = this;
        var msg = 'A non-terminal field already exists with the specified name: "' + name + '"';
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return FieldExistsAsNonTerminalError2;
    }(Error)
  );
  var RichTextFieldReadError = (
    /** @class */
    function(_super) {
      __extends(RichTextFieldReadError2, _super);
      function RichTextFieldReadError2(fieldName) {
        var _this = this;
        var msg = "Reading rich text fields is not supported: Attempted to read rich text field: " + fieldName;
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return RichTextFieldReadError2;
    }(Error)
  );
  var CombedTextLayoutError = (
    /** @class */
    function(_super) {
      __extends(CombedTextLayoutError2, _super);
      function CombedTextLayoutError2(lineLength, cellCount) {
        var _this = this;
        var msg = "Failed to layout combed text as lineLength=" + lineLength + " is greater than cellCount=" + cellCount;
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return CombedTextLayoutError2;
    }(Error)
  );
  var ExceededMaxLengthError = (
    /** @class */
    function(_super) {
      __extends(ExceededMaxLengthError2, _super);
      function ExceededMaxLengthError2(textLength, maxLength, name) {
        var _this = this;
        var msg = "Attempted to set text with length=" + textLength + " for TextField with maxLength=" + maxLength + " and name=" + name;
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return ExceededMaxLengthError2;
    }(Error)
  );
  var InvalidMaxLengthError = (
    /** @class */
    function(_super) {
      __extends(InvalidMaxLengthError2, _super);
      function InvalidMaxLengthError2(textLength, maxLength, name) {
        var _this = this;
        var msg = "Attempted to set maxLength=" + maxLength + ", which is less than " + textLength + ", the length of this field's current value (name=" + name + ")";
        _this = _super.call(this, msg) || this;
        return _this;
      }
      return InvalidMaxLengthError2;
    }(Error)
  );

  // node_modules/@pdfme/pdf-lib/es/api/text/alignment.js
  var TextAlignment;
  (function(TextAlignment2) {
    TextAlignment2[TextAlignment2["Left"] = 0] = "Left";
    TextAlignment2[TextAlignment2["Center"] = 1] = "Center";
    TextAlignment2[TextAlignment2["Right"] = 2] = "Right";
  })(TextAlignment || (TextAlignment = {}));

  // node_modules/@pdfme/pdf-lib/es/api/text/layout.js
  var MIN_FONT_SIZE = 4;
  var MAX_FONT_SIZE = 500;
  var computeFontSize = function(lines, font, bounds, multiline) {
    if (multiline === void 0) {
      multiline = false;
    }
    var fontSize = MIN_FONT_SIZE;
    while (fontSize < MAX_FONT_SIZE) {
      var linesUsed = 0;
      for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {
        linesUsed += 1;
        var line = lines[lineIdx];
        var words = line.split(" ");
        var spaceInLineRemaining = bounds.width;
        for (var idx = 0, len = words.length; idx < len; idx++) {
          var isLastWord = idx === len - 1;
          var word = isLastWord ? words[idx] : words[idx] + " ";
          var widthOfWord = font.widthOfTextAtSize(word, fontSize);
          spaceInLineRemaining -= widthOfWord;
          if (spaceInLineRemaining <= 0) {
            linesUsed += 1;
            spaceInLineRemaining = bounds.width - widthOfWord;
          }
        }
      }
      if (!multiline && linesUsed > lines.length)
        return fontSize - 1;
      var height = font.heightAtSize(fontSize);
      var lineHeight = height + height * 0.2;
      var totalHeight = lineHeight * linesUsed;
      if (totalHeight > Math.abs(bounds.height))
        return fontSize - 1;
      fontSize += 1;
    }
    return fontSize;
  };
  var computeCombedFontSize = function(line, font, bounds, cellCount) {
    var cellWidth = bounds.width / cellCount;
    var cellHeight = bounds.height;
    var fontSize = MIN_FONT_SIZE;
    var chars3 = charSplit(line);
    while (fontSize < MAX_FONT_SIZE) {
      for (var idx = 0, len = chars3.length; idx < len; idx++) {
        var c = chars3[idx];
        var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;
        if (tooLong)
          return fontSize - 1;
      }
      var height = font.heightAtSize(fontSize, { descender: false });
      if (height > cellHeight)
        return fontSize - 1;
      fontSize += 1;
    }
    return fontSize;
  };
  var lastIndexOfWhitespace = function(line) {
    for (var idx = line.length; idx > 0; idx--) {
      if (/\s/.test(line[idx]))
        return idx;
    }
    return void 0;
  };
  var splitOutLines = function(input, maxWidth, font, fontSize) {
    var _a;
    var lastWhitespaceIdx = input.length;
    while (lastWhitespaceIdx > 0) {
      var line = input.substring(0, lastWhitespaceIdx);
      var encoded = font.encodeText(line);
      var width = font.widthOfTextAtSize(line, fontSize);
      if (width < maxWidth) {
        var remainder = input.substring(lastWhitespaceIdx) || void 0;
        return { line, encoded, width, remainder };
      }
      lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;
    }
    return {
      line: input,
      encoded: font.encodeText(input),
      width: font.widthOfTextAtSize(input, fontSize),
      remainder: void 0
    };
  };
  var layoutMultilineText = function(text, _a) {
    var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;
    var lines = lineSplit(cleanText(text));
    if (fontSize === void 0 || fontSize === 0) {
      fontSize = computeFontSize(lines, font, bounds, true);
    }
    var height = font.heightAtSize(fontSize);
    var lineHeight = height + height * 0.2;
    var textLines = [];
    var minX = bounds.x;
    var minY = bounds.y;
    var maxX = bounds.x + bounds.width;
    var maxY = bounds.y + bounds.height;
    var y = bounds.y + bounds.height;
    for (var idx = 0, len = lines.length; idx < len; idx++) {
      var prevRemainder = lines[idx];
      while (prevRemainder !== void 0) {
        var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize), line = _b.line, encoded = _b.encoded, width = _b.width, remainder = _b.remainder;
        var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
        y -= lineHeight;
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x + width > maxX)
          maxX = x + width;
        if (y + height > maxY)
          maxY = y + height;
        textLines.push({ text: line, encoded, width, height, x, y });
        prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();
      }
    }
    return {
      fontSize,
      lineHeight,
      lines: textLines,
      bounds: {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      }
    };
  };
  var layoutCombedText = function(text, _a) {
    var fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds, cellCount = _a.cellCount;
    var line = mergeLines(cleanText(text));
    if (line.length > cellCount) {
      throw new CombedTextLayoutError(line.length, cellCount);
    }
    if (fontSize === void 0 || fontSize === 0) {
      fontSize = computeCombedFontSize(line, font, bounds, cellCount);
    }
    var cellWidth = bounds.width / cellCount;
    var height = font.heightAtSize(fontSize, { descender: false });
    var y = bounds.y + (bounds.height / 2 - height / 2);
    var cells = [];
    var minX = bounds.x;
    var minY = bounds.y;
    var maxX = bounds.x + bounds.width;
    var maxY = bounds.y + bounds.height;
    var cellOffset = 0;
    var charOffset = 0;
    while (cellOffset < cellCount) {
      var _b = charAtIndex(line, charOffset), char = _b[0], charLength = _b[1];
      var encoded = font.encodeText(char);
      var width = font.widthOfTextAtSize(char, fontSize);
      var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);
      var x = cellCenter - width / 2;
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x + width > maxX)
        maxX = x + width;
      if (y + height > maxY)
        maxY = y + height;
      cells.push({ text: line, encoded, width, height, x, y });
      cellOffset += 1;
      charOffset += charLength;
    }
    return {
      fontSize,
      cells,
      bounds: {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      }
    };
  };
  var layoutSinglelineText = function(text, _a) {
    var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;
    var line = mergeLines(cleanText(text));
    if (fontSize === void 0 || fontSize === 0) {
      fontSize = computeFontSize([line], font, bounds);
    }
    var encoded = font.encodeText(line);
    var width = font.widthOfTextAtSize(line, fontSize);
    var height = font.heightAtSize(fontSize, { descender: false });
    var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
    var y = bounds.y + (bounds.height / 2 - height / 2);
    return {
      fontSize,
      line: { text: line, encoded, width, height, x, y },
      bounds: { x, y, width, height }
    };
  };

  // node_modules/@pdfme/pdf-lib/es/api/form/appearances.js
  var normalizeAppearance = function(appearance) {
    if ("normal" in appearance)
      return appearance;
    return { normal: appearance };
  };
  var tfRegex2 = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]+(\d*\.\d+|\d+)[\0\t\n\f\r\ ]+Tf/;
  var getDefaultFontSize = function(field) {
    var _a, _b;
    var da = (_a = field.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
    var daMatch = (_b = findLastMatch(da, tfRegex2).match) !== null && _b !== void 0 ? _b : [];
    var defaultFontSize = Number(daMatch[2]);
    return isFinite(defaultFontSize) ? defaultFontSize : void 0;
  };
  var colorRegex = /(\d*\.\d+|\d+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+(g|rg|k)/;
  var getDefaultColor = function(field) {
    var _a;
    var da = (_a = field.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
    var daMatch = findLastMatch(da, colorRegex).match;
    var _b = daMatch !== null && daMatch !== void 0 ? daMatch : [], c1 = _b[1], c2 = _b[2], c3 = _b[3], c4 = _b[4], colorSpace = _b[5];
    if (colorSpace === "g" && c1) {
      return grayscale(Number(c1));
    }
    if (colorSpace === "rg" && c1 && c2 && c3) {
      return rgb(Number(c1), Number(c2), Number(c3));
    }
    if (colorSpace === "k" && c1 && c2 && c3 && c4) {
      return cmyk(Number(c1), Number(c2), Number(c3), Number(c4));
    }
    return void 0;
  };
  var updateDefaultAppearance = function(field, color, font, fontSize) {
    var _a;
    if (fontSize === void 0) {
      fontSize = 0;
    }
    var da = [
      setFillingColor(color).toString(),
      setFontAndSize((_a = font === null || font === void 0 ? void 0 : font.name) !== null && _a !== void 0 ? _a : "dummy__noop", fontSize).toString()
    ].join("\n");
    field.setDefaultAppearance(da);
  };
  var defaultCheckBoxAppearanceProvider = function(checkBox, widget) {
    var _a, _b, _c;
    var widgetColor = getDefaultColor(widget);
    var fieldColor = getDefaultColor(checkBox.acroField);
    var rectangle2 = widget.getRectangle();
    var ap = widget.getAppearanceCharacteristics();
    var bs = widget.getBorderStyle();
    var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
    var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
    var _d = adjustDimsForRotation(rectangle2, rotation), width = _d.width, height = _d.height;
    var rotate = rotateInPlace(__assign(__assign({}, rectangle2), { rotation }));
    var black = rgb(0, 0, 0);
    var borderColor = (_b = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b !== void 0 ? _b : black;
    var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
    var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
    var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
    if (widgetColor) {
      updateDefaultAppearance(widget, textColor);
    } else {
      updateDefaultAppearance(checkBox.acroField, textColor);
    }
    var options = {
      x: 0 + borderWidth / 2,
      y: 0 + borderWidth / 2,
      width: width - borderWidth,
      height: height - borderWidth,
      thickness: 1.5,
      borderWidth,
      borderColor,
      markColor: textColor
    };
    return {
      normal: {
        on: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options), { color: normalBackgroundColor, filled: true }))),
        off: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options), { color: normalBackgroundColor, filled: false })))
      },
      down: {
        on: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options), { color: downBackgroundColor, filled: true }))),
        off: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options), { color: downBackgroundColor, filled: false })))
      }
    };
  };
  var defaultRadioGroupAppearanceProvider = function(radioGroup, widget) {
    var _a, _b, _c;
    var widgetColor = getDefaultColor(widget);
    var fieldColor = getDefaultColor(radioGroup.acroField);
    var rectangle2 = widget.getRectangle();
    var ap = widget.getAppearanceCharacteristics();
    var bs = widget.getBorderStyle();
    var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
    var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
    var _d = adjustDimsForRotation(rectangle2, rotation), width = _d.width, height = _d.height;
    var rotate = rotateInPlace(__assign(__assign({}, rectangle2), { rotation }));
    var black = rgb(0, 0, 0);
    var borderColor = (_b = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b !== void 0 ? _b : black;
    var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
    var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
    var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
    if (widgetColor) {
      updateDefaultAppearance(widget, textColor);
    } else {
      updateDefaultAppearance(radioGroup.acroField, textColor);
    }
    var options = {
      x: width / 2,
      y: height / 2,
      width: width - borderWidth,
      height: height - borderWidth,
      borderWidth,
      borderColor,
      dotColor: textColor
    };
    return {
      normal: {
        on: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options), { color: normalBackgroundColor, filled: true }))),
        off: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options), { color: normalBackgroundColor, filled: false })))
      },
      down: {
        on: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options), { color: downBackgroundColor, filled: true }))),
        off: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options), { color: downBackgroundColor, filled: false })))
      }
    };
  };
  var defaultButtonAppearanceProvider = function(button, widget, font) {
    var _a, _b, _c, _d, _e;
    var widgetColor = getDefaultColor(widget);
    var fieldColor = getDefaultColor(button.acroField);
    var widgetFontSize = getDefaultFontSize(widget);
    var fieldFontSize = getDefaultFontSize(button.acroField);
    var rectangle2 = widget.getRectangle();
    var ap = widget.getAppearanceCharacteristics();
    var bs = widget.getBorderStyle();
    var captions = ap === null || ap === void 0 ? void 0 : ap.getCaptions();
    var normalText = (_a = captions === null || captions === void 0 ? void 0 : captions.normal) !== null && _a !== void 0 ? _a : "";
    var downText = (_c = (_b = captions === null || captions === void 0 ? void 0 : captions.down) !== null && _b !== void 0 ? _b : normalText) !== null && _c !== void 0 ? _c : "";
    var borderWidth = (_d = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _d !== void 0 ? _d : 0;
    var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
    var _f = adjustDimsForRotation(rectangle2, rotation), width = _f.width, height = _f.height;
    var rotate = rotateInPlace(__assign(__assign({}, rectangle2), { rotation }));
    var black = rgb(0, 0, 0);
    var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
    var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
    var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
    var bounds = {
      x: borderWidth,
      y: borderWidth,
      width: width - borderWidth * 2,
      height: height - borderWidth * 2
    };
    var normalLayout = layoutSinglelineText(normalText, {
      alignment: TextAlignment.Center,
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds
    });
    var downLayout = layoutSinglelineText(downText, {
      alignment: TextAlignment.Center,
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds
    });
    var fontSize = Math.min(normalLayout.fontSize, downLayout.fontSize);
    var textColor = (_e = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _e !== void 0 ? _e : black;
    if (widgetColor || widgetFontSize !== void 0) {
      updateDefaultAppearance(widget, textColor, font, fontSize);
    } else {
      updateDefaultAppearance(button.acroField, textColor, font, fontSize);
    }
    var options = {
      x: 0 + borderWidth / 2,
      y: 0 + borderWidth / 2,
      width: width - borderWidth,
      height: height - borderWidth,
      borderWidth,
      borderColor,
      textColor,
      font: font.name,
      fontSize
    };
    return {
      normal: __spreadArrays(rotate, drawButton(__assign(__assign({}, options), { color: normalBackgroundColor, textLines: [normalLayout.line] }))),
      down: __spreadArrays(rotate, drawButton(__assign(__assign({}, options), { color: downBackgroundColor, textLines: [downLayout.line] })))
    };
  };
  var defaultTextFieldAppearanceProvider = function(textField, widget, font) {
    var _a, _b, _c, _d;
    var widgetColor = getDefaultColor(widget);
    var fieldColor = getDefaultColor(textField.acroField);
    var widgetFontSize = getDefaultFontSize(widget);
    var fieldFontSize = getDefaultFontSize(textField.acroField);
    var rectangle2 = widget.getRectangle();
    var ap = widget.getAppearanceCharacteristics();
    var bs = widget.getBorderStyle();
    var text = (_a = textField.getText()) !== null && _a !== void 0 ? _a : "";
    var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
    var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
    var _e = adjustDimsForRotation(rectangle2, rotation), width = _e.width, height = _e.height;
    var rotate = rotateInPlace(__assign(__assign({}, rectangle2), { rotation }));
    var black = rgb(0, 0, 0);
    var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
    var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
    var textLines;
    var fontSize;
    var padding = textField.isCombed() ? 0 : 1;
    var bounds = {
      x: borderWidth + padding,
      y: borderWidth + padding,
      width: width - (borderWidth + padding) * 2,
      height: height - (borderWidth + padding) * 2
    };
    if (textField.isMultiline()) {
      var layout = layoutMultilineText(text, {
        alignment: textField.getAlignment(),
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      });
      textLines = layout.lines;
      fontSize = layout.fontSize;
    } else if (textField.isCombed()) {
      var layout = layoutCombedText(text, {
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds,
        cellCount: (_c = textField.getMaxLength()) !== null && _c !== void 0 ? _c : 0
      });
      textLines = layout.cells;
      fontSize = layout.fontSize;
    } else {
      var layout = layoutSinglelineText(text, {
        alignment: textField.getAlignment(),
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      });
      textLines = [layout.line];
      fontSize = layout.fontSize;
    }
    var textColor = (_d = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _d !== void 0 ? _d : black;
    if (widgetColor || widgetFontSize !== void 0) {
      updateDefaultAppearance(widget, textColor, font, fontSize);
    } else {
      updateDefaultAppearance(textField.acroField, textColor, font, fontSize);
    }
    var options = {
      x: 0 + borderWidth / 2,
      y: 0 + borderWidth / 2,
      width: width - borderWidth,
      height: height - borderWidth,
      borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
      borderColor,
      textColor,
      font: font.name,
      fontSize,
      color: normalBackgroundColor,
      textLines,
      padding
    };
    return __spreadArrays(rotate, drawTextField(options));
  };
  var defaultDropdownAppearanceProvider = function(dropdown, widget, font) {
    var _a, _b, _c;
    var widgetColor = getDefaultColor(widget);
    var fieldColor = getDefaultColor(dropdown.acroField);
    var widgetFontSize = getDefaultFontSize(widget);
    var fieldFontSize = getDefaultFontSize(dropdown.acroField);
    var rectangle2 = widget.getRectangle();
    var ap = widget.getAppearanceCharacteristics();
    var bs = widget.getBorderStyle();
    var text = (_a = dropdown.getSelected()[0]) !== null && _a !== void 0 ? _a : "";
    var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
    var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
    var _d = adjustDimsForRotation(rectangle2, rotation), width = _d.width, height = _d.height;
    var rotate = rotateInPlace(__assign(__assign({}, rectangle2), { rotation }));
    var black = rgb(0, 0, 0);
    var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
    var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
    var padding = 1;
    var bounds = {
      x: borderWidth + padding,
      y: borderWidth + padding,
      width: width - (borderWidth + padding) * 2,
      height: height - (borderWidth + padding) * 2
    };
    var _e = layoutSinglelineText(text, {
      alignment: TextAlignment.Left,
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds
    }), line = _e.line, fontSize = _e.fontSize;
    var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
    if (widgetColor || widgetFontSize !== void 0) {
      updateDefaultAppearance(widget, textColor, font, fontSize);
    } else {
      updateDefaultAppearance(dropdown.acroField, textColor, font, fontSize);
    }
    var options = {
      x: 0 + borderWidth / 2,
      y: 0 + borderWidth / 2,
      width: width - borderWidth,
      height: height - borderWidth,
      borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
      borderColor,
      textColor,
      font: font.name,
      fontSize,
      color: normalBackgroundColor,
      textLines: [line],
      padding
    };
    return __spreadArrays(rotate, drawTextField(options));
  };
  var defaultOptionListAppearanceProvider = function(optionList, widget, font) {
    var _a, _b;
    var widgetColor = getDefaultColor(widget);
    var fieldColor = getDefaultColor(optionList.acroField);
    var widgetFontSize = getDefaultFontSize(widget);
    var fieldFontSize = getDefaultFontSize(optionList.acroField);
    var rectangle2 = widget.getRectangle();
    var ap = widget.getAppearanceCharacteristics();
    var bs = widget.getBorderStyle();
    var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
    var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
    var _c = adjustDimsForRotation(rectangle2, rotation), width = _c.width, height = _c.height;
    var rotate = rotateInPlace(__assign(__assign({}, rectangle2), { rotation }));
    var black = rgb(0, 0, 0);
    var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
    var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
    var options = optionList.getOptions();
    var selected = optionList.getSelected();
    if (optionList.isSorted())
      options.sort();
    var text = "";
    for (var idx = 0, len = options.length; idx < len; idx++) {
      text += options[idx];
      if (idx < len - 1)
        text += "\n";
    }
    var padding = 1;
    var bounds = {
      x: borderWidth + padding,
      y: borderWidth + padding,
      width: width - (borderWidth + padding) * 2,
      height: height - (borderWidth + padding) * 2
    };
    var _d = layoutMultilineText(text, {
      alignment: TextAlignment.Left,
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds
    }), lines = _d.lines, fontSize = _d.fontSize, lineHeight = _d.lineHeight;
    var selectedLines = [];
    for (var idx = 0, len = lines.length; idx < len; idx++) {
      var line = lines[idx];
      if (selected.includes(line.text))
        selectedLines.push(idx);
    }
    var blue = rgb(153 / 255, 193 / 255, 218 / 255);
    var textColor = (_b = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _b !== void 0 ? _b : black;
    if (widgetColor || widgetFontSize !== void 0) {
      updateDefaultAppearance(widget, textColor, font, fontSize);
    } else {
      updateDefaultAppearance(optionList.acroField, textColor, font, fontSize);
    }
    return __spreadArrays(rotate, drawOptionList({
      x: 0 + borderWidth / 2,
      y: 0 + borderWidth / 2,
      width: width - borderWidth,
      height: height - borderWidth,
      borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
      borderColor,
      textColor,
      font: font.name,
      fontSize,
      color: normalBackgroundColor,
      textLines: lines,
      lineHeight,
      selectedColor: blue,
      selectedLines,
      padding
    }));
  };

  // node_modules/@pdfme/pdf-lib/es/api/PDFEmbeddedPage.js
  var PDFEmbeddedPage = (
    /** @class */
    function() {
      function PDFEmbeddedPage2(ref, doc, embedder) {
        this.alreadyEmbedded = false;
        assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
        assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
        assertIs(embedder, "embedder", [[PDFPageEmbedder_default, "PDFPageEmbedder"]]);
        this.ref = ref;
        this.doc = doc;
        this.width = embedder.width;
        this.height = embedder.height;
        this.embedder = embedder;
      }
      PDFEmbeddedPage2.prototype.scale = function(factor) {
        assertIs(factor, "factor", ["number"]);
        return { width: this.width * factor, height: this.height * factor };
      };
      PDFEmbeddedPage2.prototype.size = function() {
        return this.scale(1);
      };
      PDFEmbeddedPage2.prototype.embed = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!this.alreadyEmbedded)
                  return [3, 2];
                return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
              case 1:
                _a.sent();
                this.alreadyEmbedded = true;
                _a.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFEmbeddedPage2.of = function(ref, doc, embedder) {
        return new PDFEmbeddedPage2(ref, doc, embedder);
      };
      return PDFEmbeddedPage2;
    }()
  );
  var PDFEmbeddedPage_default = PDFEmbeddedPage;

  // node_modules/@pdfme/pdf-lib/es/api/PDFFont.js
  var PDFFont = (
    /** @class */
    function() {
      function PDFFont2(ref, doc, embedder) {
        this.modified = true;
        assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
        assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
        assertIs(embedder, "embedder", [
          [CustomFontEmbedder_default, "CustomFontEmbedder"],
          [StandardFontEmbedder_default, "StandardFontEmbedder"]
        ]);
        this.ref = ref;
        this.doc = doc;
        this.name = embedder.fontName;
        this.embedder = embedder;
      }
      PDFFont2.prototype.encodeText = function(text) {
        assertIs(text, "text", ["string"]);
        this.modified = true;
        return this.embedder.encodeText(text);
      };
      PDFFont2.prototype.widthOfTextAtSize = function(text, size) {
        assertIs(text, "text", ["string"]);
        assertIs(size, "size", ["number"]);
        return this.embedder.widthOfTextAtSize(text, size);
      };
      PDFFont2.prototype.heightAtSize = function(size, options) {
        var _a;
        assertIs(size, "size", ["number"]);
        assertOrUndefined(options === null || options === void 0 ? void 0 : options.descender, "options.descender", ["boolean"]);
        return this.embedder.heightOfFontAtSize(size, {
          descender: (_a = options === null || options === void 0 ? void 0 : options.descender) !== null && _a !== void 0 ? _a : true
        });
      };
      PDFFont2.prototype.sizeAtHeight = function(height) {
        assertIs(height, "height", ["number"]);
        return this.embedder.sizeOfFontAtHeight(height);
      };
      PDFFont2.prototype.getCharacterSet = function() {
        if (this.embedder instanceof StandardFontEmbedder_default) {
          return this.embedder.encoding.supportedCodePoints;
        } else {
          return this.embedder.font.characterSet;
        }
      };
      PDFFont2.prototype.embed = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.modified)
                  return [3, 2];
                return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
              case 1:
                _a.sent();
                this.modified = false;
                _a.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFFont2.of = function(ref, doc, embedder) {
        return new PDFFont2(ref, doc, embedder);
      };
      return PDFFont2;
    }()
  );
  var PDFFont_default = PDFFont;

  // node_modules/@pdfme/pdf-lib/es/api/PDFImage.js
  var PDFImage = (
    /** @class */
    function() {
      function PDFImage2(ref, doc, embedder) {
        assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
        assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
        assertIs(embedder, "embedder", [
          [JpegEmbedder_default, "JpegEmbedder"],
          [PngEmbedder_default, "PngEmbedder"]
        ]);
        this.ref = ref;
        this.doc = doc;
        this.width = embedder.width;
        this.height = embedder.height;
        this.embedder = embedder;
      }
      PDFImage2.prototype.scale = function(factor) {
        assertIs(factor, "factor", ["number"]);
        return { width: this.width * factor, height: this.height * factor };
      };
      PDFImage2.prototype.scaleToFit = function(width, height) {
        assertIs(width, "width", ["number"]);
        assertIs(height, "height", ["number"]);
        var imgWidthScale = width / this.width;
        var imgHeightScale = height / this.height;
        var scale2 = Math.min(imgWidthScale, imgHeightScale);
        return this.scale(scale2);
      };
      PDFImage2.prototype.size = function() {
        return this.scale(1);
      };
      PDFImage2.prototype.embed = function() {
        return __awaiter(this, void 0, void 0, function() {
          var _a, doc, ref;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!this.embedder)
                  return [
                    2
                    /*return*/
                  ];
                if (!this.embedTask) {
                  _a = this, doc = _a.doc, ref = _a.ref;
                  this.embedTask = this.embedder.embedIntoContext(doc.context, ref);
                }
                return [4, this.embedTask];
              case 1:
                _b.sent();
                this.embedder = void 0;
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFImage2.of = function(ref, doc, embedder) {
        return new PDFImage2(ref, doc, embedder);
      };
      return PDFImage2;
    }()
  );
  var PDFImage_default = PDFImage;

  // node_modules/@pdfme/pdf-lib/es/api/image/alignment.js
  var ImageAlignment;
  (function(ImageAlignment2) {
    ImageAlignment2[ImageAlignment2["Left"] = 0] = "Left";
    ImageAlignment2[ImageAlignment2["Center"] = 1] = "Center";
    ImageAlignment2[ImageAlignment2["Right"] = 2] = "Right";
  })(ImageAlignment || (ImageAlignment = {}));

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFField.js
  var assertFieldAppearanceOptions = function(options) {
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.x, "options.x", ["number"]);
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.y, "options.y", ["number"]);
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.width, "options.width", ["number"]);
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.height, "options.height", ["number"]);
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.textColor, "options.textColor", [
      [Object, "Color"]
    ]);
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.backgroundColor, "options.backgroundColor", [
      [Object, "Color"]
    ]);
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderColor, "options.borderColor", [
      [Object, "Color"]
    ]);
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderWidth, "options.borderWidth", ["number"]);
    assertOrUndefined(options === null || options === void 0 ? void 0 : options.rotate, "options.rotate", [[Object, "Rotation"]]);
  };
  var PDFField = (
    /** @class */
    function() {
      function PDFField2(acroField, ref, doc) {
        assertIs(acroField, "acroField", [[PDFAcroTerminal_default, "PDFAcroTerminal"]]);
        assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
        assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
        this.acroField = acroField;
        this.ref = ref;
        this.doc = doc;
      }
      PDFField2.prototype.getName = function() {
        var _a;
        return (_a = this.acroField.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : "";
      };
      PDFField2.prototype.isReadOnly = function() {
        return this.acroField.hasFlag(AcroFieldFlags.ReadOnly);
      };
      PDFField2.prototype.enableReadOnly = function() {
        this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, true);
      };
      PDFField2.prototype.disableReadOnly = function() {
        this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, false);
      };
      PDFField2.prototype.isRequired = function() {
        return this.acroField.hasFlag(AcroFieldFlags.Required);
      };
      PDFField2.prototype.enableRequired = function() {
        this.acroField.setFlagTo(AcroFieldFlags.Required, true);
      };
      PDFField2.prototype.disableRequired = function() {
        this.acroField.setFlagTo(AcroFieldFlags.Required, false);
      };
      PDFField2.prototype.isExported = function() {
        return !this.acroField.hasFlag(AcroFieldFlags.NoExport);
      };
      PDFField2.prototype.enableExporting = function() {
        this.acroField.setFlagTo(AcroFieldFlags.NoExport, false);
      };
      PDFField2.prototype.disableExporting = function() {
        this.acroField.setFlagTo(AcroFieldFlags.NoExport, true);
      };
      PDFField2.prototype.needsAppearancesUpdate = function() {
        throw new MethodNotImplementedError(this.constructor.name, "needsAppearancesUpdate");
      };
      PDFField2.prototype.defaultUpdateAppearances = function(_font) {
        throw new MethodNotImplementedError(this.constructor.name, "defaultUpdateAppearances");
      };
      PDFField2.prototype.markAsDirty = function() {
        this.doc.getForm().markFieldAsDirty(this.ref);
      };
      PDFField2.prototype.markAsClean = function() {
        this.doc.getForm().markFieldAsClean(this.ref);
      };
      PDFField2.prototype.isDirty = function() {
        return this.doc.getForm().fieldIsDirty(this.ref);
      };
      PDFField2.prototype.createWidget = function(options) {
        var _a;
        var textColor = options.textColor;
        var backgroundColor = options.backgroundColor;
        var borderColor = options.borderColor;
        var borderWidth = options.borderWidth;
        var degreesAngle = toDegrees(options.rotate);
        var caption = options.caption;
        var x = options.x;
        var y = options.y;
        var width = options.width + borderWidth;
        var height = options.height + borderWidth;
        var hidden = Boolean(options.hidden);
        var pageRef = options.page;
        assertMultiple(degreesAngle, "degreesAngle", 90);
        var widget = PDFWidgetAnnotation_default.create(this.doc.context, this.ref);
        var rect = rotateRectangle({ x, y, width, height }, borderWidth, degreesAngle);
        widget.setRectangle(rect);
        if (pageRef)
          widget.setP(pageRef);
        var ac = widget.getOrCreateAppearanceCharacteristics();
        if (backgroundColor) {
          ac.setBackgroundColor(colorToComponents(backgroundColor));
        }
        ac.setRotation(degreesAngle);
        if (caption)
          ac.setCaptions({ normal: caption });
        if (borderColor)
          ac.setBorderColor(colorToComponents(borderColor));
        var bs = widget.getOrCreateBorderStyle();
        if (borderWidth !== void 0)
          bs.setWidth(borderWidth);
        widget.setFlagTo(AnnotationFlags.Print, true);
        widget.setFlagTo(AnnotationFlags.Hidden, hidden);
        widget.setFlagTo(AnnotationFlags.Invisible, false);
        if (textColor) {
          var da = (_a = this.acroField.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
          var newDa = da + "\n" + setFillingColor(textColor).toString();
          this.acroField.setDefaultAppearance(newDa);
        }
        return widget;
      };
      PDFField2.prototype.updateWidgetAppearanceWithFont = function(widget, font, _a) {
        var normal = _a.normal, rollover = _a.rollover, down = _a.down;
        this.updateWidgetAppearances(widget, {
          normal: this.createAppearanceStream(widget, normal, font),
          rollover: rollover && this.createAppearanceStream(widget, rollover, font),
          down: down && this.createAppearanceStream(widget, down, font)
        });
      };
      PDFField2.prototype.updateOnOffWidgetAppearance = function(widget, onValue, _a) {
        var normal = _a.normal, rollover = _a.rollover, down = _a.down;
        this.updateWidgetAppearances(widget, {
          normal: this.createAppearanceDict(widget, normal, onValue),
          rollover: rollover && this.createAppearanceDict(widget, rollover, onValue),
          down: down && this.createAppearanceDict(widget, down, onValue)
        });
      };
      PDFField2.prototype.updateWidgetAppearances = function(widget, _a) {
        var normal = _a.normal, rollover = _a.rollover, down = _a.down;
        widget.setNormalAppearance(normal);
        if (rollover) {
          widget.setRolloverAppearance(rollover);
        } else {
          widget.removeRolloverAppearance();
        }
        if (down) {
          widget.setDownAppearance(down);
        } else {
          widget.removeDownAppearance();
        }
      };
      PDFField2.prototype.createAppearanceStream = function(widget, appearance, font) {
        var _a;
        var context = this.acroField.dict.context;
        var _b = widget.getRectangle(), width = _b.width, height = _b.height;
        var Resources = font && { Font: (_a = {}, _a[font.name] = font.ref, _a) };
        var stream2 = context.formXObject(appearance, {
          Resources,
          BBox: context.obj([0, 0, width, height]),
          Matrix: context.obj([1, 0, 0, 1, 0, 0])
        });
        var streamRef = context.register(stream2);
        return streamRef;
      };
      PDFField2.prototype.createImageAppearanceStream = function(widget, image, alignment) {
        var _a;
        var _b;
        var context = this.acroField.dict.context;
        var rectangle2 = widget.getRectangle();
        var ap = widget.getAppearanceCharacteristics();
        var bs = widget.getBorderStyle();
        var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
        var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
        var rotate = rotateInPlace(__assign(__assign({}, rectangle2), { rotation }));
        var adj = adjustDimsForRotation(rectangle2, rotation);
        var imageDims = image.scaleToFit(adj.width - borderWidth * 2, adj.height - borderWidth * 2);
        var options = {
          x: borderWidth,
          y: borderWidth,
          width: imageDims.width,
          height: imageDims.height,
          //
          rotate: degrees(0),
          xSkew: degrees(0),
          ySkew: degrees(0)
        };
        if (alignment === ImageAlignment.Center) {
          options.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;
          options.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;
        } else if (alignment === ImageAlignment.Right) {
          options.x = adj.width - borderWidth - imageDims.width;
          options.y = adj.height - borderWidth - imageDims.height;
        }
        var imageName = this.doc.context.addRandomSuffix("Image", 10);
        var appearance = __spreadArrays(rotate, drawImage(imageName, options));
        var Resources = { XObject: (_a = {}, _a[imageName] = image.ref, _a) };
        var stream2 = context.formXObject(appearance, {
          Resources,
          BBox: context.obj([0, 0, rectangle2.width, rectangle2.height]),
          Matrix: context.obj([1, 0, 0, 1, 0, 0])
        });
        return context.register(stream2);
      };
      PDFField2.prototype.createAppearanceDict = function(widget, appearance, onValue) {
        var context = this.acroField.dict.context;
        var onStreamRef = this.createAppearanceStream(widget, appearance.on);
        var offStreamRef = this.createAppearanceStream(widget, appearance.off);
        var appearanceDict = context.obj({});
        appearanceDict.set(onValue, onStreamRef);
        appearanceDict.set(PDFName_default.of("Off"), offStreamRef);
        return appearanceDict;
      };
      return PDFField2;
    }()
  );
  var PDFField_default = PDFField;

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFCheckBox.js
  var PDFCheckBox = (
    /** @class */
    function(_super) {
      __extends(PDFCheckBox2, _super);
      function PDFCheckBox2(acroCheckBox, ref, doc) {
        var _this = _super.call(this, acroCheckBox, ref, doc) || this;
        assertIs(acroCheckBox, "acroCheckBox", [
          [PDFAcroCheckBox_default, "PDFAcroCheckBox"]
        ]);
        _this.acroField = acroCheckBox;
        return _this;
      }
      PDFCheckBox2.prototype.check = function() {
        var _a;
        var onValue = (_a = this.acroField.getOnValue()) !== null && _a !== void 0 ? _a : PDFName_default.of("Yes");
        this.markAsDirty();
        this.acroField.setValue(onValue);
      };
      PDFCheckBox2.prototype.uncheck = function() {
        this.markAsDirty();
        this.acroField.setValue(PDFName_default.of("Off"));
      };
      PDFCheckBox2.prototype.isChecked = function() {
        var onValue = this.acroField.getOnValue();
        return !!onValue && onValue === this.acroField.getValue();
      };
      PDFCheckBox2.prototype.addToPage = function(page, options) {
        var _a, _b, _c, _d, _e, _f;
        assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
        assertFieldAppearanceOptions(options);
        if (!options)
          options = {};
        if (!("textColor" in options))
          options.textColor = rgb(0, 0, 0);
        if (!("backgroundColor" in options))
          options.backgroundColor = rgb(1, 1, 1);
        if (!("borderColor" in options))
          options.borderColor = rgb(0, 0, 0);
        if (!("borderWidth" in options))
          options.borderWidth = 1;
        var widget = this.createWidget({
          x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
          width: (_c = options.width) !== null && _c !== void 0 ? _c : 50,
          height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
          textColor: options.textColor,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
          rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),
          hidden: options.hidden,
          page: page.ref
        });
        var widgetRef = this.doc.context.register(widget.dict);
        this.acroField.addWidget(widgetRef);
        widget.setAppearanceState(PDFName_default.of("Off"));
        this.updateWidgetAppearance(widget, PDFName_default.of("Yes"));
        page.node.addAnnot(widgetRef);
      };
      PDFCheckBox2.prototype.needsAppearancesUpdate = function() {
        var _a;
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var state = widget.getAppearanceState();
          var normal = (_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
          if (!(normal instanceof PDFDict_default))
            return true;
          if (state && !normal.has(state))
            return true;
        }
        return false;
      };
      PDFCheckBox2.prototype.defaultUpdateAppearances = function() {
        this.updateAppearances();
      };
      PDFCheckBox2.prototype.updateAppearances = function(provider) {
        var _a;
        assertOrUndefined(provider, "provider", [Function]);
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var onValue = (_a = widget.getOnValue()) !== null && _a !== void 0 ? _a : PDFName_default.of("Yes");
          if (!onValue)
            continue;
          this.updateWidgetAppearance(widget, onValue, provider);
        }
        this.markAsClean();
      };
      PDFCheckBox2.prototype.updateWidgetAppearance = function(widget, onValue, provider) {
        var apProvider = provider !== null && provider !== void 0 ? provider : defaultCheckBoxAppearanceProvider;
        var appearances = normalizeAppearance(apProvider(this, widget));
        this.updateOnOffWidgetAppearance(widget, onValue, appearances);
      };
      PDFCheckBox2.of = function(acroCheckBox, ref, doc) {
        return new PDFCheckBox2(acroCheckBox, ref, doc);
      };
      return PDFCheckBox2;
    }(PDFField_default)
  );
  var PDFCheckBox_default = PDFCheckBox;

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFDropdown.js
  var PDFDropdown = (
    /** @class */
    function(_super) {
      __extends(PDFDropdown2, _super);
      function PDFDropdown2(acroComboBox, ref, doc) {
        var _this = _super.call(this, acroComboBox, ref, doc) || this;
        assertIs(acroComboBox, "acroComboBox", [
          [PDFAcroComboBox_default, "PDFAcroComboBox"]
        ]);
        _this.acroField = acroComboBox;
        return _this;
      }
      PDFDropdown2.prototype.getOptions = function() {
        var rawOptions = this.acroField.getOptions();
        var options = new Array(rawOptions.length);
        for (var idx = 0, len = options.length; idx < len; idx++) {
          var _a = rawOptions[idx], display = _a.display, value = _a.value;
          options[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
        }
        return options;
      };
      PDFDropdown2.prototype.getSelected = function() {
        var values2 = this.acroField.getValues();
        var selected = new Array(values2.length);
        for (var idx = 0, len = values2.length; idx < len; idx++) {
          selected[idx] = values2[idx].decodeText();
        }
        return selected;
      };
      PDFDropdown2.prototype.setOptions = function(options) {
        assertIs(options, "options", [Array]);
        var optionObjects = new Array(options.length);
        for (var idx = 0, len = options.length; idx < len; idx++) {
          optionObjects[idx] = { value: PDFHexString_default.fromText(options[idx]) };
        }
        this.acroField.setOptions(optionObjects);
      };
      PDFDropdown2.prototype.addOptions = function(options) {
        assertIs(options, "options", ["string", Array]);
        var optionsArr = Array.isArray(options) ? options : [options];
        var existingOptions = this.acroField.getOptions();
        var newOptions = new Array(optionsArr.length);
        for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
          newOptions[idx] = { value: PDFHexString_default.fromText(optionsArr[idx]) };
        }
        this.acroField.setOptions(existingOptions.concat(newOptions));
      };
      PDFDropdown2.prototype.select = function(options, merge) {
        if (merge === void 0) {
          merge = false;
        }
        assertIs(options, "options", ["string", Array]);
        assertIs(merge, "merge", ["boolean"]);
        var optionsArr = Array.isArray(options) ? options : [options];
        var validOptions = this.getOptions();
        var hasCustomOption = optionsArr.find(function(option) {
          return !validOptions.includes(option);
        });
        if (hasCustomOption)
          this.enableEditing();
        this.markAsDirty();
        if (optionsArr.length > 1 || optionsArr.length === 1 && merge) {
          this.enableMultiselect();
        }
        var values2 = new Array(optionsArr.length);
        for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
          values2[idx] = PDFHexString_default.fromText(optionsArr[idx]);
        }
        if (merge) {
          var existingValues = this.acroField.getValues();
          this.acroField.setValues(existingValues.concat(values2));
        } else {
          this.acroField.setValues(values2);
        }
      };
      PDFDropdown2.prototype.clear = function() {
        this.markAsDirty();
        this.acroField.setValues([]);
      };
      PDFDropdown2.prototype.setFontSize = function(fontSize) {
        assertPositive(fontSize, "fontSize");
        this.acroField.setFontSize(fontSize);
        this.markAsDirty();
      };
      PDFDropdown2.prototype.isEditable = function() {
        return this.acroField.hasFlag(AcroChoiceFlags.Edit);
      };
      PDFDropdown2.prototype.enableEditing = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.Edit, true);
      };
      PDFDropdown2.prototype.disableEditing = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.Edit, false);
      };
      PDFDropdown2.prototype.isSorted = function() {
        return this.acroField.hasFlag(AcroChoiceFlags.Sort);
      };
      PDFDropdown2.prototype.enableSorting = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.Sort, true);
      };
      PDFDropdown2.prototype.disableSorting = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.Sort, false);
      };
      PDFDropdown2.prototype.isMultiselect = function() {
        return this.acroField.hasFlag(AcroChoiceFlags.MultiSelect);
      };
      PDFDropdown2.prototype.enableMultiselect = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, true);
      };
      PDFDropdown2.prototype.disableMultiselect = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, false);
      };
      PDFDropdown2.prototype.isSpellChecked = function() {
        return !this.acroField.hasFlag(AcroChoiceFlags.DoNotSpellCheck);
      };
      PDFDropdown2.prototype.enableSpellChecking = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.DoNotSpellCheck, false);
      };
      PDFDropdown2.prototype.disableSpellChecking = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.DoNotSpellCheck, true);
      };
      PDFDropdown2.prototype.isSelectOnClick = function() {
        return this.acroField.hasFlag(AcroChoiceFlags.CommitOnSelChange);
      };
      PDFDropdown2.prototype.enableSelectOnClick = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, true);
      };
      PDFDropdown2.prototype.disableSelectOnClick = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, false);
      };
      PDFDropdown2.prototype.addToPage = function(page, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
        assertFieldAppearanceOptions(options);
        if (!options)
          options = {};
        if (!("textColor" in options))
          options.textColor = rgb(0, 0, 0);
        if (!("backgroundColor" in options))
          options.backgroundColor = rgb(1, 1, 1);
        if (!("borderColor" in options))
          options.borderColor = rgb(0, 0, 0);
        if (!("borderWidth" in options))
          options.borderWidth = 1;
        var widget = this.createWidget({
          x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
          width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
          height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
          textColor: options.textColor,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
          rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),
          hidden: options.hidden,
          page: page.ref
        });
        var widgetRef = this.doc.context.register(widget.dict);
        this.acroField.addWidget(widgetRef);
        var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
        this.updateWidgetAppearance(widget, font);
        page.node.addAnnot(widgetRef);
      };
      PDFDropdown2.prototype.needsAppearancesUpdate = function() {
        var _a;
        if (this.isDirty())
          return true;
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream_default;
          if (!hasAppearances)
            return true;
        }
        return false;
      };
      PDFDropdown2.prototype.defaultUpdateAppearances = function(font) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        this.updateAppearances(font);
      };
      PDFDropdown2.prototype.updateAppearances = function(font, provider) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        assertOrUndefined(provider, "provider", [Function]);
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          this.updateWidgetAppearance(widget, font, provider);
        }
        this.markAsClean();
      };
      PDFDropdown2.prototype.updateWidgetAppearance = function(widget, font, provider) {
        var apProvider = provider !== null && provider !== void 0 ? provider : defaultDropdownAppearanceProvider;
        var appearances = normalizeAppearance(apProvider(this, widget, font));
        this.updateWidgetAppearanceWithFont(widget, font, appearances);
      };
      PDFDropdown2.of = function(acroComboBox, ref, doc) {
        return new PDFDropdown2(acroComboBox, ref, doc);
      };
      return PDFDropdown2;
    }(PDFField_default)
  );
  var PDFDropdown_default = PDFDropdown;

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFOptionList.js
  var PDFOptionList = (
    /** @class */
    function(_super) {
      __extends(PDFOptionList2, _super);
      function PDFOptionList2(acroListBox, ref, doc) {
        var _this = _super.call(this, acroListBox, ref, doc) || this;
        assertIs(acroListBox, "acroListBox", [[PDFAcroListBox_default, "PDFAcroListBox"]]);
        _this.acroField = acroListBox;
        return _this;
      }
      PDFOptionList2.prototype.getOptions = function() {
        var rawOptions = this.acroField.getOptions();
        var options = new Array(rawOptions.length);
        for (var idx = 0, len = options.length; idx < len; idx++) {
          var _a = rawOptions[idx], display = _a.display, value = _a.value;
          options[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
        }
        return options;
      };
      PDFOptionList2.prototype.getSelected = function() {
        var values2 = this.acroField.getValues();
        var selected = new Array(values2.length);
        for (var idx = 0, len = values2.length; idx < len; idx++) {
          selected[idx] = values2[idx].decodeText();
        }
        return selected;
      };
      PDFOptionList2.prototype.setOptions = function(options) {
        assertIs(options, "options", [Array]);
        this.markAsDirty();
        var optionObjects = new Array(options.length);
        for (var idx = 0, len = options.length; idx < len; idx++) {
          optionObjects[idx] = { value: PDFHexString_default.fromText(options[idx]) };
        }
        this.acroField.setOptions(optionObjects);
      };
      PDFOptionList2.prototype.addOptions = function(options) {
        assertIs(options, "options", ["string", Array]);
        this.markAsDirty();
        var optionsArr = Array.isArray(options) ? options : [options];
        var existingOptions = this.acroField.getOptions();
        var newOptions = new Array(optionsArr.length);
        for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
          newOptions[idx] = { value: PDFHexString_default.fromText(optionsArr[idx]) };
        }
        this.acroField.setOptions(existingOptions.concat(newOptions));
      };
      PDFOptionList2.prototype.select = function(options, merge) {
        if (merge === void 0) {
          merge = false;
        }
        assertIs(options, "options", ["string", Array]);
        assertIs(merge, "merge", ["boolean"]);
        var optionsArr = Array.isArray(options) ? options : [options];
        var validOptions = this.getOptions();
        assertIsSubset(optionsArr, "option", validOptions);
        this.markAsDirty();
        if (optionsArr.length > 1 || optionsArr.length === 1 && merge) {
          this.enableMultiselect();
        }
        var values2 = new Array(optionsArr.length);
        for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
          values2[idx] = PDFHexString_default.fromText(optionsArr[idx]);
        }
        if (merge) {
          var existingValues = this.acroField.getValues();
          this.acroField.setValues(existingValues.concat(values2));
        } else {
          this.acroField.setValues(values2);
        }
      };
      PDFOptionList2.prototype.clear = function() {
        this.markAsDirty();
        this.acroField.setValues([]);
      };
      PDFOptionList2.prototype.setFontSize = function(fontSize) {
        assertPositive(fontSize, "fontSize");
        this.acroField.setFontSize(fontSize);
        this.markAsDirty();
      };
      PDFOptionList2.prototype.isSorted = function() {
        return this.acroField.hasFlag(AcroChoiceFlags.Sort);
      };
      PDFOptionList2.prototype.enableSorting = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.Sort, true);
      };
      PDFOptionList2.prototype.disableSorting = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.Sort, false);
      };
      PDFOptionList2.prototype.isMultiselect = function() {
        return this.acroField.hasFlag(AcroChoiceFlags.MultiSelect);
      };
      PDFOptionList2.prototype.enableMultiselect = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, true);
      };
      PDFOptionList2.prototype.disableMultiselect = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, false);
      };
      PDFOptionList2.prototype.isSelectOnClick = function() {
        return this.acroField.hasFlag(AcroChoiceFlags.CommitOnSelChange);
      };
      PDFOptionList2.prototype.enableSelectOnClick = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, true);
      };
      PDFOptionList2.prototype.disableSelectOnClick = function() {
        this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, false);
      };
      PDFOptionList2.prototype.addToPage = function(page, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
        assertFieldAppearanceOptions(options);
        if (!options)
          options = {};
        if (!("textColor" in options))
          options.textColor = rgb(0, 0, 0);
        if (!("backgroundColor" in options))
          options.backgroundColor = rgb(1, 1, 1);
        if (!("borderColor" in options))
          options.borderColor = rgb(0, 0, 0);
        if (!("borderWidth" in options))
          options.borderWidth = 1;
        var widget = this.createWidget({
          x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
          width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
          height: (_d = options.height) !== null && _d !== void 0 ? _d : 100,
          textColor: options.textColor,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
          rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),
          hidden: options.hidden,
          page: page.ref
        });
        var widgetRef = this.doc.context.register(widget.dict);
        this.acroField.addWidget(widgetRef);
        var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
        this.updateWidgetAppearance(widget, font);
        page.node.addAnnot(widgetRef);
      };
      PDFOptionList2.prototype.needsAppearancesUpdate = function() {
        var _a;
        if (this.isDirty())
          return true;
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream_default;
          if (!hasAppearances)
            return true;
        }
        return false;
      };
      PDFOptionList2.prototype.defaultUpdateAppearances = function(font) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        this.updateAppearances(font);
      };
      PDFOptionList2.prototype.updateAppearances = function(font, provider) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        assertOrUndefined(provider, "provider", [Function]);
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          this.updateWidgetAppearance(widget, font, provider);
        }
        this.markAsClean();
      };
      PDFOptionList2.prototype.updateWidgetAppearance = function(widget, font, provider) {
        var apProvider = provider !== null && provider !== void 0 ? provider : defaultOptionListAppearanceProvider;
        var appearances = normalizeAppearance(apProvider(this, widget, font));
        this.updateWidgetAppearanceWithFont(widget, font, appearances);
      };
      PDFOptionList2.of = function(acroListBox, ref, doc) {
        return new PDFOptionList2(acroListBox, ref, doc);
      };
      return PDFOptionList2;
    }(PDFField_default)
  );
  var PDFOptionList_default = PDFOptionList;

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFRadioGroup.js
  var PDFRadioGroup = (
    /** @class */
    function(_super) {
      __extends(PDFRadioGroup2, _super);
      function PDFRadioGroup2(acroRadioButton, ref, doc) {
        var _this = _super.call(this, acroRadioButton, ref, doc) || this;
        assertIs(acroRadioButton, "acroRadioButton", [
          [PDFAcroRadioButton_default, "PDFAcroRadioButton"]
        ]);
        _this.acroField = acroRadioButton;
        return _this;
      }
      PDFRadioGroup2.prototype.getOptions = function() {
        var exportValues = this.acroField.getExportValues();
        if (exportValues) {
          var exportOptions = new Array(exportValues.length);
          for (var idx = 0, len = exportValues.length; idx < len; idx++) {
            exportOptions[idx] = exportValues[idx].decodeText();
          }
          return exportOptions;
        }
        var onValues = this.acroField.getOnValues();
        var onOptions = new Array(onValues.length);
        for (var idx = 0, len = onOptions.length; idx < len; idx++) {
          onOptions[idx] = onValues[idx].decodeText();
        }
        return onOptions;
      };
      PDFRadioGroup2.prototype.getSelected = function() {
        var value = this.acroField.getValue();
        if (value === PDFName_default.of("Off"))
          return void 0;
        var exportValues = this.acroField.getExportValues();
        if (exportValues) {
          var onValues = this.acroField.getOnValues();
          for (var idx = 0, len = onValues.length; idx < len; idx++) {
            if (onValues[idx] === value)
              return exportValues[idx].decodeText();
          }
        }
        return value.decodeText();
      };
      PDFRadioGroup2.prototype.select = function(option) {
        assertIs(option, "option", ["string"]);
        var validOptions = this.getOptions();
        assertIsOneOf(option, "option", validOptions);
        this.markAsDirty();
        var onValues = this.acroField.getOnValues();
        var exportValues = this.acroField.getExportValues();
        if (exportValues) {
          for (var idx = 0, len = exportValues.length; idx < len; idx++) {
            if (exportValues[idx].decodeText() === option) {
              this.acroField.setValue(onValues[idx]);
            }
          }
        } else {
          for (var idx = 0, len = onValues.length; idx < len; idx++) {
            var value = onValues[idx];
            if (value.decodeText() === option)
              this.acroField.setValue(value);
          }
        }
      };
      PDFRadioGroup2.prototype.clear = function() {
        this.markAsDirty();
        this.acroField.setValue(PDFName_default.of("Off"));
      };
      PDFRadioGroup2.prototype.isOffToggleable = function() {
        return !this.acroField.hasFlag(AcroButtonFlags.NoToggleToOff);
      };
      PDFRadioGroup2.prototype.enableOffToggling = function() {
        this.acroField.setFlagTo(AcroButtonFlags.NoToggleToOff, false);
      };
      PDFRadioGroup2.prototype.disableOffToggling = function() {
        this.acroField.setFlagTo(AcroButtonFlags.NoToggleToOff, true);
      };
      PDFRadioGroup2.prototype.isMutuallyExclusive = function() {
        return !this.acroField.hasFlag(AcroButtonFlags.RadiosInUnison);
      };
      PDFRadioGroup2.prototype.enableMutualExclusion = function() {
        this.acroField.setFlagTo(AcroButtonFlags.RadiosInUnison, false);
      };
      PDFRadioGroup2.prototype.disableMutualExclusion = function() {
        this.acroField.setFlagTo(AcroButtonFlags.RadiosInUnison, true);
      };
      PDFRadioGroup2.prototype.addOptionToPage = function(option, page, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        assertIs(option, "option", ["string"]);
        assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
        assertFieldAppearanceOptions(options);
        var widget = this.createWidget({
          x: (_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0,
          y: (_b = options === null || options === void 0 ? void 0 : options.y) !== null && _b !== void 0 ? _b : 0,
          width: (_c = options === null || options === void 0 ? void 0 : options.width) !== null && _c !== void 0 ? _c : 50,
          height: (_d = options === null || options === void 0 ? void 0 : options.height) !== null && _d !== void 0 ? _d : 50,
          textColor: (_e = options === null || options === void 0 ? void 0 : options.textColor) !== null && _e !== void 0 ? _e : rgb(0, 0, 0),
          backgroundColor: (_f = options === null || options === void 0 ? void 0 : options.backgroundColor) !== null && _f !== void 0 ? _f : rgb(1, 1, 1),
          borderColor: (_g = options === null || options === void 0 ? void 0 : options.borderColor) !== null && _g !== void 0 ? _g : rgb(0, 0, 0),
          borderWidth: (_h = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _h !== void 0 ? _h : 1,
          rotate: (_j = options === null || options === void 0 ? void 0 : options.rotate) !== null && _j !== void 0 ? _j : degrees(0),
          hidden: options === null || options === void 0 ? void 0 : options.hidden,
          page: page.ref
        });
        var widgetRef = this.doc.context.register(widget.dict);
        var apStateValue = this.acroField.addWidgetWithOpt(widgetRef, PDFHexString_default.fromText(option), !this.isMutuallyExclusive());
        widget.setAppearanceState(PDFName_default.of("Off"));
        this.updateWidgetAppearance(widget, apStateValue);
        page.node.addAnnot(widgetRef);
      };
      PDFRadioGroup2.prototype.needsAppearancesUpdate = function() {
        var _a;
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var state = widget.getAppearanceState();
          var normal = (_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
          if (!(normal instanceof PDFDict_default))
            return true;
          if (state && !normal.has(state))
            return true;
        }
        return false;
      };
      PDFRadioGroup2.prototype.defaultUpdateAppearances = function() {
        this.updateAppearances();
      };
      PDFRadioGroup2.prototype.updateAppearances = function(provider) {
        assertOrUndefined(provider, "provider", [Function]);
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var onValue = widget.getOnValue();
          if (!onValue)
            continue;
          this.updateWidgetAppearance(widget, onValue, provider);
        }
      };
      PDFRadioGroup2.prototype.updateWidgetAppearance = function(widget, onValue, provider) {
        var apProvider = provider !== null && provider !== void 0 ? provider : defaultRadioGroupAppearanceProvider;
        var appearances = normalizeAppearance(apProvider(this, widget));
        this.updateOnOffWidgetAppearance(widget, onValue, appearances);
      };
      PDFRadioGroup2.of = function(acroRadioButton, ref, doc) {
        return new PDFRadioGroup2(acroRadioButton, ref, doc);
      };
      return PDFRadioGroup2;
    }(PDFField_default)
  );
  var PDFRadioGroup_default = PDFRadioGroup;

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFSignature.js
  var PDFSignature = (
    /** @class */
    function(_super) {
      __extends(PDFSignature2, _super);
      function PDFSignature2(acroSignature, ref, doc) {
        var _this = _super.call(this, acroSignature, ref, doc) || this;
        assertIs(acroSignature, "acroSignature", [
          [PDFAcroSignature_default, "PDFAcroSignature"]
        ]);
        _this.acroField = acroSignature;
        return _this;
      }
      PDFSignature2.prototype.needsAppearancesUpdate = function() {
        return false;
      };
      PDFSignature2.of = function(acroSignature, ref, doc) {
        return new PDFSignature2(acroSignature, ref, doc);
      };
      return PDFSignature2;
    }(PDFField_default)
  );
  var PDFSignature_default = PDFSignature;

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFTextField.js
  var PDFTextField = (
    /** @class */
    function(_super) {
      __extends(PDFTextField2, _super);
      function PDFTextField2(acroText, ref, doc) {
        var _this = _super.call(this, acroText, ref, doc) || this;
        assertIs(acroText, "acroText", [[PDFAcroText_default, "PDFAcroText"]]);
        _this.acroField = acroText;
        return _this;
      }
      PDFTextField2.prototype.getText = function() {
        var value = this.acroField.getValue();
        if (!value && this.isRichFormatted()) {
          throw new RichTextFieldReadError(this.getName());
        }
        return value === null || value === void 0 ? void 0 : value.decodeText();
      };
      PDFTextField2.prototype.setText = function(text) {
        assertOrUndefined(text, "text", ["string"]);
        var maxLength = this.getMaxLength();
        if (maxLength !== void 0 && text && text.length > maxLength) {
          throw new ExceededMaxLengthError(text.length, maxLength, this.getName());
        }
        this.markAsDirty();
        this.disableRichFormatting();
        if (text) {
          this.acroField.setValue(PDFHexString_default.fromText(text));
        } else {
          this.acroField.removeValue();
        }
      };
      PDFTextField2.prototype.getAlignment = function() {
        var quadding = this.acroField.getQuadding();
        return quadding === 0 ? TextAlignment.Left : quadding === 1 ? TextAlignment.Center : quadding === 2 ? TextAlignment.Right : TextAlignment.Left;
      };
      PDFTextField2.prototype.setAlignment = function(alignment) {
        assertIsOneOf(alignment, "alignment", TextAlignment);
        this.markAsDirty();
        this.acroField.setQuadding(alignment);
      };
      PDFTextField2.prototype.getMaxLength = function() {
        return this.acroField.getMaxLength();
      };
      PDFTextField2.prototype.setMaxLength = function(maxLength) {
        assertRangeOrUndefined(maxLength, "maxLength", 0, Number.MAX_SAFE_INTEGER);
        this.markAsDirty();
        if (maxLength === void 0) {
          this.acroField.removeMaxLength();
        } else {
          var text = this.getText();
          if (text && text.length > maxLength) {
            throw new InvalidMaxLengthError(text.length, maxLength, this.getName());
          }
          this.acroField.setMaxLength(maxLength);
        }
      };
      PDFTextField2.prototype.removeMaxLength = function() {
        this.markAsDirty();
        this.acroField.removeMaxLength();
      };
      PDFTextField2.prototype.setImage = function(image) {
        var fieldAlignment = this.getAlignment();
        var alignment = fieldAlignment === TextAlignment.Center ? ImageAlignment.Center : fieldAlignment === TextAlignment.Right ? ImageAlignment.Right : ImageAlignment.Left;
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var streamRef = this.createImageAppearanceStream(widget, image, alignment);
          this.updateWidgetAppearances(widget, { normal: streamRef });
        }
        this.markAsClean();
      };
      PDFTextField2.prototype.setFontSize = function(fontSize) {
        assertPositive(fontSize, "fontSize");
        this.acroField.setFontSize(fontSize);
        this.markAsDirty();
      };
      PDFTextField2.prototype.isMultiline = function() {
        return this.acroField.hasFlag(AcroTextFlags.Multiline);
      };
      PDFTextField2.prototype.enableMultiline = function() {
        this.markAsDirty();
        this.acroField.setFlagTo(AcroTextFlags.Multiline, true);
      };
      PDFTextField2.prototype.disableMultiline = function() {
        this.markAsDirty();
        this.acroField.setFlagTo(AcroTextFlags.Multiline, false);
      };
      PDFTextField2.prototype.isPassword = function() {
        return this.acroField.hasFlag(AcroTextFlags.Password);
      };
      PDFTextField2.prototype.enablePassword = function() {
        this.acroField.setFlagTo(AcroTextFlags.Password, true);
      };
      PDFTextField2.prototype.disablePassword = function() {
        this.acroField.setFlagTo(AcroTextFlags.Password, false);
      };
      PDFTextField2.prototype.isFileSelector = function() {
        return this.acroField.hasFlag(AcroTextFlags.FileSelect);
      };
      PDFTextField2.prototype.enableFileSelection = function() {
        this.acroField.setFlagTo(AcroTextFlags.FileSelect, true);
      };
      PDFTextField2.prototype.disableFileSelection = function() {
        this.acroField.setFlagTo(AcroTextFlags.FileSelect, false);
      };
      PDFTextField2.prototype.isSpellChecked = function() {
        return !this.acroField.hasFlag(AcroTextFlags.DoNotSpellCheck);
      };
      PDFTextField2.prototype.enableSpellChecking = function() {
        this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, false);
      };
      PDFTextField2.prototype.disableSpellChecking = function() {
        this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, true);
      };
      PDFTextField2.prototype.isScrollable = function() {
        return !this.acroField.hasFlag(AcroTextFlags.DoNotScroll);
      };
      PDFTextField2.prototype.enableScrolling = function() {
        this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, false);
      };
      PDFTextField2.prototype.disableScrolling = function() {
        this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, true);
      };
      PDFTextField2.prototype.isCombed = function() {
        return this.acroField.hasFlag(AcroTextFlags.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && this.getMaxLength() !== void 0;
      };
      PDFTextField2.prototype.enableCombing = function() {
        if (this.getMaxLength() === void 0) {
          var msg = "PDFTextFields must have a max length in order to be combed";
          console.warn(msg);
        }
        this.markAsDirty();
        this.disableMultiline();
        this.disablePassword();
        this.disableFileSelection();
        this.acroField.setFlagTo(AcroTextFlags.Comb, true);
      };
      PDFTextField2.prototype.disableCombing = function() {
        this.markAsDirty();
        this.acroField.setFlagTo(AcroTextFlags.Comb, false);
      };
      PDFTextField2.prototype.isRichFormatted = function() {
        return this.acroField.hasFlag(AcroTextFlags.RichText);
      };
      PDFTextField2.prototype.enableRichFormatting = function() {
        this.acroField.setFlagTo(AcroTextFlags.RichText, true);
      };
      PDFTextField2.prototype.disableRichFormatting = function() {
        this.acroField.setFlagTo(AcroTextFlags.RichText, false);
      };
      PDFTextField2.prototype.addToPage = function(page, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
        assertFieldAppearanceOptions(options);
        if (!options)
          options = {};
        if (!("textColor" in options))
          options.textColor = rgb(0, 0, 0);
        if (!("backgroundColor" in options))
          options.backgroundColor = rgb(1, 1, 1);
        if (!("borderColor" in options))
          options.borderColor = rgb(0, 0, 0);
        if (!("borderWidth" in options))
          options.borderWidth = 1;
        var widget = this.createWidget({
          x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
          width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
          height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
          textColor: options.textColor,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
          rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),
          hidden: options.hidden,
          page: page.ref
        });
        var widgetRef = this.doc.context.register(widget.dict);
        this.acroField.addWidget(widgetRef);
        var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
        this.updateWidgetAppearance(widget, font);
        page.node.addAnnot(widgetRef);
      };
      PDFTextField2.prototype.needsAppearancesUpdate = function() {
        var _a;
        if (this.isDirty())
          return true;
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream_default;
          if (!hasAppearances)
            return true;
        }
        return false;
      };
      PDFTextField2.prototype.defaultUpdateAppearances = function(font) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        this.updateAppearances(font);
      };
      PDFTextField2.prototype.updateAppearances = function(font, provider) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        assertOrUndefined(provider, "provider", [Function]);
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          this.updateWidgetAppearance(widget, font, provider);
        }
        this.markAsClean();
      };
      PDFTextField2.prototype.updateWidgetAppearance = function(widget, font, provider) {
        var apProvider = provider !== null && provider !== void 0 ? provider : defaultTextFieldAppearanceProvider;
        var appearances = normalizeAppearance(apProvider(this, widget, font));
        this.updateWidgetAppearanceWithFont(widget, font, appearances);
      };
      PDFTextField2.of = function(acroText, ref, doc) {
        return new PDFTextField2(acroText, ref, doc);
      };
      return PDFTextField2;
    }(PDFField_default)
  );
  var PDFTextField_default = PDFTextField;

  // node_modules/@pdfme/pdf-lib/es/api/StandardFonts.js
  var StandardFonts;
  (function(StandardFonts2) {
    StandardFonts2["Courier"] = "Courier";
    StandardFonts2["CourierBold"] = "Courier-Bold";
    StandardFonts2["CourierOblique"] = "Courier-Oblique";
    StandardFonts2["CourierBoldOblique"] = "Courier-BoldOblique";
    StandardFonts2["Helvetica"] = "Helvetica";
    StandardFonts2["HelveticaBold"] = "Helvetica-Bold";
    StandardFonts2["HelveticaOblique"] = "Helvetica-Oblique";
    StandardFonts2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
    StandardFonts2["TimesRoman"] = "Times-Roman";
    StandardFonts2["TimesRomanBold"] = "Times-Bold";
    StandardFonts2["TimesRomanItalic"] = "Times-Italic";
    StandardFonts2["TimesRomanBoldItalic"] = "Times-BoldItalic";
    StandardFonts2["Symbol"] = "Symbol";
    StandardFonts2["ZapfDingbats"] = "ZapfDingbats";
  })(StandardFonts || (StandardFonts = {}));

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFForm.js
  var PDFForm = (
    /** @class */
    function() {
      function PDFForm2(acroForm, doc) {
        var _this = this;
        this.embedDefaultFont = function() {
          return _this.doc.embedStandardFont(StandardFonts.Helvetica);
        };
        assertIs(acroForm, "acroForm", [[PDFAcroForm_default, "PDFAcroForm"]]);
        assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
        this.acroForm = acroForm;
        this.doc = doc;
        this.dirtyFields = /* @__PURE__ */ new Set();
        this.defaultFontCache = Cache_default.populatedBy(this.embedDefaultFont);
      }
      PDFForm2.prototype.hasXFA = function() {
        return this.acroForm.dict.has(PDFName_default.of("XFA"));
      };
      PDFForm2.prototype.deleteXFA = function() {
        this.acroForm.dict.delete(PDFName_default.of("XFA"));
      };
      PDFForm2.prototype.getFields = function() {
        var allFields = this.acroForm.getAllFields();
        var fields = [];
        for (var idx = 0, len = allFields.length; idx < len; idx++) {
          var _a = allFields[idx], acroField = _a[0], ref = _a[1];
          var field = convertToPDFField(acroField, ref, this.doc);
          if (field)
            fields.push(field);
        }
        return fields;
      };
      PDFForm2.prototype.getFieldMaybe = function(name) {
        assertIs(name, "name", ["string"]);
        var fields = this.getFields();
        for (var idx = 0, len = fields.length; idx < len; idx++) {
          var field = fields[idx];
          if (field.getName() === name)
            return field;
        }
        return void 0;
      };
      PDFForm2.prototype.getField = function(name) {
        assertIs(name, "name", ["string"]);
        var field = this.getFieldMaybe(name);
        if (field)
          return field;
        throw new NoSuchFieldError(name);
      };
      PDFForm2.prototype.getButton = function(name) {
        assertIs(name, "name", ["string"]);
        var field = this.getField(name);
        if (field instanceof PDFButton_default)
          return field;
        throw new UnexpectedFieldTypeError(name, PDFButton_default, field);
      };
      PDFForm2.prototype.getCheckBox = function(name) {
        assertIs(name, "name", ["string"]);
        var field = this.getField(name);
        if (field instanceof PDFCheckBox_default)
          return field;
        throw new UnexpectedFieldTypeError(name, PDFCheckBox_default, field);
      };
      PDFForm2.prototype.getDropdown = function(name) {
        assertIs(name, "name", ["string"]);
        var field = this.getField(name);
        if (field instanceof PDFDropdown_default)
          return field;
        throw new UnexpectedFieldTypeError(name, PDFDropdown_default, field);
      };
      PDFForm2.prototype.getOptionList = function(name) {
        assertIs(name, "name", ["string"]);
        var field = this.getField(name);
        if (field instanceof PDFOptionList_default)
          return field;
        throw new UnexpectedFieldTypeError(name, PDFOptionList_default, field);
      };
      PDFForm2.prototype.getRadioGroup = function(name) {
        assertIs(name, "name", ["string"]);
        var field = this.getField(name);
        if (field instanceof PDFRadioGroup_default)
          return field;
        throw new UnexpectedFieldTypeError(name, PDFRadioGroup_default, field);
      };
      PDFForm2.prototype.getSignature = function(name) {
        assertIs(name, "name", ["string"]);
        var field = this.getField(name);
        if (field instanceof PDFSignature_default)
          return field;
        throw new UnexpectedFieldTypeError(name, PDFSignature_default, field);
      };
      PDFForm2.prototype.getTextField = function(name) {
        assertIs(name, "name", ["string"]);
        var field = this.getField(name);
        if (field instanceof PDFTextField_default)
          return field;
        throw new UnexpectedFieldTypeError(name, PDFTextField_default, field);
      };
      PDFForm2.prototype.createButton = function(name) {
        assertIs(name, "name", ["string"]);
        var nameParts = splitFieldName(name);
        var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
        var button = PDFAcroPushButton_default.create(this.doc.context);
        button.setPartialName(nameParts.terminal);
        addFieldToParent(parent, [button, button.ref], nameParts.terminal);
        return PDFButton_default.of(button, button.ref, this.doc);
      };
      PDFForm2.prototype.createCheckBox = function(name) {
        assertIs(name, "name", ["string"]);
        var nameParts = splitFieldName(name);
        var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
        var checkBox = PDFAcroCheckBox_default.create(this.doc.context);
        checkBox.setPartialName(nameParts.terminal);
        addFieldToParent(parent, [checkBox, checkBox.ref], nameParts.terminal);
        return PDFCheckBox_default.of(checkBox, checkBox.ref, this.doc);
      };
      PDFForm2.prototype.createDropdown = function(name) {
        assertIs(name, "name", ["string"]);
        var nameParts = splitFieldName(name);
        var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
        var comboBox = PDFAcroComboBox_default.create(this.doc.context);
        comboBox.setPartialName(nameParts.terminal);
        addFieldToParent(parent, [comboBox, comboBox.ref], nameParts.terminal);
        return PDFDropdown_default.of(comboBox, comboBox.ref, this.doc);
      };
      PDFForm2.prototype.createOptionList = function(name) {
        assertIs(name, "name", ["string"]);
        var nameParts = splitFieldName(name);
        var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
        var listBox = PDFAcroListBox_default.create(this.doc.context);
        listBox.setPartialName(nameParts.terminal);
        addFieldToParent(parent, [listBox, listBox.ref], nameParts.terminal);
        return PDFOptionList_default.of(listBox, listBox.ref, this.doc);
      };
      PDFForm2.prototype.createRadioGroup = function(name) {
        assertIs(name, "name", ["string"]);
        var nameParts = splitFieldName(name);
        var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
        var radioButton = PDFAcroRadioButton_default.create(this.doc.context);
        radioButton.setPartialName(nameParts.terminal);
        addFieldToParent(parent, [radioButton, radioButton.ref], nameParts.terminal);
        return PDFRadioGroup_default.of(radioButton, radioButton.ref, this.doc);
      };
      PDFForm2.prototype.createTextField = function(name) {
        assertIs(name, "name", ["string"]);
        var nameParts = splitFieldName(name);
        var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
        var text = PDFAcroText_default.create(this.doc.context);
        text.setPartialName(nameParts.terminal);
        addFieldToParent(parent, [text, text.ref], nameParts.terminal);
        return PDFTextField_default.of(text, text.ref, this.doc);
      };
      PDFForm2.prototype.flatten = function(options) {
        if (options === void 0) {
          options = { updateFieldAppearances: true };
        }
        if (options.updateFieldAppearances) {
          this.updateFieldAppearances();
        }
        var fields = this.getFields();
        for (var i = 0, lenFields = fields.length; i < lenFields; i++) {
          var field = fields[i];
          var widgets = field.acroField.getWidgets();
          for (var j = 0, lenWidgets = widgets.length; j < lenWidgets; j++) {
            var widget = widgets[j];
            var page = this.findWidgetPage(widget);
            var widgetRef = this.findWidgetAppearanceRef(field, widget);
            var xObjectKey = page.node.newXObject("FlatWidget", widgetRef);
            var rectangle2 = widget.getRectangle();
            var operators = __spreadArrays([
              pushGraphicsState(),
              translate(rectangle2.x, rectangle2.y)
            ], rotateInPlace(__assign(__assign({}, rectangle2), { rotation: 0 })), [
              drawObject(xObjectKey),
              popGraphicsState()
            ]).filter(Boolean);
            page.pushOperators.apply(page, operators);
          }
          this.removeField(field);
        }
      };
      PDFForm2.prototype.removeField = function(field) {
        var widgets = field.acroField.getWidgets();
        var pages = /* @__PURE__ */ new Set();
        for (var i = 0, len = widgets.length; i < len; i++) {
          var widget = widgets[i];
          var widgetRef = this.findWidgetAppearanceRef(field, widget);
          var page = this.findWidgetPage(widget);
          pages.add(page);
          page.node.removeAnnot(widgetRef);
        }
        pages.forEach(function(page2) {
          return page2.node.removeAnnot(field.ref);
        });
        this.acroForm.removeField(field.acroField);
        var fieldKids = field.acroField.normalizedEntries().Kids;
        var kidsCount = fieldKids.size();
        for (var childIndex = 0; childIndex < kidsCount; childIndex++) {
          var child = fieldKids.get(childIndex);
          if (child instanceof PDFRef_default) {
            this.doc.context.delete(child);
          }
        }
        this.doc.context.delete(field.ref);
      };
      PDFForm2.prototype.updateFieldAppearances = function(font) {
        assertOrUndefined(font, "font", [[PDFFont_default, "PDFFont"]]);
        font = font !== null && font !== void 0 ? font : this.getDefaultFont();
        var fields = this.getFields();
        for (var idx = 0, len = fields.length; idx < len; idx++) {
          var field = fields[idx];
          if (field.needsAppearancesUpdate()) {
            field.defaultUpdateAppearances(font);
          }
        }
      };
      PDFForm2.prototype.markFieldAsDirty = function(fieldRef) {
        assertOrUndefined(fieldRef, "fieldRef", [[PDFRef_default, "PDFRef"]]);
        this.dirtyFields.add(fieldRef);
      };
      PDFForm2.prototype.markFieldAsClean = function(fieldRef) {
        assertOrUndefined(fieldRef, "fieldRef", [[PDFRef_default, "PDFRef"]]);
        this.dirtyFields.delete(fieldRef);
      };
      PDFForm2.prototype.fieldIsDirty = function(fieldRef) {
        assertOrUndefined(fieldRef, "fieldRef", [[PDFRef_default, "PDFRef"]]);
        return this.dirtyFields.has(fieldRef);
      };
      PDFForm2.prototype.getDefaultFont = function() {
        return this.defaultFontCache.access();
      };
      PDFForm2.prototype.findWidgetPage = function(widget) {
        var pageRef = widget.P();
        var page = this.doc.getPages().find(function(x) {
          return x.ref === pageRef;
        });
        if (page === void 0) {
          var widgetRef = this.doc.context.getObjectRef(widget.dict);
          if (widgetRef === void 0) {
            throw new Error("Could not find PDFRef for PDFObject");
          }
          page = this.doc.findPageForAnnotationRef(widgetRef);
          if (page === void 0) {
            throw new Error("Could not find page for PDFRef " + widgetRef);
          }
        }
        return page;
      };
      PDFForm2.prototype.findWidgetAppearanceRef = function(field, widget) {
        var _a;
        var refOrDict = widget.getNormalAppearance();
        if (refOrDict instanceof PDFDict_default && (field instanceof PDFCheckBox_default || field instanceof PDFRadioGroup_default)) {
          var value = field.acroField.getValue();
          var ref = (_a = refOrDict.get(value)) !== null && _a !== void 0 ? _a : refOrDict.get(PDFName_default.of("Off"));
          if (ref instanceof PDFRef_default) {
            refOrDict = ref;
          }
        }
        if (!(refOrDict instanceof PDFRef_default)) {
          var name_1 = field.getName();
          throw new Error("Failed to extract appearance ref for: " + name_1);
        }
        return refOrDict;
      };
      PDFForm2.prototype.findOrCreateNonTerminals = function(partialNames) {
        var nonTerminal = [
          this.acroForm
        ];
        for (var idx = 0, len = partialNames.length; idx < len; idx++) {
          var namePart = partialNames[idx];
          if (!namePart)
            throw new InvalidFieldNamePartError(namePart);
          var parent_1 = nonTerminal[0], parentRef = nonTerminal[1];
          var res = this.findNonTerminal(namePart, parent_1);
          if (res) {
            nonTerminal = res;
          } else {
            var node = PDFAcroNonTerminal_default.create(this.doc.context);
            node.setPartialName(namePart);
            node.setParent(parentRef);
            var nodeRef = this.doc.context.register(node.dict);
            parent_1.addField(nodeRef);
            nonTerminal = [node, nodeRef];
          }
        }
        return nonTerminal;
      };
      PDFForm2.prototype.findNonTerminal = function(partialName, parent) {
        var fields = parent instanceof PDFAcroForm_default ? this.acroForm.getFields() : createPDFAcroFields(parent.Kids());
        for (var idx = 0, len = fields.length; idx < len; idx++) {
          var _a = fields[idx], field = _a[0], ref = _a[1];
          if (field.getPartialName() === partialName) {
            if (field instanceof PDFAcroNonTerminal_default)
              return [field, ref];
            throw new FieldAlreadyExistsError(partialName);
          }
        }
        return void 0;
      };
      PDFForm2.of = function(acroForm, doc) {
        return new PDFForm2(acroForm, doc);
      };
      return PDFForm2;
    }()
  );
  var PDFForm_default = PDFForm;
  var convertToPDFField = function(field, ref, doc) {
    if (field instanceof PDFAcroPushButton_default)
      return PDFButton_default.of(field, ref, doc);
    if (field instanceof PDFAcroCheckBox_default)
      return PDFCheckBox_default.of(field, ref, doc);
    if (field instanceof PDFAcroComboBox_default)
      return PDFDropdown_default.of(field, ref, doc);
    if (field instanceof PDFAcroListBox_default)
      return PDFOptionList_default.of(field, ref, doc);
    if (field instanceof PDFAcroText_default)
      return PDFTextField_default.of(field, ref, doc);
    if (field instanceof PDFAcroRadioButton_default) {
      return PDFRadioGroup_default.of(field, ref, doc);
    }
    if (field instanceof PDFAcroSignature_default) {
      return PDFSignature_default.of(field, ref, doc);
    }
    return void 0;
  };
  var splitFieldName = function(fullyQualifiedName) {
    if (fullyQualifiedName.length === 0) {
      throw new Error("PDF field names must not be empty strings");
    }
    var parts = fullyQualifiedName.split(".");
    for (var idx = 0, len = parts.length; idx < len; idx++) {
      if (parts[idx] === "") {
        throw new Error('Periods in PDF field names must be separated by at least one character: "' + fullyQualifiedName + '"');
      }
    }
    if (parts.length === 1)
      return { nonTerminal: [], terminal: parts[0] };
    return {
      nonTerminal: parts.slice(0, parts.length - 1),
      terminal: parts[parts.length - 1]
    };
  };
  var addFieldToParent = function(_a, _b, partialName) {
    var parent = _a[0], parentRef = _a[1];
    var field = _b[0], fieldRef = _b[1];
    var entries = parent.normalizedEntries();
    var fields = createPDFAcroFields("Kids" in entries ? entries.Kids : entries.Fields);
    for (var idx = 0, len = fields.length; idx < len; idx++) {
      if (fields[idx][0].getPartialName() === partialName) {
        throw new FieldAlreadyExistsError(partialName);
      }
    }
    parent.addField(fieldRef);
    field.setParent(parentRef);
  };

  // node_modules/@pdfme/pdf-lib/es/api/sizes.js
  var PageSizes = {
    "4A0": [4767.87, 6740.79],
    "2A0": [3370.39, 4767.87],
    A0: [2383.94, 3370.39],
    A1: [1683.78, 2383.94],
    A2: [1190.55, 1683.78],
    A3: [841.89, 1190.55],
    A4: [595.28, 841.89],
    A5: [419.53, 595.28],
    A6: [297.64, 419.53],
    A7: [209.76, 297.64],
    A8: [147.4, 209.76],
    A9: [104.88, 147.4],
    A10: [73.7, 104.88],
    B0: [2834.65, 4008.19],
    B1: [2004.09, 2834.65],
    B2: [1417.32, 2004.09],
    B3: [1000.63, 1417.32],
    B4: [708.66, 1000.63],
    B5: [498.9, 708.66],
    B6: [354.33, 498.9],
    B7: [249.45, 354.33],
    B8: [175.75, 249.45],
    B9: [124.72, 175.75],
    B10: [87.87, 124.72],
    C0: [2599.37, 3676.54],
    C1: [1836.85, 2599.37],
    C2: [1298.27, 1836.85],
    C3: [918.43, 1298.27],
    C4: [649.13, 918.43],
    C5: [459.21, 649.13],
    C6: [323.15, 459.21],
    C7: [229.61, 323.15],
    C8: [161.57, 229.61],
    C9: [113.39, 161.57],
    C10: [79.37, 113.39],
    RA0: [2437.8, 3458.27],
    RA1: [1729.13, 2437.8],
    RA2: [1218.9, 1729.13],
    RA3: [864.57, 1218.9],
    RA4: [609.45, 864.57],
    SRA0: [2551.18, 3628.35],
    SRA1: [1814.17, 2551.18],
    SRA2: [1275.59, 1814.17],
    SRA3: [907.09, 1275.59],
    SRA4: [637.8, 907.09],
    Executive: [521.86, 756],
    Folio: [612, 936],
    Legal: [612, 1008],
    Letter: [612, 792],
    Tabloid: [792, 1224]
  };

  // node_modules/@pdfme/pdf-lib/es/api/PDFDocumentOptions.js
  var ParseSpeeds;
  (function(ParseSpeeds2) {
    ParseSpeeds2[ParseSpeeds2["Fastest"] = Infinity] = "Fastest";
    ParseSpeeds2[ParseSpeeds2["Fast"] = 1500] = "Fast";
    ParseSpeeds2[ParseSpeeds2["Medium"] = 500] = "Medium";
    ParseSpeeds2[ParseSpeeds2["Slow"] = 100] = "Slow";
  })(ParseSpeeds || (ParseSpeeds = {}));

  // node_modules/@pdfme/pdf-lib/es/api/PDFEmbeddedFile.js
  var PDFEmbeddedFile = (
    /** @class */
    function() {
      function PDFEmbeddedFile2(ref, doc, embedder) {
        this.alreadyEmbedded = false;
        this.ref = ref;
        this.doc = doc;
        this.embedder = embedder;
      }
      PDFEmbeddedFile2.prototype.embed = function() {
        return __awaiter(this, void 0, void 0, function() {
          var ref, Names, EmbeddedFiles, EFNames, AF;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!this.alreadyEmbedded)
                  return [3, 2];
                return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
              case 1:
                ref = _a.sent();
                if (!this.doc.catalog.has(PDFName_default.of("Names"))) {
                  this.doc.catalog.set(PDFName_default.of("Names"), this.doc.context.obj({}));
                }
                Names = this.doc.catalog.lookup(PDFName_default.of("Names"), PDFDict_default);
                if (!Names.has(PDFName_default.of("EmbeddedFiles"))) {
                  Names.set(PDFName_default.of("EmbeddedFiles"), this.doc.context.obj({}));
                }
                EmbeddedFiles = Names.lookup(PDFName_default.of("EmbeddedFiles"), PDFDict_default);
                if (!EmbeddedFiles.has(PDFName_default.of("Names"))) {
                  EmbeddedFiles.set(PDFName_default.of("Names"), this.doc.context.obj([]));
                }
                EFNames = EmbeddedFiles.lookup(PDFName_default.of("Names"), PDFArray_default);
                EFNames.push(PDFHexString_default.fromText(this.embedder.fileName));
                EFNames.push(ref);
                if (!this.doc.catalog.has(PDFName_default.of("AF"))) {
                  this.doc.catalog.set(PDFName_default.of("AF"), this.doc.context.obj([]));
                }
                AF = this.doc.catalog.lookup(PDFName_default.of("AF"), PDFArray_default);
                AF.push(ref);
                this.alreadyEmbedded = true;
                _a.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFEmbeddedFile2.of = function(ref, doc, embedder) {
        return new PDFEmbeddedFile2(ref, doc, embedder);
      };
      return PDFEmbeddedFile2;
    }()
  );
  var PDFEmbeddedFile_default = PDFEmbeddedFile;

  // node_modules/@pdfme/pdf-lib/es/api/PDFJavaScript.js
  var PDFJavaScript = (
    /** @class */
    function() {
      function PDFJavaScript2(ref, doc, embedder) {
        this.alreadyEmbedded = false;
        this.ref = ref;
        this.doc = doc;
        this.embedder = embedder;
      }
      PDFJavaScript2.prototype.embed = function() {
        return __awaiter(this, void 0, void 0, function() {
          var _a, catalog, context, ref, Names, Javascript, JSNames;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!!this.alreadyEmbedded)
                  return [3, 2];
                _a = this.doc, catalog = _a.catalog, context = _a.context;
                return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
              case 1:
                ref = _b.sent();
                if (!catalog.has(PDFName_default.of("Names"))) {
                  catalog.set(PDFName_default.of("Names"), context.obj({}));
                }
                Names = catalog.lookup(PDFName_default.of("Names"), PDFDict_default);
                if (!Names.has(PDFName_default.of("JavaScript"))) {
                  Names.set(PDFName_default.of("JavaScript"), context.obj({}));
                }
                Javascript = Names.lookup(PDFName_default.of("JavaScript"), PDFDict_default);
                if (!Javascript.has(PDFName_default.of("Names"))) {
                  Javascript.set(PDFName_default.of("Names"), context.obj([]));
                }
                JSNames = Javascript.lookup(PDFName_default.of("Names"), PDFArray_default);
                JSNames.push(PDFHexString_default.fromText(this.embedder.scriptName));
                JSNames.push(ref);
                this.alreadyEmbedded = true;
                _b.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFJavaScript2.of = function(ref, doc, embedder) {
        return new PDFJavaScript2(ref, doc, embedder);
      };
      return PDFJavaScript2;
    }()
  );
  var PDFJavaScript_default = PDFJavaScript;

  // node_modules/@pdfme/pdf-lib/es/core/embedders/JavaScriptEmbedder.js
  var JavaScriptEmbedder = (
    /** @class */
    function() {
      function JavaScriptEmbedder2(script, scriptName) {
        this.script = script;
        this.scriptName = scriptName;
      }
      JavaScriptEmbedder2.for = function(script, scriptName) {
        return new JavaScriptEmbedder2(script, scriptName);
      };
      JavaScriptEmbedder2.prototype.embedIntoContext = function(context, ref) {
        return __awaiter(this, void 0, void 0, function() {
          var jsActionDict;
          return __generator(this, function(_a) {
            jsActionDict = context.obj({
              Type: "Action",
              S: "JavaScript",
              JS: PDFHexString_default.fromText(this.script)
            });
            if (ref) {
              context.assign(ref, jsActionDict);
              return [2, ref];
            } else {
              return [2, context.register(jsActionDict)];
            }
            return [
              2
              /*return*/
            ];
          });
        });
      };
      return JavaScriptEmbedder2;
    }()
  );
  var JavaScriptEmbedder_default = JavaScriptEmbedder;

  // node_modules/@pdfme/pdf-lib/es/api/PDFDocument.js
  var PDFDocument = (
    /** @class */
    function() {
      function PDFDocument2(context, ignoreEncryption, updateMetadata) {
        var _this = this;
        this.defaultWordBreaks = [" "];
        this.computePages = function() {
          var pages = [];
          _this.catalog.Pages().traverse(function(node, ref) {
            if (node instanceof PDFPageLeaf_default) {
              var page = _this.pageMap.get(node);
              if (!page) {
                page = PDFPage_default.of(node, ref, _this);
                _this.pageMap.set(node, page);
              }
              pages.push(page);
            }
          });
          return pages;
        };
        this.getOrCreateForm = function() {
          var acroForm = _this.catalog.getOrCreateAcroForm();
          return PDFForm_default.of(acroForm, _this);
        };
        assertIs(context, "context", [[PDFContext_default, "PDFContext"]]);
        assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
        this.context = context;
        this.catalog = context.lookup(context.trailerInfo.Root);
        this.isEncrypted = !!context.lookup(context.trailerInfo.Encrypt);
        this.pageCache = Cache_default.populatedBy(this.computePages);
        this.pageMap = /* @__PURE__ */ new Map();
        this.formCache = Cache_default.populatedBy(this.getOrCreateForm);
        this.fonts = [];
        this.images = [];
        this.embeddedPages = [];
        this.embeddedFiles = [];
        this.javaScripts = [];
        if (!ignoreEncryption && this.isEncrypted)
          throw new EncryptedPDFError();
        if (updateMetadata)
          this.updateInfoDict();
      }
      PDFDocument2.load = function(pdf, options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var _a, ignoreEncryption, _b, parseSpeed, _c, throwOnInvalidObject, _d, updateMetadata, _e, capNumbers, bytes, context;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                _a = options.ignoreEncryption, ignoreEncryption = _a === void 0 ? false : _a, _b = options.parseSpeed, parseSpeed = _b === void 0 ? ParseSpeeds.Slow : _b, _c = options.throwOnInvalidObject, throwOnInvalidObject = _c === void 0 ? false : _c, _d = options.updateMetadata, updateMetadata = _d === void 0 ? true : _d, _e = options.capNumbers, capNumbers = _e === void 0 ? false : _e;
                assertIs(pdf, "pdf", ["string", Uint8Array, ArrayBuffer]);
                assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
                assertIs(parseSpeed, "parseSpeed", ["number"]);
                assertIs(throwOnInvalidObject, "throwOnInvalidObject", ["boolean"]);
                bytes = toUint8Array(pdf);
                return [4, PDFParser_default.forBytesWithOptions(bytes, parseSpeed, throwOnInvalidObject, capNumbers).parseDocument()];
              case 1:
                context = _f.sent();
                return [2, new PDFDocument2(context, ignoreEncryption, updateMetadata)];
            }
          });
        });
      };
      PDFDocument2.create = function(options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var _a, updateMetadata, context, pageTree, pageTreeRef, catalog;
          return __generator(this, function(_b) {
            _a = options.updateMetadata, updateMetadata = _a === void 0 ? true : _a;
            context = PDFContext_default.create();
            pageTree = PDFPageTree_default.withContext(context);
            pageTreeRef = context.register(pageTree);
            catalog = PDFCatalog_default.withContextAndPages(context, pageTreeRef);
            context.trailerInfo.Root = context.register(catalog);
            return [2, new PDFDocument2(context, false, updateMetadata)];
          });
        });
      };
      PDFDocument2.prototype.registerFontkit = function(fontkit) {
        this.fontkit = fontkit;
      };
      PDFDocument2.prototype.getForm = function() {
        var form = this.formCache.access();
        if (form.hasXFA()) {
          console.warn("Removing XFA form data as pdf-lib does not support reading or writing XFA");
          form.deleteXFA();
        }
        return form;
      };
      PDFDocument2.prototype.getTitle = function() {
        var title = this.getInfoDict().lookup(PDFName_default.Title);
        if (!title)
          return void 0;
        assertIsLiteralOrHexString(title);
        return title.decodeText();
      };
      PDFDocument2.prototype.getAuthor = function() {
        var author = this.getInfoDict().lookup(PDFName_default.Author);
        if (!author)
          return void 0;
        assertIsLiteralOrHexString(author);
        return author.decodeText();
      };
      PDFDocument2.prototype.getSubject = function() {
        var subject = this.getInfoDict().lookup(PDFName_default.Subject);
        if (!subject)
          return void 0;
        assertIsLiteralOrHexString(subject);
        return subject.decodeText();
      };
      PDFDocument2.prototype.getKeywords = function() {
        var keywords = this.getInfoDict().lookup(PDFName_default.Keywords);
        if (!keywords)
          return void 0;
        assertIsLiteralOrHexString(keywords);
        return keywords.decodeText();
      };
      PDFDocument2.prototype.getCreator = function() {
        var creator = this.getInfoDict().lookup(PDFName_default.Creator);
        if (!creator)
          return void 0;
        assertIsLiteralOrHexString(creator);
        return creator.decodeText();
      };
      PDFDocument2.prototype.getProducer = function() {
        var producer = this.getInfoDict().lookup(PDFName_default.Producer);
        if (!producer)
          return void 0;
        assertIsLiteralOrHexString(producer);
        return producer.decodeText();
      };
      PDFDocument2.prototype.getCreationDate = function() {
        var creationDate = this.getInfoDict().lookup(PDFName_default.CreationDate);
        if (!creationDate)
          return void 0;
        assertIsLiteralOrHexString(creationDate);
        return creationDate.decodeDate();
      };
      PDFDocument2.prototype.getModificationDate = function() {
        var modificationDate = this.getInfoDict().lookup(PDFName_default.ModDate);
        if (!modificationDate)
          return void 0;
        assertIsLiteralOrHexString(modificationDate);
        return modificationDate.decodeDate();
      };
      PDFDocument2.prototype.setTitle = function(title, options) {
        assertIs(title, "title", ["string"]);
        var key = PDFName_default.of("Title");
        this.getInfoDict().set(key, PDFHexString_default.fromText(title));
        if (options === null || options === void 0 ? void 0 : options.showInWindowTitleBar) {
          var prefs = this.catalog.getOrCreateViewerPreferences();
          prefs.setDisplayDocTitle(true);
        }
      };
      PDFDocument2.prototype.setAuthor = function(author) {
        assertIs(author, "author", ["string"]);
        var key = PDFName_default.of("Author");
        this.getInfoDict().set(key, PDFHexString_default.fromText(author));
      };
      PDFDocument2.prototype.setSubject = function(subject) {
        assertIs(subject, "author", ["string"]);
        var key = PDFName_default.of("Subject");
        this.getInfoDict().set(key, PDFHexString_default.fromText(subject));
      };
      PDFDocument2.prototype.setKeywords = function(keywords) {
        assertIs(keywords, "keywords", [Array]);
        var key = PDFName_default.of("Keywords");
        this.getInfoDict().set(key, PDFHexString_default.fromText(keywords.join(" ")));
      };
      PDFDocument2.prototype.setCreator = function(creator) {
        assertIs(creator, "creator", ["string"]);
        var key = PDFName_default.of("Creator");
        this.getInfoDict().set(key, PDFHexString_default.fromText(creator));
      };
      PDFDocument2.prototype.setProducer = function(producer) {
        assertIs(producer, "creator", ["string"]);
        var key = PDFName_default.of("Producer");
        this.getInfoDict().set(key, PDFHexString_default.fromText(producer));
      };
      PDFDocument2.prototype.setLanguage = function(language) {
        assertIs(language, "language", ["string"]);
        var key = PDFName_default.of("Lang");
        this.catalog.set(key, PDFString_default.of(language));
      };
      PDFDocument2.prototype.setCreationDate = function(creationDate) {
        assertIs(creationDate, "creationDate", [[Date, "Date"]]);
        var key = PDFName_default.of("CreationDate");
        this.getInfoDict().set(key, PDFString_default.fromDate(creationDate));
      };
      PDFDocument2.prototype.setModificationDate = function(modificationDate) {
        assertIs(modificationDate, "modificationDate", [[Date, "Date"]]);
        var key = PDFName_default.of("ModDate");
        this.getInfoDict().set(key, PDFString_default.fromDate(modificationDate));
      };
      PDFDocument2.prototype.getPageCount = function() {
        if (this.pageCount === void 0)
          this.pageCount = this.getPages().length;
        return this.pageCount;
      };
      PDFDocument2.prototype.getPages = function() {
        return this.pageCache.access();
      };
      PDFDocument2.prototype.getPage = function(index) {
        var pages = this.getPages();
        assertRange(index, "index", 0, pages.length - 1);
        return pages[index];
      };
      PDFDocument2.prototype.getPageIndices = function() {
        return range(0, this.getPageCount());
      };
      PDFDocument2.prototype.removePage = function(index) {
        var pageCount = this.getPageCount();
        if (this.pageCount === 0)
          throw new RemovePageFromEmptyDocumentError();
        assertRange(index, "index", 0, pageCount - 1);
        this.catalog.removeLeafNode(index);
        this.pageCount = pageCount - 1;
      };
      PDFDocument2.prototype.addPage = function(page) {
        assertIs(page, "page", ["undefined", [PDFPage_default, "PDFPage"], Array]);
        return this.insertPage(this.getPageCount(), page);
      };
      PDFDocument2.prototype.insertPage = function(index, page) {
        var pageCount = this.getPageCount();
        assertRange(index, "index", 0, pageCount);
        assertIs(page, "page", ["undefined", [PDFPage_default, "PDFPage"], Array]);
        if (!page || Array.isArray(page)) {
          var dims = Array.isArray(page) ? page : PageSizes.A4;
          page = PDFPage_default.create(this);
          page.setSize.apply(page, dims);
        } else if (page.doc !== this) {
          throw new ForeignPageError();
        }
        var parentRef = this.catalog.insertLeafNode(page.ref, index);
        page.node.setParent(parentRef);
        this.pageMap.set(page.node, page);
        this.pageCache.invalidate();
        this.pageCount = pageCount + 1;
        return page;
      };
      PDFDocument2.prototype.copyPages = function(srcDoc, indices) {
        return __awaiter(this, void 0, void 0, function() {
          var copier, srcPages, copiedPages, idx, len, srcPage, copiedPage, ref;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                assertIs(srcDoc, "srcDoc", [[PDFDocument2, "PDFDocument"]]);
                assertIs(indices, "indices", [Array]);
                return [4, srcDoc.flush()];
              case 1:
                _a.sent();
                copier = PDFObjectCopier_default.for(srcDoc.context, this.context);
                srcPages = srcDoc.getPages();
                copiedPages = new Array(indices.length);
                for (idx = 0, len = indices.length; idx < len; idx++) {
                  srcPage = srcPages[indices[idx]];
                  copiedPage = copier.copy(srcPage.node);
                  ref = this.context.register(copiedPage);
                  copiedPages[idx] = PDFPage_default.of(copiedPage, ref, this);
                }
                return [2, copiedPages];
            }
          });
        });
      };
      PDFDocument2.prototype.copy = function() {
        return __awaiter(this, void 0, void 0, function() {
          var pdfCopy, contentPages, idx, len;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, PDFDocument2.create()];
              case 1:
                pdfCopy = _a.sent();
                return [4, pdfCopy.copyPages(this, this.getPageIndices())];
              case 2:
                contentPages = _a.sent();
                for (idx = 0, len = contentPages.length; idx < len; idx++) {
                  pdfCopy.addPage(contentPages[idx]);
                }
                if (this.getAuthor() !== void 0) {
                  pdfCopy.setAuthor(this.getAuthor());
                }
                if (this.getCreationDate() !== void 0) {
                  pdfCopy.setCreationDate(this.getCreationDate());
                }
                if (this.getCreator() !== void 0) {
                  pdfCopy.setCreator(this.getCreator());
                }
                if (this.getModificationDate() !== void 0) {
                  pdfCopy.setModificationDate(this.getModificationDate());
                }
                if (this.getProducer() !== void 0) {
                  pdfCopy.setProducer(this.getProducer());
                }
                if (this.getSubject() !== void 0) {
                  pdfCopy.setSubject(this.getSubject());
                }
                if (this.getTitle() !== void 0) {
                  pdfCopy.setTitle(this.getTitle());
                }
                pdfCopy.defaultWordBreaks = this.defaultWordBreaks;
                return [2, pdfCopy];
            }
          });
        });
      };
      PDFDocument2.prototype.addJavaScript = function(name, script) {
        assertIs(name, "name", ["string"]);
        assertIs(script, "script", ["string"]);
        var embedder = JavaScriptEmbedder_default.for(script, name);
        var ref = this.context.nextRef();
        var javaScript = PDFJavaScript_default.of(ref, this, embedder);
        this.javaScripts.push(javaScript);
      };
      PDFDocument2.prototype.attach = function(attachment, name, options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var bytes, embedder, ref, embeddedFile;
          return __generator(this, function(_a) {
            assertIs(attachment, "attachment", ["string", Uint8Array, ArrayBuffer]);
            assertIs(name, "name", ["string"]);
            assertOrUndefined(options.mimeType, "mimeType", ["string"]);
            assertOrUndefined(options.description, "description", ["string"]);
            assertOrUndefined(options.creationDate, "options.creationDate", [Date]);
            assertOrUndefined(options.modificationDate, "options.modificationDate", [
              Date
            ]);
            assertIsOneOfOrUndefined(options.afRelationship, "options.afRelationship", AFRelationship);
            bytes = toUint8Array(attachment);
            embedder = FileEmbedder_default.for(bytes, name, options);
            ref = this.context.nextRef();
            embeddedFile = PDFEmbeddedFile_default.of(ref, this, embedder);
            this.embeddedFiles.push(embeddedFile);
            return [
              2
              /*return*/
            ];
          });
        });
      };
      PDFDocument2.prototype.embedFont = function(font, options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var _a, subset, customName, features, embedder, bytes, fontkit, _b, ref, pdfFont;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                _a = options.subset, subset = _a === void 0 ? false : _a, customName = options.customName, features = options.features;
                assertIs(font, "font", ["string", Uint8Array, ArrayBuffer]);
                assertIs(subset, "subset", ["boolean"]);
                if (!isStandardFont(font))
                  return [3, 1];
                embedder = StandardFontEmbedder_default.for(font, customName);
                return [3, 7];
              case 1:
                if (!canBeConvertedToUint8Array(font))
                  return [3, 6];
                bytes = toUint8Array(font);
                fontkit = this.assertFontkit();
                if (!subset)
                  return [3, 3];
                return [4, CustomFontSubsetEmbedder_default.for(fontkit, bytes, customName, features)];
              case 2:
                _b = _c.sent();
                return [3, 5];
              case 3:
                return [4, CustomFontEmbedder_default.for(fontkit, bytes, customName, features)];
              case 4:
                _b = _c.sent();
                _c.label = 5;
              case 5:
                embedder = _b;
                return [3, 7];
              case 6:
                throw new TypeError("`font` must be one of `StandardFonts | string | Uint8Array | ArrayBuffer`");
              case 7:
                ref = this.context.nextRef();
                pdfFont = PDFFont_default.of(ref, this, embedder);
                this.fonts.push(pdfFont);
                return [2, pdfFont];
            }
          });
        });
      };
      PDFDocument2.prototype.embedStandardFont = function(font, customName) {
        assertIs(font, "font", ["string"]);
        if (!isStandardFont(font)) {
          throw new TypeError("`font` must be one of type `StandardFonts`");
        }
        var embedder = StandardFontEmbedder_default.for(font, customName);
        var ref = this.context.nextRef();
        var pdfFont = PDFFont_default.of(ref, this, embedder);
        this.fonts.push(pdfFont);
        return pdfFont;
      };
      PDFDocument2.prototype.embedJpg = function(jpg) {
        return __awaiter(this, void 0, void 0, function() {
          var bytes, embedder, ref, pdfImage;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                assertIs(jpg, "jpg", ["string", Uint8Array, ArrayBuffer]);
                bytes = toUint8Array(jpg);
                return [4, JpegEmbedder_default.for(bytes)];
              case 1:
                embedder = _a.sent();
                ref = this.context.nextRef();
                pdfImage = PDFImage_default.of(ref, this, embedder);
                this.images.push(pdfImage);
                return [2, pdfImage];
            }
          });
        });
      };
      PDFDocument2.prototype.embedPng = function(png) {
        return __awaiter(this, void 0, void 0, function() {
          var bytes, embedder, ref, pdfImage;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                assertIs(png, "png", ["string", Uint8Array, ArrayBuffer]);
                bytes = toUint8Array(png);
                return [4, PngEmbedder_default.for(bytes)];
              case 1:
                embedder = _a.sent();
                ref = this.context.nextRef();
                pdfImage = PDFImage_default.of(ref, this, embedder);
                this.images.push(pdfImage);
                return [2, pdfImage];
            }
          });
        });
      };
      PDFDocument2.prototype.embedPdf = function(pdf, indices) {
        if (indices === void 0) {
          indices = [0];
        }
        return __awaiter(this, void 0, void 0, function() {
          var srcDoc, _a, srcPages;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                assertIs(pdf, "pdf", [
                  "string",
                  Uint8Array,
                  ArrayBuffer,
                  [PDFDocument2, "PDFDocument"]
                ]);
                assertIs(indices, "indices", [Array]);
                if (!(pdf instanceof PDFDocument2))
                  return [3, 1];
                _a = pdf;
                return [3, 3];
              case 1:
                return [4, PDFDocument2.load(pdf)];
              case 2:
                _a = _b.sent();
                _b.label = 3;
              case 3:
                srcDoc = _a;
                srcPages = pluckIndices(srcDoc.getPages(), indices);
                return [2, this.embedPages(srcPages)];
            }
          });
        });
      };
      PDFDocument2.prototype.embedPage = function(page, boundingBox, transformationMatrix) {
        return __awaiter(this, void 0, void 0, function() {
          var embeddedPage;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                assertIs(page, "page", [[PDFPage_default, "PDFPage"]]);
                return [4, this.embedPages([page], [boundingBox], [transformationMatrix])];
              case 1:
                embeddedPage = _a.sent()[0];
                return [2, embeddedPage];
            }
          });
        });
      };
      PDFDocument2.prototype.embedPages = function(pages, boundingBoxes, transformationMatrices) {
        if (boundingBoxes === void 0) {
          boundingBoxes = [];
        }
        if (transformationMatrices === void 0) {
          transformationMatrices = [];
        }
        return __awaiter(this, void 0, void 0, function() {
          var idx, len, currPage, nextPage, context, maybeCopyPage, embeddedPages, idx, len, page, box, matrix, embedder, ref;
          var _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (pages.length === 0)
                  return [2, []];
                for (idx = 0, len = pages.length - 1; idx < len; idx++) {
                  currPage = pages[idx];
                  nextPage = pages[idx + 1];
                  if (currPage.node.context !== nextPage.node.context) {
                    throw new PageEmbeddingMismatchedContextError();
                  }
                }
                context = pages[0].node.context;
                maybeCopyPage = context === this.context ? function(p) {
                  return p;
                } : PDFObjectCopier_default.for(context, this.context).copy;
                embeddedPages = new Array(pages.length);
                idx = 0, len = pages.length;
                _b.label = 1;
              case 1:
                if (!(idx < len))
                  return [3, 4];
                page = maybeCopyPage(pages[idx].node);
                box = boundingBoxes[idx];
                matrix = transformationMatrices[idx];
                return [4, PDFPageEmbedder_default.for(page, box, matrix)];
              case 2:
                embedder = _b.sent();
                ref = this.context.nextRef();
                embeddedPages[idx] = PDFEmbeddedPage_default.of(ref, this, embedder);
                _b.label = 3;
              case 3:
                idx++;
                return [3, 1];
              case 4:
                (_a = this.embeddedPages).push.apply(_a, embeddedPages);
                return [2, embeddedPages];
            }
          });
        });
      };
      PDFDocument2.prototype.flush = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.embedAll(this.fonts)];
              case 1:
                _a.sent();
                return [4, this.embedAll(this.images)];
              case 2:
                _a.sent();
                return [4, this.embedAll(this.embeddedPages)];
              case 3:
                _a.sent();
                return [4, this.embedAll(this.embeddedFiles)];
              case 4:
                _a.sent();
                return [4, this.embedAll(this.javaScripts)];
              case 5:
                _a.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFDocument2.prototype.save = function(options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var _a, useObjectStreams, _b, addDefaultPage, _c, objectsPerTick, _d, updateFieldAppearances, form, Writer;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                _a = options.useObjectStreams, useObjectStreams = _a === void 0 ? true : _a, _b = options.addDefaultPage, addDefaultPage = _b === void 0 ? true : _b, _c = options.objectsPerTick, objectsPerTick = _c === void 0 ? 50 : _c, _d = options.updateFieldAppearances, updateFieldAppearances = _d === void 0 ? true : _d;
                assertIs(useObjectStreams, "useObjectStreams", ["boolean"]);
                assertIs(addDefaultPage, "addDefaultPage", ["boolean"]);
                assertIs(objectsPerTick, "objectsPerTick", ["number"]);
                assertIs(updateFieldAppearances, "updateFieldAppearances", ["boolean"]);
                if (addDefaultPage && this.getPageCount() === 0)
                  this.addPage();
                if (updateFieldAppearances) {
                  form = this.formCache.getValue();
                  if (form)
                    form.updateFieldAppearances();
                }
                return [4, this.flush()];
              case 1:
                _e.sent();
                Writer = useObjectStreams ? PDFStreamWriter_default : PDFWriter_default;
                return [2, Writer.forContext(this.context, objectsPerTick).serializeToBuffer()];
            }
          });
        });
      };
      PDFDocument2.prototype.saveAsBase64 = function(options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var _a, dataUri, otherOptions, bytes, base64;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a = options.dataUri, dataUri = _a === void 0 ? false : _a, otherOptions = __rest(options, ["dataUri"]);
                assertIs(dataUri, "dataUri", ["boolean"]);
                return [4, this.save(otherOptions)];
              case 1:
                bytes = _b.sent();
                base64 = encodeToBase64(bytes);
                return [2, dataUri ? "data:application/pdf;base64," + base64 : base64];
            }
          });
        });
      };
      PDFDocument2.prototype.findPageForAnnotationRef = function(ref) {
        var pages = this.getPages();
        for (var idx = 0, len = pages.length; idx < len; idx++) {
          var page = pages[idx];
          var annotations = page.node.Annots();
          if ((annotations === null || annotations === void 0 ? void 0 : annotations.indexOf(ref)) !== void 0) {
            return page;
          }
        }
        return void 0;
      };
      PDFDocument2.prototype.embedAll = function(embeddables) {
        return __awaiter(this, void 0, void 0, function() {
          var idx, len;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                idx = 0, len = embeddables.length;
                _a.label = 1;
              case 1:
                if (!(idx < len))
                  return [3, 4];
                return [4, embeddables[idx].embed()];
              case 2:
                _a.sent();
                _a.label = 3;
              case 3:
                idx++;
                return [3, 1];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      PDFDocument2.prototype.updateInfoDict = function() {
        var pdfLib = "pdf-lib (https://github.com/Hopding/pdf-lib)";
        var now = /* @__PURE__ */ new Date();
        var info = this.getInfoDict();
        this.setProducer(pdfLib);
        this.setModificationDate(now);
        if (!info.get(PDFName_default.of("Creator")))
          this.setCreator(pdfLib);
        if (!info.get(PDFName_default.of("CreationDate")))
          this.setCreationDate(now);
      };
      PDFDocument2.prototype.getInfoDict = function() {
        var existingInfo = this.context.lookup(this.context.trailerInfo.Info);
        if (existingInfo instanceof PDFDict_default)
          return existingInfo;
        var newInfo = this.context.obj({});
        this.context.trailerInfo.Info = this.context.register(newInfo);
        return newInfo;
      };
      PDFDocument2.prototype.assertFontkit = function() {
        if (!this.fontkit)
          throw new FontkitNotRegisteredError();
        return this.fontkit;
      };
      return PDFDocument2;
    }()
  );
  var PDFDocument_default = PDFDocument;
  function assertIsLiteralOrHexString(pdfObject) {
    if (!(pdfObject instanceof PDFHexString_default) && !(pdfObject instanceof PDFString_default)) {
      throw new UnexpectedObjectTypeError([PDFHexString_default, PDFString_default], pdfObject);
    }
  }

  // node_modules/@pdfme/pdf-lib/es/api/PDFPageOptions.js
  var BlendMode;
  (function(BlendMode2) {
    BlendMode2["Normal"] = "Normal";
    BlendMode2["Multiply"] = "Multiply";
    BlendMode2["Screen"] = "Screen";
    BlendMode2["Overlay"] = "Overlay";
    BlendMode2["Darken"] = "Darken";
    BlendMode2["Lighten"] = "Lighten";
    BlendMode2["ColorDodge"] = "ColorDodge";
    BlendMode2["ColorBurn"] = "ColorBurn";
    BlendMode2["HardLight"] = "HardLight";
    BlendMode2["SoftLight"] = "SoftLight";
    BlendMode2["Difference"] = "Difference";
    BlendMode2["Exclusion"] = "Exclusion";
  })(BlendMode || (BlendMode = {}));

  // node_modules/@pdfme/pdf-lib/es/api/PDFPage.js
  var PDFPage = (
    /** @class */
    function() {
      function PDFPage2(leafNode, ref, doc) {
        this.fontSize = 24;
        this.fontColor = rgb(0, 0, 0);
        this.lineHeight = 24;
        this.x = 0;
        this.y = 0;
        assertIs(leafNode, "leafNode", [[PDFPageLeaf_default, "PDFPageLeaf"]]);
        assertIs(ref, "ref", [[PDFRef_default, "PDFRef"]]);
        assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
        this.node = leafNode;
        this.ref = ref;
        this.doc = doc;
      }
      PDFPage2.prototype.setRotation = function(angle) {
        var degreesAngle = toDegrees(angle);
        assertMultiple(degreesAngle, "degreesAngle", 90);
        this.node.set(PDFName_default.of("Rotate"), this.doc.context.obj(degreesAngle));
      };
      PDFPage2.prototype.getRotation = function() {
        var Rotate = this.node.Rotate();
        return degrees(Rotate ? Rotate.asNumber() : 0);
      };
      PDFPage2.prototype.setSize = function(width, height) {
        assertIs(width, "width", ["number"]);
        assertIs(height, "height", ["number"]);
        var mediaBox = this.getMediaBox();
        this.setMediaBox(mediaBox.x, mediaBox.y, width, height);
        var cropBox = this.getCropBox();
        var bleedBox = this.getBleedBox();
        var trimBox = this.getTrimBox();
        var artBox = this.getArtBox();
        var hasCropBox = this.node.CropBox();
        var hasBleedBox = this.node.BleedBox();
        var hasTrimBox = this.node.TrimBox();
        var hasArtBox = this.node.ArtBox();
        if (hasCropBox && rectanglesAreEqual(cropBox, mediaBox)) {
          this.setCropBox(mediaBox.x, mediaBox.y, width, height);
        }
        if (hasBleedBox && rectanglesAreEqual(bleedBox, mediaBox)) {
          this.setBleedBox(mediaBox.x, mediaBox.y, width, height);
        }
        if (hasTrimBox && rectanglesAreEqual(trimBox, mediaBox)) {
          this.setTrimBox(mediaBox.x, mediaBox.y, width, height);
        }
        if (hasArtBox && rectanglesAreEqual(artBox, mediaBox)) {
          this.setArtBox(mediaBox.x, mediaBox.y, width, height);
        }
      };
      PDFPage2.prototype.setWidth = function(width) {
        assertIs(width, "width", ["number"]);
        this.setSize(width, this.getSize().height);
      };
      PDFPage2.prototype.setHeight = function(height) {
        assertIs(height, "height", ["number"]);
        this.setSize(this.getSize().width, height);
      };
      PDFPage2.prototype.setMediaBox = function(x, y, width, height) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        assertIs(width, "width", ["number"]);
        assertIs(height, "height", ["number"]);
        var mediaBox = this.doc.context.obj([x, y, x + width, y + height]);
        this.node.set(PDFName_default.MediaBox, mediaBox);
      };
      PDFPage2.prototype.setCropBox = function(x, y, width, height) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        assertIs(width, "width", ["number"]);
        assertIs(height, "height", ["number"]);
        var cropBox = this.doc.context.obj([x, y, x + width, y + height]);
        this.node.set(PDFName_default.CropBox, cropBox);
      };
      PDFPage2.prototype.setBleedBox = function(x, y, width, height) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        assertIs(width, "width", ["number"]);
        assertIs(height, "height", ["number"]);
        var bleedBox = this.doc.context.obj([x, y, x + width, y + height]);
        this.node.set(PDFName_default.BleedBox, bleedBox);
      };
      PDFPage2.prototype.setTrimBox = function(x, y, width, height) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        assertIs(width, "width", ["number"]);
        assertIs(height, "height", ["number"]);
        var trimBox = this.doc.context.obj([x, y, x + width, y + height]);
        this.node.set(PDFName_default.TrimBox, trimBox);
      };
      PDFPage2.prototype.setArtBox = function(x, y, width, height) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        assertIs(width, "width", ["number"]);
        assertIs(height, "height", ["number"]);
        var artBox = this.doc.context.obj([x, y, x + width, y + height]);
        this.node.set(PDFName_default.ArtBox, artBox);
      };
      PDFPage2.prototype.getSize = function() {
        var _a = this.getMediaBox(), width = _a.width, height = _a.height;
        return { width, height };
      };
      PDFPage2.prototype.getWidth = function() {
        return this.getSize().width;
      };
      PDFPage2.prototype.getHeight = function() {
        return this.getSize().height;
      };
      PDFPage2.prototype.getMediaBox = function() {
        var mediaBox = this.node.MediaBox();
        return mediaBox.asRectangle();
      };
      PDFPage2.prototype.getCropBox = function() {
        var _a;
        var cropBox = this.node.CropBox();
        return (_a = cropBox === null || cropBox === void 0 ? void 0 : cropBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getMediaBox();
      };
      PDFPage2.prototype.getBleedBox = function() {
        var _a;
        var bleedBox = this.node.BleedBox();
        return (_a = bleedBox === null || bleedBox === void 0 ? void 0 : bleedBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
      };
      PDFPage2.prototype.getTrimBox = function() {
        var _a;
        var trimBox = this.node.TrimBox();
        return (_a = trimBox === null || trimBox === void 0 ? void 0 : trimBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
      };
      PDFPage2.prototype.getArtBox = function() {
        var _a;
        var artBox = this.node.ArtBox();
        return (_a = artBox === null || artBox === void 0 ? void 0 : artBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
      };
      PDFPage2.prototype.translateContent = function(x, y) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        this.node.normalize();
        this.getContentStream();
        var start = this.createContentStream(pushGraphicsState(), translate(x, y));
        var startRef = this.doc.context.register(start);
        var end = this.createContentStream(popGraphicsState());
        var endRef = this.doc.context.register(end);
        this.node.wrapContentStreams(startRef, endRef);
      };
      PDFPage2.prototype.scale = function(x, y) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        this.setSize(this.getWidth() * x, this.getHeight() * y);
        this.scaleContent(x, y);
        this.scaleAnnotations(x, y);
      };
      PDFPage2.prototype.scaleContent = function(x, y) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        this.node.normalize();
        this.getContentStream();
        var start = this.createContentStream(pushGraphicsState(), scale(x, y));
        var startRef = this.doc.context.register(start);
        var end = this.createContentStream(popGraphicsState());
        var endRef = this.doc.context.register(end);
        this.node.wrapContentStreams(startRef, endRef);
      };
      PDFPage2.prototype.scaleAnnotations = function(x, y) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        var annots = this.node.Annots();
        if (!annots)
          return;
        for (var idx = 0; idx < annots.size(); idx++) {
          var annot = annots.lookup(idx);
          if (annot instanceof PDFDict_default)
            this.scaleAnnot(annot, x, y);
        }
      };
      PDFPage2.prototype.resetPosition = function() {
        this.getContentStream(false);
        this.x = 0;
        this.y = 0;
      };
      PDFPage2.prototype.setFont = function(font) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        this.font = font;
        this.fontKey = this.node.newFontDictionary(this.font.name, this.font.ref);
      };
      PDFPage2.prototype.setFontSize = function(fontSize) {
        assertIs(fontSize, "fontSize", ["number"]);
        this.fontSize = fontSize;
      };
      PDFPage2.prototype.setFontColor = function(fontColor) {
        assertIs(fontColor, "fontColor", [[Object, "Color"]]);
        this.fontColor = fontColor;
      };
      PDFPage2.prototype.setLineHeight = function(lineHeight) {
        assertIs(lineHeight, "lineHeight", ["number"]);
        this.lineHeight = lineHeight;
      };
      PDFPage2.prototype.getPosition = function() {
        return { x: this.x, y: this.y };
      };
      PDFPage2.prototype.getX = function() {
        return this.x;
      };
      PDFPage2.prototype.getY = function() {
        return this.y;
      };
      PDFPage2.prototype.moveTo = function(x, y) {
        assertIs(x, "x", ["number"]);
        assertIs(y, "y", ["number"]);
        this.x = x;
        this.y = y;
      };
      PDFPage2.prototype.moveDown = function(yDecrease) {
        assertIs(yDecrease, "yDecrease", ["number"]);
        this.y -= yDecrease;
      };
      PDFPage2.prototype.moveUp = function(yIncrease) {
        assertIs(yIncrease, "yIncrease", ["number"]);
        this.y += yIncrease;
      };
      PDFPage2.prototype.moveLeft = function(xDecrease) {
        assertIs(xDecrease, "xDecrease", ["number"]);
        this.x -= xDecrease;
      };
      PDFPage2.prototype.moveRight = function(xIncrease) {
        assertIs(xIncrease, "xIncrease", ["number"]);
        this.x += xIncrease;
      };
      PDFPage2.prototype.pushOperators = function() {
        var operator = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operator[_i] = arguments[_i];
        }
        assertEachIs(operator, "operator", [[PDFOperator_default, "PDFOperator"]]);
        var contentStream = this.getContentStream();
        contentStream.push.apply(contentStream, operator);
      };
      PDFPage2.prototype.drawText = function(text, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (options === void 0) {
          options = {};
        }
        assertIs(text, "text", ["string"]);
        assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
        assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
        assertOrUndefined(options.font, "options.font", [[PDFFont_default, "PDFFont"]]);
        assertOrUndefined(options.size, "options.size", ["number"]);
        assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
        assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
        assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
        assertOrUndefined(options.x, "options.x", ["number"]);
        assertOrUndefined(options.y, "options.y", ["number"]);
        assertOrUndefined(options.lineHeight, "options.lineHeight", ["number"]);
        assertOrUndefined(options.maxWidth, "options.maxWidth", ["number"]);
        assertOrUndefined(options.wordBreaks, "options.wordBreaks", [Array]);
        assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
        var _h = this.setOrEmbedFont(options.font), oldFont = _h.oldFont, newFont = _h.newFont, newFontKey = _h.newFontKey;
        var fontSize = options.size || this.fontSize;
        var wordBreaks = options.wordBreaks || this.doc.defaultWordBreaks;
        var textWidth = function(t) {
          return newFont.widthOfTextAtSize(t, fontSize);
        };
        var lines = options.maxWidth === void 0 ? lineSplit(cleanText(text)) : breakTextIntoLines(text, wordBreaks, options.maxWidth, textWidth);
        var encodedLines = new Array(lines.length);
        for (var idx = 0, len = lines.length; idx < len; idx++) {
          encodedLines[idx] = newFont.encodeText(lines[idx]);
        }
        var graphicsStateKey = this.maybeEmbedGraphicsState({
          opacity: options.opacity,
          blendMode: options.blendMode
        });
        var contentStream = this.getContentStream();
        contentStream.push.apply(contentStream, drawLinesOfText(encodedLines, {
          color: (_a = options.color) !== null && _a !== void 0 ? _a : this.fontColor,
          font: newFontKey,
          size: fontSize,
          rotate: (_b = options.rotate) !== null && _b !== void 0 ? _b : degrees(0),
          xSkew: (_c = options.xSkew) !== null && _c !== void 0 ? _c : degrees(0),
          ySkew: (_d = options.ySkew) !== null && _d !== void 0 ? _d : degrees(0),
          x: (_e = options.x) !== null && _e !== void 0 ? _e : this.x,
          y: (_f = options.y) !== null && _f !== void 0 ? _f : this.y,
          lineHeight: (_g = options.lineHeight) !== null && _g !== void 0 ? _g : this.lineHeight,
          graphicsState: graphicsStateKey
        }));
        if (options.font) {
          if (oldFont)
            this.setFont(oldFont);
          else
            this.resetFont();
        }
      };
      PDFPage2.prototype.drawImage = function(image, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (options === void 0) {
          options = {};
        }
        assertIs(image, "image", [[PDFImage_default, "PDFImage"]]);
        assertOrUndefined(options.x, "options.x", ["number"]);
        assertOrUndefined(options.y, "options.y", ["number"]);
        assertOrUndefined(options.width, "options.width", ["number"]);
        assertOrUndefined(options.height, "options.height", ["number"]);
        assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
        assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
        assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
        assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
        assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
        var xObjectKey = this.node.newXObject("Image", image.ref);
        var graphicsStateKey = this.maybeEmbedGraphicsState({
          opacity: options.opacity,
          blendMode: options.blendMode
        });
        var contentStream = this.getContentStream();
        contentStream.push.apply(contentStream, drawImage(xObjectKey, {
          x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
          width: (_c = options.width) !== null && _c !== void 0 ? _c : image.size().width,
          height: (_d = options.height) !== null && _d !== void 0 ? _d : image.size().height,
          rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : degrees(0),
          xSkew: (_f = options.xSkew) !== null && _f !== void 0 ? _f : degrees(0),
          ySkew: (_g = options.ySkew) !== null && _g !== void 0 ? _g : degrees(0),
          graphicsState: graphicsStateKey
        }));
      };
      PDFPage2.prototype.drawPage = function(embeddedPage, options) {
        var _a, _b, _c, _d, _e;
        if (options === void 0) {
          options = {};
        }
        assertIs(embeddedPage, "embeddedPage", [
          [PDFEmbeddedPage_default, "PDFEmbeddedPage"]
        ]);
        assertOrUndefined(options.x, "options.x", ["number"]);
        assertOrUndefined(options.y, "options.y", ["number"]);
        assertOrUndefined(options.xScale, "options.xScale", ["number"]);
        assertOrUndefined(options.yScale, "options.yScale", ["number"]);
        assertOrUndefined(options.width, "options.width", ["number"]);
        assertOrUndefined(options.height, "options.height", ["number"]);
        assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
        assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
        assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
        assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
        assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
        var xObjectKey = this.node.newXObject("EmbeddedPdfPage", embeddedPage.ref);
        var graphicsStateKey = this.maybeEmbedGraphicsState({
          opacity: options.opacity,
          blendMode: options.blendMode
        });
        var xScale = options.width !== void 0 ? options.width / embeddedPage.width : options.xScale !== void 0 ? options.xScale : 1;
        var yScale = options.height !== void 0 ? options.height / embeddedPage.height : options.yScale !== void 0 ? options.yScale : 1;
        var contentStream = this.getContentStream();
        contentStream.push.apply(contentStream, drawPage(xObjectKey, {
          x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
          xScale,
          yScale,
          rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : degrees(0),
          xSkew: (_d = options.xSkew) !== null && _d !== void 0 ? _d : degrees(0),
          ySkew: (_e = options.ySkew) !== null && _e !== void 0 ? _e : degrees(0),
          graphicsState: graphicsStateKey
        }));
      };
      PDFPage2.prototype.drawSvgPath = function(path, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (options === void 0) {
          options = {};
        }
        assertIs(path, "path", ["string"]);
        assertOrUndefined(options.x, "options.x", ["number"]);
        assertOrUndefined(options.y, "options.y", ["number"]);
        assertOrUndefined(options.scale, "options.scale", ["number"]);
        assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
        assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
        assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
        assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
        assertOrUndefined(options.borderColor, "options.borderColor", [
          [Object, "Color"]
        ]);
        assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
          Array
        ]);
        assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
          "number"
        ]);
        assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", LineCapStyle);
        assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
        assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
        var graphicsStateKey = this.maybeEmbedGraphicsState({
          opacity: options.opacity,
          borderOpacity: options.borderOpacity,
          blendMode: options.blendMode
        });
        if (!("color" in options) && !("borderColor" in options)) {
          options.borderColor = rgb(0, 0, 0);
        }
        var contentStream = this.getContentStream();
        contentStream.push.apply(contentStream, drawSvgPath(path, {
          x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
          scale: options.scale,
          rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : degrees(0),
          color: (_d = options.color) !== null && _d !== void 0 ? _d : void 0,
          borderColor: (_e = options.borderColor) !== null && _e !== void 0 ? _e : void 0,
          borderWidth: (_f = options.borderWidth) !== null && _f !== void 0 ? _f : 0,
          borderDashArray: (_g = options.borderDashArray) !== null && _g !== void 0 ? _g : void 0,
          borderDashPhase: (_h = options.borderDashPhase) !== null && _h !== void 0 ? _h : void 0,
          borderLineCap: (_j = options.borderLineCap) !== null && _j !== void 0 ? _j : void 0,
          graphicsState: graphicsStateKey
        }));
      };
      PDFPage2.prototype.drawLine = function(options) {
        var _a, _b, _c, _d, _e;
        assertIs(options.start, "options.start", [
          [Object, "{ x: number, y: number }"]
        ]);
        assertIs(options.end, "options.end", [
          [Object, "{ x: number, y: number }"]
        ]);
        assertIs(options.start.x, "options.start.x", ["number"]);
        assertIs(options.start.y, "options.start.y", ["number"]);
        assertIs(options.end.x, "options.end.x", ["number"]);
        assertIs(options.end.y, "options.end.y", ["number"]);
        assertOrUndefined(options.thickness, "options.thickness", ["number"]);
        assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
        assertOrUndefined(options.dashArray, "options.dashArray", [Array]);
        assertOrUndefined(options.dashPhase, "options.dashPhase", ["number"]);
        assertIsOneOfOrUndefined(options.lineCap, "options.lineCap", LineCapStyle);
        assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
        assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
        var graphicsStateKey = this.maybeEmbedGraphicsState({
          borderOpacity: options.opacity,
          blendMode: options.blendMode
        });
        if (!("color" in options)) {
          options.color = rgb(0, 0, 0);
        }
        var contentStream = this.getContentStream();
        contentStream.push.apply(contentStream, drawLine({
          start: options.start,
          end: options.end,
          thickness: (_a = options.thickness) !== null && _a !== void 0 ? _a : 1,
          color: (_b = options.color) !== null && _b !== void 0 ? _b : void 0,
          dashArray: (_c = options.dashArray) !== null && _c !== void 0 ? _c : void 0,
          dashPhase: (_d = options.dashPhase) !== null && _d !== void 0 ? _d : void 0,
          lineCap: (_e = options.lineCap) !== null && _e !== void 0 ? _e : void 0,
          graphicsState: graphicsStateKey
        }));
      };
      PDFPage2.prototype.drawRectangle = function(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (options === void 0) {
          options = {};
        }
        assertOrUndefined(options.x, "options.x", ["number"]);
        assertOrUndefined(options.y, "options.y", ["number"]);
        assertOrUndefined(options.width, "options.width", ["number"]);
        assertOrUndefined(options.height, "options.height", ["number"]);
        assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
        assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
        assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
        assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
        assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
        assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
        assertOrUndefined(options.borderColor, "options.borderColor", [
          [Object, "Color"]
        ]);
        assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
          Array
        ]);
        assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
          "number"
        ]);
        assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", LineCapStyle);
        assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
        assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
        var graphicsStateKey = this.maybeEmbedGraphicsState({
          opacity: options.opacity,
          borderOpacity: options.borderOpacity,
          blendMode: options.blendMode
        });
        if (!("color" in options) && !("borderColor" in options)) {
          options.color = rgb(0, 0, 0);
        }
        var contentStream = this.getContentStream();
        contentStream.push.apply(contentStream, drawRectangle({
          x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
          width: (_c = options.width) !== null && _c !== void 0 ? _c : 150,
          height: (_d = options.height) !== null && _d !== void 0 ? _d : 100,
          rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : degrees(0),
          xSkew: (_f = options.xSkew) !== null && _f !== void 0 ? _f : degrees(0),
          ySkew: (_g = options.ySkew) !== null && _g !== void 0 ? _g : degrees(0),
          borderWidth: (_h = options.borderWidth) !== null && _h !== void 0 ? _h : 0,
          color: (_j = options.color) !== null && _j !== void 0 ? _j : void 0,
          borderColor: (_k = options.borderColor) !== null && _k !== void 0 ? _k : void 0,
          borderDashArray: (_l = options.borderDashArray) !== null && _l !== void 0 ? _l : void 0,
          borderDashPhase: (_m = options.borderDashPhase) !== null && _m !== void 0 ? _m : void 0,
          graphicsState: graphicsStateKey,
          borderLineCap: (_o = options.borderLineCap) !== null && _o !== void 0 ? _o : void 0
        }));
      };
      PDFPage2.prototype.drawSquare = function(options) {
        if (options === void 0) {
          options = {};
        }
        var size = options.size;
        assertOrUndefined(size, "size", ["number"]);
        this.drawRectangle(__assign(__assign({}, options), { width: size, height: size }));
      };
      PDFPage2.prototype.drawEllipse = function(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (options === void 0) {
          options = {};
        }
        assertOrUndefined(options.x, "options.x", ["number"]);
        assertOrUndefined(options.y, "options.y", ["number"]);
        assertOrUndefined(options.xScale, "options.xScale", ["number"]);
        assertOrUndefined(options.yScale, "options.yScale", ["number"]);
        assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
        assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
        assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
        assertOrUndefined(options.borderColor, "options.borderColor", [
          [Object, "Color"]
        ]);
        assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
        assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
        assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
          Array
        ]);
        assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
          "number"
        ]);
        assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", LineCapStyle);
        assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", BlendMode);
        var graphicsStateKey = this.maybeEmbedGraphicsState({
          opacity: options.opacity,
          borderOpacity: options.borderOpacity,
          blendMode: options.blendMode
        });
        if (!("color" in options) && !("borderColor" in options)) {
          options.color = rgb(0, 0, 0);
        }
        var contentStream = this.getContentStream();
        contentStream.push.apply(contentStream, drawEllipse({
          x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
          y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
          xScale: (_c = options.xScale) !== null && _c !== void 0 ? _c : 100,
          yScale: (_d = options.yScale) !== null && _d !== void 0 ? _d : 100,
          rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : void 0,
          color: (_f = options.color) !== null && _f !== void 0 ? _f : void 0,
          borderColor: (_g = options.borderColor) !== null && _g !== void 0 ? _g : void 0,
          borderWidth: (_h = options.borderWidth) !== null && _h !== void 0 ? _h : 0,
          borderDashArray: (_j = options.borderDashArray) !== null && _j !== void 0 ? _j : void 0,
          borderDashPhase: (_k = options.borderDashPhase) !== null && _k !== void 0 ? _k : void 0,
          borderLineCap: (_l = options.borderLineCap) !== null && _l !== void 0 ? _l : void 0,
          graphicsState: graphicsStateKey
        }));
      };
      PDFPage2.prototype.drawCircle = function(options) {
        if (options === void 0) {
          options = {};
        }
        var _a = options.size, size = _a === void 0 ? 100 : _a;
        assertOrUndefined(size, "size", ["number"]);
        this.drawEllipse(__assign(__assign({}, options), { xScale: size, yScale: size }));
      };
      PDFPage2.prototype.setOrEmbedFont = function(font) {
        var oldFont = this.font;
        var oldFontKey = this.fontKey;
        if (font)
          this.setFont(font);
        else
          this.getFont();
        var newFont = this.font;
        var newFontKey = this.fontKey;
        return { oldFont, oldFontKey, newFont, newFontKey };
      };
      PDFPage2.prototype.getFont = function() {
        if (!this.font || !this.fontKey) {
          var font = this.doc.embedStandardFont(StandardFonts.Helvetica);
          this.setFont(font);
        }
        return [this.font, this.fontKey];
      };
      PDFPage2.prototype.resetFont = function() {
        this.font = void 0;
        this.fontKey = void 0;
      };
      PDFPage2.prototype.getContentStream = function(useExisting) {
        if (useExisting === void 0) {
          useExisting = true;
        }
        if (useExisting && this.contentStream)
          return this.contentStream;
        this.contentStream = this.createContentStream();
        this.contentStreamRef = this.doc.context.register(this.contentStream);
        this.node.addContentStream(this.contentStreamRef);
        return this.contentStream;
      };
      PDFPage2.prototype.createContentStream = function() {
        var operators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operators[_i] = arguments[_i];
        }
        var dict = this.doc.context.obj({});
        var contentStream = PDFContentStream_default.of(dict, operators);
        return contentStream;
      };
      PDFPage2.prototype.maybeEmbedGraphicsState = function(options) {
        var opacity = options.opacity, borderOpacity = options.borderOpacity, blendMode = options.blendMode;
        if (opacity === void 0 && borderOpacity === void 0 && blendMode === void 0) {
          return void 0;
        }
        var graphicsState = this.doc.context.obj({
          Type: "ExtGState",
          ca: opacity,
          CA: borderOpacity,
          BM: blendMode
        });
        var key = this.node.newExtGState("GS", graphicsState);
        return key;
      };
      PDFPage2.prototype.scaleAnnot = function(annot, x, y) {
        var selectors = ["RD", "CL", "Vertices", "QuadPoints", "L", "Rect"];
        for (var idx = 0, len = selectors.length; idx < len; idx++) {
          var list = annot.lookup(PDFName_default.of(selectors[idx]));
          if (list instanceof PDFArray_default)
            list.scalePDFNumbers(x, y);
        }
        var inkLists = annot.lookup(PDFName_default.of("InkList"));
        if (inkLists instanceof PDFArray_default) {
          for (var idx = 0, len = inkLists.size(); idx < len; idx++) {
            var arr = inkLists.lookup(idx);
            if (arr instanceof PDFArray_default)
              arr.scalePDFNumbers(x, y);
          }
        }
      };
      PDFPage2.of = function(leafNode, ref, doc) {
        return new PDFPage2(leafNode, ref, doc);
      };
      PDFPage2.create = function(doc) {
        assertIs(doc, "doc", [[PDFDocument_default, "PDFDocument"]]);
        var dummyRef = PDFRef_default.of(-1);
        var pageLeaf = PDFPageLeaf_default.withContextAndParent(doc.context, dummyRef);
        var pageRef = doc.context.register(pageLeaf);
        return new PDFPage2(pageLeaf, pageRef, doc);
      };
      return PDFPage2;
    }()
  );
  var PDFPage_default = PDFPage;

  // node_modules/@pdfme/pdf-lib/es/api/form/PDFButton.js
  var PDFButton = (
    /** @class */
    function(_super) {
      __extends(PDFButton2, _super);
      function PDFButton2(acroPushButton, ref, doc) {
        var _this = _super.call(this, acroPushButton, ref, doc) || this;
        assertIs(acroPushButton, "acroButton", [
          [PDFAcroPushButton_default, "PDFAcroPushButton"]
        ]);
        _this.acroField = acroPushButton;
        return _this;
      }
      PDFButton2.prototype.setImage = function(image, alignment) {
        if (alignment === void 0) {
          alignment = ImageAlignment.Center;
        }
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var streamRef = this.createImageAppearanceStream(widget, image, alignment);
          this.updateWidgetAppearances(widget, { normal: streamRef });
        }
        this.markAsClean();
      };
      PDFButton2.prototype.setFontSize = function(fontSize) {
        assertPositive(fontSize, "fontSize");
        this.acroField.setFontSize(fontSize);
        this.markAsDirty();
      };
      PDFButton2.prototype.addToPage = function(text, page, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        assertOrUndefined(text, "text", ["string"]);
        assertOrUndefined(page, "page", [[PDFPage_default, "PDFPage"]]);
        assertFieldAppearanceOptions(options);
        var widget = this.createWidget({
          x: ((_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0) - ((_b = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _b !== void 0 ? _b : 0) / 2,
          y: ((_c = options === null || options === void 0 ? void 0 : options.y) !== null && _c !== void 0 ? _c : 0) - ((_d = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _d !== void 0 ? _d : 0) / 2,
          width: (_e = options === null || options === void 0 ? void 0 : options.width) !== null && _e !== void 0 ? _e : 100,
          height: (_f = options === null || options === void 0 ? void 0 : options.height) !== null && _f !== void 0 ? _f : 50,
          textColor: (_g = options === null || options === void 0 ? void 0 : options.textColor) !== null && _g !== void 0 ? _g : rgb(0, 0, 0),
          backgroundColor: (_h = options === null || options === void 0 ? void 0 : options.backgroundColor) !== null && _h !== void 0 ? _h : rgb(0.75, 0.75, 0.75),
          borderColor: options === null || options === void 0 ? void 0 : options.borderColor,
          borderWidth: (_j = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _j !== void 0 ? _j : 0,
          rotate: (_k = options === null || options === void 0 ? void 0 : options.rotate) !== null && _k !== void 0 ? _k : degrees(0),
          caption: text,
          hidden: options === null || options === void 0 ? void 0 : options.hidden,
          page: page.ref
        });
        var widgetRef = this.doc.context.register(widget.dict);
        this.acroField.addWidget(widgetRef);
        var font = (_l = options === null || options === void 0 ? void 0 : options.font) !== null && _l !== void 0 ? _l : this.doc.getForm().getDefaultFont();
        this.updateWidgetAppearance(widget, font);
        page.node.addAnnot(widgetRef);
      };
      PDFButton2.prototype.needsAppearancesUpdate = function() {
        var _a;
        if (this.isDirty())
          return true;
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream_default;
          if (!hasAppearances)
            return true;
        }
        return false;
      };
      PDFButton2.prototype.defaultUpdateAppearances = function(font) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        this.updateAppearances(font);
      };
      PDFButton2.prototype.updateAppearances = function(font, provider) {
        assertIs(font, "font", [[PDFFont_default, "PDFFont"]]);
        assertOrUndefined(provider, "provider", [Function]);
        var widgets = this.acroField.getWidgets();
        for (var idx = 0, len = widgets.length; idx < len; idx++) {
          var widget = widgets[idx];
          this.updateWidgetAppearance(widget, font, provider);
        }
      };
      PDFButton2.prototype.updateWidgetAppearance = function(widget, font, provider) {
        var apProvider = provider !== null && provider !== void 0 ? provider : defaultButtonAppearanceProvider;
        var appearances = normalizeAppearance(apProvider(this, widget, font));
        this.updateWidgetAppearanceWithFont(widget, font, appearances);
      };
      PDFButton2.of = function(acroPushButton, ref, doc) {
        return new PDFButton2(acroPushButton, ref, doc);
      };
      return PDFButton2;
    }(PDFField_default)
  );
  var PDFButton_default = PDFButton;

  // node_modules/fontkit/dist/browser-module.mjs
  var browser_module_exports = {};
  __export(browser_module_exports, {
    create: () => $d636bc798e7178db$export$185802fd694ee1f5,
    defaultLanguage: () => $d636bc798e7178db$export$42940898df819940,
    logErrors: () => $d636bc798e7178db$export$bd5c5d8b8dcafd78,
    registerFormat: () => $d636bc798e7178db$export$36b2f24e97d43be,
    setDefaultLanguage: () => $d636bc798e7178db$export$5157e7780d44cc36
  });

  // node_modules/restructure/src/DecodeStream.js
  var ENCODING_MAPPING = {
    utf16le: "utf-16le",
    ucs2: "utf-16le",
    utf16be: "utf-16be"
  };
  var DecodeStream2 = class {
    constructor(buffer) {
      this.buffer = buffer;
      this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      this.pos = 0;
      this.length = this.buffer.length;
    }
    readString(length, encoding = "ascii") {
      encoding = ENCODING_MAPPING[encoding] || encoding;
      let buf = this.readBuffer(length);
      try {
        let decoder = new TextDecoder(encoding);
        return decoder.decode(buf);
      } catch (err) {
        return buf;
      }
    }
    readBuffer(length) {
      return this.buffer.slice(this.pos, this.pos += length);
    }
    readUInt24BE() {
      return (this.readUInt16BE() << 8) + this.readUInt8();
    }
    readUInt24LE() {
      return this.readUInt16LE() + (this.readUInt8() << 16);
    }
    readInt24BE() {
      return (this.readInt16BE() << 8) + this.readUInt8();
    }
    readInt24LE() {
      return this.readUInt16LE() + (this.readInt8() << 16);
    }
  };
  DecodeStream2.TYPES = {
    UInt8: 1,
    UInt16: 2,
    UInt24: 3,
    UInt32: 4,
    Int8: 1,
    Int16: 2,
    Int24: 3,
    Int32: 4,
    Float: 4,
    Double: 8
  };
  for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
    if (key.slice(0, 3) === "get") {
      let type = key.slice(3).replace("Ui", "UI");
      if (type === "Float32") {
        type = "Float";
      } else if (type === "Float64") {
        type = "Double";
      }
      let bytes = DecodeStream2.TYPES[type];
      DecodeStream2.prototype["read" + type + (bytes === 1 ? "" : "BE")] = function() {
        const ret = this.view[key](this.pos, false);
        this.pos += bytes;
        return ret;
      };
      if (bytes !== 1) {
        DecodeStream2.prototype["read" + type + "LE"] = function() {
          const ret = this.view[key](this.pos, true);
          this.pos += bytes;
          return ret;
        };
      }
    }
  }

  // node_modules/restructure/src/EncodeStream.js
  var textEncoder = new TextEncoder();
  var isBigEndian = new Uint8Array(new Uint16Array([4660]).buffer)[0] == 18;
  var EncodeStream = class {
    constructor(buffer) {
      this.buffer = buffer;
      this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
      this.pos = 0;
    }
    writeBuffer(buffer) {
      this.buffer.set(buffer, this.pos);
      this.pos += buffer.length;
    }
    writeString(string, encoding = "ascii") {
      let buf;
      switch (encoding) {
        case "utf16le":
        case "utf16-le":
        case "ucs2":
          buf = stringToUtf16(string, isBigEndian);
          break;
        case "utf16be":
        case "utf16-be":
          buf = stringToUtf16(string, !isBigEndian);
          break;
        case "utf8":
          buf = textEncoder.encode(string);
          break;
        case "ascii":
          buf = stringToAscii(string);
          break;
        default:
          throw new Error(`Unsupported encoding: ${encoding}`);
      }
      this.writeBuffer(buf);
    }
    writeUInt24BE(val) {
      this.buffer[this.pos++] = val >>> 16 & 255;
      this.buffer[this.pos++] = val >>> 8 & 255;
      this.buffer[this.pos++] = val & 255;
    }
    writeUInt24LE(val) {
      this.buffer[this.pos++] = val & 255;
      this.buffer[this.pos++] = val >>> 8 & 255;
      this.buffer[this.pos++] = val >>> 16 & 255;
    }
    writeInt24BE(val) {
      if (val >= 0) {
        this.writeUInt24BE(val);
      } else {
        this.writeUInt24BE(val + 16777215 + 1);
      }
    }
    writeInt24LE(val) {
      if (val >= 0) {
        this.writeUInt24LE(val);
      } else {
        this.writeUInt24LE(val + 16777215 + 1);
      }
    }
    fill(val, length) {
      if (length < this.buffer.length) {
        this.buffer.fill(val, this.pos, this.pos + length);
        this.pos += length;
      } else {
        const buf = new Uint8Array(length);
        buf.fill(val);
        this.writeBuffer(buf);
      }
    }
  };
  function stringToUtf16(string, swap) {
    let buf = new Uint16Array(string.length);
    for (let i = 0; i < string.length; i++) {
      let code = string.charCodeAt(i);
      if (swap) {
        code = code >> 8 | (code & 255) << 8;
      }
      buf[i] = code;
    }
    return new Uint8Array(buf.buffer);
  }
  function stringToAscii(string) {
    let buf = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      buf[i] = string.charCodeAt(i);
    }
    return buf;
  }
  for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
    if (key.slice(0, 3) === "set") {
      let type = key.slice(3).replace("Ui", "UI");
      if (type === "Float32") {
        type = "Float";
      } else if (type === "Float64") {
        type = "Double";
      }
      let bytes = DecodeStream2.TYPES[type];
      EncodeStream.prototype["write" + type + (bytes === 1 ? "" : "BE")] = function(value) {
        this.view[key](this.pos, value, false);
        this.pos += bytes;
      };
      if (bytes !== 1) {
        EncodeStream.prototype["write" + type + "LE"] = function(value) {
          this.view[key](this.pos, value, true);
          this.pos += bytes;
        };
      }
    }
  }

  // node_modules/restructure/src/Base.js
  var Base = class {
    fromBuffer(buffer) {
      let stream2 = new DecodeStream2(buffer);
      return this.decode(stream2);
    }
    toBuffer(value) {
      let size = this.size(value);
      let buffer = new Uint8Array(size);
      let stream2 = new EncodeStream(buffer);
      this.encode(stream2, value);
      return buffer;
    }
  };

  // node_modules/restructure/src/Number.js
  var NumberT = class extends Base {
    constructor(type, endian = "BE") {
      super();
      this.type = type;
      this.endian = endian;
      this.fn = this.type;
      if (this.type[this.type.length - 1] !== "8") {
        this.fn += this.endian;
      }
    }
    size() {
      return DecodeStream2.TYPES[this.type];
    }
    decode(stream2) {
      return stream2[`read${this.fn}`]();
    }
    encode(stream2, val) {
      return stream2[`write${this.fn}`](val);
    }
  };
  var uint8 = new NumberT("UInt8");
  var uint16be = new NumberT("UInt16", "BE");
  var uint16 = uint16be;
  var uint16le = new NumberT("UInt16", "LE");
  var uint24be = new NumberT("UInt24", "BE");
  var uint24 = uint24be;
  var uint24le = new NumberT("UInt24", "LE");
  var uint32be = new NumberT("UInt32", "BE");
  var uint32 = uint32be;
  var uint32le = new NumberT("UInt32", "LE");
  var int8 = new NumberT("Int8");
  var int16be = new NumberT("Int16", "BE");
  var int16 = int16be;
  var int16le = new NumberT("Int16", "LE");
  var int24be = new NumberT("Int24", "BE");
  var int24 = int24be;
  var int24le = new NumberT("Int24", "LE");
  var int32be = new NumberT("Int32", "BE");
  var int32 = int32be;
  var int32le = new NumberT("Int32", "LE");
  var floatbe = new NumberT("Float", "BE");
  var float = floatbe;
  var floatle = new NumberT("Float", "LE");
  var doublebe = new NumberT("Double", "BE");
  var double = doublebe;
  var doublele = new NumberT("Double", "LE");
  var Fixed = class extends NumberT {
    constructor(size, endian, fracBits = size >> 1) {
      super(`Int${size}`, endian);
      this._point = 1 << fracBits;
    }
    decode(stream2) {
      return super.decode(stream2) / this._point;
    }
    encode(stream2, val) {
      return super.encode(stream2, val * this._point | 0);
    }
  };
  var fixed16be = new Fixed(16, "BE");
  var fixed16 = fixed16be;
  var fixed16le = new Fixed(16, "LE");
  var fixed32be = new Fixed(32, "BE");
  var fixed32 = fixed32be;
  var fixed32le = new Fixed(32, "LE");

  // node_modules/restructure/src/utils.js
  function resolveLength(length, stream2, parent) {
    let res;
    if (typeof length === "number") {
      res = length;
    } else if (typeof length === "function") {
      res = length.call(parent, parent);
    } else if (parent && typeof length === "string") {
      res = parent[length];
    } else if (stream2 && length instanceof NumberT) {
      res = length.decode(stream2);
    }
    if (isNaN(res)) {
      throw new Error("Not a fixed size");
    }
    return res;
  }
  ;
  var PropertyDescriptor = class {
    constructor(opts = {}) {
      this.enumerable = true;
      this.configurable = true;
      for (let key in opts) {
        const val = opts[key];
        this[key] = val;
      }
    }
  };

  // node_modules/restructure/src/Array.js
  var ArrayT = class extends Base {
    constructor(type, length, lengthType = "count") {
      super();
      this.type = type;
      this.length = length;
      this.lengthType = lengthType;
    }
    decode(stream2, parent) {
      let length;
      const { pos } = stream2;
      const res = [];
      let ctx = parent;
      if (this.length != null) {
        length = resolveLength(this.length, stream2, parent);
      }
      if (this.length instanceof NumberT) {
        Object.defineProperties(res, {
          parent: { value: parent },
          _startOffset: { value: pos },
          _currentOffset: { value: 0, writable: true },
          _length: { value: length }
        });
        ctx = res;
      }
      if (length == null || this.lengthType === "bytes") {
        const target = length != null ? stream2.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream2.length;
        while (stream2.pos < target) {
          res.push(this.type.decode(stream2, ctx));
        }
      } else {
        for (let i = 0, end = length; i < end; i++) {
          res.push(this.type.decode(stream2, ctx));
        }
      }
      return res;
    }
    size(array, ctx, includePointers = true) {
      if (!array) {
        return this.type.size(null, ctx) * resolveLength(this.length, null, ctx);
      }
      let size = 0;
      if (this.length instanceof NumberT) {
        size += this.length.size();
        ctx = { parent: ctx, pointerSize: 0 };
      }
      for (let item of array) {
        size += this.type.size(item, ctx);
      }
      if (ctx && includePointers && this.length instanceof NumberT) {
        size += ctx.pointerSize;
      }
      return size;
    }
    encode(stream2, array, parent) {
      let ctx = parent;
      if (this.length instanceof NumberT) {
        ctx = {
          pointers: [],
          startOffset: stream2.pos,
          parent
        };
        ctx.pointerOffset = stream2.pos + this.size(array, ctx, false);
        this.length.encode(stream2, array.length);
      }
      for (let item of array) {
        this.type.encode(stream2, item, ctx);
      }
      if (this.length instanceof NumberT) {
        let i = 0;
        while (i < ctx.pointers.length) {
          const ptr = ctx.pointers[i++];
          ptr.type.encode(stream2, ptr.val, ptr.parent);
        }
      }
    }
  };

  // node_modules/restructure/src/LazyArray.js
  var LazyArray = class extends ArrayT {
    decode(stream2, parent) {
      const { pos } = stream2;
      const length = resolveLength(this.length, stream2, parent);
      if (this.length instanceof NumberT) {
        parent = {
          parent,
          _startOffset: pos,
          _currentOffset: 0,
          _length: length
        };
      }
      const res = new LazyArrayValue(this.type, length, stream2, parent);
      stream2.pos += length * this.type.size(null, parent);
      return res;
    }
    size(val, ctx) {
      if (val instanceof LazyArrayValue) {
        val = val.toArray();
      }
      return super.size(val, ctx);
    }
    encode(stream2, val, ctx) {
      if (val instanceof LazyArrayValue) {
        val = val.toArray();
      }
      return super.encode(stream2, val, ctx);
    }
  };
  var LazyArrayValue = class {
    constructor(type, length, stream2, ctx) {
      this.type = type;
      this.length = length;
      this.stream = stream2;
      this.ctx = ctx;
      this.base = this.stream.pos;
      this.items = [];
    }
    get(index) {
      if (index < 0 || index >= this.length) {
        return void 0;
      }
      if (this.items[index] == null) {
        const { pos } = this.stream;
        this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
        this.items[index] = this.type.decode(this.stream, this.ctx);
        this.stream.pos = pos;
      }
      return this.items[index];
    }
    toArray() {
      const result = [];
      for (let i = 0, end = this.length; i < end; i++) {
        result.push(this.get(i));
      }
      return result;
    }
  };

  // node_modules/restructure/src/Bitfield.js
  var Bitfield = class extends Base {
    constructor(type, flags = []) {
      super();
      this.type = type;
      this.flags = flags;
    }
    decode(stream2) {
      const val = this.type.decode(stream2);
      const res = {};
      for (let i = 0; i < this.flags.length; i++) {
        const flag3 = this.flags[i];
        if (flag3 != null) {
          res[flag3] = !!(val & 1 << i);
        }
      }
      return res;
    }
    size() {
      return this.type.size();
    }
    encode(stream2, keys) {
      let val = 0;
      for (let i = 0; i < this.flags.length; i++) {
        const flag3 = this.flags[i];
        if (flag3 != null) {
          if (keys[flag3]) {
            val |= 1 << i;
          }
        }
      }
      return this.type.encode(stream2, val);
    }
  };

  // node_modules/restructure/src/Boolean.js
  var BooleanT = class extends Base {
    constructor(type) {
      super();
      this.type = type;
    }
    decode(stream2, parent) {
      return !!this.type.decode(stream2, parent);
    }
    size(val, parent) {
      return this.type.size(val, parent);
    }
    encode(stream2, val, parent) {
      return this.type.encode(stream2, +val, parent);
    }
  };

  // node_modules/restructure/src/Buffer.js
  var BufferT = class extends Base {
    constructor(length) {
      super();
      this.length = length;
    }
    decode(stream2, parent) {
      const length = resolveLength(this.length, stream2, parent);
      return stream2.readBuffer(length);
    }
    size(val, parent) {
      if (!val) {
        return resolveLength(this.length, null, parent);
      }
      let len = val.length;
      if (this.length instanceof NumberT) {
        len += this.length.size();
      }
      return len;
    }
    encode(stream2, buf, parent) {
      if (this.length instanceof NumberT) {
        this.length.encode(stream2, buf.length);
      }
      return stream2.writeBuffer(buf);
    }
  };

  // node_modules/restructure/src/Enum.js
  var Enum = class extends Base {
    constructor(type, options = []) {
      super();
      this.type = type;
      this.options = options;
    }
    decode(stream2) {
      const index = this.type.decode(stream2);
      return this.options[index] || index;
    }
    size() {
      return this.type.size();
    }
    encode(stream2, val) {
      const index = this.options.indexOf(val);
      if (index === -1) {
        throw new Error(`Unknown option in enum: ${val}`);
      }
      return this.type.encode(stream2, index);
    }
  };

  // node_modules/restructure/src/Optional.js
  var Optional = class extends Base {
    constructor(type, condition = true) {
      super();
      this.type = type;
      this.condition = condition;
    }
    decode(stream2, parent) {
      let { condition } = this;
      if (typeof condition === "function") {
        condition = condition.call(parent, parent);
      }
      if (condition) {
        return this.type.decode(stream2, parent);
      }
    }
    size(val, parent) {
      let { condition } = this;
      if (typeof condition === "function") {
        condition = condition.call(parent, parent);
      }
      if (condition) {
        return this.type.size(val, parent);
      } else {
        return 0;
      }
    }
    encode(stream2, val, parent) {
      let { condition } = this;
      if (typeof condition === "function") {
        condition = condition.call(parent, parent);
      }
      if (condition) {
        return this.type.encode(stream2, val, parent);
      }
    }
  };

  // node_modules/restructure/src/Reserved.js
  var Reserved = class extends Base {
    constructor(type, count = 1) {
      super();
      this.type = type;
      this.count = count;
    }
    decode(stream2, parent) {
      stream2.pos += this.size(null, parent);
      return void 0;
    }
    size(data, parent) {
      const count = resolveLength(this.count, null, parent);
      return this.type.size() * count;
    }
    encode(stream2, val, parent) {
      return stream2.fill(0, this.size(val, parent));
    }
  };

  // node_modules/restructure/src/String.js
  var StringT = class extends Base {
    constructor(length, encoding = "ascii") {
      super();
      this.length = length;
      this.encoding = encoding;
    }
    decode(stream2, parent) {
      let length, pos;
      if (this.length != null) {
        length = resolveLength(this.length, stream2, parent);
      } else {
        let buffer;
        ({ buffer, length, pos } = stream2);
        while (pos < length && buffer[pos] !== 0) {
          ++pos;
        }
        length = pos - stream2.pos;
      }
      let { encoding } = this;
      if (typeof encoding === "function") {
        encoding = encoding.call(parent, parent) || "ascii";
      }
      const string = stream2.readString(length, encoding);
      if (this.length == null && stream2.pos < stream2.length) {
        stream2.pos++;
      }
      return string;
    }
    size(val, parent) {
      if (!val) {
        return resolveLength(this.length, null, parent);
      }
      let { encoding } = this;
      if (typeof encoding === "function") {
        encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
      }
      if (encoding === "utf16be") {
        encoding = "utf16le";
      }
      let size = byteLength(val, encoding);
      if (this.length instanceof NumberT) {
        size += this.length.size();
      }
      if (this.length == null) {
        size++;
      }
      return size;
    }
    encode(stream2, val, parent) {
      let { encoding } = this;
      if (typeof encoding === "function") {
        encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
      }
      if (this.length instanceof NumberT) {
        this.length.encode(stream2, byteLength(val, encoding));
      }
      stream2.writeString(val, encoding);
      if (this.length == null) {
        return stream2.writeUInt8(0);
      }
    }
  };
  function byteLength(string, encoding) {
    switch (encoding) {
      case "ascii":
        return string.length;
      case "utf8":
        let len = 0;
        for (let i = 0; i < string.length; i++) {
          let c = string.charCodeAt(i);
          if (c >= 55296 && c <= 56319 && i < string.length - 1) {
            let c2 = string.charCodeAt(++i);
            if ((c2 & 64512) === 56320) {
              c = ((c & 1023) << 10) + (c2 & 1023) + 65536;
            } else {
              i--;
            }
          }
          if ((c & 4294967168) === 0) {
            len++;
          } else if ((c & 4294965248) === 0) {
            len += 2;
          } else if ((c & 4294901760) === 0) {
            len += 3;
          } else if ((c & 4292870144) === 0) {
            len += 4;
          }
        }
        return len;
      case "utf16le":
      case "utf16-le":
      case "utf16be":
      case "utf16-be":
      case "ucs2":
        return string.length * 2;
      default:
        throw new Error("Unknown encoding " + encoding);
    }
  }

  // node_modules/restructure/src/Struct.js
  var Struct = class extends Base {
    constructor(fields = {}) {
      super();
      this.fields = fields;
    }
    decode(stream2, parent, length = 0) {
      const res = this._setup(stream2, parent, length);
      this._parseFields(stream2, res, this.fields);
      if (this.process != null) {
        this.process.call(res, stream2);
      }
      return res;
    }
    _setup(stream2, parent, length) {
      const res = {};
      Object.defineProperties(res, {
        parent: { value: parent },
        _startOffset: { value: stream2.pos },
        _currentOffset: { value: 0, writable: true },
        _length: { value: length }
      });
      return res;
    }
    _parseFields(stream2, res, fields) {
      for (let key in fields) {
        var val;
        const type = fields[key];
        if (typeof type === "function") {
          val = type.call(res, res);
        } else {
          val = type.decode(stream2, res);
        }
        if (val !== void 0) {
          if (val instanceof PropertyDescriptor) {
            Object.defineProperty(res, key, val);
          } else {
            res[key] = val;
          }
        }
        res._currentOffset = stream2.pos - res._startOffset;
      }
    }
    size(val, parent, includePointers = true) {
      if (val == null) {
        val = {};
      }
      const ctx = {
        parent,
        val,
        pointerSize: 0
      };
      if (this.preEncode != null) {
        this.preEncode.call(val);
      }
      let size = 0;
      for (let key in this.fields) {
        const type = this.fields[key];
        if (type.size != null) {
          size += type.size(val[key], ctx);
        }
      }
      if (includePointers) {
        size += ctx.pointerSize;
      }
      return size;
    }
    encode(stream2, val, parent) {
      let type;
      if (this.preEncode != null) {
        this.preEncode.call(val, stream2);
      }
      const ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent,
        val,
        pointerSize: 0
      };
      ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
      for (let key in this.fields) {
        type = this.fields[key];
        if (type.encode != null) {
          type.encode(stream2, val[key], ctx);
        }
      }
      let i = 0;
      while (i < ctx.pointers.length) {
        const ptr = ctx.pointers[i++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
    }
  };

  // node_modules/restructure/src/VersionedStruct.js
  var getPath = (object, pathArray) => {
    return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
  };
  var VersionedStruct = class _VersionedStruct extends Struct {
    constructor(type, versions = {}) {
      super();
      this.type = type;
      this.versions = versions;
      if (typeof type === "string") {
        this.versionPath = type.split(".");
      }
    }
    decode(stream2, parent, length = 0) {
      const res = this._setup(stream2, parent, length);
      if (typeof this.type === "string") {
        res.version = getPath(parent, this.versionPath);
      } else {
        res.version = this.type.decode(stream2);
      }
      if (this.versions.header) {
        this._parseFields(stream2, res, this.versions.header);
      }
      const fields = this.versions[res.version];
      if (fields == null) {
        throw new Error(`Unknown version ${res.version}`);
      }
      if (fields instanceof _VersionedStruct) {
        return fields.decode(stream2, parent);
      }
      this._parseFields(stream2, res, fields);
      if (this.process != null) {
        this.process.call(res, stream2);
      }
      return res;
    }
    size(val, parent, includePointers = true) {
      let key, type;
      if (!val) {
        throw new Error("Not a fixed size");
      }
      if (this.preEncode != null) {
        this.preEncode.call(val);
      }
      const ctx = {
        parent,
        val,
        pointerSize: 0
      };
      let size = 0;
      if (typeof this.type !== "string") {
        size += this.type.size(val.version, ctx);
      }
      if (this.versions.header) {
        for (key in this.versions.header) {
          type = this.versions.header[key];
          if (type.size != null) {
            size += type.size(val[key], ctx);
          }
        }
      }
      const fields = this.versions[val.version];
      if (fields == null) {
        throw new Error(`Unknown version ${val.version}`);
      }
      for (key in fields) {
        type = fields[key];
        if (type.size != null) {
          size += type.size(val[key], ctx);
        }
      }
      if (includePointers) {
        size += ctx.pointerSize;
      }
      return size;
    }
    encode(stream2, val, parent) {
      let key, type;
      if (this.preEncode != null) {
        this.preEncode.call(val, stream2);
      }
      const ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent,
        val,
        pointerSize: 0
      };
      ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
      if (typeof this.type !== "string") {
        this.type.encode(stream2, val.version);
      }
      if (this.versions.header) {
        for (key in this.versions.header) {
          type = this.versions.header[key];
          if (type.encode != null) {
            type.encode(stream2, val[key], ctx);
          }
        }
      }
      const fields = this.versions[val.version];
      for (key in fields) {
        type = fields[key];
        if (type.encode != null) {
          type.encode(stream2, val[key], ctx);
        }
      }
      let i = 0;
      while (i < ctx.pointers.length) {
        const ptr = ctx.pointers[i++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
    }
  };

  // node_modules/restructure/src/Pointer.js
  var Pointer = class extends Base {
    constructor(offsetType, type, options = {}) {
      super();
      this.offsetType = offsetType;
      this.type = type;
      this.options = options;
      if (this.type === "void") {
        this.type = null;
      }
      if (this.options.type == null) {
        this.options.type = "local";
      }
      if (this.options.allowNull == null) {
        this.options.allowNull = true;
      }
      if (this.options.nullValue == null) {
        this.options.nullValue = 0;
      }
      if (this.options.lazy == null) {
        this.options.lazy = false;
      }
      if (this.options.relativeTo) {
        if (typeof this.options.relativeTo !== "function") {
          throw new Error("relativeTo option must be a function");
        }
        this.relativeToGetter = options.relativeTo;
      }
    }
    decode(stream2, ctx) {
      const offset = this.offsetType.decode(stream2, ctx);
      if (offset === this.options.nullValue && this.options.allowNull) {
        return null;
      }
      let relative;
      switch (this.options.type) {
        case "local":
          relative = ctx._startOffset;
          break;
        case "immediate":
          relative = stream2.pos - this.offsetType.size();
          break;
        case "parent":
          relative = ctx.parent._startOffset;
          break;
        default:
          var c = ctx;
          while (c.parent) {
            c = c.parent;
          }
          relative = c._startOffset || 0;
      }
      if (this.options.relativeTo) {
        relative += this.relativeToGetter(ctx);
      }
      const ptr = offset + relative;
      if (this.type != null) {
        let val = null;
        const decodeValue = () => {
          if (val != null) {
            return val;
          }
          const { pos } = stream2;
          stream2.pos = ptr;
          val = this.type.decode(stream2, ctx);
          stream2.pos = pos;
          return val;
        };
        if (this.options.lazy) {
          return new PropertyDescriptor({
            get: decodeValue
          });
        }
        return decodeValue();
      } else {
        return ptr;
      }
    }
    size(val, ctx) {
      const parent = ctx;
      switch (this.options.type) {
        case "local":
        case "immediate":
          break;
        case "parent":
          ctx = ctx.parent;
          break;
        default:
          while (ctx.parent) {
            ctx = ctx.parent;
          }
      }
      let { type } = this;
      if (type == null) {
        if (!(val instanceof VoidPointer)) {
          throw new Error("Must be a VoidPointer");
        }
        ({ type } = val);
        val = val.value;
      }
      if (val && ctx) {
        let size = type.size(val, parent);
        ctx.pointerSize += size;
      }
      return this.offsetType.size();
    }
    encode(stream2, val, ctx) {
      let relative;
      const parent = ctx;
      if (val == null) {
        this.offsetType.encode(stream2, this.options.nullValue);
        return;
      }
      switch (this.options.type) {
        case "local":
          relative = ctx.startOffset;
          break;
        case "immediate":
          relative = stream2.pos + this.offsetType.size(val, parent);
          break;
        case "parent":
          ctx = ctx.parent;
          relative = ctx.startOffset;
          break;
        default:
          relative = 0;
          while (ctx.parent) {
            ctx = ctx.parent;
          }
      }
      if (this.options.relativeTo) {
        relative += this.relativeToGetter(parent.val);
      }
      this.offsetType.encode(stream2, ctx.pointerOffset - relative);
      let { type } = this;
      if (type == null) {
        if (!(val instanceof VoidPointer)) {
          throw new Error("Must be a VoidPointer");
        }
        ({ type } = val);
        val = val.value;
      }
      ctx.pointers.push({
        type,
        val,
        parent
      });
      return ctx.pointerOffset += type.size(val, parent);
    }
  };
  var VoidPointer = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
  };

  // node_modules/@swc/helpers/src/_define_property.mjs
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // node_modules/@swc/helpers/node_modules/tslib/tslib.es6.mjs
  var extendStatics2 = function(d, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics2(d, b);
  };
  function __extends2(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign2 = function() {
    __assign2 = Object.assign || function __assign3(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  function __rest2(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate2(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param2(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function")
        throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn)
        context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access)
        context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_ = accept(result.get))
          descriptor.get = _;
        if (_ = accept(result.set))
          descriptor.set = _;
        if (_ = accept(result.init))
          initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field")
          initializers.unshift(_);
        else
          descriptor[key] = _;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  ;
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  ;
  function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
  }
  ;
  function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol")
      name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  }
  ;
  function __metadata2(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter2(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator2(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  var __createBinding2 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  };
  function __exportStar2(m, o) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
        __createBinding2(o, m, p);
  }
  function __values2(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read2(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spread2() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read2(arguments[i]));
    return ar;
  }
  function __spreadArrays2() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await2(v) {
    return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
  }
  function __asyncGenerator2(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator2(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await2(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues2(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject2(cooked, raw2) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw2 });
    } else {
      cooked.raw = raw2;
    }
    return cooked;
  }
  ;
  var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  };
  function __importStar2(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  }
  function __importDefault2(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet2(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet2(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
      throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object")
        throw new TypeError("Object expected.");
      var dispose2;
      if (async) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose2 = value[Symbol.asyncDispose];
      }
      if (dispose2 === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose2 = value[Symbol.dispose];
      }
      if (typeof dispose2 !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose: dispose2, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
  };
  function __disposeResources(env) {
    function fail(e) {
      env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  }
  var tslib_es6_default = {
    __extends: __extends2,
    __assign: __assign2,
    __rest: __rest2,
    __decorate: __decorate2,
    __param: __param2,
    __metadata: __metadata2,
    __awaiter: __awaiter2,
    __generator: __generator2,
    __createBinding: __createBinding2,
    __exportStar: __exportStar2,
    __values: __values2,
    __read: __read2,
    __spread: __spread2,
    __spreadArrays: __spreadArrays2,
    __spreadArray,
    __await: __await2,
    __asyncGenerator: __asyncGenerator2,
    __asyncDelegator: __asyncDelegator2,
    __asyncValues: __asyncValues2,
    __makeTemplateObject: __makeTemplateObject2,
    __importStar: __importStar2,
    __importDefault: __importDefault2,
    __classPrivateFieldGet: __classPrivateFieldGet2,
    __classPrivateFieldSet: __classPrivateFieldSet2,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources
  };

  // node_modules/unicode-properties/dist/module.mjs
  var import_base64_js = __toESM(require_base64_js(), 1);
  var import_unicode_trie = __toESM(require_unicode_trie(), 1);
  function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
  }
  var $f4087201da764553$exports = {};
  $f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
  var $747425b437e121da$var$trie = new (0, import_unicode_trie.default)((0, import_base64_js.default).toByteArray("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"));
  var $747425b437e121da$var$log2 = Math.log2 || ((n) => Math.log(n) / Math.LN2);
  var $747425b437e121da$var$bits = (n) => $747425b437e121da$var$log2(n) + 1 | 0;
  var $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).categories.length - 1);
  var $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).combiningClasses.length - 1);
  var $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).scripts.length - 1);
  var $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).eaw.length - 1);
  var $747425b437e121da$var$NUMBER_BITS = 10;
  var $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
  var $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
  var $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
  var $747425b437e121da$var$EAW_SHIFT = $747425b437e121da$var$NUMBER_BITS;
  var $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
  var $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
  var $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
  var $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
  var $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
  function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
    const val = $747425b437e121da$var$trie.get(codePoint);
    return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
  }
  function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
    const val = $747425b437e121da$var$trie.get(codePoint);
    return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
  }
  function $747425b437e121da$export$941569448d136665(codePoint) {
    const val = $747425b437e121da$var$trie.get(codePoint);
    return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
  }
  function $747425b437e121da$export$92f6187db8ca6d26(codePoint) {
    const val = $747425b437e121da$var$trie.get(codePoint);
    return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).eaw[val >> $747425b437e121da$var$EAW_SHIFT & $747425b437e121da$var$EAW_MASK];
  }
  function $747425b437e121da$export$7d1258ebb7625a0d(codePoint) {
    let val = $747425b437e121da$var$trie.get(codePoint);
    let num = val & $747425b437e121da$var$NUMBER_MASK;
    if (num === 0)
      return null;
    else if (num <= 50)
      return num - 1;
    else if (num < 480) {
      const numerator = (num >> 4) - 12;
      const denominator = (num & 15) + 1;
      return numerator / denominator;
    } else if (num < 768) {
      val = (num >> 5) - 14;
      let exp = (num & 31) + 2;
      while (exp > 0) {
        val *= 10;
        exp--;
      }
      return val;
    } else {
      val = (num >> 2) - 191;
      let exp = (num & 3) + 1;
      while (exp > 0) {
        val *= 60;
        exp--;
      }
      return val;
    }
  }
  function $747425b437e121da$export$52c8ea63abd07594(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
  }
  function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
    return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
  }
  function $747425b437e121da$export$a5b49f4dc6a07d2c(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
  }
  function $747425b437e121da$export$7b6804e8df61fcf5(codePoint) {
    return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Ll";
  }
  function $747425b437e121da$export$aebd617640818cda(codePoint) {
    return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lu";
  }
  function $747425b437e121da$export$de8b4ee23b2cf823(codePoint) {
    return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lt";
  }
  function $747425b437e121da$export$3c52dd84024ae72c(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Zs" || category === "Zl" || category === "Zp";
  }
  function $747425b437e121da$export$a11bdcffe109e74b(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
  }
  function $747425b437e121da$export$e33ad6871e762338(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Mn" || category === "Me" || category === "Mc";
  }
  var $747425b437e121da$export$2e2bcd8739ae039 = {
    getCategory: $747425b437e121da$export$410364bbb673ddbc,
    getCombiningClass: $747425b437e121da$export$c03b919c6651ed55,
    getScript: $747425b437e121da$export$941569448d136665,
    getEastAsianWidth: $747425b437e121da$export$92f6187db8ca6d26,
    getNumericValue: $747425b437e121da$export$7d1258ebb7625a0d,
    isAlphabetic: $747425b437e121da$export$52c8ea63abd07594,
    isDigit: $747425b437e121da$export$727d9dbc4fbb948f,
    isPunctuation: $747425b437e121da$export$a5b49f4dc6a07d2c,
    isLowerCase: $747425b437e121da$export$7b6804e8df61fcf5,
    isUpperCase: $747425b437e121da$export$aebd617640818cda,
    isTitleCase: $747425b437e121da$export$de8b4ee23b2cf823,
    isWhiteSpace: $747425b437e121da$export$3c52dd84024ae72c,
    isBaseForm: $747425b437e121da$export$a11bdcffe109e74b,
    isMark: $747425b437e121da$export$e33ad6871e762338
  };

  // node_modules/fontkit/dist/browser-module.mjs
  var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);
  var import_unicode_trie2 = __toESM(require_unicode_trie(), 1);
  var import_dfa = __toESM(require_dfa(), 1);
  var import_clone = __toESM(require_clone(), 1);
  var import_tiny_inflate = __toESM(require_tiny_inflate(), 1);
  var import_decompress = __toESM(require_decompress(), 1);
  function $parcel$export(e, n, v, s) {
    Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
  }
  function $parcel$interopDefault2(a) {
    return a && a.__esModule ? a.default : a;
  }
  var $d636bc798e7178db$exports = {};
  $parcel$export($d636bc798e7178db$exports, "logErrors", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);
  $parcel$export($d636bc798e7178db$exports, "registerFormat", () => $d636bc798e7178db$export$36b2f24e97d43be);
  $parcel$export($d636bc798e7178db$exports, "create", () => $d636bc798e7178db$export$185802fd694ee1f5);
  $parcel$export($d636bc798e7178db$exports, "defaultLanguage", () => $d636bc798e7178db$export$42940898df819940);
  $parcel$export($d636bc798e7178db$exports, "setDefaultLanguage", () => $d636bc798e7178db$export$5157e7780d44cc36);
  var $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;
  var $d636bc798e7178db$var$formats = [];
  function $d636bc798e7178db$export$36b2f24e97d43be(format) {
    $d636bc798e7178db$var$formats.push(format);
  }
  function $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName) {
    for (let i = 0; i < $d636bc798e7178db$var$formats.length; i++) {
      let format = $d636bc798e7178db$var$formats[i];
      if (format.probe(buffer)) {
        let font = new format(new (0, DecodeStream2)(buffer));
        if (postscriptName)
          return font.getFont(postscriptName);
        return font;
      }
    }
    throw new Error("Unknown font format");
  }
  var $d636bc798e7178db$export$42940898df819940 = "en";
  function $d636bc798e7178db$export$5157e7780d44cc36(lang = "en") {
    $d636bc798e7178db$export$42940898df819940 = lang;
  }
  function $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key1, descriptor) {
    if (descriptor.get) {
      let get = descriptor.get;
      descriptor.get = function() {
        let value = get.call(this);
        Object.defineProperty(this, key1, {
          value
        });
        return value;
      };
    } else if (typeof descriptor.value === "function") {
      let fn = descriptor.value;
      return {
        get() {
          let cache1 = /* @__PURE__ */ new Map();
          function memoized(...args) {
            let key = args.length > 0 ? args[0] : "value";
            if (cache1.has(key))
              return cache1.get(key);
            let result = fn.apply(this, args);
            cache1.set(key, result);
            return result;
          }
          Object.defineProperty(this, key1, {
            value: memoized
          });
          return memoized;
        }
      };
    }
  }
  var $26a62205ad06574e$var$SubHeader = new Struct({
    firstCode: uint16,
    entryCount: uint16,
    idDelta: int16,
    idRangeOffset: uint16
  });
  var $26a62205ad06574e$var$CmapGroup = new Struct({
    startCharCode: uint32,
    endCharCode: uint32,
    glyphID: uint32
  });
  var $26a62205ad06574e$var$UnicodeValueRange = new Struct({
    startUnicodeValue: uint24,
    additionalCount: uint8
  });
  var $26a62205ad06574e$var$UVSMapping = new Struct({
    unicodeValue: uint24,
    glyphID: uint16
  });
  var $26a62205ad06574e$var$DefaultUVS = new ArrayT($26a62205ad06574e$var$UnicodeValueRange, uint32);
  var $26a62205ad06574e$var$NonDefaultUVS = new ArrayT($26a62205ad06574e$var$UVSMapping, uint32);
  var $26a62205ad06574e$var$VarSelectorRecord = new Struct({
    varSelector: uint24,
    defaultUVS: new Pointer(uint32, $26a62205ad06574e$var$DefaultUVS, {
      type: "parent"
    }),
    nonDefaultUVS: new Pointer(uint32, $26a62205ad06574e$var$NonDefaultUVS, {
      type: "parent"
    })
  });
  var $26a62205ad06574e$var$CmapSubtable = new VersionedStruct(uint16, {
    0: {
      length: uint16,
      language: uint16,
      codeMap: new LazyArray(uint8, 256)
    },
    2: {
      length: uint16,
      language: uint16,
      subHeaderKeys: new ArrayT(uint16, 256),
      subHeaderCount: (t) => Math.max.apply(Math, t.subHeaderKeys),
      subHeaders: new LazyArray($26a62205ad06574e$var$SubHeader, "subHeaderCount"),
      glyphIndexArray: new LazyArray(uint16, "subHeaderCount")
    },
    4: {
      length: uint16,
      language: uint16,
      segCountX2: uint16,
      segCount: (t) => t.segCountX2 >> 1,
      searchRange: uint16,
      entrySelector: uint16,
      rangeShift: uint16,
      endCode: new LazyArray(uint16, "segCount"),
      reservedPad: new Reserved(uint16),
      startCode: new LazyArray(uint16, "segCount"),
      idDelta: new LazyArray(int16, "segCount"),
      idRangeOffset: new LazyArray(uint16, "segCount"),
      glyphIndexArray: new LazyArray(uint16, (t) => (t.length - t._currentOffset) / 2)
    },
    6: {
      length: uint16,
      language: uint16,
      firstCode: uint16,
      entryCount: uint16,
      glyphIndices: new LazyArray(uint16, "entryCount")
    },
    8: {
      reserved: new Reserved(uint16),
      length: uint32,
      language: uint16,
      is32: new LazyArray(uint8, 8192),
      nGroups: uint32,
      groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
    },
    10: {
      reserved: new Reserved(uint16),
      length: uint32,
      language: uint32,
      firstCode: uint32,
      entryCount: uint32,
      glyphIndices: new LazyArray(uint16, "numChars")
    },
    12: {
      reserved: new Reserved(uint16),
      length: uint32,
      language: uint32,
      nGroups: uint32,
      groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
    },
    13: {
      reserved: new Reserved(uint16),
      length: uint32,
      language: uint32,
      nGroups: uint32,
      groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
    },
    14: {
      length: uint32,
      numRecords: uint32,
      varSelectors: new LazyArray($26a62205ad06574e$var$VarSelectorRecord, "numRecords")
    }
  });
  var $26a62205ad06574e$var$CmapEntry = new Struct({
    platformID: uint16,
    encodingID: uint16,
    table: new Pointer(uint32, $26a62205ad06574e$var$CmapSubtable, {
      type: "parent",
      lazy: true
    })
  });
  var $26a62205ad06574e$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    numSubtables: uint16,
    tables: new ArrayT($26a62205ad06574e$var$CmapEntry, "numSubtables")
  });
  var $f2612a29f92ac062$export$2e2bcd8739ae039 = new Struct({
    version: int32,
    revision: int32,
    checkSumAdjustment: uint32,
    magicNumber: uint32,
    flags: uint16,
    unitsPerEm: uint16,
    created: new ArrayT(int32, 2),
    modified: new ArrayT(int32, 2),
    xMin: int16,
    yMin: int16,
    xMax: int16,
    yMax: int16,
    macStyle: new Bitfield(uint16, [
      "bold",
      "italic",
      "underline",
      "outline",
      "shadow",
      "condensed",
      "extended"
    ]),
    lowestRecPPEM: uint16,
    fontDirectionHint: int16,
    indexToLocFormat: int16,
    glyphDataFormat: int16
    // 0 for current format
  });
  var $2c179dd593583073$export$2e2bcd8739ae039 = new Struct({
    version: int32,
    ascent: int16,
    descent: int16,
    lineGap: int16,
    advanceWidthMax: uint16,
    minLeftSideBearing: int16,
    minRightSideBearing: int16,
    xMaxExtent: int16,
    caretSlopeRise: int16,
    caretSlopeRun: int16,
    caretOffset: int16,
    reserved: new Reserved(int16, 4),
    metricDataFormat: int16,
    numberOfMetrics: uint16
    // Number of advance widths in 'hmtx' table
  });
  var $bdc9060542264b85$var$HmtxEntry = new Struct({
    advance: uint16,
    bearing: int16
  });
  var $bdc9060542264b85$export$2e2bcd8739ae039 = new Struct({
    metrics: new LazyArray($bdc9060542264b85$var$HmtxEntry, (t) => t.parent.hhea.numberOfMetrics),
    bearings: new LazyArray(int16, (t) => t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics)
  });
  var $dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new Struct({
    version: int32,
    numGlyphs: uint16,
    maxPoints: uint16,
    maxContours: uint16,
    maxComponentPoints: uint16,
    maxComponentContours: uint16,
    maxZones: uint16,
    maxTwilightPoints: uint16,
    maxStorage: uint16,
    maxFunctionDefs: uint16,
    maxInstructionDefs: uint16,
    maxStackElements: uint16,
    maxSizeOfInstructions: uint16,
    maxComponentElements: uint16,
    maxComponentDepth: uint16
    // Maximum levels of recursion; 1 for simple components
  });
  function $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
    if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID])
      return $e449ad78d50845fe$export$479e671907f486d1[languageID];
    return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];
  }
  var $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
    "x-mac-roman",
    "x-mac-cyrillic",
    "iso-8859-6",
    "iso-8859-8"
  ]);
  var $e449ad78d50845fe$var$MAC_ENCODINGS = {
    "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026 \xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7",
    "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83",
    "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026 \u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD",
    "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
    "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026 \u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142",
    "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026 \u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7",
    "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
    "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
  };
  var $e449ad78d50845fe$var$encodingCache = /* @__PURE__ */ new Map();
  function $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {
    let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);
    if (cached)
      return cached;
    let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];
    if (mapping) {
      let res = /* @__PURE__ */ new Map();
      for (let i = 0; i < mapping.length; i++)
        res.set(mapping.charCodeAt(i), 128 + i);
      $e449ad78d50845fe$var$encodingCache.set(encoding, res);
      return res;
    }
    if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
      let decoder = new TextDecoder(encoding);
      let mapping2 = new Uint8Array(128);
      for (let i = 0; i < 128; i++)
        mapping2[i] = 128 + i;
      let res = /* @__PURE__ */ new Map();
      let s = decoder.decode(mapping2);
      for (let i1 = 0; i1 < 128; i1++)
        res.set(s.charCodeAt(i1), 128 + i1);
      $e449ad78d50845fe$var$encodingCache.set(encoding, res);
      return res;
    }
  }
  var $e449ad78d50845fe$export$6fef87b7618bdf0b = [
    // unicode
    [
      "utf16be",
      "utf16be",
      "utf16be",
      "utf16be",
      "utf16be",
      "utf16be"
    ],
    // macintosh
    // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
    // 0	Roman                 17	Malayalam
    // 1	Japanese	            18	Sinhalese
    // 2	Traditional Chinese	  19	Burmese
    // 3	Korean	              20	Khmer
    // 4	Arabic	              21	Thai
    // 5	Hebrew	              22	Laotian
    // 6	Greek	                23	Georgian
    // 7	Russian	              24	Armenian
    // 8	RSymbol	              25	Simplified Chinese
    // 9	Devanagari	          26	Tibetan
    // 10	Gurmukhi	            27	Mongolian
    // 11	Gujarati	            28	Geez
    // 12	Oriya	                29	Slavic
    // 13	Bengali	              30	Vietnamese
    // 14	Tamil	                31	Sindhi
    // 15	Telugu	              32	(Uninterpreted)
    // 16	Kannada
    [
      "x-mac-roman",
      "shift-jis",
      "big5",
      "euc-kr",
      "iso-8859-6",
      "iso-8859-8",
      "x-mac-greek",
      "x-mac-cyrillic",
      "x-mac-symbol",
      "x-mac-devanagari",
      "x-mac-gurmukhi",
      "x-mac-gujarati",
      "Oriya",
      "Bengali",
      "Tamil",
      "Telugu",
      "Kannada",
      "Malayalam",
      "Sinhalese",
      "Burmese",
      "Khmer",
      "iso-8859-11",
      "Laotian",
      "Georgian",
      "Armenian",
      "hz-gb-2312",
      "Tibetan",
      "Mongolian",
      "Geez",
      "x-mac-ce",
      "Vietnamese",
      "Sindhi"
    ],
    // ISO (deprecated)
    [
      "ascii"
    ],
    // windows
    // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
    [
      "symbol",
      "utf16be",
      "shift-jis",
      "gb18030",
      "big5",
      "x-cp20949",
      "johab",
      null,
      null,
      null,
      "utf16be"
    ]
  ];
  var $e449ad78d50845fe$export$479e671907f486d1 = {
    15: "x-mac-icelandic",
    17: "x-mac-turkish",
    18: "x-mac-croatian",
    24: "x-mac-ce",
    25: "x-mac-ce",
    26: "x-mac-ce",
    27: "x-mac-ce",
    28: "x-mac-ce",
    30: "x-mac-icelandic",
    37: "x-mac-romanian",
    38: "x-mac-ce",
    39: "x-mac-ce",
    40: "x-mac-ce",
    143: "x-mac-inuit",
    146: "x-mac-gaelic"
  };
  var $e449ad78d50845fe$export$2092376fd002e13 = [
    // unicode
    [],
    {
      0: "en",
      30: "fo",
      60: "ks",
      90: "rw",
      1: "fr",
      31: "fa",
      61: "ku",
      91: "rn",
      2: "de",
      32: "ru",
      62: "sd",
      92: "ny",
      3: "it",
      33: "zh",
      63: "bo",
      93: "mg",
      4: "nl",
      34: "nl-BE",
      64: "ne",
      94: "eo",
      5: "sv",
      35: "ga",
      65: "sa",
      128: "cy",
      6: "es",
      36: "sq",
      66: "mr",
      129: "eu",
      7: "da",
      37: "ro",
      67: "bn",
      130: "ca",
      8: "pt",
      38: "cz",
      68: "as",
      131: "la",
      9: "no",
      39: "sk",
      69: "gu",
      132: "qu",
      10: "he",
      40: "si",
      70: "pa",
      133: "gn",
      11: "ja",
      41: "yi",
      71: "or",
      134: "ay",
      12: "ar",
      42: "sr",
      72: "ml",
      135: "tt",
      13: "fi",
      43: "mk",
      73: "kn",
      136: "ug",
      14: "el",
      44: "bg",
      74: "ta",
      137: "dz",
      15: "is",
      45: "uk",
      75: "te",
      138: "jv",
      16: "mt",
      46: "be",
      76: "si",
      139: "su",
      17: "tr",
      47: "uz",
      77: "my",
      140: "gl",
      18: "hr",
      48: "kk",
      78: "km",
      141: "af",
      19: "zh-Hant",
      49: "az-Cyrl",
      79: "lo",
      142: "br",
      20: "ur",
      50: "az-Arab",
      80: "vi",
      143: "iu",
      21: "hi",
      51: "hy",
      81: "id",
      144: "gd",
      22: "th",
      52: "ka",
      82: "tl",
      145: "gv",
      23: "ko",
      53: "mo",
      83: "ms",
      146: "ga",
      24: "lt",
      54: "ky",
      84: "ms-Arab",
      147: "to",
      25: "pl",
      55: "tg",
      85: "am",
      148: "el-polyton",
      26: "hu",
      56: "tk",
      86: "ti",
      149: "kl",
      27: "es",
      57: "mn-CN",
      87: "om",
      150: "az",
      28: "lv",
      58: "mn",
      88: "so",
      151: "nn",
      29: "se",
      59: "ps",
      89: "sw"
    },
    // ISO (deprecated)
    [],
    {
      1078: "af",
      16393: "en-IN",
      1159: "rw",
      1074: "tn",
      1052: "sq",
      6153: "en-IE",
      1089: "sw",
      1115: "si",
      1156: "gsw",
      8201: "en-JM",
      1111: "kok",
      1051: "sk",
      1118: "am",
      17417: "en-MY",
      1042: "ko",
      1060: "sl",
      5121: "ar-DZ",
      5129: "en-NZ",
      1088: "ky",
      11274: "es-AR",
      15361: "ar-BH",
      13321: "en-PH",
      1108: "lo",
      16394: "es-BO",
      3073: "ar",
      18441: "en-SG",
      1062: "lv",
      13322: "es-CL",
      2049: "ar-IQ",
      7177: "en-ZA",
      1063: "lt",
      9226: "es-CO",
      11265: "ar-JO",
      11273: "en-TT",
      2094: "dsb",
      5130: "es-CR",
      13313: "ar-KW",
      2057: "en-GB",
      1134: "lb",
      7178: "es-DO",
      12289: "ar-LB",
      1033: "en",
      1071: "mk",
      12298: "es-EC",
      4097: "ar-LY",
      12297: "en-ZW",
      2110: "ms-BN",
      17418: "es-SV",
      6145: "ary",
      1061: "et",
      1086: "ms",
      4106: "es-GT",
      8193: "ar-OM",
      1080: "fo",
      1100: "ml",
      18442: "es-HN",
      16385: "ar-QA",
      1124: "fil",
      1082: "mt",
      2058: "es-MX",
      1025: "ar-SA",
      1035: "fi",
      1153: "mi",
      19466: "es-NI",
      10241: "ar-SY",
      2060: "fr-BE",
      1146: "arn",
      6154: "es-PA",
      7169: "aeb",
      3084: "fr-CA",
      1102: "mr",
      15370: "es-PY",
      14337: "ar-AE",
      1036: "fr",
      1148: "moh",
      10250: "es-PE",
      9217: "ar-YE",
      5132: "fr-LU",
      1104: "mn",
      20490: "es-PR",
      1067: "hy",
      6156: "fr-MC",
      2128: "mn-CN",
      3082: "es",
      1101: "as",
      4108: "fr-CH",
      1121: "ne",
      1034: "es",
      2092: "az-Cyrl",
      1122: "fy",
      1044: "nb",
      21514: "es-US",
      1068: "az",
      1110: "gl",
      2068: "nn",
      14346: "es-UY",
      1133: "ba",
      1079: "ka",
      1154: "oc",
      8202: "es-VE",
      1069: "eu",
      3079: "de-AT",
      1096: "or",
      2077: "sv-FI",
      1059: "be",
      1031: "de",
      1123: "ps",
      1053: "sv",
      2117: "bn",
      5127: "de-LI",
      1045: "pl",
      1114: "syr",
      1093: "bn-IN",
      4103: "de-LU",
      1046: "pt",
      1064: "tg",
      8218: "bs-Cyrl",
      2055: "de-CH",
      2070: "pt-PT",
      2143: "tzm",
      5146: "bs",
      1032: "el",
      1094: "pa",
      1097: "ta",
      1150: "br",
      1135: "kl",
      1131: "qu-BO",
      1092: "tt",
      1026: "bg",
      1095: "gu",
      2155: "qu-EC",
      1098: "te",
      1027: "ca",
      1128: "ha",
      3179: "qu",
      1054: "th",
      3076: "zh-HK",
      1037: "he",
      1048: "ro",
      1105: "bo",
      5124: "zh-MO",
      1081: "hi",
      1047: "rm",
      1055: "tr",
      2052: "zh",
      1038: "hu",
      1049: "ru",
      1090: "tk",
      4100: "zh-SG",
      1039: "is",
      9275: "smn",
      1152: "ug",
      1028: "zh-TW",
      1136: "ig",
      4155: "smj-NO",
      1058: "uk",
      1155: "co",
      1057: "id",
      5179: "smj",
      1070: "hsb",
      1050: "hr",
      1117: "iu",
      3131: "se-FI",
      1056: "ur",
      4122: "hr-BA",
      2141: "iu-Latn",
      1083: "se",
      2115: "uz-Cyrl",
      1029: "cs",
      2108: "ga",
      2107: "se-SE",
      1091: "uz",
      1030: "da",
      1076: "xh",
      8251: "sms",
      1066: "vi",
      1164: "prs",
      1077: "zu",
      6203: "sma-NO",
      1106: "cy",
      1125: "dv",
      1040: "it",
      7227: "sms",
      1160: "wo",
      2067: "nl-BE",
      2064: "it-CH",
      1103: "sa",
      1157: "sah",
      1043: "nl",
      1041: "ja",
      7194: "sr-Cyrl-BA",
      1144: "ii",
      3081: "en-AU",
      1099: "kn",
      3098: "sr",
      1130: "yo",
      10249: "en-BZ",
      1087: "kk",
      6170: "sr-Latn-BA",
      4105: "en-CA",
      1107: "km",
      2074: "sr-Latn",
      9225: "en-029",
      1158: "quc",
      1132: "nso"
    }
  ];
  var $2bcf221753ec8e32$var$NameRecord = new Struct({
    platformID: uint16,
    encodingID: uint16,
    languageID: uint16,
    nameID: uint16,
    length: uint16,
    string: new Pointer(uint16, new StringT("length", (t) => (0, $e449ad78d50845fe$export$badc544e0651b6b1)(t.platformID, t.encodingID, t.languageID)), {
      type: "parent",
      relativeTo: (ctx) => ctx.parent.stringOffset,
      allowNull: false
    })
  });
  var $2bcf221753ec8e32$var$LangTagRecord = new Struct({
    length: uint16,
    tag: new Pointer(uint16, new StringT("length", "utf16be"), {
      type: "parent",
      relativeTo: (ctx) => ctx.stringOffset
    })
  });
  var $2bcf221753ec8e32$var$NameTable = new VersionedStruct(uint16, {
    0: {
      count: uint16,
      stringOffset: uint16,
      records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count")
    },
    1: {
      count: uint16,
      stringOffset: uint16,
      records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count"),
      langTagCount: uint16,
      langTags: new ArrayT($2bcf221753ec8e32$var$LangTagRecord, "langTagCount")
    }
  });
  var $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;
  var $2bcf221753ec8e32$var$NAMES = [
    "copyright",
    "fontFamily",
    "fontSubfamily",
    "uniqueSubfamily",
    "fullName",
    "version",
    "postscriptName",
    "trademark",
    "manufacturer",
    "designer",
    "description",
    "vendorURL",
    "designerURL",
    "license",
    "licenseURL",
    null,
    "preferredFamily",
    "preferredSubfamily",
    "compatibleFull",
    "sampleText",
    "postscriptCIDFontName",
    "wwsFamilyName",
    "wwsSubfamilyName"
  ];
  $2bcf221753ec8e32$var$NameTable.process = function(stream2) {
    var records = {};
    for (let record of this.records) {
      let language = (0, $e449ad78d50845fe$export$2092376fd002e13)[record.platformID][record.languageID];
      if (language == null && this.langTags != null && record.languageID >= 32768)
        language = this.langTags[record.languageID - 32768].tag;
      if (language == null)
        language = record.platformID + "-" + record.languageID;
      let key = record.nameID >= 256 ? "fontFeatures" : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;
      if (records[key] == null)
        records[key] = {};
      let obj = records[key];
      if (record.nameID >= 256)
        obj = obj[record.nameID] || (obj[record.nameID] = {});
      if (typeof record.string === "string" || typeof obj[language] !== "string")
        obj[language] = record.string;
    }
    this.records = records;
  };
  $2bcf221753ec8e32$var$NameTable.preEncode = function() {
    if (Array.isArray(this.records))
      return;
    this.version = 0;
    let records = [];
    for (let key in this.records) {
      let val = this.records[key];
      if (key === "fontFeatures")
        continue;
      records.push({
        platformID: 3,
        encodingID: 1,
        languageID: 1033,
        nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
        length: val.en.length * 2,
        string: val.en
      });
      if (key === "postscriptName")
        records.push({
          platformID: 1,
          encodingID: 0,
          languageID: 0,
          nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
          length: val.en.length,
          string: val.en
        });
    }
    this.records = records;
    this.count = records.length;
    this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);
  };
  var $84b272aa31b70606$var$OS2 = new VersionedStruct(uint16, {
    header: {
      xAvgCharWidth: int16,
      usWeightClass: uint16,
      usWidthClass: uint16,
      fsType: new Bitfield(uint16, [
        null,
        "noEmbedding",
        "viewOnly",
        "editable",
        null,
        null,
        null,
        null,
        "noSubsetting",
        "bitmapOnly"
      ]),
      ySubscriptXSize: int16,
      ySubscriptYSize: int16,
      ySubscriptXOffset: int16,
      ySubscriptYOffset: int16,
      ySuperscriptXSize: int16,
      ySuperscriptYSize: int16,
      ySuperscriptXOffset: int16,
      ySuperscriptYOffset: int16,
      yStrikeoutSize: int16,
      yStrikeoutPosition: int16,
      sFamilyClass: int16,
      panose: new ArrayT(uint8, 10),
      ulCharRange: new ArrayT(uint32, 4),
      vendorID: new StringT(4),
      fsSelection: new Bitfield(uint16, [
        "italic",
        "underscore",
        "negative",
        "outlined",
        "strikeout",
        "bold",
        "regular",
        "useTypoMetrics",
        "wws",
        "oblique"
      ]),
      usFirstCharIndex: uint16,
      usLastCharIndex: uint16
      // The maximum Unicode index in this font
    },
    // The Apple version of this table ends here, but the Microsoft one continues on...
    0: {},
    1: {
      typoAscender: int16,
      typoDescender: int16,
      typoLineGap: int16,
      winAscent: uint16,
      winDescent: uint16,
      codePageRange: new ArrayT(uint32, 2)
    },
    2: {
      // these should be common with version 1 somehow
      typoAscender: int16,
      typoDescender: int16,
      typoLineGap: int16,
      winAscent: uint16,
      winDescent: uint16,
      codePageRange: new ArrayT(uint32, 2),
      xHeight: int16,
      capHeight: int16,
      defaultChar: uint16,
      breakChar: uint16,
      maxContent: uint16
    },
    5: {
      typoAscender: int16,
      typoDescender: int16,
      typoLineGap: int16,
      winAscent: uint16,
      winDescent: uint16,
      codePageRange: new ArrayT(uint32, 2),
      xHeight: int16,
      capHeight: int16,
      defaultChar: uint16,
      breakChar: uint16,
      maxContent: uint16,
      usLowerOpticalPointSize: uint16,
      usUpperOpticalPointSize: uint16
    }
  });
  var $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;
  $84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];
  var $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;
  var $32d9e2eb9565d93c$export$2e2bcd8739ae039 = new VersionedStruct(fixed32, {
    header: {
      italicAngle: fixed32,
      underlinePosition: int16,
      underlineThickness: int16,
      isFixedPitch: uint32,
      minMemType42: uint32,
      maxMemType42: uint32,
      minMemType1: uint32,
      maxMemType1: uint32
      // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
    },
    1: {},
    2: {
      numberOfGlyphs: uint16,
      glyphNameIndex: new ArrayT(uint16, "numberOfGlyphs"),
      names: new ArrayT(new StringT(uint8))
    },
    2.5: {
      numberOfGlyphs: uint16,
      offsets: new ArrayT(uint8, "numberOfGlyphs")
    },
    3: {},
    4: {
      map: new ArrayT(uint32, (t) => t.parent.maxp.numGlyphs)
    }
  });
  var $5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new Struct({
    controlValues: new ArrayT(int16)
  });
  var $5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new Struct({
    instructions: new ArrayT(uint8)
  });
  var $2b2b260902b1c57e$var$loca = new VersionedStruct("head.indexToLocFormat", {
    0: {
      offsets: new ArrayT(uint16)
    },
    1: {
      offsets: new ArrayT(uint32)
    }
  });
  $2b2b260902b1c57e$var$loca.process = function() {
    if (this.version === 0 && !this._processed) {
      for (let i = 0; i < this.offsets.length; i++)
        this.offsets[i] <<= 1;
      this._processed = true;
    }
  };
  $2b2b260902b1c57e$var$loca.preEncode = function() {
    if (this.version === 0 && this._processed !== false) {
      for (let i = 0; i < this.offsets.length; i++)
        this.offsets[i] >>>= 1;
      this._processed = false;
    }
  };
  var $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;
  var $7afb878c7bea4f66$export$2e2bcd8739ae039 = new Struct({
    controlValueProgram: new ArrayT(uint8)
  });
  var $6c92b6371bce8bd9$export$2e2bcd8739ae039 = new ArrayT(new BufferT());
  var $43e9821ef3717eec$export$2e2bcd8739ae039 = class {
    getCFFVersion(ctx) {
      while (ctx && !ctx.hdrSize)
        ctx = ctx.parent;
      return ctx ? ctx.version : -1;
    }
    decode(stream2, parent) {
      let version = this.getCFFVersion(parent);
      let count = version >= 2 ? stream2.readUInt32BE() : stream2.readUInt16BE();
      if (count === 0)
        return [];
      let offSize = stream2.readUInt8();
      let offsetType;
      if (offSize === 1)
        offsetType = uint8;
      else if (offSize === 2)
        offsetType = uint16;
      else if (offSize === 3)
        offsetType = uint24;
      else if (offSize === 4)
        offsetType = uint32;
      else
        throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream2.pos}`);
      let ret = [];
      let startPos = stream2.pos + (count + 1) * offSize - 1;
      let start = offsetType.decode(stream2);
      for (let i = 0; i < count; i++) {
        let end = offsetType.decode(stream2);
        if (this.type != null) {
          let pos = stream2.pos;
          stream2.pos = startPos + start;
          parent.length = end - start;
          ret.push(this.type.decode(stream2, parent));
          stream2.pos = pos;
        } else
          ret.push({
            offset: startPos + start,
            length: end - start
          });
        start = end;
      }
      stream2.pos = startPos + start;
      return ret;
    }
    size(arr, parent) {
      let size = 2;
      if (arr.length === 0)
        return size;
      let type = this.type || new BufferT();
      let offset = 1;
      for (let i = 0; i < arr.length; i++) {
        let item = arr[i];
        offset += type.size(item, parent);
      }
      let offsetType;
      if (offset <= 255)
        offsetType = uint8;
      else if (offset <= 65535)
        offsetType = uint16;
      else if (offset <= 16777215)
        offsetType = uint24;
      else if (offset <= 4294967295)
        offsetType = uint32;
      else
        throw new Error("Bad offset in CFFIndex");
      size += 1 + offsetType.size() * (arr.length + 1);
      size += offset - 1;
      return size;
    }
    encode(stream2, arr, parent) {
      stream2.writeUInt16BE(arr.length);
      if (arr.length === 0)
        return;
      let type = this.type || new BufferT();
      let sizes = [];
      let offset = 1;
      for (let item of arr) {
        let s = type.size(item, parent);
        sizes.push(s);
        offset += s;
      }
      let offsetType;
      if (offset <= 255)
        offsetType = uint8;
      else if (offset <= 65535)
        offsetType = uint16;
      else if (offset <= 16777215)
        offsetType = uint24;
      else if (offset <= 4294967295)
        offsetType = uint32;
      else
        throw new Error("Bad offset in CFFIndex");
      stream2.writeUInt8(offsetType.size());
      offset = 1;
      offsetType.encode(stream2, offset);
      for (let size of sizes) {
        offset += size;
        offsetType.encode(stream2, offset);
      }
      for (let item1 of arr)
        type.encode(stream2, item1, parent);
      return;
    }
    constructor(type) {
      this.type = type;
    }
  };
  var $c2d28e92708f99da$var$FLOAT_EOF = 15;
  var $c2d28e92708f99da$var$FLOAT_LOOKUP = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    ".",
    "E",
    "E-",
    null,
    "-"
  ];
  var $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {
    ".": 10,
    "E": 11,
    "E-": 12,
    "-": 14
  };
  var $c2d28e92708f99da$export$2e2bcd8739ae039 = class {
    static decode(stream2, value) {
      if (32 <= value && value <= 246)
        return value - 139;
      if (247 <= value && value <= 250)
        return (value - 247) * 256 + stream2.readUInt8() + 108;
      if (251 <= value && value <= 254)
        return -(value - 251) * 256 - stream2.readUInt8() - 108;
      if (value === 28)
        return stream2.readInt16BE();
      if (value === 29)
        return stream2.readInt32BE();
      if (value === 30) {
        let str = "";
        while (true) {
          let b = stream2.readUInt8();
          let n1 = b >> 4;
          if (n1 === $c2d28e92708f99da$var$FLOAT_EOF)
            break;
          str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];
          let n2 = b & 15;
          if (n2 === $c2d28e92708f99da$var$FLOAT_EOF)
            break;
          str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n2];
        }
        return parseFloat(str);
      }
      return null;
    }
    static size(value) {
      if (value.forceLarge)
        value = 32768;
      if ((value | 0) !== value) {
        let str = "" + value;
        return 1 + Math.ceil((str.length + 1) / 2);
      } else if (-107 <= value && value <= 107)
        return 1;
      else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108)
        return 2;
      else if (-32768 <= value && value <= 32767)
        return 3;
      else
        return 5;
    }
    static encode(stream2, value) {
      let val = Number(value);
      if (value.forceLarge) {
        stream2.writeUInt8(29);
        return stream2.writeInt32BE(val);
      } else if ((val | 0) !== val) {
        stream2.writeUInt8(30);
        let str = "" + val;
        for (let i = 0; i < str.length; i += 2) {
          let c1 = str[i];
          let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
          if (i === str.length - 1)
            var n2 = $c2d28e92708f99da$var$FLOAT_EOF;
          else {
            let c2 = str[i + 1];
            var n2 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c2] || +c2;
          }
          stream2.writeUInt8(n1 << 4 | n2 & 15);
        }
        if (n2 !== $c2d28e92708f99da$var$FLOAT_EOF)
          return stream2.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);
      } else if (-107 <= val && val <= 107)
        return stream2.writeUInt8(val + 139);
      else if (108 <= val && val <= 1131) {
        val -= 108;
        stream2.writeUInt8((val >> 8) + 247);
        return stream2.writeUInt8(val & 255);
      } else if (-1131 <= val && val <= -108) {
        val = -val - 108;
        stream2.writeUInt8((val >> 8) + 251);
        return stream2.writeUInt8(val & 255);
      } else if (-32768 <= val && val <= 32767) {
        stream2.writeUInt8(28);
        return stream2.writeInt16BE(val);
      } else {
        stream2.writeUInt8(29);
        return stream2.writeInt32BE(val);
      }
    }
  };
  var $61aa549f16d58b9b$export$2e2bcd8739ae039 = class {
    decodeOperands(type, stream2, ret, operands) {
      if (Array.isArray(type))
        return operands.map((op, i) => this.decodeOperands(type[i], stream2, ret, [
          op
        ]));
      else if (type.decode != null)
        return type.decode(stream2, ret, operands);
      else
        switch (type) {
          case "number":
          case "offset":
          case "sid":
            return operands[0];
          case "boolean":
            return !!operands[0];
          default:
            return operands;
        }
    }
    encodeOperands(type, stream2, ctx, operands) {
      if (Array.isArray(type))
        return operands.map((op, i) => this.encodeOperands(type[i], stream2, ctx, op)[0]);
      else if (type.encode != null)
        return type.encode(stream2, operands, ctx);
      else if (typeof operands === "number")
        return [
          operands
        ];
      else if (typeof operands === "boolean")
        return [
          +operands
        ];
      else if (Array.isArray(operands))
        return operands;
      else
        return [
          operands
        ];
    }
    decode(stream2, parent) {
      let end = stream2.pos + parent.length;
      let ret = {};
      let operands = [];
      Object.defineProperties(ret, {
        parent: {
          value: parent
        },
        _startOffset: {
          value: stream2.pos
        }
      });
      for (let key in this.fields) {
        let field = this.fields[key];
        ret[field[1]] = field[3];
      }
      while (stream2.pos < end) {
        let b = stream2.readUInt8();
        if (b < 28) {
          if (b === 12)
            b = b << 8 | stream2.readUInt8();
          let field = this.fields[b];
          if (!field)
            throw new Error(`Unknown operator ${b}`);
          let val = this.decodeOperands(field[2], stream2, ret, operands);
          if (val != null) {
            if (val instanceof (0, PropertyDescriptor))
              Object.defineProperty(ret, field[1], val);
            else
              ret[field[1]] = val;
          }
          operands = [];
        } else
          operands.push((0, $c2d28e92708f99da$export$2e2bcd8739ae039).decode(stream2, b));
      }
      return ret;
    }
    size(dict, parent, includePointers = true) {
      let ctx = {
        parent,
        val: dict,
        pointerSize: 0,
        startOffset: parent.startOffset || 0
      };
      let len = 0;
      for (let k in this.fields) {
        let field = this.fields[k];
        let val = dict[field[1]];
        if (val == null || (0, import_fast_deep_equal.default)(val, field[3]))
          continue;
        let operands = this.encodeOperands(field[2], null, ctx, val);
        for (let op of operands)
          len += (0, $c2d28e92708f99da$export$2e2bcd8739ae039).size(op);
        let key = Array.isArray(field[0]) ? field[0] : [
          field[0]
        ];
        len += key.length;
      }
      if (includePointers)
        len += ctx.pointerSize;
      return len;
    }
    encode(stream2, dict, parent) {
      let ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent,
        val: dict,
        pointerSize: 0
      };
      ctx.pointerOffset = stream2.pos + this.size(dict, ctx, false);
      for (let field of this.ops) {
        let val = dict[field[1]];
        if (val == null || (0, import_fast_deep_equal.default)(val, field[3]))
          continue;
        let operands = this.encodeOperands(field[2], stream2, ctx, val);
        for (let op of operands)
          (0, $c2d28e92708f99da$export$2e2bcd8739ae039).encode(stream2, op);
        let key = Array.isArray(field[0]) ? field[0] : [
          field[0]
        ];
        for (let op1 of key)
          stream2.writeUInt8(op1);
      }
      let i = 0;
      while (i < ctx.pointers.length) {
        let ptr = ctx.pointers[i++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
      return;
    }
    constructor(ops = []) {
      this.ops = ops;
      this.fields = {};
      for (let field of ops) {
        let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
        this.fields[key] = field;
      }
    }
  };
  var $0e34a43d05bde82c$export$2e2bcd8739ae039 = class extends Pointer {
    decode(stream2, parent, operands) {
      this.offsetType = {
        decode: () => operands[0]
      };
      return super.decode(stream2, parent, operands);
    }
    encode(stream2, value, ctx) {
      if (!stream2) {
        this.offsetType = {
          size: () => 0
        };
        this.size(value, ctx);
        return [
          new $0e34a43d05bde82c$var$Ptr(0)
        ];
      }
      let ptr = null;
      this.offsetType = {
        encode: (stream3, val) => ptr = val
      };
      super.encode(stream2, value, ctx);
      return [
        new $0e34a43d05bde82c$var$Ptr(ptr)
      ];
    }
    constructor(type, options = {}) {
      if (options.type == null)
        options.type = "global";
      super(null, type, options);
    }
  };
  var $0e34a43d05bde82c$var$Ptr = class {
    valueOf() {
      return this.val;
    }
    constructor(val) {
      this.val = val;
      this.forceLarge = true;
    }
  };
  var $6d59db2e29cc77b3$var$CFFBlendOp = class {
    static decode(stream2, parent, operands) {
      let numBlends = operands.pop();
      while (operands.length > numBlends)
        operands.pop();
    }
  };
  var $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
    // key       name                    type                                          default
    [
      6,
      "BlueValues",
      "delta",
      null
    ],
    [
      7,
      "OtherBlues",
      "delta",
      null
    ],
    [
      8,
      "FamilyBlues",
      "delta",
      null
    ],
    [
      9,
      "FamilyOtherBlues",
      "delta",
      null
    ],
    [
      [
        12,
        9
      ],
      "BlueScale",
      "number",
      0.039625
    ],
    [
      [
        12,
        10
      ],
      "BlueShift",
      "number",
      7
    ],
    [
      [
        12,
        11
      ],
      "BlueFuzz",
      "number",
      1
    ],
    [
      10,
      "StdHW",
      "number",
      null
    ],
    [
      11,
      "StdVW",
      "number",
      null
    ],
    [
      [
        12,
        12
      ],
      "StemSnapH",
      "delta",
      null
    ],
    [
      [
        12,
        13
      ],
      "StemSnapV",
      "delta",
      null
    ],
    [
      [
        12,
        14
      ],
      "ForceBold",
      "boolean",
      false
    ],
    [
      [
        12,
        17
      ],
      "LanguageGroup",
      "number",
      0
    ],
    [
      [
        12,
        18
      ],
      "ExpansionFactor",
      "number",
      0.06
    ],
    [
      [
        12,
        19
      ],
      "initialRandomSeed",
      "number",
      0
    ],
    [
      20,
      "defaultWidthX",
      "number",
      0
    ],
    [
      21,
      "nominalWidthX",
      "number",
      0
    ],
    [
      22,
      "vsindex",
      "number",
      0
    ],
    [
      23,
      "blend",
      $6d59db2e29cc77b3$var$CFFBlendOp,
      null
    ],
    [
      19,
      "Subrs",
      new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(), {
        type: "local"
      }),
      null
    ]
  ]);
  var $229224aec43783c5$export$2e2bcd8739ae039 = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall",
    "001.000",
    "001.001",
    "001.002",
    "001.003",
    "Black",
    "Bold",
    "Book",
    "Light",
    "Medium",
    "Regular",
    "Roman",
    "Semibold"
  ];
  var $bc0433d9b7e41f5f$export$dee0027060fa13bd = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "",
    "questiondown",
    "",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "",
    "ring",
    "cedilla",
    "",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "AE",
    "",
    "ordfeminine",
    "",
    "",
    "",
    "",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "",
    "",
    "",
    "",
    "",
    "ae",
    "",
    "",
    "",
    "dotlessi",
    "",
    "",
    "lslash",
    "oslash",
    "oe",
    "germandbls"
  ];
  var $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "",
    "",
    "isuperior",
    "",
    "",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "",
    "",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "",
    "",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "",
    "Dotaccentsmall",
    "",
    "",
    "Macronsmall",
    "",
    "",
    "figuredash",
    "hypheninferior",
    "",
    "",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
  ];
  var $ef658f5c9a1488b2$export$c33b50336c234f16 = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron"
  ];
  var $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = [
    ".notdef",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
  ];
  var $ef658f5c9a1488b2$export$dc28be11139d4120 = [
    ".notdef",
    "space",
    "dollaroldstyle",
    "dollarsuperior",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "hyphensuperior",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "centoldstyle",
    "figuredash",
    "hypheninferior",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior"
  ];
  var $7cbbe4e24ef3cb75$var$LangSysTable = new Struct({
    reserved: new Reserved(uint16),
    reqFeatureIndex: uint16,
    featureCount: uint16,
    featureIndexes: new ArrayT(uint16, "featureCount")
  });
  var $7cbbe4e24ef3cb75$var$LangSysRecord = new Struct({
    tag: new StringT(4),
    langSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {
      type: "parent"
    })
  });
  var $7cbbe4e24ef3cb75$var$Script = new Struct({
    defaultLangSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable),
    count: uint16,
    langSysRecords: new ArrayT($7cbbe4e24ef3cb75$var$LangSysRecord, "count")
  });
  var $7cbbe4e24ef3cb75$var$ScriptRecord = new Struct({
    tag: new StringT(4),
    script: new Pointer(uint16, $7cbbe4e24ef3cb75$var$Script, {
      type: "parent"
    })
  });
  var $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new ArrayT($7cbbe4e24ef3cb75$var$ScriptRecord, uint16);
  var $7cbbe4e24ef3cb75$var$FeatureParams = new Struct({
    version: uint16,
    nameID: uint16
  });
  var $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new Struct({
    featureParams: new Pointer(uint16, $7cbbe4e24ef3cb75$var$FeatureParams),
    lookupCount: uint16,
    lookupListIndexes: new ArrayT(uint16, "lookupCount")
  });
  var $7cbbe4e24ef3cb75$var$FeatureRecord = new Struct({
    tag: new StringT(4),
    feature: new Pointer(uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
      type: "parent"
    })
  });
  var $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new ArrayT($7cbbe4e24ef3cb75$var$FeatureRecord, uint16);
  var $7cbbe4e24ef3cb75$var$LookupFlags = new Struct({
    markAttachmentType: uint8,
    flags: new Bitfield(uint8, [
      "rightToLeft",
      "ignoreBaseGlyphs",
      "ignoreLigatures",
      "ignoreMarks",
      "useMarkFilteringSet"
    ])
  });
  function $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {
    let Lookup = new Struct({
      lookupType: uint16,
      flags: $7cbbe4e24ef3cb75$var$LookupFlags,
      subTableCount: uint16,
      subTables: new ArrayT(new Pointer(uint16, SubTable), "subTableCount"),
      markFilteringSet: new Optional(uint16, (t) => t.flags.flags.useMarkFilteringSet)
    });
    return new LazyArray(new Pointer(uint16, Lookup), uint16);
  }
  var $7cbbe4e24ef3cb75$var$RangeRecord = new Struct({
    start: uint16,
    end: uint16,
    startCoverageIndex: uint16
  });
  var $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new VersionedStruct(uint16, {
    1: {
      glyphCount: uint16,
      glyphs: new ArrayT(uint16, "glyphCount")
    },
    2: {
      rangeCount: uint16,
      rangeRecords: new ArrayT($7cbbe4e24ef3cb75$var$RangeRecord, "rangeCount")
    }
  });
  var $7cbbe4e24ef3cb75$var$ClassRangeRecord = new Struct({
    start: uint16,
    end: uint16,
    class: uint16
  });
  var $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new VersionedStruct(uint16, {
    1: {
      startGlyph: uint16,
      glyphCount: uint16,
      classValueArray: new ArrayT(uint16, "glyphCount")
    },
    2: {
      classRangeCount: uint16,
      classRangeRecord: new ArrayT($7cbbe4e24ef3cb75$var$ClassRangeRecord, "classRangeCount")
    }
  });
  var $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new Struct({
    a: uint16,
    b: uint16,
    deltaFormat: uint16
  });
  var $7cbbe4e24ef3cb75$var$LookupRecord = new Struct({
    sequenceIndex: uint16,
    lookupListIndex: uint16
  });
  var $7cbbe4e24ef3cb75$var$Rule = new Struct({
    glyphCount: uint16,
    lookupCount: uint16,
    input: new ArrayT(uint16, (t) => t.glyphCount - 1),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  });
  var $7cbbe4e24ef3cb75$var$RuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$Rule), uint16);
  var $7cbbe4e24ef3cb75$var$ClassRule = new Struct({
    glyphCount: uint16,
    lookupCount: uint16,
    classes: new ArrayT(uint16, (t) => t.glyphCount - 1),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  });
  var $7cbbe4e24ef3cb75$var$ClassSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassRule), uint16);
  var $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      ruleSetCount: uint16,
      ruleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$RuleSet), "ruleSetCount")
    },
    2: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      classDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
      classSetCnt: uint16,
      classSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassSet), "classSetCnt")
    },
    3: {
      glyphCount: uint16,
      lookupCount: uint16,
      coverages: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "glyphCount"),
      lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
    }
  });
  var $7cbbe4e24ef3cb75$var$ChainRule = new Struct({
    backtrackGlyphCount: uint16,
    backtrack: new ArrayT(uint16, "backtrackGlyphCount"),
    inputGlyphCount: uint16,
    input: new ArrayT(uint16, (t) => t.inputGlyphCount - 1),
    lookaheadGlyphCount: uint16,
    lookahead: new ArrayT(uint16, "lookaheadGlyphCount"),
    lookupCount: uint16,
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  });
  var $7cbbe4e24ef3cb75$var$ChainRuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRule), uint16);
  var $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      chainCount: uint16,
      chainRuleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
    },
    2: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      backtrackClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
      inputClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
      lookaheadClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
      chainCount: uint16,
      chainClassSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
    },
    3: {
      backtrackGlyphCount: uint16,
      backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
      inputGlyphCount: uint16,
      inputCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "inputGlyphCount"),
      lookaheadGlyphCount: uint16,
      lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
      lookupCount: uint16,
      lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
    }
  });
  var $1a47b0c45c1c22fe$var$F2DOT14 = new Fixed(16, "BE", 14);
  var $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new Struct({
    startCoord: $1a47b0c45c1c22fe$var$F2DOT14,
    peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,
    endCoord: $1a47b0c45c1c22fe$var$F2DOT14
  });
  var $1a47b0c45c1c22fe$var$VariationRegionList = new Struct({
    axisCount: uint16,
    regionCount: uint16,
    variationRegions: new ArrayT(new ArrayT($1a47b0c45c1c22fe$var$RegionAxisCoordinates, "axisCount"), "regionCount")
  });
  var $1a47b0c45c1c22fe$var$DeltaSet = new Struct({
    shortDeltas: new ArrayT(int16, (t) => t.parent.shortDeltaCount),
    regionDeltas: new ArrayT(int8, (t) => t.parent.regionIndexCount - t.parent.shortDeltaCount),
    deltas: (t) => t.shortDeltas.concat(t.regionDeltas)
  });
  var $1a47b0c45c1c22fe$var$ItemVariationData = new Struct({
    itemCount: uint16,
    shortDeltaCount: uint16,
    regionIndexCount: uint16,
    regionIndexes: new ArrayT(uint16, "regionIndexCount"),
    deltaSets: new ArrayT($1a47b0c45c1c22fe$var$DeltaSet, "itemCount")
  });
  var $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new Struct({
    format: uint16,
    variationRegionList: new Pointer(uint32, $1a47b0c45c1c22fe$var$VariationRegionList),
    variationDataCount: uint16,
    itemVariationData: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ItemVariationData), "variationDataCount")
  });
  var $1a47b0c45c1c22fe$var$ConditionTable = new VersionedStruct(uint16, {
    1: {
      axisIndex: uint16,
      axisIndex: uint16,
      filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,
      filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14
    }
  });
  var $1a47b0c45c1c22fe$var$ConditionSet = new Struct({
    conditionCount: uint16,
    conditionTable: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionTable), "conditionCount")
  });
  var $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new Struct({
    featureIndex: uint16,
    alternateFeatureTable: new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$6e91cf7616333d5), {
      type: "parent"
    })
  });
  var $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new Struct({
    version: fixed32,
    substitutionCount: uint16,
    substitutions: new ArrayT($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, "substitutionCount")
  });
  var $1a47b0c45c1c22fe$var$FeatureVariationRecord = new Struct({
    conditionSet: new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionSet, {
      type: "parent"
    }),
    featureTableSubstitution: new Pointer(uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {
      type: "parent"
    })
  });
  var $1a47b0c45c1c22fe$export$441b70b7971dd419 = new Struct({
    majorVersion: uint16,
    minorVersion: uint16,
    featureVariationRecordCount: uint32,
    featureVariationRecords: new ArrayT($1a47b0c45c1c22fe$var$FeatureVariationRecord, "featureVariationRecordCount")
  });
  var $b84fd3dd9d8eddb2$var$PredefinedOp = class {
    decode(stream2, parent, operands) {
      if (this.predefinedOps[operands[0]])
        return this.predefinedOps[operands[0]];
      return this.type.decode(stream2, parent, operands);
    }
    size(value, ctx) {
      return this.type.size(value, ctx);
    }
    encode(stream2, value, ctx) {
      let index = this.predefinedOps.indexOf(value);
      if (index !== -1)
        return index;
      return this.type.encode(stream2, value, ctx);
    }
    constructor(predefinedOps, type) {
      this.predefinedOps = predefinedOps;
      this.type = type;
    }
  };
  var $b84fd3dd9d8eddb2$var$CFFEncodingVersion = class extends NumberT {
    decode(stream2) {
      return uint8.decode(stream2) & 127;
    }
    constructor() {
      super("UInt8");
    }
  };
  var $b84fd3dd9d8eddb2$var$Range1 = new Struct({
    first: uint16,
    nLeft: uint8
  });
  var $b84fd3dd9d8eddb2$var$Range2 = new Struct({
    first: uint16,
    nLeft: uint16
  });
  var $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {
    0: {
      nCodes: uint8,
      codes: new ArrayT(uint8, "nCodes")
    },
    1: {
      nRanges: uint8,
      ranges: new ArrayT($b84fd3dd9d8eddb2$var$Range1, "nRanges")
    }
  });
  var $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([
    (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd),
    (0, $bc0433d9b7e41f5f$export$4f58f497e14a53c3)
  ], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {
    lazy: true
  }));
  var $b84fd3dd9d8eddb2$var$RangeArray = class extends ArrayT {
    decode(stream2, parent) {
      let length = (0, resolveLength)(this.length, stream2, parent);
      let count = 0;
      let res = [];
      while (count < length) {
        let range2 = this.type.decode(stream2, parent);
        range2.offset = count;
        count += range2.nLeft + 1;
        res.push(range2);
      }
      return res;
    }
  };
  var $b84fd3dd9d8eddb2$var$CFFCustomCharset = new VersionedStruct(uint8, {
    0: {
      glyphs: new ArrayT(uint16, (t) => t.parent.CharStrings.length - 1)
    },
    1: {
      ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, (t) => t.parent.CharStrings.length - 1)
    },
    2: {
      ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, (t) => t.parent.CharStrings.length - 1)
    }
  });
  var $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([
    (0, $ef658f5c9a1488b2$export$c33b50336c234f16),
    (0, $ef658f5c9a1488b2$export$3ed0f9e1fee8d489),
    (0, $ef658f5c9a1488b2$export$dc28be11139d4120)
  ], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomCharset, {
    lazy: true
  }));
  var $b84fd3dd9d8eddb2$var$FDRange3 = new Struct({
    first: uint16,
    fd: uint8
  });
  var $b84fd3dd9d8eddb2$var$FDRange4 = new Struct({
    first: uint32,
    fd: uint16
  });
  var $b84fd3dd9d8eddb2$var$FDSelect = new VersionedStruct(uint8, {
    0: {
      fds: new ArrayT(uint8, (t) => t.parent.CharStrings.length)
    },
    3: {
      nRanges: uint16,
      ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange3, "nRanges"),
      sentinel: uint16
    },
    4: {
      nRanges: uint32,
      ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange4, "nRanges"),
      sentinel: uint32
    }
  });
  var $b84fd3dd9d8eddb2$var$ptr = new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)((0, $6d59db2e29cc77b3$export$2e2bcd8739ae039));
  var $b84fd3dd9d8eddb2$var$CFFPrivateOp = class {
    decode(stream2, parent, operands) {
      parent.length = operands[0];
      return $b84fd3dd9d8eddb2$var$ptr.decode(stream2, parent, [
        operands[1]
      ]);
    }
    size(dict, ctx) {
      return [
        (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
        $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx)[0]
      ];
    }
    encode(stream2, dict, ctx) {
      return [
        (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
        $b84fd3dd9d8eddb2$var$ptr.encode(stream2, dict, ctx)[0]
      ];
    }
  };
  var $b84fd3dd9d8eddb2$var$FontDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
    // key       name                   type(s)                                 default
    [
      18,
      "Private",
      new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
      null
    ],
    [
      [
        12,
        38
      ],
      "FontName",
      "sid",
      null
    ],
    [
      [
        12,
        7
      ],
      "FontMatrix",
      "array",
      [
        1e-3,
        0,
        0,
        1e-3,
        0,
        0
      ]
    ],
    [
      [
        12,
        5
      ],
      "PaintType",
      "number",
      0
    ]
  ]);
  var $b84fd3dd9d8eddb2$var$CFFTopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
    // key       name                   type(s)                                 default
    [
      [
        12,
        30
      ],
      "ROS",
      [
        "sid",
        "sid",
        "number"
      ],
      null
    ],
    [
      0,
      "version",
      "sid",
      null
    ],
    [
      1,
      "Notice",
      "sid",
      null
    ],
    [
      [
        12,
        0
      ],
      "Copyright",
      "sid",
      null
    ],
    [
      2,
      "FullName",
      "sid",
      null
    ],
    [
      3,
      "FamilyName",
      "sid",
      null
    ],
    [
      4,
      "Weight",
      "sid",
      null
    ],
    [
      [
        12,
        1
      ],
      "isFixedPitch",
      "boolean",
      false
    ],
    [
      [
        12,
        2
      ],
      "ItalicAngle",
      "number",
      0
    ],
    [
      [
        12,
        3
      ],
      "UnderlinePosition",
      "number",
      -100
    ],
    [
      [
        12,
        4
      ],
      "UnderlineThickness",
      "number",
      50
    ],
    [
      [
        12,
        5
      ],
      "PaintType",
      "number",
      0
    ],
    [
      [
        12,
        6
      ],
      "CharstringType",
      "number",
      2
    ],
    [
      [
        12,
        7
      ],
      "FontMatrix",
      "array",
      [
        1e-3,
        0,
        0,
        1e-3,
        0,
        0
      ]
    ],
    [
      13,
      "UniqueID",
      "number",
      null
    ],
    [
      5,
      "FontBBox",
      "array",
      [
        0,
        0,
        0,
        0
      ]
    ],
    [
      [
        12,
        8
      ],
      "StrokeWidth",
      "number",
      0
    ],
    [
      14,
      "XUID",
      "array",
      null
    ],
    [
      15,
      "charset",
      $b84fd3dd9d8eddb2$var$CFFCharset,
      (0, $ef658f5c9a1488b2$export$c33b50336c234f16)
    ],
    [
      16,
      "Encoding",
      $b84fd3dd9d8eddb2$var$CFFEncoding,
      (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd)
    ],
    [
      17,
      "CharStrings",
      new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
      null
    ],
    [
      18,
      "Private",
      new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
      null
    ],
    [
      [
        12,
        20
      ],
      "SyntheticBase",
      "number",
      null
    ],
    [
      [
        12,
        21
      ],
      "PostScript",
      "sid",
      null
    ],
    [
      [
        12,
        22
      ],
      "BaseFontName",
      "sid",
      null
    ],
    [
      [
        12,
        23
      ],
      "BaseFontBlend",
      "delta",
      null
    ],
    // CID font specific
    [
      [
        12,
        31
      ],
      "CIDFontVersion",
      "number",
      0
    ],
    [
      [
        12,
        32
      ],
      "CIDFontRevision",
      "number",
      0
    ],
    [
      [
        12,
        33
      ],
      "CIDFontType",
      "number",
      0
    ],
    [
      [
        12,
        34
      ],
      "CIDCount",
      "number",
      8720
    ],
    [
      [
        12,
        35
      ],
      "UIDBase",
      "number",
      null
    ],
    [
      [
        12,
        37
      ],
      "FDSelect",
      new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
      null
    ],
    [
      [
        12,
        36
      ],
      "FDArray",
      new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
      null
    ],
    [
      [
        12,
        38
      ],
      "FontName",
      "sid",
      null
    ]
  ]);
  var $b84fd3dd9d8eddb2$var$VariationStore = new Struct({
    length: uint16,
    itemVariationStore: (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
  });
  var $b84fd3dd9d8eddb2$var$CFF2TopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
    [
      [
        12,
        7
      ],
      "FontMatrix",
      "array",
      [
        1e-3,
        0,
        0,
        1e-3,
        0,
        0
      ]
    ],
    [
      17,
      "CharStrings",
      new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
      null
    ],
    [
      [
        12,
        37
      ],
      "FDSelect",
      new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
      null
    ],
    [
      [
        12,
        36
      ],
      "FDArray",
      new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
      null
    ],
    [
      24,
      "vstore",
      new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$VariationStore),
      null
    ],
    [
      25,
      "maxstack",
      "number",
      193
    ]
  ]);
  var $b84fd3dd9d8eddb2$var$CFFTop = new VersionedStruct(fixed16, {
    1: {
      hdrSize: uint8,
      offSize: uint8,
      nameIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
      topDictIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFTopDict),
      stringIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
      globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
    },
    2: {
      hdrSize: uint8,
      length: uint16,
      topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,
      globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
    }
  });
  var $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;
  var $822ac0d589e4e237$var$CFFFont = class _$822ac0d589e4e237$var$CFFFont {
    static decode(stream2) {
      return new _$822ac0d589e4e237$var$CFFFont(stream2);
    }
    decode() {
      let start = this.stream.pos;
      let top = (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).decode(this.stream);
      for (let key in top) {
        let val = top[key];
        this[key] = val;
      }
      if (this.version < 2) {
        if (this.topDictIndex.length !== 1)
          throw new Error("Only a single font is allowed in CFF");
        this.topDict = this.topDictIndex[0];
      }
      this.isCIDFont = this.topDict.ROS != null;
      return this;
    }
    string(sid) {
      if (this.version >= 2)
        return null;
      if (sid < (0, $229224aec43783c5$export$2e2bcd8739ae039).length)
        return (0, $229224aec43783c5$export$2e2bcd8739ae039)[sid];
      return this.stringIndex[sid - (0, $229224aec43783c5$export$2e2bcd8739ae039).length];
    }
    get postscriptName() {
      if (this.version < 2)
        return this.nameIndex[0];
      return null;
    }
    get fullName() {
      return this.string(this.topDict.FullName);
    }
    get familyName() {
      return this.string(this.topDict.FamilyName);
    }
    getCharString(glyph) {
      this.stream.pos = this.topDict.CharStrings[glyph].offset;
      return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
    }
    getGlyphName(gid) {
      if (this.version >= 2)
        return null;
      if (this.isCIDFont)
        return null;
      let { charset } = this.topDict;
      if (Array.isArray(charset))
        return charset[gid];
      if (gid === 0)
        return ".notdef";
      gid -= 1;
      switch (charset.version) {
        case 0:
          return this.string(charset.glyphs[gid]);
        case 1:
        case 2:
          for (let i = 0; i < charset.ranges.length; i++) {
            let range2 = charset.ranges[i];
            if (range2.offset <= gid && gid <= range2.offset + range2.nLeft)
              return this.string(range2.first + (gid - range2.offset));
          }
          break;
      }
      return null;
    }
    fdForGlyph(gid) {
      if (!this.topDict.FDSelect)
        return null;
      switch (this.topDict.FDSelect.version) {
        case 0:
          return this.topDict.FDSelect.fds[gid];
        case 3:
        case 4:
          let { ranges } = this.topDict.FDSelect;
          let low = 0;
          let high = ranges.length - 1;
          while (low <= high) {
            let mid = low + high >> 1;
            if (gid < ranges[mid].first)
              high = mid - 1;
            else if (mid < high && gid >= ranges[mid + 1].first)
              low = mid + 1;
            else
              return ranges[mid].fd;
          }
        default:
          throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
      }
    }
    privateDictForGlyph(gid) {
      if (this.topDict.FDSelect) {
        let fd = this.fdForGlyph(gid);
        if (this.topDict.FDArray[fd])
          return this.topDict.FDArray[fd].Private;
        return null;
      }
      if (this.version < 2)
        return this.topDict.Private;
      return this.topDict.FDArray[0].Private;
    }
    constructor(stream2) {
      this.stream = stream2;
      this.decode();
    }
  };
  var $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;
  var $2bbf2bc1ce37cd8f$var$VerticalOrigin = new Struct({
    glyphIndex: uint16,
    vertOriginY: int16
  });
  var $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new Struct({
    majorVersion: uint16,
    minorVersion: uint16,
    defaultVertOriginY: int16,
    numVertOriginYMetrics: uint16,
    metrics: new ArrayT($2bbf2bc1ce37cd8f$var$VerticalOrigin, "numVertOriginYMetrics")
  });
  var $0941618dc22a946d$export$16b227cb15d716a0 = new Struct({
    height: uint8,
    width: uint8,
    horiBearingX: int8,
    horiBearingY: int8,
    horiAdvance: uint8,
    vertBearingX: int8,
    vertBearingY: int8,
    vertAdvance: uint8
  });
  var $0941618dc22a946d$export$62c53e75f69bfe12 = new Struct({
    height: uint8,
    width: uint8,
    bearingX: int8,
    bearingY: int8,
    advance: uint8
  });
  var $0941618dc22a946d$var$EBDTComponent = new Struct({
    glyph: uint16,
    xOffset: int8,
    yOffset: int8
  });
  var $0941618dc22a946d$var$ByteAligned = class {
  };
  var $0941618dc22a946d$var$BitAligned = class {
  };
  var $0941618dc22a946d$export$f1f5ddeb20d14f = new VersionedStruct("version", {
    1: {
      metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
      data: $0941618dc22a946d$var$ByteAligned
    },
    2: {
      metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
      data: $0941618dc22a946d$var$BitAligned
    },
    // format 3 is deprecated
    // format 4 is not supported by Microsoft
    5: {
      data: $0941618dc22a946d$var$BitAligned
    },
    6: {
      metrics: $0941618dc22a946d$export$16b227cb15d716a0,
      data: $0941618dc22a946d$var$ByteAligned
    },
    7: {
      metrics: $0941618dc22a946d$export$16b227cb15d716a0,
      data: $0941618dc22a946d$var$BitAligned
    },
    8: {
      metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
      pad: new Reserved(uint8),
      numComponents: uint16,
      components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
    },
    9: {
      metrics: $0941618dc22a946d$export$16b227cb15d716a0,
      pad: new Reserved(uint8),
      numComponents: uint16,
      components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
    },
    17: {
      metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
      dataLen: uint32,
      data: new BufferT("dataLen")
    },
    18: {
      metrics: $0941618dc22a946d$export$16b227cb15d716a0,
      dataLen: uint32,
      data: new BufferT("dataLen")
    },
    19: {
      dataLen: uint32,
      data: new BufferT("dataLen")
    }
  });
  var $9911c4c7201c13de$var$SBitLineMetrics = new Struct({
    ascender: int8,
    descender: int8,
    widthMax: uint8,
    caretSlopeNumerator: int8,
    caretSlopeDenominator: int8,
    caretOffset: int8,
    minOriginSB: int8,
    minAdvanceSB: int8,
    maxBeforeBL: int8,
    minAfterBL: int8,
    pad: new Reserved(int8, 2)
  });
  var $9911c4c7201c13de$var$CodeOffsetPair = new Struct({
    glyphCode: uint16,
    offset: uint16
  });
  var $9911c4c7201c13de$var$IndexSubtable = new VersionedStruct(uint16, {
    header: {
      imageFormat: uint16,
      imageDataOffset: uint32
    },
    1: {
      offsetArray: new ArrayT(uint32, (t) => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)
    },
    2: {
      imageSize: uint32,
      bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0)
    },
    3: {
      offsetArray: new ArrayT(uint16, (t) => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)
    },
    4: {
      numGlyphs: uint32,
      glyphArray: new ArrayT($9911c4c7201c13de$var$CodeOffsetPair, (t) => t.numGlyphs + 1)
    },
    5: {
      imageSize: uint32,
      bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0),
      numGlyphs: uint32,
      glyphCodeArray: new ArrayT(uint16, "numGlyphs")
    }
  });
  var $9911c4c7201c13de$var$IndexSubtableArray = new Struct({
    firstGlyphIndex: uint16,
    lastGlyphIndex: uint16,
    subtable: new Pointer(uint32, $9911c4c7201c13de$var$IndexSubtable)
  });
  var $9911c4c7201c13de$var$BitmapSizeTable = new Struct({
    indexSubTableArray: new Pointer(uint32, new ArrayT($9911c4c7201c13de$var$IndexSubtableArray, 1), {
      type: "parent"
    }),
    indexTablesSize: uint32,
    numberOfIndexSubTables: uint32,
    colorRef: uint32,
    hori: $9911c4c7201c13de$var$SBitLineMetrics,
    vert: $9911c4c7201c13de$var$SBitLineMetrics,
    startGlyphIndex: uint16,
    endGlyphIndex: uint16,
    ppemX: uint8,
    ppemY: uint8,
    bitDepth: uint8,
    flags: new Bitfield(uint8, [
      "horizontal",
      "vertical"
    ])
  });
  var $9911c4c7201c13de$export$2e2bcd8739ae039 = new Struct({
    version: uint32,
    numSizes: uint32,
    sizes: new ArrayT($9911c4c7201c13de$var$BitmapSizeTable, "numSizes")
  });
  var $abb847051efd51b1$var$ImageTable = new Struct({
    ppem: uint16,
    resolution: uint16,
    imageOffsets: new ArrayT(new Pointer(uint32, "void"), (t) => t.parent.parent.maxp.numGlyphs + 1)
  });
  var $abb847051efd51b1$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    flags: new Bitfield(uint16, [
      "renderOutlines"
    ]),
    numImgTables: uint32,
    imageTables: new ArrayT(new Pointer(uint32, $abb847051efd51b1$var$ImageTable), "numImgTables")
  });
  var $eb629188f3dfefdd$var$LayerRecord = new Struct({
    gid: uint16,
    paletteIndex: uint16
    // Index value to use in the appropriate palette. This value must
  });
  var $eb629188f3dfefdd$var$BaseGlyphRecord = new Struct({
    gid: uint16,
    // and is not rendered for color.
    firstLayerIndex: uint16,
    // There will be numLayers consecutive entries for this base glyph.
    numLayers: uint16
  });
  var $eb629188f3dfefdd$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    numBaseGlyphRecords: uint16,
    baseGlyphRecord: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$BaseGlyphRecord, "numBaseGlyphRecords")),
    layerRecords: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$LayerRecord, "numLayerRecords"), {
      lazy: true
    }),
    numLayerRecords: uint16
  });
  var $08734b8e7dc64587$var$ColorRecord = new Struct({
    blue: uint8,
    green: uint8,
    red: uint8,
    alpha: uint8
  });
  var $08734b8e7dc64587$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
    header: {
      numPaletteEntries: uint16,
      numPalettes: uint16,
      numColorRecords: uint16,
      colorRecords: new Pointer(uint32, new ArrayT($08734b8e7dc64587$var$ColorRecord, "numColorRecords")),
      colorRecordIndices: new ArrayT(uint16, "numPalettes")
    },
    0: {},
    1: {
      offsetPaletteTypeArray: new Pointer(uint32, new ArrayT(uint32, "numPalettes")),
      offsetPaletteLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPalettes")),
      offsetPaletteEntryLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPaletteEntries"))
    }
  });
  var $497cef411d884e34$var$BaseCoord = new VersionedStruct(uint16, {
    1: {
      coordinate: int16
      // X or Y value, in design units
    },
    2: {
      coordinate: int16,
      referenceGlyph: uint16,
      baseCoordPoint: uint16
      // Index of contour point on the referenceGlyph
    },
    3: {
      coordinate: int16,
      deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
      // Device table for X or Y value
    }
  });
  var $497cef411d884e34$var$BaseValues = new Struct({
    defaultIndex: uint16,
    baseCoordCount: uint16,
    baseCoords: new ArrayT(new Pointer(uint16, $497cef411d884e34$var$BaseCoord), "baseCoordCount")
  });
  var $497cef411d884e34$var$FeatMinMaxRecord = new Struct({
    tag: new StringT(4),
    minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
      type: "parent"
    }),
    maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
      type: "parent"
    })
    // May be NULL
  });
  var $497cef411d884e34$var$MinMax = new Struct({
    minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
    maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
    featMinMaxCount: uint16,
    featMinMaxRecords: new ArrayT($497cef411d884e34$var$FeatMinMaxRecord, "featMinMaxCount")
    // In alphabetical order
  });
  var $497cef411d884e34$var$BaseLangSysRecord = new Struct({
    tag: new StringT(4),
    minMax: new Pointer(uint16, $497cef411d884e34$var$MinMax, {
      type: "parent"
    })
  });
  var $497cef411d884e34$var$BaseScript = new Struct({
    baseValues: new Pointer(uint16, $497cef411d884e34$var$BaseValues),
    defaultMinMax: new Pointer(uint16, $497cef411d884e34$var$MinMax),
    baseLangSysCount: uint16,
    baseLangSysRecords: new ArrayT($497cef411d884e34$var$BaseLangSysRecord, "baseLangSysCount")
    // in alphabetical order by BaseLangSysTag
  });
  var $497cef411d884e34$var$BaseScriptRecord = new Struct({
    tag: new StringT(4),
    script: new Pointer(uint16, $497cef411d884e34$var$BaseScript, {
      type: "parent"
    })
  });
  var $497cef411d884e34$var$BaseScriptList = new ArrayT($497cef411d884e34$var$BaseScriptRecord, uint16);
  var $497cef411d884e34$var$BaseTagList = new ArrayT(new StringT(4), uint16);
  var $497cef411d884e34$var$Axis = new Struct({
    baseTagList: new Pointer(uint16, $497cef411d884e34$var$BaseTagList),
    baseScriptList: new Pointer(uint16, $497cef411d884e34$var$BaseScriptList)
  });
  var $497cef411d884e34$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
    header: {
      horizAxis: new Pointer(uint16, $497cef411d884e34$var$Axis),
      vertAxis: new Pointer(uint16, $497cef411d884e34$var$Axis)
      // May be NULL
    },
    65536: {},
    65537: {
      itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
    }
  });
  var $cf5f33c63ef209e6$var$AttachPoint = new ArrayT(uint16, uint16);
  var $cf5f33c63ef209e6$var$AttachList = new Struct({
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    glyphCount: uint16,
    attachPoints: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$AttachPoint), "glyphCount")
  });
  var $cf5f33c63ef209e6$var$CaretValue = new VersionedStruct(uint16, {
    1: {
      coordinate: int16
    },
    2: {
      caretValuePoint: uint16
    },
    3: {
      coordinate: int16,
      deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
    }
  });
  var $cf5f33c63ef209e6$var$LigGlyph = new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$CaretValue), uint16);
  var $cf5f33c63ef209e6$var$LigCaretList = new Struct({
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    ligGlyphCount: uint16,
    ligGlyphs: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$LigGlyph), "ligGlyphCount")
  });
  var $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new Struct({
    markSetTableFormat: uint16,
    markSetCount: uint16,
    coverage: new ArrayT(new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "markSetCount")
  });
  var $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
    header: {
      glyphClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      attachList: new Pointer(uint16, $cf5f33c63ef209e6$var$AttachList),
      ligCaretList: new Pointer(uint16, $cf5f33c63ef209e6$var$LigCaretList),
      markAttachClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71))
    },
    65536: {},
    65538: {
      markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)
    },
    65539: {
      markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),
      itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
    }
  });
  var $47e0e8ef515d9903$var$ValueFormat = new Bitfield(uint16, [
    "xPlacement",
    "yPlacement",
    "xAdvance",
    "yAdvance",
    "xPlaDevice",
    "yPlaDevice",
    "xAdvDevice",
    "yAdvDevice"
  ]);
  var $47e0e8ef515d9903$var$types = {
    xPlacement: int16,
    yPlacement: int16,
    xAdvance: int16,
    yAdvance: int16,
    xPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
      type: "global",
      relativeTo: (ctx) => ctx.rel
    }),
    yPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
      type: "global",
      relativeTo: (ctx) => ctx.rel
    }),
    xAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
      type: "global",
      relativeTo: (ctx) => ctx.rel
    }),
    yAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
      type: "global",
      relativeTo: (ctx) => ctx.rel
    })
  };
  var $47e0e8ef515d9903$var$ValueRecord = class {
    buildStruct(parent) {
      let struct = parent;
      while (!struct[this.key] && struct.parent)
        struct = struct.parent;
      if (!struct[this.key])
        return;
      let fields = {};
      fields.rel = () => struct._startOffset;
      let format = struct[this.key];
      for (let key in format)
        if (format[key])
          fields[key] = $47e0e8ef515d9903$var$types[key];
      return new Struct(fields);
    }
    size(val, ctx) {
      return this.buildStruct(ctx).size(val, ctx);
    }
    decode(stream2, parent) {
      let res = this.buildStruct(parent).decode(stream2, parent);
      delete res.rel;
      return res;
    }
    constructor(key = "valueFormat") {
      this.key = key;
    }
  };
  var $47e0e8ef515d9903$var$PairValueRecord = new Struct({
    secondGlyph: uint16,
    value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
    value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
  });
  var $47e0e8ef515d9903$var$PairSet = new ArrayT($47e0e8ef515d9903$var$PairValueRecord, uint16);
  var $47e0e8ef515d9903$var$Class2Record = new Struct({
    value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
    value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
  });
  var $47e0e8ef515d9903$var$Anchor = new VersionedStruct(uint16, {
    1: {
      xCoordinate: int16,
      yCoordinate: int16
    },
    2: {
      xCoordinate: int16,
      yCoordinate: int16,
      anchorPoint: uint16
    },
    3: {
      xCoordinate: int16,
      yCoordinate: int16,
      xDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)),
      yDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
    }
  });
  var $47e0e8ef515d9903$var$EntryExitRecord = new Struct({
    entryAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
      type: "parent"
    }),
    exitAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
      type: "parent"
    })
  });
  var $47e0e8ef515d9903$var$MarkRecord = new Struct({
    class: uint16,
    markAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
      type: "parent"
    })
  });
  var $47e0e8ef515d9903$var$MarkArray = new ArrayT($47e0e8ef515d9903$var$MarkRecord, uint16);
  var $47e0e8ef515d9903$var$BaseRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t) => t.parent.classCount);
  var $47e0e8ef515d9903$var$BaseArray = new ArrayT($47e0e8ef515d9903$var$BaseRecord, uint16);
  var $47e0e8ef515d9903$var$ComponentRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t) => t.parent.parent.classCount);
  var $47e0e8ef515d9903$var$LigatureAttach = new ArrayT($47e0e8ef515d9903$var$ComponentRecord, uint16);
  var $47e0e8ef515d9903$var$LigatureArray = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$LigatureAttach), uint16);
  var $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new VersionedStruct("lookupType", {
    1: new VersionedStruct(uint16, {
      1: {
        coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
        valueFormat: $47e0e8ef515d9903$var$ValueFormat,
        value: new $47e0e8ef515d9903$var$ValueRecord()
      },
      2: {
        coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
        valueFormat: $47e0e8ef515d9903$var$ValueFormat,
        valueCount: uint16,
        values: new LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), "valueCount")
      }
    }),
    2: new VersionedStruct(uint16, {
      1: {
        coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
        valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
        valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
        pairSetCount: uint16,
        pairSets: new LazyArray(new Pointer(uint16, $47e0e8ef515d9903$var$PairSet), "pairSetCount")
      },
      2: {
        coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
        valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
        valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
        classDef1: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
        classDef2: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
        class1Count: uint16,
        class2Count: uint16,
        classRecords: new LazyArray(new LazyArray($47e0e8ef515d9903$var$Class2Record, "class2Count"), "class1Count")
      }
    }),
    3: {
      format: uint16,
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      entryExitCount: uint16,
      entryExitRecords: new ArrayT($47e0e8ef515d9903$var$EntryExitRecord, "entryExitCount")
    },
    4: {
      format: uint16,
      markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      baseCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      classCount: uint16,
      markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
      baseArray: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
    },
    5: {
      format: uint16,
      markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      ligatureCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      classCount: uint16,
      markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
      ligatureArray: new Pointer(uint16, $47e0e8ef515d9903$var$LigatureArray)
    },
    6: {
      format: uint16,
      mark1Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      mark2Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      classCount: uint16,
      mark1Array: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
      mark2Array: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
    },
    7: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
    8: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
    9: {
      posFormat: uint16,
      lookupType: uint16,
      extension: new Pointer(uint32, null)
    }
  });
  $47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;
  var $47e0e8ef515d9903$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
    header: {
      scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
      featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
      lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
    },
    65536: {},
    65537: {
      featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
    }
  });
  var $d3f442064af66e06$var$Sequence = new ArrayT(uint16, uint16);
  var $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;
  var $d3f442064af66e06$var$Ligature = new Struct({
    glyph: uint16,
    compCount: uint16,
    components: new ArrayT(uint16, (t) => t.compCount - 1)
  });
  var $d3f442064af66e06$var$LigatureSet = new ArrayT(new Pointer(uint16, $d3f442064af66e06$var$Ligature), uint16);
  var $d3f442064af66e06$var$GSUBLookup = new VersionedStruct("lookupType", {
    1: new VersionedStruct(uint16, {
      1: {
        coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
        deltaGlyphID: int16
      },
      2: {
        coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
        glyphCount: uint16,
        substitute: new LazyArray(uint16, "glyphCount")
      }
    }),
    2: {
      substFormat: uint16,
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      count: uint16,
      sequences: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$Sequence), "count")
    },
    3: {
      substFormat: uint16,
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      count: uint16,
      alternateSet: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$AlternateSet), "count")
    },
    4: {
      substFormat: uint16,
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      count: uint16,
      ligatureSets: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$LigatureSet), "count")
    },
    5: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
    6: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
    7: {
      substFormat: uint16,
      lookupType: uint16,
      extension: new Pointer(uint32, null)
    },
    8: {
      substFormat: uint16,
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      backtrackCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "backtrackGlyphCount"),
      lookaheadGlyphCount: uint16,
      lookaheadCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "lookaheadGlyphCount"),
      glyphCount: uint16,
      substitutes: new ArrayT(uint16, "glyphCount")
    }
  });
  $d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;
  var $d3f442064af66e06$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
    header: {
      scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
      featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
      lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($d3f442064af66e06$var$GSUBLookup))
    },
    65536: {},
    65537: {
      featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
    }
  });
  var $71cfb3c4767fbd0c$var$JstfGSUBModList = new ArrayT(uint16, uint16);
  var $71cfb3c4767fbd0c$var$JstfPriority = new Struct({
    shrinkageEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
    shrinkageDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
    shrinkageEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
    shrinkageDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
    shrinkageJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f))),
    extensionEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
    extensionDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
    extensionEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
    extensionDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
    extensionJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f)))
  });
  var $71cfb3c4767fbd0c$var$JstfLangSys = new ArrayT(new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfPriority), uint16);
  var $71cfb3c4767fbd0c$var$JstfLangSysRecord = new Struct({
    tag: new StringT(4),
    jstfLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys)
  });
  var $71cfb3c4767fbd0c$var$JstfScript = new Struct({
    extenderGlyphs: new Pointer(uint16, new ArrayT(uint16, uint16)),
    defaultLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys),
    langSysCount: uint16,
    langSysRecords: new ArrayT($71cfb3c4767fbd0c$var$JstfLangSysRecord, "langSysCount")
  });
  var $71cfb3c4767fbd0c$var$JstfScriptRecord = new Struct({
    tag: new StringT(4),
    script: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfScript, {
      type: "parent"
    })
  });
  var $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new Struct({
    version: uint32,
    scriptCount: uint16,
    scriptList: new ArrayT($71cfb3c4767fbd0c$var$JstfScriptRecord, "scriptCount")
  });
  var $d059a6bd2d3b5b63$var$VariableSizeNumber = class {
    decode(stream2, parent) {
      switch (this.size(0, parent)) {
        case 1:
          return stream2.readUInt8();
        case 2:
          return stream2.readUInt16BE();
        case 3:
          return stream2.readUInt24BE();
        case 4:
          return stream2.readUInt32BE();
      }
    }
    size(val, parent) {
      return (0, resolveLength)(this._size, null, parent);
    }
    constructor(size) {
      this._size = size;
    }
  };
  var $d059a6bd2d3b5b63$var$MapDataEntry = new Struct({
    entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber((t) => ((t.parent.entryFormat & 48) >> 4) + 1),
    outerIndex: (t) => t.entry >> (t.parent.entryFormat & 15) + 1,
    innerIndex: (t) => t.entry & (1 << (t.parent.entryFormat & 15) + 1) - 1
  });
  var $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new Struct({
    entryFormat: uint16,
    mapCount: uint16,
    mapData: new ArrayT($d059a6bd2d3b5b63$var$MapDataEntry, "mapCount")
  });
  var $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new Struct({
    majorVersion: uint16,
    minorVersion: uint16,
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)),
    advanceWidthMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
    LSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
    RSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)
  });
  var $dceeca3e1977ce30$var$Signature = new Struct({
    format: uint32,
    length: uint32,
    offset: uint32
  });
  var $dceeca3e1977ce30$var$SignatureBlock = new Struct({
    reserved: new Reserved(uint16, 2),
    cbSignature: uint32,
    signature: new BufferT("cbSignature")
  });
  var $dceeca3e1977ce30$export$2e2bcd8739ae039 = new Struct({
    ulVersion: uint32,
    usNumSigs: uint16,
    usFlag: uint16,
    signatures: new ArrayT($dceeca3e1977ce30$var$Signature, "usNumSigs"),
    signatureBlocks: new ArrayT($dceeca3e1977ce30$var$SignatureBlock, "usNumSigs")
  });
  var $8acd740a9435aad0$var$GaspRange = new Struct({
    rangeMaxPPEM: uint16,
    rangeGaspBehavior: new Bitfield(uint16, [
      "grayscale",
      "gridfit",
      "symmetricSmoothing",
      "symmetricGridfit"
      // only in version 1, for ClearType
    ])
  });
  var $8acd740a9435aad0$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    numRanges: uint16,
    gaspRanges: new ArrayT($8acd740a9435aad0$var$GaspRange, "numRanges")
    // Sorted by ppem
  });
  var $b5f380243c34d6a0$var$DeviceRecord = new Struct({
    pixelSize: uint8,
    maximumWidth: uint8,
    widths: new ArrayT(uint8, (t) => t.parent.parent.maxp.numGlyphs)
  });
  var $b5f380243c34d6a0$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    numRecords: int16,
    sizeDeviceRecord: int32,
    records: new ArrayT($b5f380243c34d6a0$var$DeviceRecord, "numRecords")
  });
  var $ca2df1256966e313$var$KernPair = new Struct({
    left: uint16,
    right: uint16,
    value: int16
  });
  var $ca2df1256966e313$var$ClassTable = new Struct({
    firstGlyph: uint16,
    nGlyphs: uint16,
    offsets: new ArrayT(uint16, "nGlyphs"),
    max: (t) => t.offsets.length && Math.max.apply(Math, t.offsets)
  });
  var $ca2df1256966e313$var$Kern2Array = new Struct({
    off: (t) => t._startOffset - t.parent.parent._startOffset,
    len: (t) => ((t.parent.leftTable.max - t.off) / t.parent.rowWidth + 1) * (t.parent.rowWidth / 2),
    values: new LazyArray(int16, "len")
  });
  var $ca2df1256966e313$var$KernSubtable = new VersionedStruct("format", {
    0: {
      nPairs: uint16,
      searchRange: uint16,
      entrySelector: uint16,
      rangeShift: uint16,
      pairs: new ArrayT($ca2df1256966e313$var$KernPair, "nPairs")
    },
    2: {
      rowWidth: uint16,
      leftTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
        type: "parent"
      }),
      rightTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
        type: "parent"
      }),
      array: new Pointer(uint16, $ca2df1256966e313$var$Kern2Array, {
        type: "parent"
      })
    },
    3: {
      glyphCount: uint16,
      kernValueCount: uint8,
      leftClassCount: uint8,
      rightClassCount: uint8,
      flags: uint8,
      kernValue: new ArrayT(int16, "kernValueCount"),
      leftClass: new ArrayT(uint8, "glyphCount"),
      rightClass: new ArrayT(uint8, "glyphCount"),
      kernIndex: new ArrayT(uint8, (t) => t.leftClassCount * t.rightClassCount)
    }
  });
  var $ca2df1256966e313$var$KernTable = new VersionedStruct("version", {
    0: {
      subVersion: uint16,
      length: uint16,
      format: uint8,
      coverage: new Bitfield(uint8, [
        "horizontal",
        "minimum",
        "crossStream",
        "override"
        // If set to 1 the value in this table replaces the accumulated value
      ]),
      subtable: $ca2df1256966e313$var$KernSubtable,
      padding: new Reserved(uint8, (t) => t.length - t._currentOffset)
    },
    1: {
      length: uint32,
      coverage: new Bitfield(uint8, [
        null,
        null,
        null,
        null,
        null,
        "variation",
        "crossStream",
        "vertical"
        // Set if table has vertical kerning values
      ]),
      format: uint8,
      tupleIndex: uint16,
      subtable: $ca2df1256966e313$var$KernSubtable,
      padding: new Reserved(uint8, (t) => t.length - t._currentOffset)
    }
  });
  var $ca2df1256966e313$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
    0: {
      nTables: uint16,
      tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
    },
    1: {
      reserved: new Reserved(uint16),
      nTables: uint32,
      tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
    }
  });
  var $7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    numGlyphs: uint16,
    yPels: new ArrayT(uint8, "numGlyphs")
  });
  var $2b2ccc419d152631$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    fontNumber: uint32,
    pitch: uint16,
    xHeight: uint16,
    style: uint16,
    typeFamily: uint16,
    capHeight: uint16,
    symbolSet: uint16,
    typeface: new StringT(16),
    characterComplement: new StringT(8),
    fileName: new StringT(6),
    strokeWeight: new StringT(1),
    widthType: new StringT(1),
    serifStyle: uint8,
    reserved: new Reserved(uint8)
  });
  var $ca5b40b9bcda9c9b$var$Ratio = new Struct({
    bCharSet: uint8,
    xRatio: uint8,
    yStartRatio: uint8,
    yEndRatio: uint8
    // Ending y-Ratio value
  });
  var $ca5b40b9bcda9c9b$var$vTable = new Struct({
    yPelHeight: uint16,
    yMax: int16,
    yMin: int16
    // Minimum value (in pels) for this yPelHeight
  });
  var $ca5b40b9bcda9c9b$var$VdmxGroup = new Struct({
    recs: uint16,
    startsz: uint8,
    endsz: uint8,
    entries: new ArrayT($ca5b40b9bcda9c9b$var$vTable, "recs")
    // The VDMX records
  });
  var $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    numRecs: uint16,
    numRatios: uint16,
    ratioRanges: new ArrayT($ca5b40b9bcda9c9b$var$Ratio, "numRatios"),
    offsets: new ArrayT(uint16, "numRatios"),
    groups: new ArrayT($ca5b40b9bcda9c9b$var$VdmxGroup, "numRecs")
    // The actual VDMX groupings
  });
  var $69530a3c40755af0$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    ascent: int16,
    descent: int16,
    lineGap: int16,
    advanceHeightMax: int16,
    minTopSideBearing: int16,
    minBottomSideBearing: int16,
    yMaxExtent: int16,
    caretSlopeRise: int16,
    caretSlopeRun: int16,
    caretOffset: int16,
    reserved: new Reserved(int16, 4),
    metricDataFormat: int16,
    numberOfMetrics: uint16
    // Number of advance heights in the Vertical Metrics table
  });
  var $344073dd270f0e62$var$VmtxEntry = new Struct({
    advance: uint16,
    bearing: int16
    // The top sidebearing of the glyph
  });
  var $344073dd270f0e62$export$2e2bcd8739ae039 = new Struct({
    metrics: new LazyArray($344073dd270f0e62$var$VmtxEntry, (t) => t.parent.vhea.numberOfMetrics),
    bearings: new LazyArray(int16, (t) => t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics)
  });
  var $3793b781918cfced$var$shortFrac = new Fixed(16, "BE", 14);
  var $3793b781918cfced$var$Correspondence = new Struct({
    fromCoord: $3793b781918cfced$var$shortFrac,
    toCoord: $3793b781918cfced$var$shortFrac
  });
  var $3793b781918cfced$var$Segment = new Struct({
    pairCount: uint16,
    correspondence: new ArrayT($3793b781918cfced$var$Correspondence, "pairCount")
  });
  var $3793b781918cfced$export$2e2bcd8739ae039 = new Struct({
    version: fixed32,
    axisCount: uint32,
    segment: new ArrayT($3793b781918cfced$var$Segment, "axisCount")
  });
  var $6cb7dd5f47d82580$var$UnboundedArrayAccessor = class {
    getItem(index) {
      if (this._items[index] == null) {
        let pos = this.stream.pos;
        this.stream.pos = this.base + this.type.size(null, this.parent) * index;
        this._items[index] = this.type.decode(this.stream, this.parent);
        this.stream.pos = pos;
      }
      return this._items[index];
    }
    inspect() {
      return `[UnboundedArray ${this.type.constructor.name}]`;
    }
    constructor(type, stream2, parent) {
      this.type = type;
      this.stream = stream2;
      this.parent = parent;
      this.base = this.stream.pos;
      this._items = [];
    }
  };
  var $6cb7dd5f47d82580$export$c5af1eebc882e39a = class extends ArrayT {
    decode(stream2, parent) {
      return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream2, parent);
    }
    constructor(type) {
      super(type, 0);
    }
  };
  var $6cb7dd5f47d82580$export$8351f8c2ae2f103c = function(ValueType = uint16) {
    class Shadow {
      decode(stream2, ctx) {
        ctx = ctx.parent.parent;
        return this.type.decode(stream2, ctx);
      }
      size(val, ctx) {
        ctx = ctx.parent.parent;
        return this.type.size(val, ctx);
      }
      encode(stream2, val, ctx) {
        ctx = ctx.parent.parent;
        return this.type.encode(stream2, val, ctx);
      }
      constructor(type) {
        this.type = type;
      }
    }
    ValueType = new Shadow(ValueType);
    let BinarySearchHeader = new Struct({
      unitSize: uint16,
      nUnits: uint16,
      searchRange: uint16,
      entrySelector: uint16,
      rangeShift: uint16
    });
    let LookupSegmentSingle = new Struct({
      lastGlyph: uint16,
      firstGlyph: uint16,
      value: ValueType
    });
    let LookupSegmentArray = new Struct({
      lastGlyph: uint16,
      firstGlyph: uint16,
      values: new Pointer(uint16, new ArrayT(ValueType, (t) => t.lastGlyph - t.firstGlyph + 1), {
        type: "parent"
      })
    });
    let LookupSingle = new Struct({
      glyph: uint16,
      value: ValueType
    });
    return new VersionedStruct(uint16, {
      0: {
        values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType)
        // length == number of glyphs maybe?
      },
      2: {
        binarySearchHeader: BinarySearchHeader,
        segments: new ArrayT(LookupSegmentSingle, (t) => t.binarySearchHeader.nUnits)
      },
      4: {
        binarySearchHeader: BinarySearchHeader,
        segments: new ArrayT(LookupSegmentArray, (t) => t.binarySearchHeader.nUnits)
      },
      6: {
        binarySearchHeader: BinarySearchHeader,
        segments: new ArrayT(LookupSingle, (t) => t.binarySearchHeader.nUnits)
      },
      8: {
        firstGlyph: uint16,
        count: uint16,
        values: new ArrayT(ValueType, "count")
      }
    });
  };
  function $6cb7dd5f47d82580$export$79f7d93d790934ba(entryData = {}, lookupType = uint16) {
    let entry = Object.assign({
      newState: uint16,
      flags: uint16
    }, entryData);
    let Entry = new Struct(entry);
    let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint16, (t) => t.nClasses));
    let StateHeader = new Struct({
      nClasses: uint32,
      classTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),
      stateArray: new Pointer(uint32, StateArray),
      entryTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
    });
    return StateHeader;
  }
  function $6cb7dd5f47d82580$export$105027425199cc51(entryData = {}, lookupType = uint16) {
    let ClassLookupTable = new Struct({
      version() {
        return 8;
      },
      firstGlyph: uint16,
      values: new ArrayT(uint8, uint16)
    });
    let entry = Object.assign({
      newStateOffset: uint16,
      // convert offset to stateArray index
      newState: (t) => (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses,
      flags: uint16
    }, entryData);
    let Entry = new Struct(entry);
    let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint8, (t) => t.nClasses));
    let StateHeader1 = new Struct({
      nClasses: uint16,
      classTable: new Pointer(uint16, ClassLookupTable),
      stateArray: new Pointer(uint16, StateArray),
      entryTable: new Pointer(uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
    });
    return StateHeader1;
  }
  var $6a3746e8c708f5a3$var$BslnSubtable = new VersionedStruct("format", {
    0: {
      deltas: new ArrayT(int16, 32)
    },
    1: {
      deltas: new ArrayT(int16, 32),
      mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
    },
    2: {
      standardGlyph: uint16,
      controlPoints: new ArrayT(uint16, 32)
    },
    3: {
      standardGlyph: uint16,
      controlPoints: new ArrayT(uint16, 32),
      mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
    }
  });
  var $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new Struct({
    version: fixed32,
    format: uint16,
    defaultBaseline: uint16,
    subtable: $6a3746e8c708f5a3$var$BslnSubtable
  });
  var $d0c76fac617b308a$var$Setting = new Struct({
    setting: uint16,
    nameIndex: int16,
    name: (t) => t.parent.parent.parent.name.records.fontFeatures[t.nameIndex]
  });
  var $d0c76fac617b308a$var$FeatureName = new Struct({
    feature: uint16,
    nSettings: uint16,
    settingTable: new Pointer(uint32, new ArrayT($d0c76fac617b308a$var$Setting, "nSettings"), {
      type: "parent"
    }),
    featureFlags: new Bitfield(uint8, [
      null,
      null,
      null,
      null,
      null,
      null,
      "hasDefault",
      "exclusive"
    ]),
    defaultSetting: uint8,
    nameIndex: int16,
    name: (t) => t.parent.parent.name.records.fontFeatures[t.nameIndex]
  });
  var $d0c76fac617b308a$export$2e2bcd8739ae039 = new Struct({
    version: fixed32,
    featureNameCount: uint16,
    reserved1: new Reserved(uint16),
    reserved2: new Reserved(uint32),
    featureNames: new ArrayT($d0c76fac617b308a$var$FeatureName, "featureNameCount")
  });
  var $e83fd065f00fcd01$var$Axis = new Struct({
    axisTag: new StringT(4),
    minValue: fixed32,
    defaultValue: fixed32,
    maxValue: fixed32,
    flags: uint16,
    nameID: uint16,
    name: (t) => t.parent.parent.name.records.fontFeatures[t.nameID]
  });
  var $e83fd065f00fcd01$var$Instance = new Struct({
    nameID: uint16,
    name: (t) => t.parent.parent.name.records.fontFeatures[t.nameID],
    flags: uint16,
    coord: new ArrayT(fixed32, (t) => t.parent.axisCount),
    postscriptNameID: new Optional(uint16, (t) => t.parent.instanceSize - t._currentOffset > 0)
  });
  var $e83fd065f00fcd01$export$2e2bcd8739ae039 = new Struct({
    version: fixed32,
    offsetToData: uint16,
    countSizePairs: uint16,
    axisCount: uint16,
    axisSize: uint16,
    instanceCount: uint16,
    instanceSize: uint16,
    axis: new ArrayT($e83fd065f00fcd01$var$Axis, "axisCount"),
    instance: new ArrayT($e83fd065f00fcd01$var$Instance, "instanceCount")
  });
  var $dbe33c8d3a7f131c$var$shortFrac = new Fixed(16, "BE", 14);
  var $dbe33c8d3a7f131c$var$Offset = class {
    static decode(stream2, parent) {
      return parent.flags ? stream2.readUInt32BE() : stream2.readUInt16BE() * 2;
    }
  };
  var $dbe33c8d3a7f131c$var$gvar = new Struct({
    version: uint16,
    reserved: new Reserved(uint16),
    axisCount: uint16,
    globalCoordCount: uint16,
    globalCoords: new Pointer(uint32, new ArrayT(new ArrayT($dbe33c8d3a7f131c$var$shortFrac, "axisCount"), "globalCoordCount")),
    glyphCount: uint16,
    flags: uint16,
    offsetToData: uint32,
    offsets: new ArrayT(new Pointer($dbe33c8d3a7f131c$var$Offset, "void", {
      relativeTo: (ctx) => ctx.offsetToData,
      allowNull: false
    }), (t) => t.glyphCount + 1)
  });
  var $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;
  var $05b01887df96c4ee$var$ClassTable = new Struct({
    length: uint16,
    coverage: uint16,
    subFeatureFlags: uint32,
    stateTable: new (0, $6cb7dd5f47d82580$export$105027425199cc51)()
  });
  var $05b01887df96c4ee$var$WidthDeltaRecord = new Struct({
    justClass: uint32,
    beforeGrowLimit: fixed32,
    beforeShrinkLimit: fixed32,
    afterGrowLimit: fixed32,
    afterShrinkLimit: fixed32,
    growFlags: uint16,
    shrinkFlags: uint16
  });
  var $05b01887df96c4ee$var$WidthDeltaCluster = new ArrayT($05b01887df96c4ee$var$WidthDeltaRecord, uint32);
  var $05b01887df96c4ee$var$ActionData = new VersionedStruct("actionType", {
    0: {
      lowerLimit: fixed32,
      upperLimit: fixed32,
      order: uint16,
      glyphs: new ArrayT(uint16, uint16)
    },
    1: {
      addGlyph: uint16
    },
    2: {
      substThreshold: fixed32,
      addGlyph: uint16,
      substGlyph: uint16
    },
    3: {},
    4: {
      variationAxis: uint32,
      minimumLimit: fixed32,
      noStretchValue: fixed32,
      maximumLimit: fixed32
    },
    5: {
      flags: uint16,
      glyph: uint16
    }
  });
  var $05b01887df96c4ee$var$Action = new Struct({
    actionClass: uint16,
    actionType: uint16,
    actionLength: uint32,
    actionData: $05b01887df96c4ee$var$ActionData,
    padding: new Reserved(uint8, (t) => t.actionLength - t._currentOffset)
  });
  var $05b01887df96c4ee$var$PostcompensationAction = new ArrayT($05b01887df96c4ee$var$Action, uint32);
  var $05b01887df96c4ee$var$PostCompensationTable = new Struct({
    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$PostcompensationAction))
  });
  var $05b01887df96c4ee$var$JustificationTable = new Struct({
    classTable: new Pointer(uint16, $05b01887df96c4ee$var$ClassTable, {
      type: "parent"
    }),
    wdcOffset: uint16,
    postCompensationTable: new Pointer(uint16, $05b01887df96c4ee$var$PostCompensationTable, {
      type: "parent"
    }),
    widthDeltaClusters: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {
      type: "parent",
      relativeTo: (ctx) => ctx.wdcOffset
    }))
  });
  var $05b01887df96c4ee$export$2e2bcd8739ae039 = new Struct({
    version: uint32,
    format: uint16,
    horizontal: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable),
    vertical: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable)
  });
  var $03ee6ebd54db1053$var$LigatureData = {
    action: uint16
  };
  var $03ee6ebd54db1053$var$ContextualData = {
    markIndex: uint16,
    currentIndex: uint16
  };
  var $03ee6ebd54db1053$var$InsertionData = {
    currentInsertIndex: uint16,
    markedInsertIndex: uint16
  };
  var $03ee6ebd54db1053$var$SubstitutionTable = new Struct({
    items: new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()))
  });
  var $03ee6ebd54db1053$var$SubtableData = new VersionedStruct("type", {
    0: {
      stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)()
    },
    1: {
      stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$ContextualData),
      substitutionTable: new Pointer(uint32, $03ee6ebd54db1053$var$SubstitutionTable)
    },
    2: {
      stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$LigatureData),
      ligatureActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint32)),
      components: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16)),
      ligatureList: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
    },
    4: {
      lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()
    },
    5: {
      stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$InsertionData),
      insertionActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
    }
  });
  var $03ee6ebd54db1053$var$Subtable = new Struct({
    length: uint32,
    coverage: uint24,
    type: uint8,
    subFeatureFlags: uint32,
    table: $03ee6ebd54db1053$var$SubtableData,
    padding: new Reserved(uint8, (t) => t.length - t._currentOffset)
  });
  var $03ee6ebd54db1053$var$FeatureEntry = new Struct({
    featureType: uint16,
    featureSetting: uint16,
    enableFlags: uint32,
    disableFlags: uint32
  });
  var $03ee6ebd54db1053$var$MorxChain = new Struct({
    defaultFlags: uint32,
    chainLength: uint32,
    nFeatureEntries: uint32,
    nSubtables: uint32,
    features: new ArrayT($03ee6ebd54db1053$var$FeatureEntry, "nFeatureEntries"),
    subtables: new ArrayT($03ee6ebd54db1053$var$Subtable, "nSubtables")
  });
  var $03ee6ebd54db1053$export$2e2bcd8739ae039 = new Struct({
    version: uint16,
    unused: new Reserved(uint16),
    nChains: uint32,
    chains: new ArrayT($03ee6ebd54db1053$var$MorxChain, "nChains")
  });
  var $b7492a80b0d1a056$var$OpticalBounds = new Struct({
    left: int16,
    top: int16,
    right: int16,
    bottom: int16
  });
  var $b7492a80b0d1a056$export$2e2bcd8739ae039 = new Struct({
    version: fixed32,
    format: uint16,
    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($b7492a80b0d1a056$var$OpticalBounds)
  });
  var $c3395722bea751e2$var$tables = {};
  var $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;
  $c3395722bea751e2$var$tables.cmap = (0, $26a62205ad06574e$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.head = (0, $f2612a29f92ac062$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.hhea = (0, $2c179dd593583073$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.hmtx = (0, $bdc9060542264b85$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.maxp = (0, $dbf51cb3d3fe409d$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.name = (0, $2bcf221753ec8e32$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables["OS/2"] = (0, $84b272aa31b70606$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.post = (0, $32d9e2eb9565d93c$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.fpgm = (0, $5c0f37ca5ffb1850$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.loca = (0, $2b2b260902b1c57e$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.prep = (0, $7afb878c7bea4f66$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables["cvt "] = (0, $5202bd9d9ad8eaac$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.glyf = (0, $6c92b6371bce8bd9$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables["CFF "] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables["CFF2"] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.VORG = (0, $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.EBLC = (0, $9911c4c7201c13de$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;
  $c3395722bea751e2$var$tables.sbix = (0, $abb847051efd51b1$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.COLR = (0, $eb629188f3dfefdd$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.CPAL = (0, $08734b8e7dc64587$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.BASE = (0, $497cef411d884e34$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.GDEF = (0, $cf5f33c63ef209e6$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.GPOS = (0, $47e0e8ef515d9903$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.GSUB = (0, $d3f442064af66e06$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.JSTF = (0, $71cfb3c4767fbd0c$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.HVAR = (0, $d059a6bd2d3b5b63$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.DSIG = (0, $dceeca3e1977ce30$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.gasp = (0, $8acd740a9435aad0$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.hdmx = (0, $b5f380243c34d6a0$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.kern = (0, $ca2df1256966e313$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.LTSH = (0, $7a9f92b0c46ebe33$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.PCLT = (0, $2b2ccc419d152631$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.VDMX = (0, $ca5b40b9bcda9c9b$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.vhea = (0, $69530a3c40755af0$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.vmtx = (0, $344073dd270f0e62$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.avar = (0, $3793b781918cfced$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.bsln = (0, $6a3746e8c708f5a3$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.feat = (0, $d0c76fac617b308a$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.fvar = (0, $e83fd065f00fcd01$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.gvar = (0, $dbe33c8d3a7f131c$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.just = (0, $05b01887df96c4ee$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.morx = (0, $03ee6ebd54db1053$export$2e2bcd8739ae039);
  $c3395722bea751e2$var$tables.opbd = (0, $b7492a80b0d1a056$export$2e2bcd8739ae039);
  var $816c07a04b6dba87$var$TableEntry = new Struct({
    tag: new StringT(4),
    checkSum: uint32,
    offset: new Pointer(uint32, "void", {
      type: "global"
    }),
    length: uint32
  });
  var $816c07a04b6dba87$var$Directory = new Struct({
    tag: new StringT(4),
    numTables: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    tables: new ArrayT($816c07a04b6dba87$var$TableEntry, "numTables")
  });
  $816c07a04b6dba87$var$Directory.process = function() {
    let tables = {};
    for (let table of this.tables)
      tables[table.tag] = table;
    this.tables = tables;
  };
  $816c07a04b6dba87$var$Directory.preEncode = function() {
    if (!Array.isArray(this.tables)) {
      let tables = [];
      for (let tag in this.tables) {
        let table = this.tables[tag];
        if (table)
          tables.push({
            tag,
            checkSum: 0,
            offset: new VoidPointer((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag], table),
            length: (0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag].size(table)
          });
      }
      this.tables = tables;
    }
    this.tag = "true";
    this.numTables = this.tables.length;
    let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
    let maxPowerOf2 = Math.pow(2, maxExponentFor2);
    this.searchRange = maxPowerOf2 * 16;
    this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
    this.rangeShift = this.numTables * 16 - this.searchRange;
  };
  var $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;
  function $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr, cmp) {
    let min = 0;
    let max = arr.length - 1;
    while (min <= max) {
      let mid = min + max >> 1;
      let res = cmp(arr[mid]);
      if (res < 0)
        max = mid - 1;
      else if (res > 0)
        min = mid + 1;
      else
        return mid;
    }
    return -1;
  }
  function $12727730ddfc8bfe$export$d02631cccf789723(index, end) {
    let range1 = [];
    while (index < end)
      range1.push(index++);
    return range1;
  }
  var $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder("ascii");
  var $12727730ddfc8bfe$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);
  for (let i = 0; i < $12727730ddfc8bfe$var$CHARS.length; i++)
    $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i)] = i;
  function $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {
    let bufferLength = base64.length * 0.75;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=")
        bufferLength--;
    }
    let bytes = new Uint8Array(bufferLength);
    let p = 0;
    for (let i1 = 0, len = base64.length; i1 < len; i1 += 4) {
      let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1)];
      let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 1)];
      let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 2)];
      let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return bytes;
  }
  var $f08dd41ef10b694c$export$2e2bcd8739ae039 = class {
    findSubtable(cmapTable, pairs) {
      for (let [platformID, encodingID] of pairs)
        for (let cmap of cmapTable.tables) {
          if (cmap.platformID === platformID && cmap.encodingID === encodingID)
            return cmap.table;
        }
      return null;
    }
    lookup(codepoint, variationSelector) {
      if (this.encoding)
        codepoint = this.encoding.get(codepoint) || codepoint;
      else if (variationSelector) {
        let gid = this.getVariationSelector(codepoint, variationSelector);
        if (gid)
          return gid;
      }
      let cmap = this.cmap;
      switch (cmap.version) {
        case 0:
          return cmap.codeMap.get(codepoint) || 0;
        case 4: {
          let min = 0;
          let max = cmap.segCount - 1;
          while (min <= max) {
            let mid = min + max >> 1;
            if (codepoint < cmap.startCode.get(mid))
              max = mid - 1;
            else if (codepoint > cmap.endCode.get(mid))
              min = mid + 1;
            else {
              let rangeOffset = cmap.idRangeOffset.get(mid);
              let gid;
              if (rangeOffset === 0)
                gid = codepoint + cmap.idDelta.get(mid);
              else {
                let index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
                gid = cmap.glyphIndexArray.get(index) || 0;
                if (gid !== 0)
                  gid += cmap.idDelta.get(mid);
              }
              return gid & 65535;
            }
          }
          return 0;
        }
        case 8:
          throw new Error("TODO: cmap format 8");
        case 6:
        case 10:
          return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
        case 12:
        case 13: {
          let min = 0;
          let max = cmap.nGroups - 1;
          while (min <= max) {
            let mid = min + max >> 1;
            let group = cmap.groups.get(mid);
            if (codepoint < group.startCharCode)
              max = mid - 1;
            else if (codepoint > group.endCharCode)
              min = mid + 1;
            else {
              if (cmap.version === 12)
                return group.glyphID + (codepoint - group.startCharCode);
              else
                return group.glyphID;
            }
          }
          return 0;
        }
        case 14:
          throw new Error("TODO: cmap format 14");
        default:
          throw new Error(`Unknown cmap format ${cmap.version}`);
      }
    }
    getVariationSelector(codepoint, variationSelector) {
      if (!this.uvs)
        return 0;
      let selectors = this.uvs.varSelectors.toArray();
      let i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(selectors, (x) => variationSelector - x.varSelector);
      let sel = selectors[i];
      if (i !== -1 && sel.defaultUVS)
        i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.defaultUVS, (x) => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);
      if (i !== -1 && sel.nonDefaultUVS) {
        i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, (x) => codepoint - x.unicodeValue);
        if (i !== -1)
          return sel.nonDefaultUVS[i].glyphID;
      }
      return 0;
    }
    getCharacterSet() {
      let cmap = this.cmap;
      switch (cmap.version) {
        case 0:
          return (0, $12727730ddfc8bfe$export$d02631cccf789723)(0, cmap.codeMap.length);
        case 4: {
          let res = [];
          let endCodes = cmap.endCode.toArray();
          for (let i = 0; i < endCodes.length; i++) {
            let tail = endCodes[i] + 1;
            let start = cmap.startCode.get(i);
            res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(start, tail));
          }
          return res;
        }
        case 8:
          throw new Error("TODO: cmap format 8");
        case 6:
        case 10:
          return (0, $12727730ddfc8bfe$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
        case 12:
        case 13: {
          let res = [];
          for (let group of cmap.groups.toArray())
            res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
          return res;
        }
        case 14:
          throw new Error("TODO: cmap format 14");
        default:
          throw new Error(`Unknown cmap format ${cmap.version}`);
      }
    }
    codePointsForGlyph(gid) {
      let cmap = this.cmap;
      switch (cmap.version) {
        case 0: {
          let res = [];
          for (let i = 0; i < 256; i++)
            if (cmap.codeMap.get(i) === gid)
              res.push(i);
          return res;
        }
        case 4: {
          let res = [];
          for (let i = 0; i < cmap.segCount; i++) {
            let end = cmap.endCode.get(i);
            let start = cmap.startCode.get(i);
            let rangeOffset = cmap.idRangeOffset.get(i);
            let delta = cmap.idDelta.get(i);
            for (var c = start; c <= end; c++) {
              let g = 0;
              if (rangeOffset === 0)
                g = c + delta;
              else {
                let index = rangeOffset / 2 + (c - start) - (cmap.segCount - i);
                g = cmap.glyphIndexArray.get(index) || 0;
                if (g !== 0)
                  g += delta;
              }
              if (g === gid)
                res.push(c);
            }
          }
          return res;
        }
        case 12: {
          let res = [];
          for (let group of cmap.groups.toArray())
            if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode))
              res.push(group.startCharCode + (gid - group.glyphID));
          return res;
        }
        case 13: {
          let res = [];
          for (let group of cmap.groups.toArray())
            if (gid === group.glyphID)
              res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
          return res;
        }
        default:
          throw new Error(`Unknown cmap format ${cmap.version}`);
      }
    }
    constructor(cmapTable) {
      this.encoding = null;
      this.cmap = this.findSubtable(cmapTable, [
        // 32-bit subtables
        [
          3,
          10
        ],
        [
          0,
          6
        ],
        [
          0,
          4
        ],
        // 16-bit subtables
        [
          3,
          1
        ],
        [
          0,
          3
        ],
        [
          0,
          2
        ],
        [
          0,
          1
        ],
        [
          0,
          0
        ]
      ]);
      if (!this.cmap)
        for (let cmap of cmapTable.tables) {
          let encoding = (0, $e449ad78d50845fe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
          let mapping = (0, $e449ad78d50845fe$export$1dceb3c14ed68bee)(encoding);
          if (mapping) {
            this.cmap = cmap.table;
            this.encoding = mapping;
          }
        }
      if (!this.cmap)
        throw new Error("Could not find a supported cmap table");
      this.uvs = this.findSubtable(cmapTable, [
        [
          0,
          5
        ]
      ]);
      if (this.uvs && this.uvs.version !== 14)
        this.uvs = null;
    }
  };
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
  var $0bba3a9db57637f3$export$2e2bcd8739ae039 = class {
    process(glyphs, positions) {
      for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
        let left = glyphs[glyphIndex].id;
        let right = glyphs[glyphIndex + 1].id;
        positions[glyphIndex].xAdvance += this.getKerning(left, right);
      }
    }
    getKerning(left, right) {
      let res = 0;
      for (let table of this.kern.tables) {
        if (table.coverage.crossStream)
          continue;
        switch (table.version) {
          case 0:
            if (!table.coverage.horizontal)
              continue;
            break;
          case 1:
            if (table.coverage.vertical || table.coverage.variation)
              continue;
            break;
          default:
            throw new Error(`Unsupported kerning table version ${table.version}`);
        }
        let val = 0;
        let s = table.subtable;
        switch (table.format) {
          case 0:
            let pairIdx = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(s.pairs, function(pair) {
              return left - pair.left || right - pair.right;
            });
            if (pairIdx >= 0)
              val = s.pairs[pairIdx].value;
            break;
          case 2:
            let leftOffset = 0, rightOffset = 0;
            if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs)
              leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];
            else
              leftOffset = s.array.off;
            if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs)
              rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];
            let index = (leftOffset + rightOffset - s.array.off) / 2;
            val = s.array.values.get(index);
            break;
          case 3:
            if (left >= s.glyphCount || right >= s.glyphCount)
              return 0;
            val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
            break;
          default:
            throw new Error(`Unsupported kerning sub-table format ${table.format}`);
        }
        if (table.coverage.override)
          res = val;
        else
          res += val;
      }
      return res;
    }
    constructor(font) {
      this.kern = font.kern;
    }
  };
  var $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 = class {
    positionGlyphs(glyphs, positions) {
      let clusterStart = 0;
      let clusterEnd = 0;
      for (let index = 0; index < glyphs.length; index++) {
        let glyph = glyphs[index];
        if (glyph.isMark)
          clusterEnd = index;
        else {
          if (clusterStart !== clusterEnd)
            this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
          clusterStart = clusterEnd = index;
        }
      }
      if (clusterStart !== clusterEnd)
        this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
      return positions;
    }
    positionCluster(glyphs, positions, clusterStart, clusterEnd) {
      let base = glyphs[clusterStart];
      let baseBox = base.cbox.copy();
      if (base.codePoints.length > 1)
        baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
      let xOffset = -positions[clusterStart].xAdvance;
      let yOffset = 0;
      let yGap = this.font.unitsPerEm / 16;
      for (let index = clusterStart + 1; index <= clusterEnd; index++) {
        let mark = glyphs[index];
        let markBox = mark.cbox;
        let position = positions[index];
        let combiningClass = this.getCombiningClass(mark.codePoints[0]);
        if (combiningClass !== "Not_Reordered") {
          position.xOffset = position.yOffset = 0;
          switch (combiningClass) {
            case "Double_Above":
            case "Double_Below":
              position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
              break;
            case "Attached_Below_Left":
            case "Below_Left":
            case "Above_Left":
              position.xOffset += baseBox.minX - markBox.minX;
              break;
            case "Attached_Above_Right":
            case "Below_Right":
            case "Above_Right":
              position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
              break;
            default:
              position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
          }
          switch (combiningClass) {
            case "Double_Below":
            case "Below_Left":
            case "Below":
            case "Below_Right":
            case "Attached_Below_Left":
            case "Attached_Below":
              if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below")
                baseBox.minY += yGap;
              position.yOffset = -baseBox.minY - markBox.maxY;
              baseBox.minY += markBox.height;
              break;
            case "Double_Above":
            case "Above_Left":
            case "Above":
            case "Above_Right":
            case "Attached_Above":
            case "Attached_Above_Right":
              if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right")
                baseBox.maxY += yGap;
              position.yOffset = baseBox.maxY - markBox.minY;
              baseBox.maxY += markBox.height;
              break;
          }
          position.xAdvance = position.yAdvance = 0;
          position.xOffset += xOffset;
          position.yOffset += yOffset;
        } else {
          xOffset -= position.xAdvance;
          yOffset -= position.yAdvance;
        }
      }
      return;
    }
    getCombiningClass(codePoint) {
      let combiningClass = (0, $747425b437e121da$export$c03b919c6651ed55)(codePoint);
      if ((codePoint & -256) === 3584) {
        if (combiningClass === "Not_Reordered")
          switch (codePoint) {
            case 3633:
            case 3636:
            case 3637:
            case 3638:
            case 3639:
            case 3655:
            case 3660:
            case 3645:
            case 3662:
              return "Above_Right";
            case 3761:
            case 3764:
            case 3765:
            case 3766:
            case 3767:
            case 3771:
            case 3788:
            case 3789:
              return "Above";
            case 3772:
              return "Below";
          }
        else if (codePoint === 3642)
          return "Below_Right";
      }
      switch (combiningClass) {
        case "CCC10":
        case "CCC11":
        case "CCC12":
        case "CCC13":
        case "CCC14":
        case "CCC15":
        case "CCC16":
        case "CCC17":
        case "CCC18":
        case "CCC20":
        case "CCC22":
          return "Below";
        case "CCC23":
          return "Attached_Above";
        case "CCC24":
          return "Above_Right";
        case "CCC25":
        case "CCC19":
          return "Above_Left";
        case "CCC26":
          return "Above";
        case "CCC21":
          break;
        case "CCC27":
        case "CCC28":
        case "CCC30":
        case "CCC31":
        case "CCC33":
        case "CCC34":
        case "CCC35":
        case "CCC36":
          return "Above";
        case "CCC29":
        case "CCC32":
          return "Below";
        case "CCC103":
          return "Below_Right";
        case "CCC107":
          return "Above_Right";
        case "CCC118":
          return "Below";
        case "CCC122":
          return "Above";
        case "CCC129":
        case "CCC132":
          return "Below";
        case "CCC130":
          return "Above";
      }
      return combiningClass;
    }
    constructor(font) {
      this.font = font;
    }
  };
  var $f34600ab9d7f70d8$export$2e2bcd8739ae039 = class _$f34600ab9d7f70d8$export$2e2bcd8739ae039 {
    /**
    * The width of the bounding box
    * @type {number}
    */
    get width() {
      return this.maxX - this.minX;
    }
    /**
    * The height of the bounding box
    * @type {number}
    */
    get height() {
      return this.maxY - this.minY;
    }
    addPoint(x, y) {
      if (Math.abs(x) !== Infinity) {
        if (x < this.minX)
          this.minX = x;
        if (x > this.maxX)
          this.maxX = x;
      }
      if (Math.abs(y) !== Infinity) {
        if (y < this.minY)
          this.minY = y;
        if (y > this.maxY)
          this.maxY = y;
      }
    }
    copy() {
      return new _$f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
    }
    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
  };
  var $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {
    Caucasian_Albanian: "aghb",
    Arabic: "arab",
    Imperial_Aramaic: "armi",
    Armenian: "armn",
    Avestan: "avst",
    Balinese: "bali",
    Bamum: "bamu",
    Bassa_Vah: "bass",
    Batak: "batk",
    Bengali: [
      "bng2",
      "beng"
    ],
    Bopomofo: "bopo",
    Brahmi: "brah",
    Braille: "brai",
    Buginese: "bugi",
    Buhid: "buhd",
    Chakma: "cakm",
    Canadian_Aboriginal: "cans",
    Carian: "cari",
    Cham: "cham",
    Cherokee: "cher",
    Coptic: "copt",
    Cypriot: "cprt",
    Cyrillic: "cyrl",
    Devanagari: [
      "dev2",
      "deva"
    ],
    Deseret: "dsrt",
    Duployan: "dupl",
    Egyptian_Hieroglyphs: "egyp",
    Elbasan: "elba",
    Ethiopic: "ethi",
    Georgian: "geor",
    Glagolitic: "glag",
    Gothic: "goth",
    Grantha: "gran",
    Greek: "grek",
    Gujarati: [
      "gjr2",
      "gujr"
    ],
    Gurmukhi: [
      "gur2",
      "guru"
    ],
    Hangul: "hang",
    Han: "hani",
    Hanunoo: "hano",
    Hebrew: "hebr",
    Hiragana: "hira",
    Pahawh_Hmong: "hmng",
    Katakana_Or_Hiragana: "hrkt",
    Old_Italic: "ital",
    Javanese: "java",
    Kayah_Li: "kali",
    Katakana: "kana",
    Kharoshthi: "khar",
    Khmer: "khmr",
    Khojki: "khoj",
    Kannada: [
      "knd2",
      "knda"
    ],
    Kaithi: "kthi",
    Tai_Tham: "lana",
    Lao: "lao ",
    Latin: "latn",
    Lepcha: "lepc",
    Limbu: "limb",
    Linear_A: "lina",
    Linear_B: "linb",
    Lisu: "lisu",
    Lycian: "lyci",
    Lydian: "lydi",
    Mahajani: "mahj",
    Mandaic: "mand",
    Manichaean: "mani",
    Mende_Kikakui: "mend",
    Meroitic_Cursive: "merc",
    Meroitic_Hieroglyphs: "mero",
    Malayalam: [
      "mlm2",
      "mlym"
    ],
    Modi: "modi",
    Mongolian: "mong",
    Mro: "mroo",
    Meetei_Mayek: "mtei",
    Myanmar: [
      "mym2",
      "mymr"
    ],
    Old_North_Arabian: "narb",
    Nabataean: "nbat",
    Nko: "nko ",
    Ogham: "ogam",
    Ol_Chiki: "olck",
    Old_Turkic: "orkh",
    Oriya: [
      "ory2",
      "orya"
    ],
    Osmanya: "osma",
    Palmyrene: "palm",
    Pau_Cin_Hau: "pauc",
    Old_Permic: "perm",
    Phags_Pa: "phag",
    Inscriptional_Pahlavi: "phli",
    Psalter_Pahlavi: "phlp",
    Phoenician: "phnx",
    Miao: "plrd",
    Inscriptional_Parthian: "prti",
    Rejang: "rjng",
    Runic: "runr",
    Samaritan: "samr",
    Old_South_Arabian: "sarb",
    Saurashtra: "saur",
    Shavian: "shaw",
    Sharada: "shrd",
    Siddham: "sidd",
    Khudawadi: "sind",
    Sinhala: "sinh",
    Sora_Sompeng: "sora",
    Sundanese: "sund",
    Syloti_Nagri: "sylo",
    Syriac: "syrc",
    Tagbanwa: "tagb",
    Takri: "takr",
    Tai_Le: "tale",
    New_Tai_Lue: "talu",
    Tamil: [
      "tml2",
      "taml"
    ],
    Tai_Viet: "tavt",
    Telugu: [
      "tel2",
      "telu"
    ],
    Tifinagh: "tfng",
    Tagalog: "tglg",
    Thaana: "thaa",
    Thai: "thai",
    Tibetan: "tibt",
    Tirhuta: "tirh",
    Ugaritic: "ugar",
    Vai: "vai ",
    Warang_Citi: "wara",
    Old_Persian: "xpeo",
    Cuneiform: "xsux",
    Yi: "yi  ",
    Inherited: "zinh",
    Common: "zyyy",
    Unknown: "zzzz"
  };
  var $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};
  for (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {
    let tag = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
    if (Array.isArray(tag))
      for (let t of tag)
        $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t] = script;
    else
      $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag] = script;
  }
  function $130d1a642ebcd2b7$export$b32f0b5f69d65e51(script1) {
    return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script1];
  }
  function $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag) {
    return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag];
  }
  function $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {
    let len = string.length;
    let idx = 0;
    while (idx < len) {
      let code = string.charCodeAt(idx++);
      if (55296 <= code && code <= 56319 && idx < len) {
        let next = string.charCodeAt(idx);
        if (56320 <= next && next <= 57343) {
          idx++;
          code = ((code & 1023) << 10) + (next & 1023) + 65536;
        }
      }
      let script2 = (0, $747425b437e121da$export$941569448d136665)(code);
      if (script2 !== "Common" && script2 !== "Inherited" && script2 !== "Unknown")
        return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script2];
    }
    return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
  }
  function $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {
    for (let i = 0; i < codePoints.length; i++) {
      let codePoint = codePoints[i];
      let script3 = (0, $747425b437e121da$export$941569448d136665)(codePoint);
      if (script3 !== "Common" && script3 !== "Inherited" && script3 !== "Unknown")
        return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script3];
    }
    return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
  }
  var $130d1a642ebcd2b7$var$RTL = {
    arab: true,
    hebr: true,
    syrc: true,
    thaa: true,
    cprt: true,
    khar: true,
    phnx: true,
    "nko ": true,
    lydi: true,
    avst: true,
    armi: true,
    phli: true,
    prti: true,
    sarb: true,
    orkh: true,
    samr: true,
    mand: true,
    merc: true,
    mero: true,
    // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
    mani: true,
    mend: true,
    nbat: true,
    narb: true,
    palm: true,
    phlp: true
    // Psalter Pahlavi
  };
  function $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script4) {
    if ($130d1a642ebcd2b7$var$RTL[script4])
      return "rtl";
    return "ltr";
  }
  var $be07b3e97a42687a$export$2e2bcd8739ae039 = class {
    /**
    * The total advance width of the run.
    * @type {number}
    */
    get advanceWidth() {
      let width = 0;
      for (let position of this.positions)
        width += position.xAdvance;
      return width;
    }
    /**
    * The total advance height of the run.
    * @type {number}
    */
    get advanceHeight() {
      let height = 0;
      for (let position of this.positions)
        height += position.yAdvance;
      return height;
    }
    /**
    * The bounding box containing all glyphs in the run.
    * @type {BBox}
    */
    get bbox() {
      let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      let x = 0;
      let y = 0;
      for (let index = 0; index < this.glyphs.length; index++) {
        let glyph = this.glyphs[index];
        let p = this.positions[index];
        let b = glyph.bbox;
        bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
        bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
        x += p.xAdvance;
        y += p.yAdvance;
      }
      return bbox;
    }
    constructor(glyphs, features, script, language, direction) {
      this.glyphs = glyphs;
      this.positions = null;
      this.script = script;
      this.language = language || null;
      this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
      this.features = {};
      if (Array.isArray(features))
        for (let tag of features)
          this.features[tag] = true;
      else if (typeof features === "object")
        this.features = features;
    }
  };
  var $1ac75d9a55b67f01$export$2e2bcd8739ae039 = class {
    constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
      this.xAdvance = xAdvance;
      this.yAdvance = yAdvance;
      this.xOffset = xOffset;
      this.yOffset = yOffset;
    }
  };
  var $3b6302b64eccc32c$var$features = {
    allTypographicFeatures: {
      code: 0,
      exclusive: false,
      allTypeFeatures: 0
    },
    ligatures: {
      code: 1,
      exclusive: false,
      requiredLigatures: 0,
      commonLigatures: 2,
      rareLigatures: 4,
      // logos: 6
      rebusPictures: 8,
      diphthongLigatures: 10,
      squaredLigatures: 12,
      abbrevSquaredLigatures: 14,
      symbolLigatures: 16,
      contextualLigatures: 18,
      historicalLigatures: 20
    },
    cursiveConnection: {
      code: 2,
      exclusive: true,
      unconnected: 0,
      partiallyConnected: 1,
      cursive: 2
    },
    letterCase: {
      code: 3,
      exclusive: true
    },
    // upperAndLowerCase: 0          # deprecated
    // allCaps: 1                    # deprecated
    // allLowerCase: 2               # deprecated
    // smallCaps: 3                  # deprecated
    // initialCaps: 4                # deprecated
    // initialCapsAndSmallCaps: 5    # deprecated
    verticalSubstitution: {
      code: 4,
      exclusive: false,
      substituteVerticalForms: 0
    },
    linguisticRearrangement: {
      code: 5,
      exclusive: false,
      linguisticRearrangement: 0
    },
    numberSpacing: {
      code: 6,
      exclusive: true,
      monospacedNumbers: 0,
      proportionalNumbers: 1,
      thirdWidthNumbers: 2,
      quarterWidthNumbers: 3
    },
    smartSwash: {
      code: 8,
      exclusive: false,
      wordInitialSwashes: 0,
      wordFinalSwashes: 2,
      // lineInitialSwashes: 4
      // lineFinalSwashes: 6
      nonFinalSwashes: 8
    },
    diacritics: {
      code: 9,
      exclusive: true,
      showDiacritics: 0,
      hideDiacritics: 1,
      decomposeDiacritics: 2
    },
    verticalPosition: {
      code: 10,
      exclusive: true,
      normalPosition: 0,
      superiors: 1,
      inferiors: 2,
      ordinals: 3,
      scientificInferiors: 4
    },
    fractions: {
      code: 11,
      exclusive: true,
      noFractions: 0,
      verticalFractions: 1,
      diagonalFractions: 2
    },
    overlappingCharacters: {
      code: 13,
      exclusive: false,
      preventOverlap: 0
    },
    typographicExtras: {
      code: 14,
      exclusive: false,
      // hyphensToEmDash: 0
      // hyphenToEnDash: 2
      slashedZero: 4
    },
    // formInterrobang: 6
    // smartQuotes: 8
    // periodsToEllipsis: 10
    mathematicalExtras: {
      code: 15,
      exclusive: false,
      // hyphenToMinus: 0
      // asteristoMultiply: 2
      // slashToDivide: 4
      // inequalityLigatures: 6
      // exponents: 8
      mathematicalGreek: 10
    },
    ornamentSets: {
      code: 16,
      exclusive: true,
      noOrnaments: 0,
      dingbats: 1,
      piCharacters: 2,
      fleurons: 3,
      decorativeBorders: 4,
      internationalSymbols: 5,
      mathSymbols: 6
    },
    characterAlternatives: {
      code: 17,
      exclusive: true,
      noAlternates: 0
    },
    // user defined options
    designComplexity: {
      code: 18,
      exclusive: true,
      designLevel1: 0,
      designLevel2: 1,
      designLevel3: 2,
      designLevel4: 3,
      designLevel5: 4
    },
    styleOptions: {
      code: 19,
      exclusive: true,
      noStyleOptions: 0,
      displayText: 1,
      engravedText: 2,
      illuminatedCaps: 3,
      titlingCaps: 4,
      tallCaps: 5
    },
    characterShape: {
      code: 20,
      exclusive: true,
      traditionalCharacters: 0,
      simplifiedCharacters: 1,
      JIS1978Characters: 2,
      JIS1983Characters: 3,
      JIS1990Characters: 4,
      traditionalAltOne: 5,
      traditionalAltTwo: 6,
      traditionalAltThree: 7,
      traditionalAltFour: 8,
      traditionalAltFive: 9,
      expertCharacters: 10,
      JIS2004Characters: 11,
      hojoCharacters: 12,
      NLCCharacters: 13,
      traditionalNamesCharacters: 14
    },
    numberCase: {
      code: 21,
      exclusive: true,
      lowerCaseNumbers: 0,
      upperCaseNumbers: 1
    },
    textSpacing: {
      code: 22,
      exclusive: true,
      proportionalText: 0,
      monospacedText: 1,
      halfWidthText: 2,
      thirdWidthText: 3,
      quarterWidthText: 4,
      altProportionalText: 5,
      altHalfWidthText: 6
    },
    transliteration: {
      code: 23,
      exclusive: true,
      noTransliteration: 0
    },
    // hanjaToHangul: 1
    // hiraganaToKatakana: 2
    // katakanaToHiragana: 3
    // kanaToRomanization: 4
    // romanizationToHiragana: 5
    // romanizationToKatakana: 6
    // hanjaToHangulAltOne: 7
    // hanjaToHangulAltTwo: 8
    // hanjaToHangulAltThree: 9
    annotation: {
      code: 24,
      exclusive: true,
      noAnnotation: 0,
      boxAnnotation: 1,
      roundedBoxAnnotation: 2,
      circleAnnotation: 3,
      invertedCircleAnnotation: 4,
      parenthesisAnnotation: 5,
      periodAnnotation: 6,
      romanNumeralAnnotation: 7,
      diamondAnnotation: 8,
      invertedBoxAnnotation: 9,
      invertedRoundedBoxAnnotation: 10
    },
    kanaSpacing: {
      code: 25,
      exclusive: true,
      fullWidthKana: 0,
      proportionalKana: 1
    },
    ideographicSpacing: {
      code: 26,
      exclusive: true,
      fullWidthIdeographs: 0,
      proportionalIdeographs: 1,
      halfWidthIdeographs: 2
    },
    unicodeDecomposition: {
      code: 27,
      exclusive: false,
      canonicalComposition: 0,
      compatibilityComposition: 2,
      transcodingComposition: 4
    },
    rubyKana: {
      code: 28,
      exclusive: false,
      // noRubyKana: 0     # deprecated - use rubyKanaOff instead
      // rubyKana: 1     # deprecated - use rubyKanaOn instead
      rubyKana: 2
    },
    CJKSymbolAlternatives: {
      code: 29,
      exclusive: true,
      noCJKSymbolAlternatives: 0,
      CJKSymbolAltOne: 1,
      CJKSymbolAltTwo: 2,
      CJKSymbolAltThree: 3,
      CJKSymbolAltFour: 4,
      CJKSymbolAltFive: 5
    },
    ideographicAlternatives: {
      code: 30,
      exclusive: true,
      noIdeographicAlternatives: 0,
      ideographicAltOne: 1,
      ideographicAltTwo: 2,
      ideographicAltThree: 3,
      ideographicAltFour: 4,
      ideographicAltFive: 5
    },
    CJKVerticalRomanPlacement: {
      code: 31,
      exclusive: true,
      CJKVerticalRomanCentered: 0,
      CJKVerticalRomanHBaseline: 1
    },
    italicCJKRoman: {
      code: 32,
      exclusive: false,
      // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
      // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
      CJKItalicRoman: 2
    },
    caseSensitiveLayout: {
      code: 33,
      exclusive: false,
      caseSensitiveLayout: 0,
      caseSensitiveSpacing: 2
    },
    alternateKana: {
      code: 34,
      exclusive: false,
      alternateHorizKana: 0,
      alternateVertKana: 2
    },
    stylisticAlternatives: {
      code: 35,
      exclusive: false,
      noStylisticAlternates: 0,
      stylisticAltOne: 2,
      stylisticAltTwo: 4,
      stylisticAltThree: 6,
      stylisticAltFour: 8,
      stylisticAltFive: 10,
      stylisticAltSix: 12,
      stylisticAltSeven: 14,
      stylisticAltEight: 16,
      stylisticAltNine: 18,
      stylisticAltTen: 20,
      stylisticAltEleven: 22,
      stylisticAltTwelve: 24,
      stylisticAltThirteen: 26,
      stylisticAltFourteen: 28,
      stylisticAltFifteen: 30,
      stylisticAltSixteen: 32,
      stylisticAltSeventeen: 34,
      stylisticAltEighteen: 36,
      stylisticAltNineteen: 38,
      stylisticAltTwenty: 40
    },
    contextualAlternates: {
      code: 36,
      exclusive: false,
      contextualAlternates: 0,
      swashAlternates: 2,
      contextualSwashAlternates: 4
    },
    lowerCase: {
      code: 37,
      exclusive: true,
      defaultLowerCase: 0,
      lowerCaseSmallCaps: 1,
      lowerCasePetiteCaps: 2
    },
    upperCase: {
      code: 38,
      exclusive: true,
      defaultUpperCase: 0,
      upperCaseSmallCaps: 1,
      upperCasePetiteCaps: 2
    },
    languageTag: {
      code: 39,
      exclusive: true
    },
    CJKRomanSpacing: {
      code: 103,
      exclusive: true,
      halfWidthCJKRoman: 0,
      proportionalCJKRoman: 1,
      defaultCJKRoman: 2,
      fullWidthCJKRoman: 3
    }
  };
  var $3b6302b64eccc32c$var$feature = (name, selector) => [
    $3b6302b64eccc32c$var$features[name].code,
    $3b6302b64eccc32c$var$features[name][selector]
  ];
  var $3b6302b64eccc32c$var$OTMapping = {
    rlig: $3b6302b64eccc32c$var$feature("ligatures", "requiredLigatures"),
    clig: $3b6302b64eccc32c$var$feature("ligatures", "contextualLigatures"),
    dlig: $3b6302b64eccc32c$var$feature("ligatures", "rareLigatures"),
    hlig: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
    liga: $3b6302b64eccc32c$var$feature("ligatures", "commonLigatures"),
    hist: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
    smcp: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCaseSmallCaps"),
    pcap: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCasePetiteCaps"),
    frac: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
    dnom: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
    numr: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
    afrc: $3b6302b64eccc32c$var$feature("fractions", "verticalFractions"),
    // aalt
    // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
    // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
    // unic, vatu, vhal, vjmo, vpal, vrt2
    // dist -> trak table?
    // kern, vkrn -> kern table
    // lfbd + opbd + rtbd -> opbd table?
    // mark, mkmk -> acnt table?
    // locl -> languageTag + ltag table
    case: $3b6302b64eccc32c$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
    ccmp: $3b6302b64eccc32c$var$feature("unicodeDecomposition", "canonicalComposition"),
    cpct: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
    valt: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
    swsh: $3b6302b64eccc32c$var$feature("contextualAlternates", "swashAlternates"),
    cswh: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualSwashAlternates"),
    curs: $3b6302b64eccc32c$var$feature("cursiveConnection", "cursive"),
    c2pc: $3b6302b64eccc32c$var$feature("upperCase", "upperCasePetiteCaps"),
    c2sc: $3b6302b64eccc32c$var$feature("upperCase", "upperCaseSmallCaps"),
    init: $3b6302b64eccc32c$var$feature("smartSwash", "wordInitialSwashes"),
    fin2: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
    medi: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
    med2: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
    fin3: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
    fina: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
    pkna: $3b6302b64eccc32c$var$feature("kanaSpacing", "proportionalKana"),
    half: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
    halt: $3b6302b64eccc32c$var$feature("textSpacing", "altHalfWidthText"),
    hkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateHorizKana"),
    vkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateVertKana"),
    // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
    ital: $3b6302b64eccc32c$var$feature("italicCJKRoman", "CJKItalicRoman"),
    lnum: $3b6302b64eccc32c$var$feature("numberCase", "upperCaseNumbers"),
    onum: $3b6302b64eccc32c$var$feature("numberCase", "lowerCaseNumbers"),
    mgrk: $3b6302b64eccc32c$var$feature("mathematicalExtras", "mathematicalGreek"),
    // nalt: not enough info. what type of annotation?
    // ornm: ditto, which ornament style?
    calt: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualAlternates"),
    vrt2: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
    vert: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
    tnum: $3b6302b64eccc32c$var$feature("numberSpacing", "monospacedNumbers"),
    pnum: $3b6302b64eccc32c$var$feature("numberSpacing", "proportionalNumbers"),
    sups: $3b6302b64eccc32c$var$feature("verticalPosition", "superiors"),
    subs: $3b6302b64eccc32c$var$feature("verticalPosition", "inferiors"),
    ordn: $3b6302b64eccc32c$var$feature("verticalPosition", "ordinals"),
    pwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
    hwid: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
    qwid: $3b6302b64eccc32c$var$feature("textSpacing", "quarterWidthText"),
    twid: $3b6302b64eccc32c$var$feature("textSpacing", "thirdWidthText"),
    fwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
    palt: $3b6302b64eccc32c$var$feature("textSpacing", "altProportionalText"),
    trad: $3b6302b64eccc32c$var$feature("characterShape", "traditionalCharacters"),
    smpl: $3b6302b64eccc32c$var$feature("characterShape", "simplifiedCharacters"),
    jp78: $3b6302b64eccc32c$var$feature("characterShape", "JIS1978Characters"),
    jp83: $3b6302b64eccc32c$var$feature("characterShape", "JIS1983Characters"),
    jp90: $3b6302b64eccc32c$var$feature("characterShape", "JIS1990Characters"),
    jp04: $3b6302b64eccc32c$var$feature("characterShape", "JIS2004Characters"),
    expt: $3b6302b64eccc32c$var$feature("characterShape", "expertCharacters"),
    hojo: $3b6302b64eccc32c$var$feature("characterShape", "hojoCharacters"),
    nlck: $3b6302b64eccc32c$var$feature("characterShape", "NLCCharacters"),
    tnam: $3b6302b64eccc32c$var$feature("characterShape", "traditionalNamesCharacters"),
    ruby: $3b6302b64eccc32c$var$feature("rubyKana", "rubyKana"),
    titl: $3b6302b64eccc32c$var$feature("styleOptions", "titlingCaps"),
    zero: $3b6302b64eccc32c$var$feature("typographicExtras", "slashedZero"),
    ss01: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltOne"),
    ss02: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwo"),
    ss03: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThree"),
    ss04: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFour"),
    ss05: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFive"),
    ss06: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSix"),
    ss07: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeven"),
    ss08: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEight"),
    ss09: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNine"),
    ss10: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTen"),
    ss11: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEleven"),
    ss12: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
    ss13: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
    ss14: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
    ss15: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
    ss16: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
    ss17: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
    ss18: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
    ss19: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
    ss20: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwenty")
  };
  for (let i = 1; i <= 99; i++)
    $3b6302b64eccc32c$var$OTMapping[`cv${`00${i}`.slice(-2)}`] = [
      $3b6302b64eccc32c$var$features.characterAlternatives.code,
      i
    ];
  var $3b6302b64eccc32c$var$AATMapping = {};
  for (let ot in $3b6302b64eccc32c$var$OTMapping) {
    let aat = $3b6302b64eccc32c$var$OTMapping[ot];
    if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null)
      $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};
    $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;
  }
  function $3b6302b64eccc32c$export$b813f7d2a1677c16(features1) {
    let res = {};
    for (let k in features1) {
      let r;
      if (r = $3b6302b64eccc32c$var$OTMapping[k]) {
        if (res[r[0]] == null)
          res[r[0]] = {};
        res[r[0]][r[1]] = features1[k];
      }
    }
    return res;
  }
  function $3b6302b64eccc32c$var$mapFeatureStrings(f) {
    let [type, setting] = f;
    if (isNaN(type))
      var typeCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type].code;
    else
      var typeCode = type;
    if (isNaN(setting))
      var settingCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type][setting];
    else
      var settingCode = setting;
    return [
      typeCode,
      settingCode
    ];
  }
  function $3b6302b64eccc32c$export$bd6df347a4f391c4(features2) {
    let res = {};
    if (Array.isArray(features2))
      for (let k = 0; k < features2.length; k++) {
        let r;
        let f = $3b6302b64eccc32c$var$mapFeatureStrings(features2[k]);
        if (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]])
          res[r] = true;
      }
    else if (typeof features2 === "object")
      for (let type in features2) {
        let feature1 = features2[type];
        for (let setting in feature1) {
          let r;
          let f = $3b6302b64eccc32c$var$mapFeatureStrings([
            type,
            setting
          ]);
          if (feature1[setting] && (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]]))
            res[r] = true;
        }
      }
    return Object.keys(res);
  }
  var $ff5ce077dae0f144$export$2e2bcd8739ae039 = class {
    lookup(glyph) {
      switch (this.table.version) {
        case 0:
          return this.table.values.getItem(glyph);
        case 2:
        case 4: {
          let min = 0;
          let max = this.table.binarySearchHeader.nUnits - 1;
          while (min <= max) {
            var mid = min + max >> 1;
            var seg = this.table.segments[mid];
            if (seg.firstGlyph === 65535)
              return null;
            if (glyph < seg.firstGlyph)
              max = mid - 1;
            else if (glyph > seg.lastGlyph)
              min = mid + 1;
            else {
              if (this.table.version === 2)
                return seg.value;
              else
                return seg.values[glyph - seg.firstGlyph];
            }
          }
          return null;
        }
        case 6: {
          let min = 0;
          let max = this.table.binarySearchHeader.nUnits - 1;
          while (min <= max) {
            var mid = min + max >> 1;
            var seg = this.table.segments[mid];
            if (seg.glyph === 65535)
              return null;
            if (glyph < seg.glyph)
              max = mid - 1;
            else if (glyph > seg.glyph)
              min = mid + 1;
            else
              return seg.value;
          }
          return null;
        }
        case 8:
          return this.table.values[glyph - this.table.firstGlyph];
        default:
          throw new Error(`Unknown lookup table format: ${this.table.version}`);
      }
    }
    glyphsForValue(classValue) {
      let res = [];
      switch (this.table.version) {
        case 2:
        case 4:
          for (let segment of this.table.segments)
            if (this.table.version === 2 && segment.value === classValue)
              res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));
            else {
              for (let index = 0; index < segment.values.length; index++)
                if (segment.values[index] === classValue)
                  res.push(segment.firstGlyph + index);
            }
          break;
        case 6:
          for (let segment1 of this.table.segments)
            if (segment1.value === classValue)
              res.push(segment1.glyph);
          break;
        case 8:
          for (let i = 0; i < this.table.values.length; i++)
            if (this.table.values[i] === classValue)
              res.push(this.table.firstGlyph + i);
          break;
        default:
          throw new Error(`Unknown lookup table format: ${this.table.version}`);
      }
      return res;
    }
    constructor(table) {
      this.table = table;
    }
  };
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
  var $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;
  var $50c7aac9316f2948$var$START_OF_LINE_STATE = 1;
  var $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;
  var $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;
  var $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;
  var $50c7aac9316f2948$var$END_OF_LINE_CLASS = 3;
  var $50c7aac9316f2948$var$DONT_ADVANCE = 16384;
  var $50c7aac9316f2948$export$2e2bcd8739ae039 = class {
    process(glyphs, reverse, processEntry) {
      let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE;
      let index = reverse ? glyphs.length - 1 : 0;
      let dir = reverse ? -1 : 1;
      while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {
        let glyph = null;
        let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
        let shouldAdvance = true;
        if (index === glyphs.length || index === -1)
          classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;
        else {
          glyph = glyphs[index];
          if (glyph.id === 65535)
            classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;
          else {
            classCode = this.lookupTable.lookup(glyph.id);
            if (classCode == null)
              classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
          }
        }
        let row = this.stateTable.stateArray.getItem(currentState);
        let entryIndex = row[classCode];
        let entry = this.stateTable.entryTable.getItem(entryIndex);
        if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {
          processEntry(glyph, entry, index);
          shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);
        }
        currentState = entry.newState;
        if (shouldAdvance)
          index += dir;
      }
      return glyphs;
    }
    /**
    * Performs a depth-first traversal of the glyph strings
    * represented by the state machine.
    */
    traverse(opts, state = 0, visited = /* @__PURE__ */ new Set()) {
      if (visited.has(state))
        return;
      visited.add(state);
      let { nClasses, stateArray, entryTable } = this.stateTable;
      let row = stateArray.getItem(state);
      for (let classCode = 4; classCode < nClasses; classCode++) {
        let entryIndex = row[classCode];
        let entry = entryTable.getItem(entryIndex);
        for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
          if (opts.enter)
            opts.enter(glyph, entry);
          if (entry.newState !== 0)
            this.traverse(opts, entry.newState, visited);
          if (opts.exit)
            opts.exit(glyph, entry);
        }
      }
    }
    constructor(stateTable) {
      this.stateTable = stateTable;
      this.lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(stateTable.classTable);
    }
  };
  var $55f71433a605c87d$var$MARK_FIRST = 32768;
  var $55f71433a605c87d$var$MARK_LAST = 8192;
  var $55f71433a605c87d$var$VERB = 15;
  var $55f71433a605c87d$var$SET_MARK = 32768;
  var $55f71433a605c87d$var$SET_COMPONENT = 32768;
  var $55f71433a605c87d$var$PERFORM_ACTION = 8192;
  var $55f71433a605c87d$var$LAST_MASK = 2147483648;
  var $55f71433a605c87d$var$STORE_MASK = 1073741824;
  var $55f71433a605c87d$var$OFFSET_MASK = 1073741823;
  var $55f71433a605c87d$var$VERTICAL_ONLY = 8388608;
  var $55f71433a605c87d$var$REVERSE_DIRECTION = 4194304;
  var $55f71433a605c87d$var$HORIZONTAL_AND_VERTICAL = 2097152;
  var $55f71433a605c87d$var$CURRENT_IS_KASHIDA_LIKE = 8192;
  var $55f71433a605c87d$var$MARKED_IS_KASHIDA_LIKE = 4096;
  var $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 2048;
  var $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 1024;
  var $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 992;
  var $55f71433a605c87d$var$MARKED_INSERT_COUNT = 31;
  var $55f71433a605c87d$export$2e2bcd8739ae039 = class {
    // Processes an array of glyphs and applies the specified features
    // Features should be in the form of {featureType:{featureSetting:boolean}}
    process(glyphs, features = {}) {
      for (let chain of this.morx.chains) {
        let flags = chain.defaultFlags;
        for (let feature of chain.features) {
          let f;
          if (f = features[feature.featureType]) {
            if (f[feature.featureSetting]) {
              flags &= feature.disableFlags;
              flags |= feature.enableFlags;
            } else if (f[feature.featureSetting] === false) {
              flags |= ~feature.disableFlags;
              flags &= ~feature.enableFlags;
            }
          }
        }
        for (let subtable of chain.subtables)
          if (subtable.subFeatureFlags & flags)
            this.processSubtable(subtable, glyphs);
      }
      let index = glyphs.length - 1;
      while (index >= 0) {
        if (glyphs[index].id === 65535)
          glyphs.splice(index, 1);
        index--;
      }
      return glyphs;
    }
    processSubtable(subtable, glyphs) {
      this.subtable = subtable;
      this.glyphs = glyphs;
      if (this.subtable.type === 4) {
        this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
        return;
      }
      this.ligatureStack = [];
      this.markedGlyph = null;
      this.firstGlyph = null;
      this.lastGlyph = null;
      this.markedIndex = null;
      let stateMachine = this.getStateMachine(subtable);
      let process = this.getProcessor();
      let reverse = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
      return stateMachine.process(this.glyphs, reverse, process);
    }
    getStateMachine(subtable) {
      return new (0, $50c7aac9316f2948$export$2e2bcd8739ae039)(subtable.table.stateTable);
    }
    getProcessor() {
      switch (this.subtable.type) {
        case 0:
          return this.processIndicRearragement;
        case 1:
          return this.processContextualSubstitution;
        case 2:
          return this.processLigature;
        case 4:
          return this.processNoncontextualSubstitutions;
        case 5:
          return this.processGlyphInsertion;
        default:
          throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
      }
    }
    processIndicRearragement(glyph, entry, index) {
      if (entry.flags & $55f71433a605c87d$var$MARK_FIRST)
        this.firstGlyph = index;
      if (entry.flags & $55f71433a605c87d$var$MARK_LAST)
        this.lastGlyph = index;
      $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);
    }
    processContextualSubstitution(glyph, entry, index) {
      let subsitutions = this.subtable.table.substitutionTable.items;
      if (entry.markIndex !== 65535) {
        let lookup4 = subsitutions.getItem(entry.markIndex);
        let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
        glyph = this.glyphs[this.markedGlyph];
        var gid = lookupTable.lookup(glyph.id);
        if (gid)
          this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
      }
      if (entry.currentIndex !== 65535) {
        let lookup4 = subsitutions.getItem(entry.currentIndex);
        let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
        glyph = this.glyphs[index];
        var gid = lookupTable.lookup(glyph.id);
        if (gid)
          this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
      }
      if (entry.flags & $55f71433a605c87d$var$SET_MARK)
        this.markedGlyph = index;
    }
    processLigature(glyph, entry, index) {
      if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT)
        this.ligatureStack.push(index);
      if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {
        let actions = this.subtable.table.ligatureActions;
        let components = this.subtable.table.components;
        let ligatureList = this.subtable.table.ligatureList;
        let actionIndex = entry.action;
        let last2 = false;
        let ligatureIndex = 0;
        let codePoints = [];
        let ligatureGlyphs = [];
        while (!last2) {
          let componentGlyph = this.ligatureStack.pop();
          codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
          let action = actions.getItem(actionIndex++);
          last2 = !!(action & $55f71433a605c87d$var$LAST_MASK);
          let store = !!(action & $55f71433a605c87d$var$STORE_MASK);
          let offset = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2;
          offset += this.glyphs[componentGlyph].id;
          let component = components.getItem(offset);
          ligatureIndex += component;
          if (last2 || store) {
            let ligatureEntry = ligatureList.getItem(ligatureIndex);
            this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
            ligatureGlyphs.push(componentGlyph);
            ligatureIndex = 0;
            codePoints = [];
          } else
            this.glyphs[componentGlyph] = this.font.getGlyph(65535);
        }
        this.ligatureStack.push(...ligatureGlyphs);
      }
    }
    processNoncontextualSubstitutions(subtable, glyphs, index) {
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(subtable.table.lookupTable);
      for (index = 0; index < glyphs.length; index++) {
        let glyph = glyphs[index];
        if (glyph.id !== 65535) {
          let gid = lookupTable.lookup(glyph.id);
          if (gid)
            glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
        }
      }
    }
    _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
      let insertions = [];
      while (count--) {
        let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
        insertions.push(this.font.getGlyph(gid));
      }
      if (!isBefore)
        glyphIndex++;
      this.glyphs.splice(glyphIndex, 0, ...insertions);
    }
    processGlyphInsertion(glyph, entry, index) {
      if (entry.flags & $55f71433a605c87d$var$SET_MARK)
        this.markedIndex = index;
      if (entry.markedInsertIndex !== 65535) {
        let count = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;
        let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);
        this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
      }
      if (entry.currentInsertIndex !== 65535) {
        let count = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;
        let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);
        this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore);
      }
    }
    getSupportedFeatures() {
      let features = [];
      for (let chain of this.morx.chains)
        for (let feature of chain.features)
          features.push([
            feature.featureType,
            feature.featureSetting
          ]);
      return features;
    }
    generateInputs(gid) {
      if (!this.inputCache)
        this.generateInputCache();
      return this.inputCache[gid] || [];
    }
    generateInputCache() {
      this.inputCache = {};
      for (let chain of this.morx.chains) {
        let flags = chain.defaultFlags;
        for (let subtable of chain.subtables)
          if (subtable.subFeatureFlags & flags)
            this.generateInputsForSubtable(subtable);
      }
    }
    generateInputsForSubtable(subtable) {
      if (subtable.type !== 2)
        return;
      let reverse = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
      if (reverse)
        throw new Error("Reverse subtable, not supported.");
      this.subtable = subtable;
      this.ligatureStack = [];
      let stateMachine = this.getStateMachine(subtable);
      let process = this.getProcessor();
      let input = [];
      let stack = [];
      this.glyphs = [];
      stateMachine.traverse({
        enter: (glyph, entry) => {
          let glyphs = this.glyphs;
          stack.push({
            glyphs: glyphs.slice(),
            ligatureStack: this.ligatureStack.slice()
          });
          let g1 = this.font.getGlyph(glyph);
          input.push(g1);
          glyphs.push(input[input.length - 1]);
          process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
          let count = 0;
          let found = 0;
          for (let i = 0; i < glyphs.length && count <= 1; i++)
            if (glyphs[i].id !== 65535) {
              count++;
              found = glyphs[i].id;
            }
          if (count === 1) {
            let result = input.map((g) => g.id);
            let cache1 = this.inputCache[found];
            if (cache1)
              cache1.push(result);
            else
              this.inputCache[found] = [
                result
              ];
          }
        },
        exit: () => {
          ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
          input.pop();
        }
      });
    }
    constructor(font) {
      this.processIndicRearragement = this.processIndicRearragement.bind(this);
      this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
      this.processLigature = this.processLigature.bind(this);
      this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
      this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
      this.font = font;
      this.morx = font.morx;
      this.inputCache = null;
    }
  };
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
  function $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
    let end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
    if (reverseB)
      end.reverse();
    let start = glyphs.splice(rangeA[0], rangeA[1], ...end);
    if (reverseA)
      start.reverse();
    glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start);
    return glyphs;
  }
  function $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
    let length = lastGlyph - firstGlyph + 1;
    switch (verb) {
      case 0:
        return glyphs;
      case 1:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          1
        ], [
          lastGlyph,
          0
        ]);
      case 2:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          0
        ], [
          lastGlyph,
          1
        ]);
      case 3:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          1
        ], [
          lastGlyph,
          1
        ]);
      case 4:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          2
        ], [
          lastGlyph,
          0
        ]);
      case 5:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          2
        ], [
          lastGlyph,
          0
        ], true, false);
      case 6:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          0
        ], [
          lastGlyph,
          2
        ]);
      case 7:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          0
        ], [
          lastGlyph,
          2
        ], false, true);
      case 8:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          1
        ], [
          lastGlyph,
          2
        ]);
      case 9:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          1
        ], [
          lastGlyph,
          2
        ], false, true);
      case 10:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          2
        ], [
          lastGlyph,
          1
        ]);
      case 11:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          2
        ], [
          lastGlyph,
          1
        ], true, false);
      case 12:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          2
        ], [
          lastGlyph,
          2
        ]);
      case 13:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          2
        ], [
          lastGlyph,
          2
        ], true, false);
      case 14:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          2
        ], [
          lastGlyph,
          2
        ], false, true);
      case 15:
        return $55f71433a605c87d$var$swap(glyphs, [
          firstGlyph,
          2
        ], [
          lastGlyph,
          2
        ], true, true);
      default:
        throw new Error(`Unknown verb: ${verb}`);
    }
  }
  var $ba6dd74203be8728$export$2e2bcd8739ae039 = class {
    substitute(glyphRun) {
      if (glyphRun.direction === "rtl")
        glyphRun.glyphs.reverse();
      this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));
    }
    getAvailableFeatures(script, language) {
      return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
    }
    stringsForGlyph(gid) {
      let glyphStrings = this.morxProcessor.generateInputs(gid);
      let result = /* @__PURE__ */ new Set();
      for (let glyphs of glyphStrings)
        this._addStrings(glyphs, 0, result, "");
      return result;
    }
    _addStrings(glyphs, index, strings, string) {
      let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);
      for (let codePoint of codePoints) {
        let s = string + String.fromCodePoint(codePoint);
        if (index < glyphs.length - 1)
          this._addStrings(glyphs, index + 1, strings, s);
        else
          strings.add(s);
      }
    }
    constructor(font) {
      this.font = font;
      this.morxProcessor = new (0, $55f71433a605c87d$export$2e2bcd8739ae039)(font);
      this.fallbackPosition = false;
    }
  };
  var $94d7a73bd2edfc9a$export$2e2bcd8739ae039 = class {
    /**
    * Adds the given features to the last stage.
    * Ignores features that have already been applied.
    */
    _addFeatures(features, global) {
      let stageIndex = this.stages.length - 1;
      let stage = this.stages[stageIndex];
      for (let feature of features)
        if (this.allFeatures[feature] == null) {
          stage.push(feature);
          this.allFeatures[feature] = stageIndex;
          if (global)
            this.globalFeatures[feature] = true;
        }
    }
    /**
    * Add features to the last stage
    */
    add(arg, global = true) {
      if (this.stages.length === 0)
        this.stages.push([]);
      if (typeof arg === "string")
        arg = [
          arg
        ];
      if (Array.isArray(arg))
        this._addFeatures(arg, global);
      else if (typeof arg === "object") {
        this._addFeatures(arg.global || [], true);
        this._addFeatures(arg.local || [], false);
      } else
        throw new Error("Unsupported argument to ShapingPlan#add");
    }
    /**
    * Add a new stage
    */
    addStage(arg, global) {
      if (typeof arg === "function")
        this.stages.push(arg, []);
      else {
        this.stages.push([]);
        this.add(arg, global);
      }
    }
    setFeatureOverrides(features) {
      if (Array.isArray(features))
        this.add(features);
      else if (typeof features === "object")
        for (let tag in features) {
          if (features[tag])
            this.add(tag);
          else if (this.allFeatures[tag] != null) {
            let stage = this.stages[this.allFeatures[tag]];
            stage.splice(stage.indexOf(tag), 1);
            delete this.allFeatures[tag];
            delete this.globalFeatures[tag];
          }
        }
    }
    /**
    * Assigns the global features to the given glyphs
    */
    assignGlobalFeatures(glyphs) {
      for (let glyph of glyphs)
        for (let feature in this.globalFeatures)
          glyph.features[feature] = true;
    }
    /**
    * Executes the planned stages using the given OTProcessor
    */
    process(processor, glyphs, positions) {
      for (let stage of this.stages) {
        if (typeof stage === "function") {
          if (!positions)
            stage(this.font, glyphs, this);
        } else if (stage.length > 0)
          processor.applyFeatures(stage, glyphs, positions);
      }
    }
    constructor(font, script, direction) {
      this.font = font;
      this.script = script;
      this.direction = direction;
      this.stages = [];
      this.globalFeatures = {};
      this.allFeatures = {};
    }
  };
  var $649970d87335b30f$var$VARIATION_FEATURES = [
    "rvrn"
  ];
  var $649970d87335b30f$var$COMMON_FEATURES = [
    "ccmp",
    "locl",
    "rlig",
    "mark",
    "mkmk"
  ];
  var $649970d87335b30f$var$FRACTIONAL_FEATURES = [
    "frac",
    "numr",
    "dnom"
  ];
  var $649970d87335b30f$var$HORIZONTAL_FEATURES = [
    "calt",
    "clig",
    "liga",
    "rclt",
    "curs",
    "kern"
  ];
  var $649970d87335b30f$var$VERTICAL_FEATURES = [
    "vert"
  ];
  var $649970d87335b30f$var$DIRECTIONAL_FEATURES = {
    ltr: [
      "ltra",
      "ltrm"
    ],
    rtl: [
      "rtla",
      "rtlm"
    ]
  };
  var $649970d87335b30f$export$2e2bcd8739ae039 = class {
    static plan(plan, glyphs, features) {
      this.planPreprocessing(plan);
      this.planFeatures(plan);
      this.planPostprocessing(plan, features);
      plan.assignGlobalFeatures(glyphs);
      this.assignFeatures(plan, glyphs);
    }
    static planPreprocessing(plan) {
      plan.add({
        global: [
          ...$649970d87335b30f$var$VARIATION_FEATURES,
          ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]
        ],
        local: $649970d87335b30f$var$FRACTIONAL_FEATURES
      });
    }
    static planFeatures(plan) {
    }
    static planPostprocessing(plan, userFeatures) {
      plan.add([
        ...$649970d87335b30f$var$COMMON_FEATURES,
        ...$649970d87335b30f$var$HORIZONTAL_FEATURES
      ]);
      plan.setFeatureOverrides(userFeatures);
    }
    static assignFeatures(plan, glyphs) {
      for (let i = 0; i < glyphs.length; i++) {
        let glyph = glyphs[i];
        if (glyph.codePoints[0] === 8260) {
          let start = i;
          let end = i + 1;
          while (start > 0 && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[start - 1].codePoints[0])) {
            glyphs[start - 1].features.numr = true;
            glyphs[start - 1].features.frac = true;
            start--;
          }
          while (end < glyphs.length && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[end].codePoints[0])) {
            glyphs[end].features.dnom = true;
            glyphs[end].features.frac = true;
            end++;
          }
          glyph.features.frac = true;
          i = end - 1;
        }
      }
    }
  };
  (0, _defineProperty)($649970d87335b30f$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
  var $764eb544bbe1ccf0$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("ABABAAAAAACgMQAAAZUBav7t2CtPA0EUBeDZB00pin9AJZIEgyUEj0QhweDAgQOJxCBRBElQSBwSicLgkOAwnNKZ5GaY2c7uzj4o5yZfZrrbefbuIx2nSq3CGmzAWH/+K+UO7MIe7MMhHMMpnMMFXMIVXIt2t3CnP088iPqjqNN8e4Ij7Rle4LUH82rLm6i/92A+RERERERERERNmfz/89GDeRARERERzbN8ceps2Iwt9H0C9/AJ6yOlDkbTczcot5VSm8Pm1vcFWfb7+BKOLTuOd2UlTX4wGP85Eg953lWPFbnuN7PkjtLmalOWbNenkHOSa7T3KmR9MVTZ2zZkVj1kHa68MueVKH0R4zqQ44WEXLM8VjcWHP0PtKLfPzQnMtGn3W4QYf6qxFxceVI394r2xnV+1rih0fV1Vzf3fO1n3evL5J78ruvZ5ptX2Rwy92Tfb1wlEqut3U+sZ3HXOeJ7/zDrbyuP6+Zz0fqa6Nv3vhY7Yu1xWnGevmsvsUpTT/RYIe8waUH/rvHMWKFzLfN8L+rTfp645mfX7ftlnfDtYxN59w0="));
  var $764eb544bbe1ccf0$var$FEATURES = [
    "isol",
    "fina",
    "fin2",
    "fin3",
    "medi",
    "med2",
    "init"
  ];
  var $764eb544bbe1ccf0$var$ShapingClasses = {
    Non_Joining: 0,
    Left_Joining: 1,
    Right_Joining: 2,
    Dual_Joining: 3,
    Join_Causing: 3,
    ALAPH: 4,
    "DALATH RISH": 5,
    Transparent: 6
  };
  var $764eb544bbe1ccf0$var$ISOL = "isol";
  var $764eb544bbe1ccf0$var$FINA = "fina";
  var $764eb544bbe1ccf0$var$FIN2 = "fin2";
  var $764eb544bbe1ccf0$var$FIN3 = "fin3";
  var $764eb544bbe1ccf0$var$MEDI = "medi";
  var $764eb544bbe1ccf0$var$MED2 = "med2";
  var $764eb544bbe1ccf0$var$INIT = "init";
  var $764eb544bbe1ccf0$var$NONE = null;
  var $764eb544bbe1ccf0$var$STATE_TABLE = [
    //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
    // State 0: prev was U,  not willing to join.
    [
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$NONE,
        0
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        1
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        1
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        6
      ]
    ],
    // State 1: prev was R or ISOL/ALAPH,  not willing to join.
    [
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$NONE,
        0
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        1
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$FIN2,
        5
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        6
      ]
    ],
    // State 2: prev was D/L in ISOL form,  willing to join.
    [
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$NONE,
        0
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$INIT,
        $764eb544bbe1ccf0$var$FINA,
        1
      ],
      [
        $764eb544bbe1ccf0$var$INIT,
        $764eb544bbe1ccf0$var$FINA,
        3
      ],
      [
        $764eb544bbe1ccf0$var$INIT,
        $764eb544bbe1ccf0$var$FINA,
        4
      ],
      [
        $764eb544bbe1ccf0$var$INIT,
        $764eb544bbe1ccf0$var$FINA,
        6
      ]
    ],
    // State 3: prev was D in FINA form,  willing to join.
    [
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$NONE,
        0
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$MEDI,
        $764eb544bbe1ccf0$var$FINA,
        1
      ],
      [
        $764eb544bbe1ccf0$var$MEDI,
        $764eb544bbe1ccf0$var$FINA,
        3
      ],
      [
        $764eb544bbe1ccf0$var$MEDI,
        $764eb544bbe1ccf0$var$FINA,
        4
      ],
      [
        $764eb544bbe1ccf0$var$MEDI,
        $764eb544bbe1ccf0$var$FINA,
        6
      ]
    ],
    // State 4: prev was FINA ALAPH,  not willing to join.
    [
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$NONE,
        0
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$MED2,
        $764eb544bbe1ccf0$var$ISOL,
        1
      ],
      [
        $764eb544bbe1ccf0$var$MED2,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$MED2,
        $764eb544bbe1ccf0$var$FIN2,
        5
      ],
      [
        $764eb544bbe1ccf0$var$MED2,
        $764eb544bbe1ccf0$var$ISOL,
        6
      ]
    ],
    // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
    [
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$NONE,
        0
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$ISOL,
        $764eb544bbe1ccf0$var$ISOL,
        1
      ],
      [
        $764eb544bbe1ccf0$var$ISOL,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$ISOL,
        $764eb544bbe1ccf0$var$FIN2,
        5
      ],
      [
        $764eb544bbe1ccf0$var$ISOL,
        $764eb544bbe1ccf0$var$ISOL,
        6
      ]
    ],
    // State 6: prev was DALATH/RISH,  not willing to join.
    [
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$NONE,
        0
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        1
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        2
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$FIN3,
        5
      ],
      [
        $764eb544bbe1ccf0$var$NONE,
        $764eb544bbe1ccf0$var$ISOL,
        6
      ]
    ]
  ];
  var $764eb544bbe1ccf0$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
    static planFeatures(plan) {
      plan.add([
        "ccmp",
        "locl"
      ]);
      for (let i = 0; i < $764eb544bbe1ccf0$var$FEATURES.length; i++) {
        let feature = $764eb544bbe1ccf0$var$FEATURES[i];
        plan.addStage(feature, false);
      }
      plan.addStage("mset");
    }
    static assignFeatures(plan, glyphs) {
      super.assignFeatures(plan, glyphs);
      let prev = -1;
      let state = 0;
      let actions = [];
      for (let i = 0; i < glyphs.length; i++) {
        let curAction, prevAction;
        var glyph = glyphs[i];
        let type = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);
        if (type === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {
          actions[i] = $764eb544bbe1ccf0$var$NONE;
          continue;
        }
        [prevAction, curAction, state] = $764eb544bbe1ccf0$var$STATE_TABLE[state][type];
        if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1)
          actions[prev] = prevAction;
        actions[i] = curAction;
        prev = i;
      }
      for (let index = 0; index < glyphs.length; index++) {
        let feature;
        var glyph = glyphs[index];
        if (feature = actions[index])
          glyph.features[feature] = true;
      }
    }
  };
  function $764eb544bbe1ccf0$var$getShapingClass(codePoint) {
    let res = $764eb544bbe1ccf0$var$trie.get(codePoint);
    if (res)
      return res - 1;
    let category = (0, $747425b437e121da$export$410364bbb673ddbc)(codePoint);
    if (category === "Mn" || category === "Me" || category === "Cf")
      return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;
    return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;
  }
  var $85d408632270248b$export$2e2bcd8739ae039 = class {
    reset(options = {}, index = 0) {
      this.options = options;
      this.flags = options.flags || {};
      this.markAttachmentType = options.markAttachmentType || 0;
      this.index = index;
    }
    get cur() {
      return this.glyphs[this.index] || null;
    }
    shouldIgnore(glyph) {
      return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
    }
    move(dir) {
      this.index += dir;
      while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index]))
        this.index += dir;
      if (0 > this.index || this.index >= this.glyphs.length)
        return null;
      return this.glyphs[this.index];
    }
    next() {
      return this.move(1);
    }
    prev() {
      return this.move(-1);
    }
    peek(count = 1) {
      let idx = this.index;
      let res = this.increment(count);
      this.index = idx;
      return res;
    }
    peekIndex(count = 1) {
      let idx = this.index;
      this.increment(count);
      let res = this.index;
      this.index = idx;
      return res;
    }
    increment(count = 1) {
      let dir = count < 0 ? -1 : 1;
      count = Math.abs(count);
      while (count--)
        this.move(dir);
      return this.glyphs[this.index];
    }
    constructor(glyphs, options) {
      this.glyphs = glyphs;
      this.reset(options);
    }
  };
  var $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = [
    "DFLT",
    "dflt",
    "latn"
  ];
  var $a83b9c36aaa94fd3$export$2e2bcd8739ae039 = class {
    findScript(script) {
      if (this.table.scriptList == null)
        return null;
      if (!Array.isArray(script))
        script = [
          script
        ];
      for (let s of script)
        for (let entry of this.table.scriptList) {
          if (entry.tag === s)
            return entry;
        }
      return null;
    }
    selectScript(script, language, direction) {
      let changed = false;
      let entry;
      if (!this.script || script !== this.scriptTag) {
        entry = this.findScript(script);
        if (!entry)
          entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);
        if (!entry)
          return this.scriptTag;
        this.scriptTag = entry.tag;
        this.script = entry.script;
        this.language = null;
        this.languageTag = null;
        changed = true;
      }
      if (!direction || direction !== this.direction)
        this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
      if (language && language.length < 4)
        language += " ".repeat(4 - language.length);
      if (!language || language !== this.languageTag) {
        this.language = null;
        for (let lang of this.script.langSysRecords)
          if (lang.tag === language) {
            this.language = lang.langSys;
            this.languageTag = lang.tag;
            break;
          }
        if (!this.language) {
          this.language = this.script.defaultLangSys;
          this.languageTag = null;
        }
        changed = true;
      }
      if (changed) {
        this.features = {};
        if (this.language)
          for (let featureIndex of this.language.featureIndexes) {
            let record = this.table.featureList[featureIndex];
            let substituteFeature = this.substituteFeatureForVariations(featureIndex);
            this.features[record.tag] = substituteFeature || record.feature;
          }
      }
      return this.scriptTag;
    }
    lookupsForFeatures(userFeatures = [], exclude) {
      let lookups = [];
      for (let tag of userFeatures) {
        let feature = this.features[tag];
        if (!feature)
          continue;
        for (let lookupIndex of feature.lookupListIndexes) {
          if (exclude && exclude.indexOf(lookupIndex) !== -1)
            continue;
          lookups.push({
            feature: tag,
            index: lookupIndex,
            lookup: this.table.lookupList.get(lookupIndex)
          });
        }
      }
      lookups.sort((a, b) => a.index - b.index);
      return lookups;
    }
    substituteFeatureForVariations(featureIndex) {
      if (this.variationsIndex === -1)
        return null;
      let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
      let substitutions = record.featureTableSubstitution.substitutions;
      for (let substitution of substitutions) {
        if (substitution.featureIndex === featureIndex)
          return substitution.alternateFeatureTable;
      }
      return null;
    }
    findVariationsIndex(coords) {
      let variations = this.table.featureVariations;
      if (!variations)
        return -1;
      let records = variations.featureVariationRecords;
      for (let i = 0; i < records.length; i++) {
        let conditions = records[i].conditionSet.conditionTable;
        if (this.variationConditionsMatch(conditions, coords))
          return i;
      }
      return -1;
    }
    variationConditionsMatch(conditions, coords) {
      return conditions.every((condition) => {
        let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
        return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
      });
    }
    applyFeatures(userFeatures, glyphs, advances) {
      let lookups = this.lookupsForFeatures(userFeatures);
      this.applyLookups(lookups, glyphs, advances);
    }
    applyLookups(lookups, glyphs, positions) {
      this.glyphs = glyphs;
      this.positions = positions;
      this.glyphIterator = new (0, $85d408632270248b$export$2e2bcd8739ae039)(glyphs);
      for (let { feature, lookup: lookup4 } of lookups) {
        this.currentFeature = feature;
        this.glyphIterator.reset(lookup4.flags);
        while (this.glyphIterator.index < glyphs.length) {
          if (!(feature in this.glyphIterator.cur.features)) {
            this.glyphIterator.next();
            continue;
          }
          for (let table of lookup4.subTables) {
            let res = this.applyLookup(lookup4.lookupType, table);
            if (res)
              break;
          }
          this.glyphIterator.next();
        }
      }
    }
    applyLookup(lookup4, table) {
      throw new Error("applyLookup must be implemented by subclasses");
    }
    applyLookupList(lookupRecords) {
      let options = this.glyphIterator.options;
      let glyphIndex = this.glyphIterator.index;
      for (let lookupRecord of lookupRecords) {
        this.glyphIterator.reset(options, glyphIndex);
        this.glyphIterator.increment(lookupRecord.sequenceIndex);
        let lookup4 = this.table.lookupList.get(lookupRecord.lookupListIndex);
        this.glyphIterator.reset(lookup4.flags, this.glyphIterator.index);
        for (let table of lookup4.subTables) {
          if (this.applyLookup(lookup4.lookupType, table))
            break;
        }
      }
      this.glyphIterator.reset(options, glyphIndex);
      return true;
    }
    coverageIndex(coverage, glyph) {
      if (glyph == null)
        glyph = this.glyphIterator.cur.id;
      switch (coverage.version) {
        case 1:
          return coverage.glyphs.indexOf(glyph);
        case 2:
          for (let range2 of coverage.rangeRecords) {
            if (range2.start <= glyph && glyph <= range2.end)
              return range2.startCoverageIndex + glyph - range2.start;
          }
          break;
      }
      return -1;
    }
    match(sequenceIndex, sequence, fn, matched) {
      let pos = this.glyphIterator.index;
      let glyph = this.glyphIterator.increment(sequenceIndex);
      let idx = 0;
      while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
        if (matched)
          matched.push(this.glyphIterator.index);
        idx++;
        glyph = this.glyphIterator.next();
      }
      this.glyphIterator.index = pos;
      if (idx < sequence.length)
        return false;
      return matched || true;
    }
    sequenceMatches(sequenceIndex, sequence) {
      return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
    }
    sequenceMatchIndices(sequenceIndex, sequence) {
      return this.match(sequenceIndex, sequence, (component, glyph) => {
        if (!(this.currentFeature in glyph.features))
          return false;
        return component === glyph.id;
      }, []);
    }
    coverageSequenceMatches(sequenceIndex, sequence) {
      return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
    }
    getClassID(glyph, classDef) {
      switch (classDef.version) {
        case 1:
          let i = glyph - classDef.startGlyph;
          if (i >= 0 && i < classDef.classValueArray.length)
            return classDef.classValueArray[i];
          break;
        case 2:
          for (let range2 of classDef.classRangeRecord) {
            if (range2.start <= glyph && glyph <= range2.end)
              return range2.class;
          }
          break;
      }
      return 0;
    }
    classSequenceMatches(sequenceIndex, sequence, classDef) {
      return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
    }
    applyContext(table) {
      let index, set;
      switch (table.version) {
        case 1:
          index = this.coverageIndex(table.coverage);
          if (index === -1)
            return false;
          set = table.ruleSets[index];
          for (let rule of set) {
            if (this.sequenceMatches(1, rule.input))
              return this.applyLookupList(rule.lookupRecords);
          }
          break;
        case 2:
          if (this.coverageIndex(table.coverage) === -1)
            return false;
          index = this.getClassID(this.glyphIterator.cur.id, table.classDef);
          if (index === -1)
            return false;
          set = table.classSet[index];
          for (let rule1 of set) {
            if (this.classSequenceMatches(1, rule1.classes, table.classDef))
              return this.applyLookupList(rule1.lookupRecords);
          }
          break;
        case 3:
          if (this.coverageSequenceMatches(0, table.coverages))
            return this.applyLookupList(table.lookupRecords);
          break;
      }
      return false;
    }
    applyChainingContext(table) {
      let index;
      switch (table.version) {
        case 1:
          index = this.coverageIndex(table.coverage);
          if (index === -1)
            return false;
          let set = table.chainRuleSets[index];
          for (let rule of set) {
            if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead))
              return this.applyLookupList(rule.lookupRecords);
          }
          break;
        case 2:
          if (this.coverageIndex(table.coverage) === -1)
            return false;
          index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
          let rules = table.chainClassSet[index];
          if (!rules)
            return false;
          for (let rule2 of rules) {
            if (this.classSequenceMatches(-rule2.backtrack.length, rule2.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule2.input, table.inputClassDef) && this.classSequenceMatches(1 + rule2.input.length, rule2.lookahead, table.lookaheadClassDef))
              return this.applyLookupList(rule2.lookupRecords);
          }
          break;
        case 3:
          if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage))
            return this.applyLookupList(table.lookupRecords);
          break;
      }
      return false;
    }
    constructor(font, table) {
      this.font = font;
      this.table = table;
      this.script = null;
      this.scriptTag = null;
      this.language = null;
      this.languageTag = null;
      this.features = {};
      this.lookups = {};
      this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
      this.selectScript();
      this.glyphs = [];
      this.positions = [];
      this.ligatureID = 1;
      this.currentFeature = null;
    }
  };
  var $10e7b257e1a9a756$export$2e2bcd8739ae039 = class _$10e7b257e1a9a756$export$2e2bcd8739ae039 {
    get id() {
      return this._id;
    }
    set id(id) {
      this._id = id;
      this.substituted = true;
      let GDEF = this._font.GDEF;
      if (GDEF && GDEF.glyphClassDef) {
        let classID = (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.glyphClassDef);
        this.isBase = classID === 1;
        this.isLigature = classID === 2;
        this.isMark = classID === 3;
        this.markAttachmentType = GDEF.markAttachClassDef ? (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
      } else {
        this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
        this.isBase = !this.isMark;
        this.isLigature = this.codePoints.length > 1;
        this.markAttachmentType = 0;
      }
    }
    copy() {
      return new _$10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
    }
    constructor(font, id, codePoints = [], features) {
      this._font = font;
      this.codePoints = codePoints;
      this.id = id;
      this.features = {};
      if (Array.isArray(features))
        for (let i = 0; i < features.length; i++) {
          let feature = features[i];
          this.features[feature] = true;
        }
      else if (typeof features === "object")
        Object.assign(this.features, features);
      this.ligatureID = null;
      this.ligatureComponent = null;
      this.isLigated = false;
      this.cursiveAttachment = null;
      this.markAttachment = null;
      this.shaperInfo = null;
      this.substituted = false;
      this.isMultiplied = false;
    }
  };
  var $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
    static planFeatures(plan) {
      plan.add([
        "ljmo",
        "vjmo",
        "tjmo"
      ], false);
    }
    static assignFeatures(plan, glyphs) {
      let state = 0;
      let i = 0;
      while (i < glyphs.length) {
        let action;
        let glyph = glyphs[i];
        let code = glyph.codePoints[0];
        let type = $e1c6bbc8cb416f8c$var$getType(code);
        [action, state] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state][type];
        switch (action) {
          case $e1c6bbc8cb416f8c$var$DECOMPOSE:
            if (!plan.font.hasGlyphForCodePoint(code))
              i = $e1c6bbc8cb416f8c$var$decompose(glyphs, i, plan.font);
            break;
          case $e1c6bbc8cb416f8c$var$COMPOSE:
            i = $e1c6bbc8cb416f8c$var$compose(glyphs, i, plan.font);
            break;
          case $e1c6bbc8cb416f8c$var$TONE_MARK:
            $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i, plan.font);
            break;
          case $e1c6bbc8cb416f8c$var$INVALID:
            i = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i, plan.font);
            break;
        }
        i++;
      }
    }
  };
  (0, _defineProperty)($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
  var $e1c6bbc8cb416f8c$var$HANGUL_BASE = 44032;
  var $e1c6bbc8cb416f8c$var$HANGUL_END = 55204;
  var $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;
  var $e1c6bbc8cb416f8c$var$L_BASE = 4352;
  var $e1c6bbc8cb416f8c$var$V_BASE = 4449;
  var $e1c6bbc8cb416f8c$var$T_BASE = 4519;
  var $e1c6bbc8cb416f8c$var$L_COUNT = 19;
  var $e1c6bbc8cb416f8c$var$V_COUNT = 21;
  var $e1c6bbc8cb416f8c$var$T_COUNT = 28;
  var $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;
  var $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;
  var $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;
  var $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 9676;
  var $e1c6bbc8cb416f8c$var$isL = (code) => 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
  var $e1c6bbc8cb416f8c$var$isV = (code) => 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
  var $e1c6bbc8cb416f8c$var$isT = (code) => 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
  var $e1c6bbc8cb416f8c$var$isTone = (code) => 12334 <= code && code <= 12335;
  var $e1c6bbc8cb416f8c$var$isLVT = (code) => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code && code <= $e1c6bbc8cb416f8c$var$HANGUL_END;
  var $e1c6bbc8cb416f8c$var$isLV = (code) => code - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0;
  var $e1c6bbc8cb416f8c$var$isCombiningL = (code) => $e1c6bbc8cb416f8c$var$L_BASE <= code && code <= $e1c6bbc8cb416f8c$var$L_END;
  var $e1c6bbc8cb416f8c$var$isCombiningV = (code) => $e1c6bbc8cb416f8c$var$V_BASE <= code && code <= $e1c6bbc8cb416f8c$var$V_END;
  var $e1c6bbc8cb416f8c$var$isCombiningT = (code) => $e1c6bbc8cb416f8c$var$T_BASE + 1 && 1 <= code && code <= $e1c6bbc8cb416f8c$var$T_END;
  var $e1c6bbc8cb416f8c$var$X = 0;
  var $e1c6bbc8cb416f8c$var$L = 1;
  var $e1c6bbc8cb416f8c$var$V = 2;
  var $e1c6bbc8cb416f8c$var$T = 3;
  var $e1c6bbc8cb416f8c$var$LV = 4;
  var $e1c6bbc8cb416f8c$var$LVT = 5;
  var $e1c6bbc8cb416f8c$var$M = 6;
  function $e1c6bbc8cb416f8c$var$getType(code) {
    if ($e1c6bbc8cb416f8c$var$isL(code))
      return $e1c6bbc8cb416f8c$var$L;
    if ($e1c6bbc8cb416f8c$var$isV(code))
      return $e1c6bbc8cb416f8c$var$V;
    if ($e1c6bbc8cb416f8c$var$isT(code))
      return $e1c6bbc8cb416f8c$var$T;
    if ($e1c6bbc8cb416f8c$var$isLV(code))
      return $e1c6bbc8cb416f8c$var$LV;
    if ($e1c6bbc8cb416f8c$var$isLVT(code))
      return $e1c6bbc8cb416f8c$var$LVT;
    if ($e1c6bbc8cb416f8c$var$isTone(code))
      return $e1c6bbc8cb416f8c$var$M;
    return $e1c6bbc8cb416f8c$var$X;
  }
  var $e1c6bbc8cb416f8c$var$NO_ACTION = 0;
  var $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;
  var $e1c6bbc8cb416f8c$var$COMPOSE = 2;
  var $e1c6bbc8cb416f8c$var$TONE_MARK = 4;
  var $e1c6bbc8cb416f8c$var$INVALID = 5;
  var $e1c6bbc8cb416f8c$var$STATE_TABLE = [
    //       X                 L                 V                T                  LV                LVT               M
    // State 0: start state
    [
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        1
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$DECOMPOSE,
        2
      ],
      [
        $e1c6bbc8cb416f8c$var$DECOMPOSE,
        3
      ],
      [
        $e1c6bbc8cb416f8c$var$INVALID,
        0
      ]
    ],
    // State 1: <L>
    [
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        1
      ],
      [
        $e1c6bbc8cb416f8c$var$COMPOSE,
        2
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$DECOMPOSE,
        2
      ],
      [
        $e1c6bbc8cb416f8c$var$DECOMPOSE,
        3
      ],
      [
        $e1c6bbc8cb416f8c$var$INVALID,
        0
      ]
    ],
    // State 2: <L,V> or <LV>
    [
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        1
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$COMPOSE,
        3
      ],
      [
        $e1c6bbc8cb416f8c$var$DECOMPOSE,
        2
      ],
      [
        $e1c6bbc8cb416f8c$var$DECOMPOSE,
        3
      ],
      [
        $e1c6bbc8cb416f8c$var$TONE_MARK,
        0
      ]
    ],
    // State 3: <L,V,T> or <LVT>
    [
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        1
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$NO_ACTION,
        0
      ],
      [
        $e1c6bbc8cb416f8c$var$DECOMPOSE,
        2
      ],
      [
        $e1c6bbc8cb416f8c$var$DECOMPOSE,
        3
      ],
      [
        $e1c6bbc8cb416f8c$var$TONE_MARK,
        0
      ]
    ]
  ];
  function $e1c6bbc8cb416f8c$var$getGlyph(font, code, features) {
    return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, font.glyphForCodePoint(code).id, [
      code
    ], features);
  }
  function $e1c6bbc8cb416f8c$var$decompose(glyphs, i, font) {
    let glyph = glyphs[i];
    let code = glyph.codePoints[0];
    let s = code - $e1c6bbc8cb416f8c$var$HANGUL_BASE;
    let t = $e1c6bbc8cb416f8c$var$T_BASE + s % $e1c6bbc8cb416f8c$var$T_COUNT;
    s = s / $e1c6bbc8cb416f8c$var$T_COUNT | 0;
    let l = $e1c6bbc8cb416f8c$var$L_BASE + s / $e1c6bbc8cb416f8c$var$V_COUNT | 0;
    let v = $e1c6bbc8cb416f8c$var$V_BASE + s % $e1c6bbc8cb416f8c$var$V_COUNT;
    if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t !== $e1c6bbc8cb416f8c$var$T_BASE && !font.hasGlyphForCodePoint(t))
      return i;
    let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font, l, glyph.features);
    ljmo.features.ljmo = true;
    let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, v, glyph.features);
    vjmo.features.vjmo = true;
    let insert2 = [
      ljmo,
      vjmo
    ];
    if (t > $e1c6bbc8cb416f8c$var$T_BASE) {
      let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, t, glyph.features);
      tjmo.features.tjmo = true;
      insert2.push(tjmo);
    }
    glyphs.splice(i, 1, ...insert2);
    return i + insert2.length - 1;
  }
  function $e1c6bbc8cb416f8c$var$compose(glyphs, i, font) {
    let glyph = glyphs[i];
    let code = glyphs[i].codePoints[0];
    let type = $e1c6bbc8cb416f8c$var$getType(code);
    let prev = glyphs[i - 1].codePoints[0];
    let prevType = $e1c6bbc8cb416f8c$var$getType(prev);
    let lv, ljmo, vjmo, tjmo;
    if (prevType === $e1c6bbc8cb416f8c$var$LV && type === $e1c6bbc8cb416f8c$var$T) {
      lv = prev;
      tjmo = glyph;
    } else {
      if (type === $e1c6bbc8cb416f8c$var$V) {
        ljmo = glyphs[i - 1];
        vjmo = glyph;
      } else {
        ljmo = glyphs[i - 2];
        vjmo = glyphs[i - 1];
        tjmo = glyph;
      }
      let l = ljmo.codePoints[0];
      let v = vjmo.codePoints[0];
      if ($e1c6bbc8cb416f8c$var$isCombiningL(l) && $e1c6bbc8cb416f8c$var$isCombiningV(v))
        lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;
    }
    let t = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;
    if (lv != null && (t === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t))) {
      let s = lv + (t - $e1c6bbc8cb416f8c$var$T_BASE);
      if (font.hasGlyphForCodePoint(s)) {
        let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;
        glyphs.splice(i - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font, s, glyph.features));
        return i - del + 1;
      }
    }
    if (ljmo)
      ljmo.features.ljmo = true;
    if (vjmo)
      vjmo.features.vjmo = true;
    if (tjmo)
      tjmo.features.tjmo = true;
    if (prevType === $e1c6bbc8cb416f8c$var$LV) {
      $e1c6bbc8cb416f8c$var$decompose(glyphs, i - 1, font);
      return i + 1;
    }
    return i;
  }
  function $e1c6bbc8cb416f8c$var$getLength(code) {
    switch ($e1c6bbc8cb416f8c$var$getType(code)) {
      case $e1c6bbc8cb416f8c$var$LV:
      case $e1c6bbc8cb416f8c$var$LVT:
        return 1;
      case $e1c6bbc8cb416f8c$var$V:
        return 2;
      case $e1c6bbc8cb416f8c$var$T:
        return 3;
    }
  }
  function $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i, font) {
    let glyph = glyphs[i];
    let code = glyphs[i].codePoints[0];
    if (font.glyphForCodePoint(code).advanceWidth === 0)
      return;
    let prev = glyphs[i - 1].codePoints[0];
    let len = $e1c6bbc8cb416f8c$var$getLength(prev);
    glyphs.splice(i, 1);
    return glyphs.splice(i - len, 0, glyph);
  }
  function $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i, font) {
    let glyph = glyphs[i];
    let code = glyphs[i].codePoints[0];
    if (font.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {
      let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);
      let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;
      glyphs.splice(idx, 0, dottedCircle);
      i++;
    }
    return i;
  }
  var $4b0735ca6c692ea5$exports = {};
  $4b0735ca6c692ea5$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
  var $aa333a9607471296$exports = {};
  $aa333a9607471296$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,23,0,0,2,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
  var $90a9d3398ee54fe5$export$a513ea61a7bee91c = {
    X: 1,
    C: 2,
    V: 4,
    N: 8,
    H: 16,
    ZWNJ: 32,
    ZWJ: 64,
    M: 128,
    SM: 256,
    VD: 512,
    A: 1024,
    Placeholder: 2048,
    Dotted_Circle: 4096,
    RS: 8192,
    Coeng: 16384,
    Repha: 32768,
    Ra: 65536,
    CM: 131072,
    Symbol: 262144
    // Avagraha, etc that take marks (SM,A,VD).
  };
  var $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {
    Start: 1,
    Ra_To_Become_Reph: 2,
    Pre_M: 4,
    Pre_C: 8,
    Base_C: 16,
    After_Main: 32,
    Above_C: 64,
    Before_Sub: 128,
    Below_C: 256,
    After_Sub: 512,
    Before_Post: 1024,
    Post_C: 2048,
    After_Post: 4096,
    Final_C: 8192,
    SMVD: 16384,
    End: 32768
  };
  var $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;
  var $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
  var $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;
  var $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {
    Default: {
      hasOldSpec: false,
      virama: 0,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
      rephMode: "Implicit",
      blwfMode: "Pre_And_Post"
    },
    Devanagari: {
      hasOldSpec: true,
      virama: 2381,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
      rephMode: "Implicit",
      blwfMode: "Pre_And_Post"
    },
    Bengali: {
      hasOldSpec: true,
      virama: 2509,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,
      rephMode: "Implicit",
      blwfMode: "Pre_And_Post"
    },
    Gurmukhi: {
      hasOldSpec: true,
      virama: 2637,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,
      rephMode: "Implicit",
      blwfMode: "Pre_And_Post"
    },
    Gujarati: {
      hasOldSpec: true,
      virama: 2765,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
      rephMode: "Implicit",
      blwfMode: "Pre_And_Post"
    },
    Oriya: {
      hasOldSpec: true,
      virama: 2893,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
      rephMode: "Implicit",
      blwfMode: "Pre_And_Post"
    },
    Tamil: {
      hasOldSpec: true,
      virama: 3021,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
      rephMode: "Implicit",
      blwfMode: "Pre_And_Post"
    },
    Telugu: {
      hasOldSpec: true,
      virama: 3149,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
      rephMode: "Explicit",
      blwfMode: "Post_Only"
    },
    Kannada: {
      hasOldSpec: true,
      virama: 3277,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
      rephMode: "Implicit",
      blwfMode: "Post_Only"
    },
    Malayalam: {
      hasOldSpec: true,
      virama: 3405,
      basePos: "Last",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
      rephMode: "Log_Repha",
      blwfMode: "Pre_And_Post"
    },
    // Handled by UniversalShaper
    // Sinhala: {
    //   hasOldSpec: false,
    //   virama: 0x0DCA,
    //   basePos: 'Last_Sinhala',
    //   rephPos: POSITIONS.After_Main,
    //   rephMode: 'Explicit',
    //   blwfMode: 'Pre_And_Post'
    // },
    Khmer: {
      hasOldSpec: false,
      virama: 6098,
      basePos: "First",
      rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
      rephMode: "Vis_Repha",
      blwfMode: "Pre_And_Post"
    }
  };
  var $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {
    // Khmer
    6078: [
      6081,
      6078
    ],
    6079: [
      6081,
      6079
    ],
    6080: [
      6081,
      6080
    ],
    6084: [
      6081,
      6084
    ],
    6085: [
      6081,
      6085
    ]
  };
  var { decompositions: $7826f90f6f0cecc9$var$decompositions } = (0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports));
  var $7826f90f6f0cecc9$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
  var $7826f90f6f0cecc9$var$stateMachine = new (0, import_dfa.default)((0, /* @__PURE__ */ $parcel$interopDefault2($4b0735ca6c692ea5$exports)));
  var $7826f90f6f0cecc9$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
    static planFeatures(plan) {
      plan.addStage($7826f90f6f0cecc9$var$setupSyllables);
      plan.addStage([
        "locl",
        "ccmp"
      ]);
      plan.addStage($7826f90f6f0cecc9$var$initialReordering);
      plan.addStage("nukt");
      plan.addStage("akhn");
      plan.addStage("rphf", false);
      plan.addStage("rkrf");
      plan.addStage("pref", false);
      plan.addStage("blwf", false);
      plan.addStage("abvf", false);
      plan.addStage("half", false);
      plan.addStage("pstf", false);
      plan.addStage("vatu");
      plan.addStage("cjct");
      plan.addStage("cfar", false);
      plan.addStage($7826f90f6f0cecc9$var$finalReordering);
      plan.addStage({
        local: [
          "init"
        ],
        global: [
          "pres",
          "abvs",
          "blws",
          "psts",
          "haln",
          "dist",
          "abvm",
          "blwm",
          "calt",
          "clig"
        ]
      });
      plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);
      plan.indicConfig = (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5).Default;
      plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
    }
    static assignFeatures(plan, glyphs) {
      for (let i = glyphs.length - 1; i >= 0; i--) {
        let codepoint = glyphs[i].codePoints[0];
        let d = (0, $90a9d3398ee54fe5$export$f647c9cfdd77d95a)[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];
        if (d) {
          let decomposed = d.map((c) => {
            let g = plan.font.glyphForCodePoint(c);
            return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [
              c
            ], glyphs[i].features);
          });
          glyphs.splice(i, 1, ...decomposed);
        }
      }
    }
  };
  (0, _defineProperty)($7826f90f6f0cecc9$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
  function $7826f90f6f0cecc9$var$indicCategory(glyph) {
    return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;
  }
  function $7826f90f6f0cecc9$var$indicPosition(glyph) {
    return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 255);
  }
  var $7826f90f6f0cecc9$var$IndicInfo = class {
    constructor(category, position, syllableType, syllable) {
      this.category = category;
      this.position = position;
      this.syllableType = syllableType;
      this.syllable = syllable;
    }
  };
  function $7826f90f6f0cecc9$var$setupSyllables(font, glyphs) {
    let syllable = 0;
    let last2 = 0;
    for (let [start, end, tags] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {
      if (start > last2) {
        ++syllable;
        for (let i = last2; i < start; i++)
          glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
      }
      ++syllable;
      for (let i = start; i <= end; i++)
        glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i]), tags[0], syllable);
      last2 = end + 1;
    }
    if (last2 < glyphs.length) {
      ++syllable;
      for (let i = last2; i < glyphs.length; i++)
        glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
    }
  }
  function $7826f90f6f0cecc9$var$isConsonant(glyph) {
    return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$8519deaa7de2b07);
  }
  function $7826f90f6f0cecc9$var$isJoiner(glyph) {
    return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$bbcd928767338e0d);
  }
  function $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {
    return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$ca9599b2a300afc);
  }
  function $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {
    for (let glyph of glyphs)
      glyph.features = {
        [feature]: true
      };
    let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
    GSUB.applyFeatures([
      feature
    ], glyphs);
    return glyphs.length === 1;
  }
  function $7826f90f6f0cecc9$var$consonantPosition(font, consonant, virama) {
    let glyphs = [
      virama,
      consonant,
      virama
    ];
    if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "blwf"))
      return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
    else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pstf"))
      return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
    else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pref"))
      return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
    return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
  }
  function $7826f90f6f0cecc9$var$initialReordering(font, glyphs, plan) {
    let indicConfig = plan.indicConfig;
    let features = font._layoutEngine.engine.GSUBProcessor.features;
    let dottedCircle = font.glyphForCodePoint(9676).id;
    let virama = font.glyphForCodePoint(indicConfig.virama).id;
    if (virama) {
      let info = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, virama, [
        indicConfig.virama
      ]);
      for (let i = 0; i < glyphs.length; i++)
        if (glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C)
          glyphs[i].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font, glyphs[i].copy(), info);
    }
    for (let start = 0, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start)) {
      let { category, syllableType } = glyphs[start].shaperInfo;
      if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster")
        continue;
      if (syllableType === "broken_cluster" && dottedCircle) {
        let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
          9676
        ]);
        g.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g), $7826f90f6f0cecc9$var$indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable);
        let i = start;
        while (i < end && glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha)
          i++;
        glyphs.splice(i++, 0, g);
        end++;
      }
      let base = end;
      let limit = start;
      let hasReph = false;
      if (indicConfig.rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features.rphf && start + 3 <= end && (indicConfig.rephMode === "Implicit" && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
        let g = [
          glyphs[start].copy(),
          glyphs[start + 1].copy(),
          glyphs[start + 2].copy()
        ];
        if ($7826f90f6f0cecc9$var$wouldSubstitute(g.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $7826f90f6f0cecc9$var$wouldSubstitute(g, "rphf")) {
          limit += 2;
          while (limit < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit]))
            limit++;
          base = start;
          hasReph = true;
        }
      } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) {
        limit++;
        while (limit < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit]))
          limit++;
        base = start;
        hasReph = true;
      }
      switch (indicConfig.basePos) {
        case "Last": {
          let i = end;
          let seenBelow = false;
          do {
            let info = glyphs[--i].shaperInfo;
            if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i])) {
              if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C && (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {
                base = i;
                break;
              }
              if (info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C)
                seenBelow = true;
              base = i;
            } else if (start < i && info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ && glyphs[i - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H)
              break;
          } while (i > limit);
          break;
        }
        case "First":
          base = start;
          for (let i = base + 1; i < end; i++)
            if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i]))
              glyphs[i].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
      }
      if (hasReph && base === start && limit - base <= 2)
        hasReph = false;
      for (let i1 = start; i1 < base; i1++) {
        let info = glyphs[i1].shaperInfo;
        info.position = Math.min((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_C, info.position);
      }
      if (base < end)
        glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
      for (let i2 = base + 1; i2 < end; i2++)
        if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
          for (let j = i2 + 1; j < end; j++)
            if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {
              glyphs[j].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Final_C;
              break;
            }
          break;
        }
      if (hasReph)
        glyphs[start].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;
      if (plan.isOldSpec) {
        let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
        for (let i = base + 1; i < end; i++)
          if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) {
            let j;
            for (j = end - 1; j > i; j--) {
              if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H)
                break;
            }
            if (glyphs[j].shaperInfo.category !== (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && j > i) {
              let t = glyphs[i];
              glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));
              glyphs[j] = t;
            }
            break;
          }
      }
      let lastPos = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Start;
      for (let i3 = start; i3 < end; i3++) {
        let info = glyphs[i3].shaperInfo;
        if (info.category & ((0, $90a9d3398ee54fe5$export$bbcd928767338e0d) | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).RS | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).CM | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc) & info.category)) {
          info.position = lastPos;
          if (info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
            for (let j = i3; j > start; j--)
              if (glyphs[j - 1].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
                info.position = glyphs[j - 1].shaperInfo.position;
                break;
              }
          }
        } else if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
          lastPos = info.position;
      }
      let last2 = base;
      for (let i4 = base + 1; i4 < end; i4++) {
        if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i4])) {
          for (let j = last2 + 1; j < i4; j++)
            if (glyphs[j].shaperInfo.position < (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
              glyphs[j].shaperInfo.position = glyphs[i4].shaperInfo.position;
          last2 = i4;
        } else if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M)
          last2 = i4;
      }
      let arr = glyphs.slice(start, end);
      arr.sort((a, b) => a.shaperInfo.position - b.shaperInfo.position);
      glyphs.splice(start, arr.length, ...arr);
      for (let i5 = start; i5 < end; i5++)
        if (glyphs[i5].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
          base = i5;
          break;
        }
      for (let i6 = start; i6 < end && glyphs[i6].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i6++)
        glyphs[i6].features.rphf = true;
      let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
      for (let i7 = start; i7 < base; i7++) {
        glyphs[i7].features.half = true;
        if (blwf)
          glyphs[i7].features.blwf = true;
      }
      for (let i8 = base + 1; i8 < end; i8++) {
        glyphs[i8].features.abvf = true;
        glyphs[i8].features.pstf = true;
        glyphs[i8].features.blwf = true;
      }
      if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
        for (let i = start; i + 1 < base; i++)
          if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Ra && glyphs[i + 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && (i + 1 === base || glyphs[i + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
            glyphs[i].features.blwf = true;
            glyphs[i + 1].features.blwf = true;
          }
      }
      let prefLen = 2;
      if (features.pref && base + prefLen < end)
        for (let i9 = base + 1; i9 + prefLen - 1 < end; i9++) {
          let g = [
            glyphs[i9].copy(),
            glyphs[i9 + 1].copy()
          ];
          if ($7826f90f6f0cecc9$var$wouldSubstitute(g, "pref")) {
            for (let j = 0; j < prefLen; j++)
              glyphs[i9++].features.pref = true;
            if (features.cfar)
              for (; i9 < end; i9++)
                glyphs[i9].features.cfar = true;
            break;
          }
        }
      for (let i10 = start + 1; i10 < end; i10++)
        if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i10])) {
          let nonJoiner = glyphs[i10].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWNJ;
          let j = i10;
          do {
            j--;
            if (nonJoiner)
              delete glyphs[j].features.half;
          } while (j > start && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));
        }
    }
  }
  function $7826f90f6f0cecc9$var$finalReordering(font, glyphs, plan) {
    let indicConfig = plan.indicConfig;
    let features = font._layoutEngine.engine.GSUBProcessor.features;
    for (let start = 0, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start)) {
      let tryPref = !!features.pref;
      let base = start;
      for (; base < end; base++)
        if (glyphs[base].shaperInfo.position >= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
          if (tryPref && base + 1 < end) {
            for (let i = base + 1; i < end; i++)
              if (glyphs[i].features.pref) {
                if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {
                  base = i;
                  while (base < end && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base]))
                    base++;
                  glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).BASE_C;
                  tryPref = false;
                }
                break;
              }
          }
          if (plan.unicodeScript === "Malayalam")
            for (let i = base + 1; i < end; i++) {
              while (i < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[i]))
                i++;
              if (i === end || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i]))
                break;
              i++;
              while (i < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[i]))
                i++;
              if (i < end && $7826f90f6f0cecc9$var$isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) {
                base = i;
                glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
              }
            }
          if (start < base && glyphs[base].shaperInfo.position > (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C)
            base--;
          break;
        }
      if (base === end && start < base && glyphs[base - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)
        base--;
      if (base < end)
        while (start < base && glyphs[base].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))
          base--;
      if (start + 1 < end && start < base) {
        let newPos = base === end ? base - 2 : base - 1;
        if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
          while (newPos > start && !(glyphs[newPos].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))))
            newPos--;
          if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
            if (newPos + 1 < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1]))
              newPos++;
          } else
            newPos = start;
        }
        if (start < newPos && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          for (let i = newPos; i > start; i--)
            if (glyphs[i - 1].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
              let oldPos = i - 1;
              if (oldPos < base && base <= newPos)
                base--;
              let tmp = glyphs[oldPos];
              glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
              glyphs[newPos] = tmp;
              newPos--;
            }
        }
      }
      if (start + 1 < end && glyphs[start].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {
        let newRephPos;
        let rephPos = indicConfig.rephPos;
        let found = false;
        if (rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post) {
          newRephPos = start + 1;
          while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos]))
            newRephPos++;
          if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
            if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1]))
              newRephPos++;
            found = true;
          }
          if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) {
            newRephPos = base;
            while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main)
              newRephPos++;
            found = newRephPos < end;
          }
          if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Sub) {
            newRephPos = base;
            while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)))
              newRephPos++;
            found = newRephPos < end;
          }
        }
        if (!found) {
          newRephPos = start + 1;
          while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos]))
            newRephPos++;
          if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
            if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1]))
              newRephPos++;
            found = true;
          }
        }
        if (!found) {
          newRephPos = end - 1;
          while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
            newRephPos--;
          if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
            for (let i = base + 1; i < newRephPos; i++)
              if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M)
                newRephPos--;
          }
        }
        let reph = glyphs[start];
        glyphs.splice(start, 0, ...glyphs.splice(start + 1, newRephPos - start));
        glyphs[newRephPos] = reph;
        if (start < base && base <= newRephPos)
          base--;
      }
      if (tryPref && base + 1 < end) {
        for (let i = base + 1; i < end; i++)
          if (glyphs[i].features.pref) {
            if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {
              let newPos = base;
              if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
                while (newPos > start && !(glyphs[newPos - 1].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))))
                  newPos--;
                if (newPos > start && glyphs[newPos - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                  let oldPos2 = i;
                  for (let j = base + 1; j < oldPos2; j++)
                    if (glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                      newPos--;
                      break;
                    }
                }
              }
              if (newPos > start && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1])) {
                if (newPos < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos]))
                  newPos++;
              }
              let oldPos = i;
              let tmp = glyphs[oldPos];
              glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
              glyphs[newPos] = tmp;
              if (newPos <= base && base < oldPos)
                base++;
            }
            break;
          }
      }
      if (glyphs[start].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M && (!start || !/Cf|Mn/.test((0, $747425b437e121da$export$410364bbb673ddbc)(glyphs[start - 1].codePoints[0]))))
        glyphs[start].features.init = true;
    }
  }
  function $7826f90f6f0cecc9$var$nextSyllable(glyphs, start) {
    if (start >= glyphs.length)
      return start;
    let syllable = glyphs[start].shaperInfo.syllable;
    while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable)
      ;
    return start;
  }
  var { categories: $7ab494fe977143c6$var$categories, decompositions: $7ab494fe977143c6$var$decompositions } = (0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports));
  var $7ab494fe977143c6$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
  var $7ab494fe977143c6$var$stateMachine = new (0, import_dfa.default)((0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports)));
  var $7ab494fe977143c6$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
    static planFeatures(plan) {
      plan.addStage($7ab494fe977143c6$var$setupSyllables);
      plan.addStage([
        "locl",
        "ccmp",
        "nukt",
        "akhn"
      ]);
      plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
      plan.addStage([
        "rphf"
      ], false);
      plan.addStage($7ab494fe977143c6$var$recordRphf);
      plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
      plan.addStage([
        "pref"
      ]);
      plan.addStage($7ab494fe977143c6$var$recordPref);
      plan.addStage([
        "rkrf",
        "abvf",
        "blwf",
        "half",
        "pstf",
        "vatu",
        "cjct"
      ]);
      plan.addStage($7ab494fe977143c6$var$reorder);
      plan.addStage([
        "abvs",
        "blws",
        "pres",
        "psts",
        "dist",
        "abvm",
        "blwm"
      ]);
    }
    static assignFeatures(plan, glyphs) {
      for (let i = glyphs.length - 1; i >= 0; i--) {
        let codepoint = glyphs[i].codePoints[0];
        if ($7ab494fe977143c6$var$decompositions[codepoint]) {
          let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map((c) => {
            let g = plan.font.glyphForCodePoint(c);
            return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [
              c
            ], glyphs[i].features);
          });
          glyphs.splice(i, 1, ...decomposed);
        }
      }
    }
  };
  (0, _defineProperty)($7ab494fe977143c6$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
  function $7ab494fe977143c6$var$useCategory(glyph) {
    return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);
  }
  var $7ab494fe977143c6$var$USEInfo = class {
    constructor(category, syllableType, syllable) {
      this.category = category;
      this.syllableType = syllableType;
      this.syllable = syllable;
    }
  };
  function $7ab494fe977143c6$var$setupSyllables(font, glyphs) {
    let syllable = 0;
    for (let [start, end, tags] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {
      ++syllable;
      for (let i = start; i <= end; i++)
        glyphs[i].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i])], tags[0], syllable);
      let limit = glyphs[start].shaperInfo.category === "R" ? 1 : Math.min(3, end - start);
      for (let i1 = start; i1 < start + limit; i1++)
        glyphs[i1].features.rphf = true;
    }
  }
  function $7ab494fe977143c6$var$clearSubstitutionFlags(font, glyphs) {
    for (let glyph of glyphs)
      glyph.substituted = false;
  }
  function $7ab494fe977143c6$var$recordRphf(font, glyphs) {
    for (let glyph of glyphs)
      if (glyph.substituted && glyph.features.rphf)
        glyph.shaperInfo.category = "R";
  }
  function $7ab494fe977143c6$var$recordPref(font, glyphs) {
    for (let glyph of glyphs)
      if (glyph.substituted)
        glyph.shaperInfo.category = "VPre";
  }
  function $7ab494fe977143c6$var$reorder(font, glyphs) {
    let dottedCircle = font.glyphForCodePoint(9676).id;
    for (let start = 0, end = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7ab494fe977143c6$var$nextSyllable(glyphs, start)) {
      let i, j;
      let info = glyphs[start].shaperInfo;
      let type = info.syllableType;
      if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster")
        continue;
      if (type === "broken_cluster" && dottedCircle) {
        let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
          9676
        ]);
        g.shaperInfo = info;
        for (i = start; i < end && glyphs[i].shaperInfo.category === "R"; i++)
          ;
        glyphs.splice(++i, 0, g);
        end++;
      }
      if (info.category === "R" && end - start > 1)
        for (i = start + 1; i < end; i++) {
          info = glyphs[i].shaperInfo;
          if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i])) {
            if ($7ab494fe977143c6$var$isHalant(glyphs[i]))
              i--;
            glyphs.splice(start, 0, ...glyphs.splice(start + 1, i - start), glyphs[i]);
            break;
          }
        }
      for (i = start, j = end; i < end; i++) {
        info = glyphs[i].shaperInfo;
        if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i]))
          j = $7ab494fe977143c6$var$isHalant(glyphs[i]) ? i + 1 : i;
        else if ((info.category === "VPre" || info.category === "VMPre") && j < i)
          glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));
      }
    }
  }
  function $7ab494fe977143c6$var$nextSyllable(glyphs, start) {
    if (start >= glyphs.length)
      return start;
    let syllable = glyphs[start].shaperInfo.syllable;
    while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable)
      ;
    return start;
  }
  function $7ab494fe977143c6$var$isHalant(glyph) {
    return glyph.shaperInfo.category === "H" && !glyph.isLigated;
  }
  function $7ab494fe977143c6$var$isBase(info) {
    return info.category === "B" || info.category === "GB";
  }
  var $102b6fe50f1d50b4$var$SHAPERS = {
    arab: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
    mong: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
    syrc: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
    "nko ": (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
    phag: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
    mand: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
    mani: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
    phlp: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
    hang: (0, $e1c6bbc8cb416f8c$export$2e2bcd8739ae039),
    bng2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    beng: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    dev2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    deva: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    gjr2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    gujr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    guru: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    gur2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    knda: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    knd2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    mlm2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    mlym: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    ory2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    orya: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    taml: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    tml2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    telu: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    tel2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    khmr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    bali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    batk: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    brah: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    bugi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    buhd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    cakm: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    cham: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    dupl: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    egyp: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    gran: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    hano: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    java: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    kthi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    kali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    khar: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    khoj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    sind: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    lepc: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    limb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    mahj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    // mand: UniversalShaper, // Mandaic
    // mani: UniversalShaper, // Manichaean
    mtei: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    modi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    // mong: UniversalShaper, // Mongolian
    // 'nko ': UniversalShaper, // NKo
    hmng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    // phag: UniversalShaper, // Phags-pa
    // phlp: UniversalShaper, // Psalter Pahlavi
    rjng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    saur: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    shrd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    sidd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    sinh: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
    sund: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    sylo: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    tglg: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    tagb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    tale: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    lana: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    tavt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    takr: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    tibt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    tfng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    tirh: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
    latn: (0, $649970d87335b30f$export$2e2bcd8739ae039),
    DFLT: (0, $649970d87335b30f$export$2e2bcd8739ae039)
  };
  function $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {
    if (!Array.isArray(script))
      script = [
        script
      ];
    for (let s of script) {
      let shaper = $102b6fe50f1d50b4$var$SHAPERS[s];
      if (shaper)
        return shaper;
    }
    return 0, $649970d87335b30f$export$2e2bcd8739ae039;
  }
  var $0a876c45f1f7c41c$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
    applyLookup(lookupType, table) {
      switch (lookupType) {
        case 1: {
          let index = this.coverageIndex(table.coverage);
          if (index === -1)
            return false;
          let glyph = this.glyphIterator.cur;
          switch (table.version) {
            case 1:
              glyph.id = glyph.id + table.deltaGlyphID & 65535;
              break;
            case 2:
              glyph.id = table.substitute.get(index);
              break;
          }
          return true;
        }
        case 2: {
          let index = this.coverageIndex(table.coverage);
          if (index !== -1) {
            let sequence = table.sequences.get(index);
            if (sequence.length === 0) {
              this.glyphs.splice(this.glyphIterator.index, 1);
              return true;
            }
            this.glyphIterator.cur.id = sequence[0];
            this.glyphIterator.cur.ligatureComponent = 0;
            let features = this.glyphIterator.cur.features;
            let curGlyph = this.glyphIterator.cur;
            let replacement = sequence.slice(1).map((gid, i) => {
              let glyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, gid, void 0, features);
              glyph.shaperInfo = curGlyph.shaperInfo;
              glyph.isLigated = curGlyph.isLigated;
              glyph.ligatureComponent = i + 1;
              glyph.substituted = true;
              glyph.isMultiplied = true;
              return glyph;
            });
            this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
            return true;
          }
          return false;
        }
        case 3: {
          let index = this.coverageIndex(table.coverage);
          if (index !== -1) {
            let USER_INDEX = 0;
            this.glyphIterator.cur.id = table.alternateSet.get(index)[USER_INDEX];
            return true;
          }
          return false;
        }
        case 4: {
          let index = this.coverageIndex(table.coverage);
          if (index === -1)
            return false;
          for (let ligature of table.ligatureSets.get(index)) {
            let matched = this.sequenceMatchIndices(1, ligature.components);
            if (!matched)
              continue;
            let curGlyph = this.glyphIterator.cur;
            let characters = curGlyph.codePoints.slice();
            for (let index2 of matched)
              characters.push(...this.glyphs[index2].codePoints);
            let ligatureGlyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters, curGlyph.features);
            ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
            ligatureGlyph.isLigated = true;
            ligatureGlyph.substituted = true;
            let isMarkLigature = curGlyph.isMark;
            for (let i = 0; i < matched.length && isMarkLigature; i++)
              isMarkLigature = this.glyphs[matched[i]].isMark;
            ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
            let lastLigID = curGlyph.ligatureID;
            let lastNumComps = curGlyph.codePoints.length;
            let curComps = lastNumComps;
            let idx = this.glyphIterator.index + 1;
            for (let matchIndex of matched) {
              if (isMarkLigature)
                idx = matchIndex;
              else
                while (idx < matchIndex) {
                  var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
                  this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
                  this.glyphs[idx].ligatureComponent = ligatureComponent;
                  idx++;
                }
              lastLigID = this.glyphs[idx].ligatureID;
              lastNumComps = this.glyphs[idx].codePoints.length;
              curComps += lastNumComps;
              idx++;
            }
            if (lastLigID && !isMarkLigature)
              for (let i1 = idx; i1 < this.glyphs.length; i1++) {
                if (this.glyphs[i1].ligatureID === lastLigID) {
                  var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i1].ligatureComponent || 1, lastNumComps);
                  this.glyphs[i1].ligatureComponent = ligatureComponent;
                } else
                  break;
              }
            for (let i2 = matched.length - 1; i2 >= 0; i2--)
              this.glyphs.splice(matched[i2], 1);
            this.glyphs[this.glyphIterator.index] = ligatureGlyph;
            return true;
          }
          return false;
        }
        case 5:
          return this.applyContext(table);
        case 6:
          return this.applyChainingContext(table);
        case 7:
          return this.applyLookup(table.lookupType, table.extension);
        default:
          throw new Error(`GSUB lookupType ${lookupType} is not supported`);
      }
    }
  };
  var $c96c93587d49c14d$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
    applyPositionValue(sequenceIndex, value) {
      let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
      if (value.xAdvance != null)
        position.xAdvance += value.xAdvance;
      if (value.yAdvance != null)
        position.yAdvance += value.yAdvance;
      if (value.xPlacement != null)
        position.xOffset += value.xPlacement;
      if (value.yPlacement != null)
        position.yOffset += value.yPlacement;
      let variationProcessor = this.font._variationProcessor;
      let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
      if (variationProcessor && variationStore) {
        if (value.xPlaDevice)
          position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);
        if (value.yPlaDevice)
          position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);
        if (value.xAdvDevice)
          position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);
        if (value.yAdvDevice)
          position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);
      }
    }
    applyLookup(lookupType, table) {
      switch (lookupType) {
        case 1: {
          let index = this.coverageIndex(table.coverage);
          if (index === -1)
            return false;
          switch (table.version) {
            case 1:
              this.applyPositionValue(0, table.value);
              break;
            case 2:
              this.applyPositionValue(0, table.values.get(index));
              break;
          }
          return true;
        }
        case 2: {
          let nextGlyph = this.glyphIterator.peek();
          if (!nextGlyph)
            return false;
          let index = this.coverageIndex(table.coverage);
          if (index === -1)
            return false;
          switch (table.version) {
            case 1:
              let set = table.pairSets.get(index);
              for (let pair of set)
                if (pair.secondGlyph === nextGlyph.id) {
                  this.applyPositionValue(0, pair.value1);
                  this.applyPositionValue(1, pair.value2);
                  return true;
                }
              return false;
            case 2:
              let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
              let class2 = this.getClassID(nextGlyph.id, table.classDef2);
              if (class1 === -1 || class2 === -1)
                return false;
              var pair1 = table.classRecords.get(class1).get(class2);
              this.applyPositionValue(0, pair1.value1);
              this.applyPositionValue(1, pair1.value2);
              return true;
          }
        }
        case 3: {
          let nextIndex = this.glyphIterator.peekIndex();
          let nextGlyph = this.glyphs[nextIndex];
          if (!nextGlyph)
            return false;
          let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
          if (!curRecord || !curRecord.exitAnchor)
            return false;
          let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
          if (!nextRecord || !nextRecord.entryAnchor)
            return false;
          let entry = this.getAnchor(nextRecord.entryAnchor);
          let exit = this.getAnchor(curRecord.exitAnchor);
          let cur = this.positions[this.glyphIterator.index];
          let next = this.positions[nextIndex];
          let d;
          switch (this.direction) {
            case "ltr":
              cur.xAdvance = exit.x + cur.xOffset;
              d = entry.x + next.xOffset;
              next.xAdvance -= d;
              next.xOffset -= d;
              break;
            case "rtl":
              d = exit.x + cur.xOffset;
              cur.xAdvance -= d;
              cur.xOffset -= d;
              next.xAdvance = entry.x + next.xOffset;
              break;
          }
          if (this.glyphIterator.flags.rightToLeft) {
            this.glyphIterator.cur.cursiveAttachment = nextIndex;
            cur.yOffset = entry.y - exit.y;
          } else {
            nextGlyph.cursiveAttachment = this.glyphIterator.index;
            cur.yOffset = exit.y - entry.y;
          }
          return true;
        }
        case 4: {
          let markIndex = this.coverageIndex(table.markCoverage);
          if (markIndex === -1)
            return false;
          let baseGlyphIndex = this.glyphIterator.index;
          while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0))
            ;
          if (baseGlyphIndex < 0)
            return false;
          let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
          if (baseIndex === -1)
            return false;
          let markRecord = table.markArray[markIndex];
          let baseAnchor = table.baseArray[baseIndex][markRecord.class];
          this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
          return true;
        }
        case 5: {
          let markIndex = this.coverageIndex(table.markCoverage);
          if (markIndex === -1)
            return false;
          let baseGlyphIndex = this.glyphIterator.index;
          while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark)
            ;
          if (baseGlyphIndex < 0)
            return false;
          let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
          if (ligIndex === -1)
            return false;
          let ligAttach = table.ligatureArray[ligIndex];
          let markGlyph = this.glyphIterator.cur;
          let ligGlyph = this.glyphs[baseGlyphIndex];
          let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
          let markRecord = table.markArray[markIndex];
          let baseAnchor = ligAttach[compIndex][markRecord.class];
          this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
          return true;
        }
        case 6: {
          let mark1Index = this.coverageIndex(table.mark1Coverage);
          if (mark1Index === -1)
            return false;
          let prevIndex = this.glyphIterator.peekIndex(-1);
          let prev = this.glyphs[prevIndex];
          if (!prev || !prev.isMark)
            return false;
          let cur = this.glyphIterator.cur;
          let good = false;
          if (cur.ligatureID === prev.ligatureID) {
            if (!cur.ligatureID)
              good = true;
            else if (cur.ligatureComponent === prev.ligatureComponent)
              good = true;
          } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent)
            good = true;
          if (!good)
            return false;
          let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
          if (mark2Index === -1)
            return false;
          let markRecord = table.mark1Array[mark1Index];
          let baseAnchor = table.mark2Array[mark2Index][markRecord.class];
          this.applyAnchor(markRecord, baseAnchor, prevIndex);
          return true;
        }
        case 7:
          return this.applyContext(table);
        case 8:
          return this.applyChainingContext(table);
        case 9:
          return this.applyLookup(table.lookupType, table.extension);
        default:
          throw new Error(`Unsupported GPOS table: ${lookupType}`);
      }
    }
    applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
      let baseCoords = this.getAnchor(baseAnchor);
      let markCoords = this.getAnchor(markRecord.markAnchor);
      let basePos = this.positions[baseGlyphIndex];
      let markPos = this.positions[this.glyphIterator.index];
      markPos.xOffset = baseCoords.x - markCoords.x;
      markPos.yOffset = baseCoords.y - markCoords.y;
      this.glyphIterator.cur.markAttachment = baseGlyphIndex;
    }
    getAnchor(anchor) {
      let x = anchor.xCoordinate;
      let y = anchor.yCoordinate;
      let variationProcessor = this.font._variationProcessor;
      let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
      if (variationProcessor && variationStore) {
        if (anchor.xDeviceTable)
          x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
        if (anchor.yDeviceTable)
          y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
      }
      return {
        x,
        y
      };
    }
    applyFeatures(userFeatures, glyphs, advances) {
      super.applyFeatures(userFeatures, glyphs, advances);
      for (var i = 0; i < this.glyphs.length; i++)
        this.fixCursiveAttachment(i);
      this.fixMarkAttachment();
    }
    fixCursiveAttachment(i) {
      let glyph = this.glyphs[i];
      if (glyph.cursiveAttachment != null) {
        let j = glyph.cursiveAttachment;
        glyph.cursiveAttachment = null;
        this.fixCursiveAttachment(j);
        this.positions[i].yOffset += this.positions[j].yOffset;
      }
    }
    fixMarkAttachment() {
      for (let i = 0; i < this.glyphs.length; i++) {
        let glyph = this.glyphs[i];
        if (glyph.markAttachment != null) {
          let j = glyph.markAttachment;
          this.positions[i].xOffset += this.positions[j].xOffset;
          this.positions[i].yOffset += this.positions[j].yOffset;
          if (this.direction === "ltr")
            for (let k = j; k < i; k++) {
              this.positions[i].xOffset -= this.positions[k].xAdvance;
              this.positions[i].yOffset -= this.positions[k].yAdvance;
            }
          else
            for (let k1 = j + 1; k1 < i + 1; k1++) {
              this.positions[i].xOffset += this.positions[k1].xAdvance;
              this.positions[i].yOffset += this.positions[k1].yAdvance;
            }
        }
      }
    }
  };
  var $a62492810de27e3d$export$2e2bcd8739ae039 = class {
    setup(glyphRun) {
      this.glyphInfos = glyphRun.glyphs.map((glyph) => new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, glyph.id, [
        ...glyph.codePoints
      ]));
      let script = null;
      if (this.GPOSProcessor)
        script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
      if (this.GSUBProcessor)
        script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
      this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);
      this.plan = new (0, $94d7a73bd2edfc9a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);
      this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
      for (let key in this.plan.allFeatures)
        glyphRun.features[key] = true;
    }
    substitute(glyphRun) {
      if (this.GSUBProcessor) {
        this.plan.process(this.GSUBProcessor, this.glyphInfos);
        glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
      }
    }
    position(glyphRun) {
      if (this.shaper.zeroMarkWidths === "BEFORE_GPOS")
        this.zeroMarkAdvances(glyphRun.positions);
      if (this.GPOSProcessor)
        this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
      if (this.shaper.zeroMarkWidths === "AFTER_GPOS")
        this.zeroMarkAdvances(glyphRun.positions);
      if (glyphRun.direction === "rtl") {
        glyphRun.glyphs.reverse();
        glyphRun.positions.reverse();
      }
      return this.GPOSProcessor && this.GPOSProcessor.features;
    }
    zeroMarkAdvances(positions) {
      for (let i = 0; i < this.glyphInfos.length; i++)
        if (this.glyphInfos[i].isMark) {
          positions[i].xAdvance = 0;
          positions[i].yAdvance = 0;
        }
    }
    cleanup() {
      this.glyphInfos = null;
      this.plan = null;
      this.shaper = null;
    }
    getAvailableFeatures(script, language) {
      let features = [];
      if (this.GSUBProcessor) {
        this.GSUBProcessor.selectScript(script, language);
        features.push(...Object.keys(this.GSUBProcessor.features));
      }
      if (this.GPOSProcessor) {
        this.GPOSProcessor.selectScript(script, language);
        features.push(...Object.keys(this.GPOSProcessor.features));
      }
      return features;
    }
    constructor(font) {
      this.font = font;
      this.glyphInfos = null;
      this.plan = null;
      this.GSUBProcessor = null;
      this.GPOSProcessor = null;
      this.fallbackPosition = true;
      if (font.GSUB)
        this.GSUBProcessor = new (0, $0a876c45f1f7c41c$export$2e2bcd8739ae039)(font, font.GSUB);
      if (font.GPOS)
        this.GPOSProcessor = new (0, $c96c93587d49c14d$export$2e2bcd8739ae039)(font, font.GPOS);
    }
  };
  var $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 = class {
    layout(string, features, script, language, direction) {
      if (typeof features === "string") {
        direction = language;
        language = script;
        script = features;
        features = [];
      }
      if (typeof string === "string") {
        if (script == null)
          script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);
        var glyphs = this.font.glyphsForString(string);
      } else {
        if (script == null) {
          let codePoints = [];
          for (let glyph of string)
            codePoints.push(...glyph.codePoints);
          script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);
        }
        var glyphs = string;
      }
      let glyphRun = new (0, $be07b3e97a42687a$export$2e2bcd8739ae039)(glyphs, features, script, language, direction);
      if (glyphs.length === 0) {
        glyphRun.positions = [];
        return glyphRun;
      }
      if (this.engine && this.engine.setup)
        this.engine.setup(glyphRun);
      this.substitute(glyphRun);
      this.position(glyphRun);
      this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
      if (this.engine && this.engine.cleanup)
        this.engine.cleanup();
      return glyphRun;
    }
    substitute(glyphRun) {
      if (this.engine && this.engine.substitute)
        this.engine.substitute(glyphRun);
    }
    position(glyphRun) {
      glyphRun.positions = glyphRun.glyphs.map((glyph) => new (0, $1ac75d9a55b67f01$export$2e2bcd8739ae039)(glyph.advanceWidth));
      let positioned = null;
      if (this.engine && this.engine.position)
        positioned = this.engine.position(glyphRun);
      if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
        if (!this.unicodeLayoutEngine)
          this.unicodeLayoutEngine = new (0, $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039)(this.font);
        this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
      }
      if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
        if (!this.kernProcessor)
          this.kernProcessor = new (0, $0bba3a9db57637f3$export$2e2bcd8739ae039)(this.font);
        this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
        glyphRun.features.kern = true;
      }
    }
    hideDefaultIgnorables(glyphs, positions) {
      let space = this.font.glyphForCodePoint(32);
      for (let i = 0; i < glyphs.length; i++)
        if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {
          glyphs[i] = space;
          positions[i].xAdvance = 0;
          positions[i].yAdvance = 0;
        }
    }
    isDefaultIgnorable(ch) {
      let plane = ch >> 16;
      if (plane === 0)
        switch (ch >> 8) {
          case 0:
            return ch === 173;
          case 3:
            return ch === 847;
          case 6:
            return ch === 1564;
          case 23:
            return 6068 <= ch && ch <= 6069;
          case 24:
            return 6155 <= ch && ch <= 6158;
          case 32:
            return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
          case 254:
            return 65024 <= ch && ch <= 65039 || ch === 65279;
          case 255:
            return 65520 <= ch && ch <= 65528;
          default:
            return false;
        }
      else
        switch (plane) {
          case 1:
            return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
          case 14:
            return 917504 <= ch && ch <= 921599;
          default:
            return false;
        }
    }
    getAvailableFeatures(script, language) {
      let features = [];
      if (this.engine)
        features.push(...this.engine.getAvailableFeatures(script, language));
      if (this.font.kern && features.indexOf("kern") === -1)
        features.push("kern");
      return features;
    }
    stringsForGlyph(gid) {
      let result = /* @__PURE__ */ new Set();
      let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
      for (let codePoint of codePoints)
        result.add(String.fromCodePoint(codePoint));
      if (this.engine && this.engine.stringsForGlyph)
        for (let string of this.engine.stringsForGlyph(gid))
          result.add(string);
      return Array.from(result);
    }
    constructor(font) {
      this.font = font;
      this.unicodeLayoutEngine = null;
      this.kernProcessor = null;
      if (this.font.morx)
        this.engine = new (0, $ba6dd74203be8728$export$2e2bcd8739ae039)(this.font);
      else if (this.font.GSUB || this.font.GPOS)
        this.engine = new (0, $a62492810de27e3d$export$2e2bcd8739ae039)(this.font);
    }
  };
  var $f43aec954cdfdf21$var$SVG_COMMANDS = {
    moveTo: "M",
    lineTo: "L",
    quadraticCurveTo: "Q",
    bezierCurveTo: "C",
    closePath: "Z"
  };
  var $f43aec954cdfdf21$export$2e2bcd8739ae039 = class _$f43aec954cdfdf21$export$2e2bcd8739ae039 {
    /**
    * Compiles the path to a JavaScript function that can be applied with
    * a graphics context in order to render the path.
    * @return {string}
    */
    toFunction() {
      return (ctx) => {
        this.commands.forEach((c) => {
          return ctx[c.command].apply(ctx, c.args);
        });
      };
    }
    /**
    * Converts the path to an SVG path data string
    * @return {string}
    */
    toSVG() {
      let cmds = this.commands.map((c) => {
        let args = c.args.map((arg) => Math.round(arg * 100) / 100);
        return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c.command]}${args.join(" ")}`;
      });
      return cmds.join("");
    }
    /**
    * Gets the "control box" of a path.
    * This is like the bounding box, but it includes all points including
    * control points of bezier segments and is much faster to compute than
    * the real bounding box.
    * @type {BBox}
    */
    get cbox() {
      if (!this._cbox) {
        let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
        for (let command1 of this.commands)
          for (let i = 0; i < command1.args.length; i += 2)
            cbox.addPoint(command1.args[i], command1.args[i + 1]);
        this._cbox = Object.freeze(cbox);
      }
      return this._cbox;
    }
    /**
    * Gets the exact bounding box of the path by evaluating curve segments.
    * Slower to compute than the control box, but more accurate.
    * @type {BBox}
    */
    get bbox() {
      if (this._bbox)
        return this._bbox;
      let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      let cx2 = 0, cy2 = 0;
      let f = (t) => Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
      for (let c of this.commands)
        switch (c.command) {
          case "moveTo":
          case "lineTo":
            let [x, y] = c.args;
            bbox.addPoint(x, y);
            cx2 = x;
            cy2 = y;
            break;
          case "quadraticCurveTo":
          case "bezierCurveTo":
            if (c.command === "quadraticCurveTo") {
              var [qp1x, qp1y, p3x, p3y] = c.args;
              var cp1x = cx2 + 2 / 3 * (qp1x - cx2);
              var cp1y = cy2 + 2 / 3 * (qp1y - cy2);
              var cp2x = p3x + 2 / 3 * (qp1x - p3x);
              var cp2y = p3y + 2 / 3 * (qp1y - p3y);
            } else
              var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c.args;
            bbox.addPoint(p3x, p3y);
            var p0 = [
              cx2,
              cy2
            ];
            var p1 = [
              cp1x,
              cp1y
            ];
            var p2 = [
              cp2x,
              cp2y
            ];
            var p3 = [
              p3x,
              p3y
            ];
            for (var i = 0; i <= 1; i++) {
              let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
              let a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
              c = 3 * p1[i] - 3 * p0[i];
              if (a === 0) {
                if (b === 0)
                  continue;
                let t = -c / b;
                if (0 < t && t < 1) {
                  if (i === 0)
                    bbox.addPoint(f(t), bbox.maxY);
                  else if (i === 1)
                    bbox.addPoint(bbox.maxX, f(t));
                }
                continue;
              }
              let b2ac = Math.pow(b, 2) - 4 * c * a;
              if (b2ac < 0)
                continue;
              let t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
              if (0 < t1 && t1 < 1) {
                if (i === 0)
                  bbox.addPoint(f(t1), bbox.maxY);
                else if (i === 1)
                  bbox.addPoint(bbox.maxX, f(t1));
              }
              let t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
              if (0 < t2 && t2 < 1) {
                if (i === 0)
                  bbox.addPoint(f(t2), bbox.maxY);
                else if (i === 1)
                  bbox.addPoint(bbox.maxX, f(t2));
              }
            }
            cx2 = p3x;
            cy2 = p3y;
            break;
        }
      return this._bbox = Object.freeze(bbox);
    }
    /**
    * Applies a mapping function to each point in the path.
    * @param {function} fn
    * @return {Path}
    */
    mapPoints(fn) {
      let path = new _$f43aec954cdfdf21$export$2e2bcd8739ae039();
      for (let c of this.commands) {
        let args = [];
        for (let i = 0; i < c.args.length; i += 2) {
          let [x, y] = fn(c.args[i], c.args[i + 1]);
          args.push(x, y);
        }
        path[c.command](...args);
      }
      return path;
    }
    /**
    * Transforms the path by the given matrix.
    */
    transform(m0, m1, m2, m3, m4, m5) {
      return this.mapPoints((x, y) => {
        const tx = m0 * x + m2 * y + m4;
        const ty = m1 * x + m3 * y + m5;
        return [
          tx,
          ty
        ];
      });
    }
    /**
    * Translates the path by the given offset.
    */
    translate(x, y) {
      return this.transform(1, 0, 0, 1, x, y);
    }
    /**
    * Rotates the path by the given angle (in radians).
    */
    rotate(angle) {
      let cos2 = Math.cos(angle);
      let sin2 = Math.sin(angle);
      return this.transform(cos2, sin2, -sin2, cos2, 0, 0);
    }
    /**
    * Scales the path.
    */
    scale(scaleX, scaleY = scaleX) {
      return this.transform(scaleX, 0, 0, scaleY, 0, 0);
    }
    constructor() {
      this.commands = [];
      this._bbox = null;
      this._cbox = null;
    }
  };
  for (let command of [
    "moveTo",
    "lineTo",
    "quadraticCurveTo",
    "bezierCurveTo",
    "closePath"
  ])
    $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function(...args) {
      this._bbox = this._cbox = null;
      this.commands.push({
        command,
        args
      });
      return this;
    };
  var $7713b9b7b438dff8$export$2e2bcd8739ae039 = [
    ".notdef",
    ".null",
    "nonmarkingreturn",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "nonbreakingspace",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "Lslash",
    "lslash",
    "Scaron",
    "scaron",
    "Zcaron",
    "zcaron",
    "brokenbar",
    "Eth",
    "eth",
    "Yacute",
    "yacute",
    "Thorn",
    "thorn",
    "minus",
    "multiply",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "onehalf",
    "onequarter",
    "threequarters",
    "franc",
    "Gbreve",
    "gbreve",
    "Idotaccent",
    "Scedilla",
    "scedilla",
    "Cacute",
    "cacute",
    "Ccaron",
    "ccaron",
    "dcroat"
  ];
  var $f92906be28e61769$export$2e2bcd8739ae039 = class {
    _getPath() {
      return new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    }
    _getCBox() {
      return this.path.cbox;
    }
    _getBBox() {
      return this.path.bbox;
    }
    _getTableMetrics(table) {
      if (this.id < table.metrics.length)
        return table.metrics.get(this.id);
      let metric = table.metrics.get(table.metrics.length - 1);
      let res = {
        advance: metric ? metric.advance : 0,
        bearing: table.bearings.get(this.id - table.metrics.length) || 0
      };
      return res;
    }
    _getMetrics(cbox) {
      if (this._metrics)
        return this._metrics;
      let { advance: advanceWidth, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
      if (this._font.vmtx)
        var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
      else {
        let os2;
        if (typeof cbox === "undefined" || cbox === null)
          ({ cbox } = this);
        if ((os2 = this._font["OS/2"]) && os2.version > 0) {
          var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
          var topBearing = os2.typoAscender - cbox.maxY;
        } else {
          let { hhea } = this._font;
          var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
          var topBearing = hhea.ascent - cbox.maxY;
        }
      }
      if (this._font._variationProcessor && this._font.HVAR)
        advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
      return this._metrics = {
        advanceWidth,
        advanceHeight,
        leftBearing,
        topBearing
      };
    }
    /**
    * The glyphs control box.
    * This is often the same as the bounding box, but is faster to compute.
    * Because of the way bezier curves are defined, some of the control points
    * can be outside of the bounding box. Where `bbox` takes this into account,
    * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
    * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
    * for a more detailed description.
    *
    * @type {BBox}
    */
    get cbox() {
      return this._getCBox();
    }
    /**
    * The glyphs bounding box, i.e. the rectangle that encloses the
    * glyph outline as tightly as possible.
    * @type {BBox}
    */
    get bbox() {
      return this._getBBox();
    }
    /**
    * A vector Path object representing the glyph outline.
    * @type {Path}
    */
    get path() {
      return this._getPath();
    }
    /**
    * Returns a path scaled to the given font size.
    * @param {number} size
    * @return {Path}
    */
    getScaledPath(size) {
      let scale2 = 1 / this._font.unitsPerEm * size;
      return this.path.scale(scale2);
    }
    /**
    * The glyph's advance width.
    * @type {number}
    */
    get advanceWidth() {
      return this._getMetrics().advanceWidth;
    }
    /**
    * The glyph's advance height.
    * @type {number}
    */
    get advanceHeight() {
      return this._getMetrics().advanceHeight;
    }
    get ligatureCaretPositions() {
    }
    _getName() {
      let { post } = this._font;
      if (!post)
        return null;
      switch (post.version) {
        case 1:
          return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id];
        case 2:
          let id = post.glyphNameIndex[this.id];
          if (id < (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length)
            return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[id];
          return post.names[id - (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length];
        case 2.5:
          return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];
        case 4:
          return String.fromCharCode(post.map[this.id]);
      }
    }
    /**
    * The glyph's name
    * @type {string}
    */
    get name() {
      return this._getName();
    }
    /**
    * Renders the glyph to the given graphics context, at the specified font size.
    * @param {CanvasRenderingContext2d} ctx
    * @param {number} size
    */
    render(ctx, size) {
      ctx.save();
      let scale2 = 1 / this._font.head.unitsPerEm * size;
      ctx.scale(scale2, scale2);
      let fn = this.path.toFunction();
      fn(ctx);
      ctx.fill();
      ctx.restore();
    }
    constructor(id, codePoints, font) {
      this.id = id;
      this.codePoints = codePoints;
      this._font = font;
      this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
      this.isLigature = this.codePoints.length > 1;
    }
  };
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "cbox", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "bbox", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "path", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "name", null);
  var $69aac16029968692$var$GlyfHeader = new Struct({
    numberOfContours: int16,
    xMin: int16,
    yMin: int16,
    xMax: int16,
    yMax: int16
  });
  var $69aac16029968692$var$ON_CURVE = 1;
  var $69aac16029968692$var$X_SHORT_VECTOR = 2;
  var $69aac16029968692$var$Y_SHORT_VECTOR = 4;
  var $69aac16029968692$var$REPEAT = 8;
  var $69aac16029968692$var$SAME_X = 16;
  var $69aac16029968692$var$SAME_Y = 32;
  var $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;
  var $69aac16029968692$var$ARGS_ARE_XY_VALUES = 2;
  var $69aac16029968692$var$ROUND_XY_TO_GRID = 4;
  var $69aac16029968692$var$WE_HAVE_A_SCALE = 8;
  var $69aac16029968692$var$MORE_COMPONENTS = 32;
  var $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
  var $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;
  var $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;
  var $69aac16029968692$var$USE_MY_METRICS = 512;
  var $69aac16029968692$var$OVERLAP_COMPOUND = 1024;
  var $69aac16029968692$var$SCALED_COMPONENT_OFFSET = 2048;
  var $69aac16029968692$var$UNSCALED_COMPONENT_OFFSET = 4096;
  var $69aac16029968692$export$baf26146a414f24a = class _$69aac16029968692$export$baf26146a414f24a {
    copy() {
      return new _$69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
    }
    constructor(onCurve, endContour, x = 0, y = 0) {
      this.onCurve = onCurve;
      this.endContour = endContour;
      this.x = x;
      this.y = y;
    }
  };
  var $69aac16029968692$var$Component = class {
    constructor(glyphID, dx, dy) {
      this.glyphID = glyphID;
      this.dx = dx;
      this.dy = dy;
      this.pos = 0;
      this.scaleX = this.scaleY = 1;
      this.scale01 = this.scale10 = 0;
    }
  };
  var $69aac16029968692$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
    // Parses just the glyph header and returns the bounding box
    _getCBox(internal) {
      if (this._font._variationProcessor && !internal)
        return this.path.cbox;
      let stream2 = this._font._getTableStream("glyf");
      stream2.pos += this._font.loca.offsets[this.id];
      let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
      let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
      return Object.freeze(cbox);
    }
    // Parses a single glyph coordinate
    _parseGlyphCoord(stream2, prev, short, same) {
      if (short) {
        var val = stream2.readUInt8();
        if (!same)
          val = -val;
        val += prev;
      } else if (same)
        var val = prev;
      else
        var val = prev + stream2.readInt16BE();
      return val;
    }
    // Decodes the glyph data into points for simple glyphs,
    // or components for composite glyphs
    _decode() {
      let glyfPos = this._font.loca.offsets[this.id];
      let nextPos = this._font.loca.offsets[this.id + 1];
      if (glyfPos === nextPos)
        return null;
      let stream2 = this._font._getTableStream("glyf");
      stream2.pos += glyfPos;
      let startPos = stream2.pos;
      let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
      if (glyph.numberOfContours > 0)
        this._decodeSimple(glyph, stream2);
      else if (glyph.numberOfContours < 0)
        this._decodeComposite(glyph, stream2, startPos);
      return glyph;
    }
    _decodeSimple(glyph, stream2) {
      glyph.points = [];
      let endPtsOfContours = new ArrayT(uint16, glyph.numberOfContours).decode(stream2);
      glyph.instructions = new ArrayT(uint8, uint16).decode(stream2);
      let flags = [];
      let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
      while (flags.length < numCoords) {
        var flag3 = stream2.readUInt8();
        flags.push(flag3);
        if (flag3 & $69aac16029968692$var$REPEAT) {
          let count = stream2.readUInt8();
          for (let j = 0; j < count; j++)
            flags.push(flag3);
        }
      }
      for (var i = 0; i < flags.length; i++) {
        var flag3 = flags[i];
        let point = new $69aac16029968692$export$baf26146a414f24a(!!(flag3 & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
        glyph.points.push(point);
      }
      let px2 = 0;
      for (var i = 0; i < flags.length; i++) {
        var flag3 = flags[i];
        glyph.points[i].x = px2 = this._parseGlyphCoord(stream2, px2, flag3 & $69aac16029968692$var$X_SHORT_VECTOR, flag3 & $69aac16029968692$var$SAME_X);
      }
      let py2 = 0;
      for (var i = 0; i < flags.length; i++) {
        var flag3 = flags[i];
        glyph.points[i].y = py2 = this._parseGlyphCoord(stream2, py2, flag3 & $69aac16029968692$var$Y_SHORT_VECTOR, flag3 & $69aac16029968692$var$SAME_Y);
      }
      if (this._font._variationProcessor) {
        let points = glyph.points.slice();
        points.push(...this._getPhantomPoints(glyph));
        this._font._variationProcessor.transformPoints(this.id, points);
        glyph.phantomPoints = points.slice(-4);
      }
      return;
    }
    _decodeComposite(glyph, stream2, offset = 0) {
      glyph.components = [];
      let haveInstructions = false;
      let flags = $69aac16029968692$var$MORE_COMPONENTS;
      while (flags & $69aac16029968692$var$MORE_COMPONENTS) {
        flags = stream2.readUInt16BE();
        let gPos = stream2.pos - offset;
        let glyphID = stream2.readUInt16BE();
        if (!haveInstructions)
          haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;
        if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {
          var dx = stream2.readInt16BE();
          var dy = stream2.readInt16BE();
        } else {
          var dx = stream2.readInt8();
          var dy = stream2.readInt8();
        }
        var component = new $69aac16029968692$var$Component(glyphID, dx, dy);
        component.pos = gPos;
        if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)
          component.scaleX = component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {
          component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
          component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {
          component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
          component.scale01 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
          component.scale10 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
          component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        }
        glyph.components.push(component);
      }
      if (this._font._variationProcessor) {
        let points = [];
        for (let j = 0; j < glyph.components.length; j++) {
          var component = glyph.components[j];
          points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));
        }
        points.push(...this._getPhantomPoints(glyph));
        this._font._variationProcessor.transformPoints(this.id, points);
        glyph.phantomPoints = points.splice(-4, 4);
        for (let i = 0; i < points.length; i++) {
          let point = points[i];
          glyph.components[i].dx = point.x;
          glyph.components[i].dy = point.y;
        }
      }
      return haveInstructions;
    }
    _getPhantomPoints(glyph) {
      let cbox = this._getCBox(true);
      if (this._metrics == null)
        this._metrics = (0, $f92906be28e61769$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);
      let { advanceWidth, advanceHeight, leftBearing, topBearing } = this._metrics;
      return [
        new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
        new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth, 0),
        new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
        new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
      ];
    }
    // Decodes font data, resolves composite glyphs, and returns an array of contours
    _getContours() {
      let glyph = this._decode();
      if (!glyph)
        return [];
      let points = [];
      if (glyph.numberOfContours < 0)
        for (let component of glyph.components) {
          let contours2 = this._font.getGlyph(component.glyphID)._getContours();
          for (let i = 0; i < contours2.length; i++) {
            let contour = contours2[i];
            for (let j = 0; j < contour.length; j++) {
              let point2 = contour[j];
              let x = point2.x * component.scaleX + point2.y * component.scale01 + component.dx;
              let y = point2.y * component.scaleY + point2.x * component.scale10 + component.dy;
              points.push(new $69aac16029968692$export$baf26146a414f24a(point2.onCurve, point2.endContour, x, y));
            }
          }
        }
      else
        points = glyph.points || [];
      if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
        this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
        this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
        this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
        this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
      }
      let contours = [];
      let cur = [];
      for (let k = 0; k < points.length; k++) {
        var point = points[k];
        cur.push(point);
        if (point.endContour) {
          contours.push(cur);
          cur = [];
        }
      }
      return contours;
    }
    _getMetrics() {
      if (this._metrics)
        return this._metrics;
      let cbox = this._getCBox(true);
      super._getMetrics(cbox);
      if (this._font._variationProcessor && !this._font.HVAR)
        this.path;
      return this._metrics;
    }
    // Converts contours to a Path object that can be rendered
    _getPath() {
      let contours = this._getContours();
      let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
      for (let i = 0; i < contours.length; i++) {
        let contour = contours[i];
        let firstPt = contour[0];
        let lastPt = contour[contour.length - 1];
        let start = 0;
        if (firstPt.onCurve) {
          var curvePt = null;
          start = 1;
        } else {
          if (lastPt.onCurve)
            firstPt = lastPt;
          else
            firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
          var curvePt = firstPt;
        }
        path.moveTo(firstPt.x, firstPt.y);
        for (let j = start; j < contour.length; j++) {
          let pt = contour[j];
          let prevPt = j === 0 ? firstPt : contour[j - 1];
          if (prevPt.onCurve && pt.onCurve)
            path.lineTo(pt.x, pt.y);
          else if (prevPt.onCurve && !pt.onCurve)
            var curvePt = pt;
          else if (!prevPt.onCurve && !pt.onCurve) {
            let midX = (prevPt.x + pt.x) / 2;
            let midY = (prevPt.y + pt.y) / 2;
            path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
            var curvePt = pt;
          } else if (!prevPt.onCurve && pt.onCurve) {
            path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
            var curvePt = null;
          } else
            throw new Error("Unknown TTF path state");
        }
        if (curvePt)
          path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
        path.closePath();
      }
      return path;
    }
    constructor(...args) {
      super(...args);
      (0, _defineProperty)(this, "type", "TTF");
    }
  };
  var $62cc5109c6101893$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
    _getName() {
      if (this._font.CFF2)
        return super._getName();
      return this._font["CFF "].getGlyphName(this.id);
    }
    bias(s) {
      if (s.length < 1240)
        return 107;
      else if (s.length < 33900)
        return 1131;
      else
        return 32768;
    }
    _getPath() {
      let cff = this._font.CFF2 || this._font["CFF "];
      let { stream: stream2 } = cff;
      let str = cff.topDict.CharStrings[this.id];
      let end = str.offset + str.length;
      stream2.pos = str.offset;
      let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
      let stack = [];
      let trans = [];
      let width = null;
      let nStems = 0;
      let x1 = 0, y1 = 0;
      let usedGsubrs;
      let usedSubrs;
      let open = false;
      this._usedGsubrs = usedGsubrs = {};
      this._usedSubrs = usedSubrs = {};
      let gsubrs = cff.globalSubrIndex || [];
      let gsubrsBias = this.bias(gsubrs);
      let privateDict = cff.privateDictForGlyph(this.id) || {};
      let subrs = privateDict.Subrs || [];
      let subrsBias = this.bias(subrs);
      let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
      let vsindex = privateDict.vsindex;
      let variationProcessor = this._font._variationProcessor;
      function checkWidth() {
        if (width == null)
          width = stack.shift() + privateDict.nominalWidthX;
      }
      function parseStems() {
        if (stack.length % 2 !== 0)
          checkWidth();
        nStems += stack.length >> 1;
        return stack.length = 0;
      }
      function moveTo2(x, y) {
        if (open)
          path.closePath();
        path.moveTo(x, y);
        open = true;
      }
      let parse2 = function() {
        while (stream2.pos < end) {
          let op = stream2.readUInt8();
          if (op < 32) {
            let index, subr, phase;
            switch (op) {
              case 1:
              case 3:
              case 18:
              case 23:
                parseStems();
                break;
              case 4:
                if (stack.length > 1)
                  checkWidth();
                y1 += stack.shift();
                moveTo2(x1, y1);
                break;
              case 5:
                while (stack.length >= 2) {
                  x1 += stack.shift();
                  y1 += stack.shift();
                  path.lineTo(x1, y1);
                }
                break;
              case 6:
              case 7:
                phase = op === 6;
                while (stack.length >= 1) {
                  if (phase)
                    x1 += stack.shift();
                  else
                    y1 += stack.shift();
                  path.lineTo(x1, y1);
                  phase = !phase;
                }
                break;
              case 8:
                while (stack.length > 0) {
                  var c1x = x1 + stack.shift();
                  var c1y = y1 + stack.shift();
                  var c2x = c1x + stack.shift();
                  var c2y = c1y + stack.shift();
                  x1 = c2x + stack.shift();
                  y1 = c2y + stack.shift();
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                }
                break;
              case 10:
                index = stack.pop() + subrsBias;
                subr = subrs[index];
                if (subr) {
                  usedSubrs[index] = true;
                  var p = stream2.pos;
                  var e = end;
                  stream2.pos = subr.offset;
                  end = subr.offset + subr.length;
                  parse2();
                  stream2.pos = p;
                  end = e;
                }
                break;
              case 11:
                if (cff.version >= 2)
                  break;
                return;
              case 14:
                if (cff.version >= 2)
                  break;
                if (stack.length > 0)
                  checkWidth();
                if (open) {
                  path.closePath();
                  open = false;
                }
                break;
              case 15:
                if (cff.version < 2)
                  throw new Error("vsindex operator not supported in CFF v1");
                vsindex = stack.pop();
                break;
              case 16: {
                if (cff.version < 2)
                  throw new Error("blend operator not supported in CFF v1");
                if (!variationProcessor)
                  throw new Error("blend operator in non-variation font");
                let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
                let numBlends = stack.pop();
                let numOperands = numBlends * blendVector.length;
                let delta = stack.length - numOperands;
                let base = delta - numBlends;
                for (let i = 0; i < numBlends; i++) {
                  let sum2 = stack[base + i];
                  for (let j = 0; j < blendVector.length; j++)
                    sum2 += blendVector[j] * stack[delta++];
                  stack[base + i] = sum2;
                }
                while (numOperands--)
                  stack.pop();
                break;
              }
              case 19:
              case 20:
                parseStems();
                stream2.pos += nStems + 7 >> 3;
                break;
              case 21:
                if (stack.length > 2)
                  checkWidth();
                x1 += stack.shift();
                y1 += stack.shift();
                moveTo2(x1, y1);
                break;
              case 22:
                if (stack.length > 1)
                  checkWidth();
                x1 += stack.shift();
                moveTo2(x1, y1);
                break;
              case 24:
                while (stack.length >= 8) {
                  var c1x = x1 + stack.shift();
                  var c1y = y1 + stack.shift();
                  var c2x = c1x + stack.shift();
                  var c2y = c1y + stack.shift();
                  x1 = c2x + stack.shift();
                  y1 = c2y + stack.shift();
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                }
                x1 += stack.shift();
                y1 += stack.shift();
                path.lineTo(x1, y1);
                break;
              case 25:
                while (stack.length >= 8) {
                  x1 += stack.shift();
                  y1 += stack.shift();
                  path.lineTo(x1, y1);
                }
                var c1x = x1 + stack.shift();
                var c1y = y1 + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                break;
              case 26:
                if (stack.length % 2)
                  x1 += stack.shift();
                while (stack.length >= 4) {
                  c1x = x1;
                  c1y = y1 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x1 = c2x;
                  y1 = c2y + stack.shift();
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                }
                break;
              case 27:
                if (stack.length % 2)
                  y1 += stack.shift();
                while (stack.length >= 4) {
                  c1x = x1 + stack.shift();
                  c1y = y1;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x1 = c2x + stack.shift();
                  y1 = c2y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                }
                break;
              case 28:
                stack.push(stream2.readInt16BE());
                break;
              case 29:
                index = stack.pop() + gsubrsBias;
                subr = gsubrs[index];
                if (subr) {
                  usedGsubrs[index] = true;
                  var p = stream2.pos;
                  var e = end;
                  stream2.pos = subr.offset;
                  end = subr.offset + subr.length;
                  parse2();
                  stream2.pos = p;
                  end = e;
                }
                break;
              case 30:
              case 31:
                phase = op === 31;
                while (stack.length >= 4) {
                  if (phase) {
                    c1x = x1 + stack.shift();
                    c1y = y1;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y1 = c2y + stack.shift();
                    x1 = c2x + (stack.length === 1 ? stack.shift() : 0);
                  } else {
                    c1x = x1;
                    c1y = y1 + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x1 = c2x + stack.shift();
                    y1 = c2y + (stack.length === 1 ? stack.shift() : 0);
                  }
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                  phase = !phase;
                }
                break;
              case 12:
                op = stream2.readUInt8();
                switch (op) {
                  case 3:
                    let a = stack.pop();
                    let b = stack.pop();
                    stack.push(a && b ? 1 : 0);
                    break;
                  case 4:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a || b ? 1 : 0);
                    break;
                  case 5:
                    a = stack.pop();
                    stack.push(a ? 0 : 1);
                    break;
                  case 9:
                    a = stack.pop();
                    stack.push(Math.abs(a));
                    break;
                  case 10:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a + b);
                    break;
                  case 11:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a - b);
                    break;
                  case 12:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a / b);
                    break;
                  case 14:
                    a = stack.pop();
                    stack.push(-a);
                    break;
                  case 15:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a === b ? 1 : 0);
                    break;
                  case 18:
                    stack.pop();
                    break;
                  case 20:
                    let val = stack.pop();
                    let idx = stack.pop();
                    trans[idx] = val;
                    break;
                  case 21:
                    idx = stack.pop();
                    stack.push(trans[idx] || 0);
                    break;
                  case 22:
                    let s1 = stack.pop();
                    let s2 = stack.pop();
                    let v1 = stack.pop();
                    let v2 = stack.pop();
                    stack.push(v1 <= v2 ? s1 : s2);
                    break;
                  case 23:
                    stack.push(Math.random());
                    break;
                  case 24:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a * b);
                    break;
                  case 26:
                    a = stack.pop();
                    stack.push(Math.sqrt(a));
                    break;
                  case 27:
                    a = stack.pop();
                    stack.push(a, a);
                    break;
                  case 28:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(b, a);
                    break;
                  case 29:
                    idx = stack.pop();
                    if (idx < 0)
                      idx = 0;
                    else if (idx > stack.length - 1)
                      idx = stack.length - 1;
                    stack.push(stack[idx]);
                    break;
                  case 30:
                    let n = stack.pop();
                    let j = stack.pop();
                    if (j >= 0)
                      while (j > 0) {
                        var t = stack[n - 1];
                        for (let i = n - 2; i >= 0; i--)
                          stack[i + 1] = stack[i];
                        stack[0] = t;
                        j--;
                      }
                    else
                      while (j < 0) {
                        var t = stack[0];
                        for (let i = 0; i <= n; i++)
                          stack[i] = stack[i + 1];
                        stack[n - 1] = t;
                        j++;
                      }
                    break;
                  case 34:
                    c1x = x1 + stack.shift();
                    c1y = y1;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    let c3x = c2x + stack.shift();
                    let c3y = c2y;
                    let c4x = c3x + stack.shift();
                    let c4y = c3y;
                    let c5x = c4x + stack.shift();
                    let c5y = c4y;
                    let c6x = c5x + stack.shift();
                    let c6y = c5y;
                    x1 = c6x;
                    y1 = c6y;
                    path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                    path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                    break;
                  case 35:
                    let pts = [];
                    for (let i = 0; i <= 5; i++) {
                      x1 += stack.shift();
                      y1 += stack.shift();
                      pts.push(x1, y1);
                    }
                    path.bezierCurveTo(...pts.slice(0, 6));
                    path.bezierCurveTo(...pts.slice(6));
                    stack.shift();
                    break;
                  case 36:
                    c1x = x1 + stack.shift();
                    c1y = y1 + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    c3x = c2x + stack.shift();
                    c3y = c2y;
                    c4x = c3x + stack.shift();
                    c4y = c3y;
                    c5x = c4x + stack.shift();
                    c5y = c4y + stack.shift();
                    c6x = c5x + stack.shift();
                    c6y = c5y;
                    x1 = c6x;
                    y1 = c6y;
                    path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                    path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                    break;
                  case 37:
                    let startx = x1;
                    let starty = y1;
                    pts = [];
                    for (let i1 = 0; i1 <= 4; i1++) {
                      x1 += stack.shift();
                      y1 += stack.shift();
                      pts.push(x1, y1);
                    }
                    if (Math.abs(x1 - startx) > Math.abs(y1 - starty)) {
                      x1 += stack.shift();
                      y1 = starty;
                    } else {
                      x1 = startx;
                      y1 += stack.shift();
                    }
                    pts.push(x1, y1);
                    path.bezierCurveTo(...pts.slice(0, 6));
                    path.bezierCurveTo(...pts.slice(6));
                    break;
                  default:
                    throw new Error(`Unknown op: 12 ${op}`);
                }
                break;
              default:
                throw new Error(`Unknown op: ${op}`);
            }
          } else if (op < 247)
            stack.push(op - 139);
          else if (op < 251) {
            var b1 = stream2.readUInt8();
            stack.push((op - 247) * 256 + b1 + 108);
          } else if (op < 255) {
            var b1 = stream2.readUInt8();
            stack.push(-(op - 251) * 256 - b1 - 108);
          } else
            stack.push(stream2.readInt32BE() / 65536);
        }
      };
      parse2();
      if (open)
        path.closePath();
      return path;
    }
    constructor(...args) {
      super(...args);
      (0, _defineProperty)(this, "type", "CFF");
    }
  };
  var $25d8f049c222084c$var$SBIXImage = new Struct({
    originX: uint16,
    originY: uint16,
    type: new StringT(4),
    data: new BufferT((t) => t.parent.buflen - t._currentOffset)
  });
  var $25d8f049c222084c$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
    /**
    * Returns an object representing a glyph image at the given point size.
    * The object has a data property with a Buffer containing the actual image data,
    * along with the image type, and origin.
    *
    * @param {number} size
    * @return {object}
    */
    getImageForSize(size) {
      for (let i = 0; i < this._font.sbix.imageTables.length; i++) {
        var table = this._font.sbix.imageTables[i];
        if (table.ppem >= size)
          break;
      }
      let offsets = table.imageOffsets;
      let start = offsets[this.id];
      let end = offsets[this.id + 1];
      if (start === end)
        return null;
      this._font.stream.pos = start;
      return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {
        buflen: end - start
      });
    }
    render(ctx, size) {
      let img = this.getImageForSize(size);
      if (img != null) {
        let scale2 = size / this._font.unitsPerEm;
        ctx.image(img.data, {
          height: size,
          x: img.originX,
          y: (this.bbox.minY - img.originY) * scale2
        });
      }
      if (this._font.sbix.flags.renderOutlines)
        super.render(ctx, size);
    }
    constructor(...args) {
      super(...args);
      (0, _defineProperty)(this, "type", "SBIX");
    }
  };
  var $0d411f0165859681$var$COLRLayer = class {
    constructor(glyph, color) {
      this.glyph = glyph;
      this.color = color;
    }
  };
  var $0d411f0165859681$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
    _getBBox() {
      let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      for (let i = 0; i < this.layers.length; i++) {
        let layer = this.layers[i];
        let b = layer.glyph.bbox;
        bbox.addPoint(b.minX, b.minY);
        bbox.addPoint(b.maxX, b.maxY);
      }
      return bbox;
    }
    /**
    * Returns an array of objects containing the glyph and color for
    * each layer in the composite color glyph.
    * @type {object[]}
    */
    get layers() {
      let cpal = this._font.CPAL;
      let colr = this._font.COLR;
      let low = 0;
      let high = colr.baseGlyphRecord.length - 1;
      while (low <= high) {
        let mid = low + high >> 1;
        var rec = colr.baseGlyphRecord[mid];
        if (this.id < rec.gid)
          high = mid - 1;
        else if (this.id > rec.gid)
          low = mid + 1;
        else {
          var baseLayer = rec;
          break;
        }
      }
      if (baseLayer == null) {
        var g = this._font._getBaseGlyph(this.id);
        var color = {
          red: 0,
          green: 0,
          blue: 0,
          alpha: 255
        };
        return [
          new $0d411f0165859681$var$COLRLayer(g, color)
        ];
      }
      let layers = [];
      for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {
        var rec = colr.layerRecords[i];
        var color = cpal.colorRecords[rec.paletteIndex];
        var g = this._font._getBaseGlyph(rec.gid);
        layers.push(new $0d411f0165859681$var$COLRLayer(g, color));
      }
      return layers;
    }
    render(ctx, size) {
      for (let { glyph, color } of this.layers) {
        ctx.fillColor([
          color.red,
          color.green,
          color.blue
        ], color.alpha / 255 * 100);
        glyph.render(ctx, size);
      }
      return;
    }
    constructor(...args) {
      super(...args);
      (0, _defineProperty)(this, "type", "COLR");
    }
  };
  var $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
  var $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 4095;
  var $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 32768;
  var $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 16384;
  var $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 8192;
  var $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 4095;
  var $0bb840cac04e911b$var$POINTS_ARE_WORDS = 128;
  var $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 127;
  var $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 128;
  var $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 64;
  var $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 63;
  var $0bb840cac04e911b$export$2e2bcd8739ae039 = class {
    normalizeCoords(coords) {
      let normalized = [];
      for (var i = 0; i < this.font.fvar.axis.length; i++) {
        let axis = this.font.fvar.axis[i];
        if (coords[i] < axis.defaultValue)
          normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
        else
          normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
      }
      if (this.font.avar)
        for (var i = 0; i < this.font.avar.segment.length; i++) {
          let segment = this.font.avar.segment[i];
          for (let j = 0; j < segment.correspondence.length; j++) {
            let pair = segment.correspondence[j];
            if (j >= 1 && normalized[i] < pair.fromCoord) {
              let prev = segment.correspondence[j - 1];
              normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
              break;
            }
          }
        }
      return normalized;
    }
    transformPoints(gid, glyphPoints) {
      if (!this.font.fvar || !this.font.gvar)
        return;
      let { gvar } = this.font;
      if (gid >= gvar.glyphCount)
        return;
      let offset = gvar.offsets[gid];
      if (offset === gvar.offsets[gid + 1])
        return;
      let { stream: stream2 } = this.font;
      stream2.pos = offset;
      if (stream2.pos >= stream2.length)
        return;
      let tupleCount = stream2.readUInt16BE();
      let offsetToData = offset + stream2.readUInt16BE();
      if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {
        var here = stream2.pos;
        stream2.pos = offsetToData;
        var sharedPoints = this.decodePoints();
        offsetToData = stream2.pos;
        stream2.pos = here;
      }
      let origPoints = glyphPoints.map((pt) => pt.copy());
      tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;
      for (let i = 0; i < tupleCount; i++) {
        let tupleDataSize = stream2.readUInt16BE();
        let tupleIndex = stream2.readUInt16BE();
        if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {
          var tupleCoords = [];
          for (let a = 0; a < gvar.axisCount; a++)
            tupleCoords.push(stream2.readInt16BE() / 16384);
        } else {
          if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount)
            throw new Error("Invalid gvar table");
          var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];
        }
        if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {
          var startCoords = [];
          for (let a = 0; a < gvar.axisCount; a++)
            startCoords.push(stream2.readInt16BE() / 16384);
          var endCoords = [];
          for (let a1 = 0; a1 < gvar.axisCount; a1++)
            endCoords.push(stream2.readInt16BE() / 16384);
        }
        let factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
        if (factor === 0) {
          offsetToData += tupleDataSize;
          continue;
        }
        var here = stream2.pos;
        stream2.pos = offsetToData;
        if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS)
          var points = this.decodePoints();
        else
          var points = sharedPoints;
        let nPoints = points.length === 0 ? glyphPoints.length : points.length;
        let xDeltas = this.decodeDeltas(nPoints);
        let yDeltas = this.decodeDeltas(nPoints);
        if (points.length === 0)
          for (let i2 = 0; i2 < glyphPoints.length; i2++) {
            var point = glyphPoints[i2];
            point.x += Math.round(xDeltas[i2] * factor);
            point.y += Math.round(yDeltas[i2] * factor);
          }
        else {
          let outPoints = origPoints.map((pt) => pt.copy());
          let hasDelta = glyphPoints.map(() => false);
          for (let i2 = 0; i2 < points.length; i2++) {
            let idx = points[i2];
            if (idx < glyphPoints.length) {
              let point2 = outPoints[idx];
              hasDelta[idx] = true;
              point2.x += Math.round(xDeltas[i2] * factor);
              point2.y += Math.round(yDeltas[i2] * factor);
            }
          }
          this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
          for (let i1 = 0; i1 < glyphPoints.length; i1++) {
            let deltaX = outPoints[i1].x - origPoints[i1].x;
            let deltaY = outPoints[i1].y - origPoints[i1].y;
            glyphPoints[i1].x += deltaX;
            glyphPoints[i1].y += deltaY;
          }
        }
        offsetToData += tupleDataSize;
        stream2.pos = here;
      }
    }
    decodePoints() {
      let stream2 = this.font.stream;
      let count = stream2.readUInt8();
      if (count & $0bb840cac04e911b$var$POINTS_ARE_WORDS)
        count = (count & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream2.readUInt8();
      let points = new Uint16Array(count);
      let i = 0;
      let point = 0;
      while (i < count) {
        let run = stream2.readUInt8();
        let runCount = (run & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;
        let fn = run & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream2.readUInt16 : stream2.readUInt8;
        for (let j = 0; j < runCount && i < count; j++) {
          point += fn.call(stream2);
          points[i++] = point;
        }
      }
      return points;
    }
    decodeDeltas(count) {
      let stream2 = this.font.stream;
      let i = 0;
      let deltas = new Int16Array(count);
      while (i < count) {
        let run = stream2.readUInt8();
        let runCount = (run & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;
        if (run & $0bb840cac04e911b$var$DELTAS_ARE_ZERO)
          i += runCount;
        else {
          let fn = run & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream2.readInt16BE : stream2.readInt8;
          for (let j = 0; j < runCount && i < count; j++)
            deltas[i++] = fn.call(stream2);
        }
      }
      return deltas;
    }
    tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
      let normalized = this.normalizedCoords;
      let { gvar } = this.font;
      let factor = 1;
      for (let i = 0; i < gvar.axisCount; i++) {
        if (tupleCoords[i] === 0)
          continue;
        if (normalized[i] === 0)
          return 0;
        if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {
          if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i]))
            return 0;
          factor = (factor * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);
        } else {
          if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i])
            return 0;
          else if (normalized[i] < tupleCoords[i])
            factor = factor * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);
          else
            factor = factor * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);
        }
      }
      return factor;
    }
    // Interpolates points without delta values.
    // Needed for the  and Q glyphs in Skia.
    // Algorithm from Freetype.
    interpolateMissingDeltas(points, inPoints, hasDelta) {
      if (points.length === 0)
        return;
      let point = 0;
      while (point < points.length) {
        let firstPoint = point;
        let endPoint = point;
        let pt = points[endPoint];
        while (!pt.endContour)
          pt = points[++endPoint];
        while (point <= endPoint && !hasDelta[point])
          point++;
        if (point > endPoint)
          continue;
        let firstDelta = point;
        let curDelta = point;
        point++;
        while (point <= endPoint) {
          if (hasDelta[point]) {
            this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
            curDelta = point;
          }
          point++;
        }
        if (curDelta === firstDelta)
          this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
        else {
          this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
          if (firstDelta > 0)
            this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
        }
        point = endPoint + 1;
      }
    }
    deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
      if (p1 > p2)
        return;
      let iterable = [
        "x",
        "y"
      ];
      for (let i = 0; i < iterable.length; i++) {
        let k = iterable[i];
        if (inPoints[ref1][k] > inPoints[ref2][k]) {
          var p = ref1;
          ref1 = ref2;
          ref2 = p;
        }
        let in1 = inPoints[ref1][k];
        let in2 = inPoints[ref2][k];
        let out1 = outPoints[ref1][k];
        let out2 = outPoints[ref2][k];
        if (in1 !== in2 || out1 === out2) {
          let scale2 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
          for (let p3 = p1; p3 <= p2; p3++) {
            let out = inPoints[p3][k];
            if (out <= in1)
              out += out1 - in1;
            else if (out >= in2)
              out += out2 - in2;
            else
              out = out1 + (out - in1) * scale2;
            outPoints[p3][k] = out;
          }
        }
      }
    }
    deltaShift(p1, p2, ref, inPoints, outPoints) {
      let deltaX = outPoints[ref].x - inPoints[ref].x;
      let deltaY = outPoints[ref].y - inPoints[ref].y;
      if (deltaX === 0 && deltaY === 0)
        return;
      for (let p = p1; p <= p2; p++)
        if (p !== ref) {
          outPoints[p].x += deltaX;
          outPoints[p].y += deltaY;
        }
    }
    getAdvanceAdjustment(gid, table) {
      let outerIndex, innerIndex;
      if (table.advanceWidthMapping) {
        let idx = gid;
        if (idx >= table.advanceWidthMapping.mapCount)
          idx = table.advanceWidthMapping.mapCount - 1;
        let entryFormat = table.advanceWidthMapping.entryFormat;
        ({ outerIndex, innerIndex } = table.advanceWidthMapping.mapData[idx]);
      } else {
        outerIndex = 0;
        innerIndex = gid;
      }
      return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
    }
    // See pseudo code from `Font Variations Overview'
    // in the OpenType specification.
    getDelta(itemStore, outerIndex, innerIndex) {
      if (outerIndex >= itemStore.itemVariationData.length)
        return 0;
      let varData = itemStore.itemVariationData[outerIndex];
      if (innerIndex >= varData.deltaSets.length)
        return 0;
      let deltaSet = varData.deltaSets[innerIndex];
      let blendVector = this.getBlendVector(itemStore, outerIndex);
      let netAdjustment = 0;
      for (let master = 0; master < varData.regionIndexCount; master++)
        netAdjustment += deltaSet.deltas[master] * blendVector[master];
      return netAdjustment;
    }
    getBlendVector(itemStore, outerIndex) {
      let varData = itemStore.itemVariationData[outerIndex];
      if (this.blendVectors.has(varData))
        return this.blendVectors.get(varData);
      let normalizedCoords = this.normalizedCoords;
      let blendVector = [];
      for (let master = 0; master < varData.regionIndexCount; master++) {
        let scalar = 1;
        let regionIndex = varData.regionIndexes[master];
        let axes = itemStore.variationRegionList.variationRegions[regionIndex];
        for (let j = 0; j < axes.length; j++) {
          let axis = axes[j];
          let axisScalar;
          if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord)
            axisScalar = 1;
          else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0)
            axisScalar = 1;
          else if (axis.peakCoord === 0)
            axisScalar = 1;
          else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord)
            axisScalar = 0;
          else {
            if (normalizedCoords[j] === axis.peakCoord)
              axisScalar = 1;
            else if (normalizedCoords[j] < axis.peakCoord)
              axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
            else
              axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
          }
          scalar *= axisScalar;
        }
        blendVector[master] = scalar;
      }
      this.blendVectors.set(varData, blendVector);
      return blendVector;
    }
    constructor(font, coords) {
      this.font = font;
      this.normalizedCoords = this.normalizeCoords(coords);
      this.blendVectors = /* @__PURE__ */ new Map();
    }
  };
  var $5cc7476da92df375$var$resolved = Promise.resolve();
  var $5cc7476da92df375$export$2e2bcd8739ae039 = class {
    includeGlyph(glyph) {
      if (typeof glyph === "object")
        glyph = glyph.id;
      if (this.mapping[glyph] == null) {
        this.glyphs.push(glyph);
        this.mapping[glyph] = this.glyphs.length - 1;
      }
      return this.mapping[glyph];
    }
    constructor(font) {
      this.font = font;
      this.glyphs = [];
      this.mapping = {};
      this.includeGlyph(0);
    }
  };
  var $807e58506be70005$var$ON_CURVE = 1;
  var $807e58506be70005$var$X_SHORT_VECTOR = 2;
  var $807e58506be70005$var$Y_SHORT_VECTOR = 4;
  var $807e58506be70005$var$REPEAT = 8;
  var $807e58506be70005$var$SAME_X = 16;
  var $807e58506be70005$var$SAME_Y = 32;
  var $807e58506be70005$var$Point = class {
    static size(val) {
      return val >= 0 && val <= 255 ? 1 : 2;
    }
    static encode(stream2, value) {
      if (value >= 0 && value <= 255)
        stream2.writeUInt8(value);
      else
        stream2.writeInt16BE(value);
    }
  };
  var $807e58506be70005$var$Glyf = new Struct({
    numberOfContours: int16,
    xMin: int16,
    yMin: int16,
    xMax: int16,
    yMax: int16,
    endPtsOfContours: new ArrayT(uint16, "numberOfContours"),
    instructions: new ArrayT(uint8, uint16),
    flags: new ArrayT(uint8, 0),
    xPoints: new ArrayT($807e58506be70005$var$Point, 0),
    yPoints: new ArrayT($807e58506be70005$var$Point, 0)
  });
  var $807e58506be70005$export$2e2bcd8739ae039 = class {
    encodeSimple(path, instructions = []) {
      let endPtsOfContours = [];
      let xPoints = [];
      let yPoints = [];
      let flags = [];
      let same = 0;
      let lastX = 0, lastY = 0, lastFlag = 0;
      let pointCount = 0;
      for (let i = 0; i < path.commands.length; i++) {
        let c = path.commands[i];
        for (let j = 0; j < c.args.length; j += 2) {
          let x = c.args[j];
          let y = c.args[j + 1];
          let flag3 = 0;
          if (c.command === "quadraticCurveTo" && j === 2) {
            let next = path.commands[i + 1];
            if (next && next.command === "quadraticCurveTo") {
              let midX = (lastX + next.args[0]) / 2;
              let midY = (lastY + next.args[1]) / 2;
              if (x === midX && y === midY)
                continue;
            }
          }
          if (!(c.command === "quadraticCurveTo" && j === 0))
            flag3 |= $807e58506be70005$var$ON_CURVE;
          flag3 = this._encodePoint(x, lastX, xPoints, flag3, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);
          flag3 = this._encodePoint(y, lastY, yPoints, flag3, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);
          if (flag3 === lastFlag && same < 255) {
            flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;
            same++;
          } else {
            if (same > 0) {
              flags.push(same);
              same = 0;
            }
            flags.push(flag3);
            lastFlag = flag3;
          }
          lastX = x;
          lastY = y;
          pointCount++;
        }
        if (c.command === "closePath")
          endPtsOfContours.push(pointCount - 1);
      }
      if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== "closePath")
        endPtsOfContours.push(pointCount - 1);
      let bbox = path.bbox;
      let glyf = {
        numberOfContours: endPtsOfContours.length,
        xMin: bbox.minX,
        yMin: bbox.minY,
        xMax: bbox.maxX,
        yMax: bbox.maxY,
        endPtsOfContours,
        instructions,
        flags,
        xPoints,
        yPoints
      };
      let size = $807e58506be70005$var$Glyf.size(glyf);
      let tail = 4 - size % 4;
      let stream2 = new EncodeStream(size + tail);
      $807e58506be70005$var$Glyf.encode(stream2, glyf);
      if (tail !== 0)
        stream2.fill(0, tail);
      return stream2.buffer;
    }
    _encodePoint(value, last2, points, flag3, shortFlag, sameFlag) {
      let diff = value - last2;
      if (value === last2)
        flag3 |= sameFlag;
      else {
        if (-255 <= diff && diff <= 255) {
          flag3 |= shortFlag;
          if (diff < 0)
            diff = -diff;
          else
            flag3 |= sameFlag;
        }
        points.push(diff);
      }
      return flag3;
    }
  };
  var $4abbb6a5dbdc441a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
    _addGlyph(gid) {
      let glyph = this.font.getGlyph(gid);
      let glyf = glyph._decode();
      let curOffset = this.font.loca.offsets[gid];
      let nextOffset = this.font.loca.offsets[gid + 1];
      let stream2 = this.font._getTableStream("glyf");
      stream2.pos += curOffset;
      let buffer = stream2.readBuffer(nextOffset - curOffset);
      if (glyf && glyf.numberOfContours < 0) {
        buffer = new Uint8Array(buffer);
        let view = new DataView(buffer.buffer);
        for (let component of glyf.components) {
          gid = this.includeGlyph(component.glyphID);
          view.setUint16(component.pos, gid);
        }
      } else if (glyf && this.font._variationProcessor)
        buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
      this.glyf.push(buffer);
      this.loca.offsets.push(this.offset);
      this.hmtx.metrics.push({
        advance: glyph.advanceWidth,
        bearing: glyph._getMetrics().leftBearing
      });
      this.offset += buffer.length;
      return this.glyf.length - 1;
    }
    encode() {
      this.glyf = [];
      this.offset = 0;
      this.loca = {
        offsets: [],
        version: this.font.loca.version
      };
      this.hmtx = {
        metrics: [],
        bearings: []
      };
      let i = 0;
      while (i < this.glyphs.length)
        this._addGlyph(this.glyphs[i++]);
      let maxp = (0, import_clone.default)(this.font.maxp);
      maxp.numGlyphs = this.glyf.length;
      this.loca.offsets.push(this.offset);
      let head = (0, import_clone.default)(this.font.head);
      head.indexToLocFormat = this.loca.version;
      let hhea = (0, import_clone.default)(this.font.hhea);
      hhea.numberOfMetrics = this.hmtx.metrics.length;
      return (0, $816c07a04b6dba87$export$2e2bcd8739ae039).toBuffer({
        tables: {
          head,
          hhea,
          loca: this.loca,
          maxp,
          "cvt ": this.font["cvt "],
          prep: this.font.prep,
          glyf: this.glyf,
          hmtx: this.hmtx,
          fpgm: this.font.fpgm
        }
      });
    }
    constructor(font) {
      super(font);
      this.glyphEncoder = new (0, $807e58506be70005$export$2e2bcd8739ae039)();
    }
  };
  var $001d739428a71d5a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
    subsetCharstrings() {
      this.charstrings = [];
      let gsubrs = {};
      for (let gid of this.glyphs) {
        this.charstrings.push(this.cff.getCharString(gid));
        let glyph = this.font.getGlyph(gid);
        let path = glyph.path;
        for (let subr in glyph._usedGsubrs)
          gsubrs[subr] = true;
      }
      this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
    }
    subsetSubrs(subrs, used) {
      let res = [];
      for (let i = 0; i < subrs.length; i++) {
        let subr = subrs[i];
        if (used[i]) {
          this.cff.stream.pos = subr.offset;
          res.push(this.cff.stream.readBuffer(subr.length));
        } else
          res.push(new Uint8Array([
            11
          ]));
      }
      return res;
    }
    subsetFontdict(topDict) {
      topDict.FDArray = [];
      topDict.FDSelect = {
        version: 0,
        fds: []
      };
      let used_fds = {};
      let used_subrs = [];
      let fd_select = {};
      for (let gid of this.glyphs) {
        let fd = this.cff.fdForGlyph(gid);
        if (fd == null)
          continue;
        if (!used_fds[fd]) {
          topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
          used_subrs.push({});
          fd_select[fd] = topDict.FDArray.length - 1;
        }
        used_fds[fd] = true;
        topDict.FDSelect.fds.push(fd_select[fd]);
        let glyph = this.font.getGlyph(gid);
        let path = glyph.path;
        for (let subr in glyph._usedSubrs)
          used_subrs[fd_select[fd]][subr] = true;
      }
      for (let i = 0; i < topDict.FDArray.length; i++) {
        let dict = topDict.FDArray[i];
        delete dict.FontName;
        if (dict.Private && dict.Private.Subrs) {
          dict.Private = Object.assign({}, dict.Private);
          dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
        }
      }
      return;
    }
    createCIDFontdict(topDict) {
      let used_subrs = {};
      for (let gid of this.glyphs) {
        let glyph = this.font.getGlyph(gid);
        let path = glyph.path;
        for (let subr in glyph._usedSubrs)
          used_subrs[subr] = true;
      }
      let privateDict = Object.assign({}, this.cff.topDict.Private);
      if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs)
        privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
      topDict.FDArray = [
        {
          Private: privateDict
        }
      ];
      return topDict.FDSelect = {
        version: 3,
        nRanges: 1,
        ranges: [
          {
            first: 0,
            fd: 0
          }
        ],
        sentinel: this.charstrings.length
      };
    }
    addString(string) {
      if (!string)
        return null;
      if (!this.strings)
        this.strings = [];
      this.strings.push(string);
      return (0, $229224aec43783c5$export$2e2bcd8739ae039).length + this.strings.length - 1;
    }
    encode() {
      this.subsetCharstrings();
      let charset = {
        version: this.charstrings.length > 255 ? 2 : 1,
        ranges: [
          {
            first: 1,
            nLeft: this.charstrings.length - 2
          }
        ]
      };
      let topDict = Object.assign({}, this.cff.topDict);
      topDict.Private = null;
      topDict.charset = charset;
      topDict.Encoding = null;
      topDict.CharStrings = this.charstrings;
      for (let key of [
        "version",
        "Notice",
        "Copyright",
        "FullName",
        "FamilyName",
        "Weight",
        "PostScript",
        "BaseFontName",
        "FontName"
      ])
        topDict[key] = this.addString(this.cff.string(topDict[key]));
      topDict.ROS = [
        this.addString("Adobe"),
        this.addString("Identity"),
        0
      ];
      topDict.CIDCount = this.charstrings.length;
      if (this.cff.isCIDFont)
        this.subsetFontdict(topDict);
      else
        this.createCIDFontdict(topDict);
      let top = {
        version: 1,
        hdrSize: this.cff.hdrSize,
        offSize: 4,
        header: this.cff.header,
        nameIndex: [
          this.cff.postscriptName
        ],
        topDictIndex: [
          topDict
        ],
        stringIndex: this.strings,
        globalSubrIndex: this.gsubrs
      };
      return (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).toBuffer(top);
    }
    constructor(font) {
      super(font);
      this.cff = this.font["CFF "];
      if (!this.cff)
        throw new Error("Not a CFF Font");
    }
  };
  var $4c1709dee528ea76$export$2e2bcd8739ae039 = class _$4c1709dee528ea76$export$2e2bcd8739ae039 {
    static probe(buffer) {
      let format = (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4));
      return format === "true" || format === "OTTO" || format === String.fromCharCode(0, 1, 0, 0);
    }
    setDefaultLanguage(lang = null) {
      this.defaultLanguage = lang;
    }
    _getTable(table) {
      if (!(table.tag in this._tables))
        try {
          this._tables[table.tag] = this._decodeTable(table);
        } catch (e) {
          if ($d636bc798e7178db$export$bd5c5d8b8dcafd78) {
            console.error(`Error decoding table ${table.tag}`);
            console.error(e.stack);
          }
        }
      return this._tables[table.tag];
    }
    _getTableStream(tag) {
      let table = this.directory.tables[tag];
      if (table) {
        this.stream.pos = table.offset;
        return this.stream;
      }
      return null;
    }
    _decodeDirectory() {
      return this.directory = (0, $816c07a04b6dba87$export$2e2bcd8739ae039).decode(this.stream, {
        _startOffset: 0
      });
    }
    _decodeTable(table) {
      let pos = this.stream.pos;
      let stream2 = this._getTableStream(table.tag);
      let result = (0, $c3395722bea751e2$export$2e2bcd8739ae039)[table.tag].decode(stream2, this, table.length);
      this.stream.pos = pos;
      return result;
    }
    /**
    * Gets a string from the font's `name` table
    * `lang` is a BCP-47 language code.
    * @return {string}
    */
    getName(key, lang = this.defaultLanguage || $d636bc798e7178db$export$42940898df819940) {
      let record = this.name && this.name.records[key];
      if (record)
        return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
      return null;
    }
    /**
    * The unique PostScript name for this font, e.g. "Helvetica-Bold"
    * @type {string}
    */
    get postscriptName() {
      return this.getName("postscriptName");
    }
    /**
    * The font's full name, e.g. "Helvetica Bold"
    * @type {string}
    */
    get fullName() {
      return this.getName("fullName");
    }
    /**
    * The font's family name, e.g. "Helvetica"
    * @type {string}
    */
    get familyName() {
      return this.getName("fontFamily");
    }
    /**
    * The font's sub-family, e.g. "Bold".
    * @type {string}
    */
    get subfamilyName() {
      return this.getName("fontSubfamily");
    }
    /**
    * The font's copyright information
    * @type {string}
    */
    get copyright() {
      return this.getName("copyright");
    }
    /**
    * The font's version number
    * @type {string}
    */
    get version() {
      return this.getName("version");
    }
    /**
    * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
    * @type {number}
    */
    get ascent() {
      return this.hhea.ascent;
    }
    /**
    * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
    * @type {number}
    */
    get descent() {
      return this.hhea.descent;
    }
    /**
    * The amount of space that should be included between lines
    * @type {number}
    */
    get lineGap() {
      return this.hhea.lineGap;
    }
    /**
    * The offset from the normal underline position that should be used
    * @type {number}
    */
    get underlinePosition() {
      return this.post.underlinePosition;
    }
    /**
    * The weight of the underline that should be used
    * @type {number}
    */
    get underlineThickness() {
      return this.post.underlineThickness;
    }
    /**
    * If this is an italic font, the angle the cursor should be drawn at to match the font design
    * @type {number}
    */
    get italicAngle() {
      return this.post.italicAngle;
    }
    /**
    * The height of capital letters above the baseline.
    * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
    * @type {number}
    */
    get capHeight() {
      let os2 = this["OS/2"];
      return os2 ? os2.capHeight : this.ascent;
    }
    /**
    * The height of lower case letters in the font.
    * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
    * @type {number}
    */
    get xHeight() {
      let os2 = this["OS/2"];
      return os2 ? os2.xHeight : 0;
    }
    /**
    * The number of glyphs in the font.
    * @type {number}
    */
    get numGlyphs() {
      return this.maxp.numGlyphs;
    }
    /**
    * The size of the fonts internal coordinate grid
    * @type {number}
    */
    get unitsPerEm() {
      return this.head.unitsPerEm;
    }
    /**
    * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
    * @type {BBox}
    */
    get bbox() {
      return Object.freeze(new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
    }
    get _cmapProcessor() {
      return new (0, $f08dd41ef10b694c$export$2e2bcd8739ae039)(this.cmap);
    }
    /**
    * An array of all of the unicode code points supported by the font.
    * @type {number[]}
    */
    get characterSet() {
      return this._cmapProcessor.getCharacterSet();
    }
    /**
    * Returns whether there is glyph in the font for the given unicode code point.
    *
    * @param {number} codePoint
    * @return {boolean}
    */
    hasGlyphForCodePoint(codePoint) {
      return !!this._cmapProcessor.lookup(codePoint);
    }
    /**
    * Maps a single unicode code point to a Glyph object.
    * Does not perform any advanced substitutions (there is no context to do so).
    *
    * @param {number} codePoint
    * @return {Glyph}
    */
    glyphForCodePoint(codePoint) {
      return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
        codePoint
      ]);
    }
    /**
    * Returns an array of Glyph objects for the given string.
    * This is only a one-to-one mapping from characters to glyphs.
    * For most uses, you should use font.layout (described below), which
    * provides a much more advanced mapping supporting AAT and OpenType shaping.
    *
    * @param {string} string
    * @return {Glyph[]}
    */
    glyphsForString(string) {
      let glyphs = [];
      let len = string.length;
      let idx = 0;
      let last2 = -1;
      let state = -1;
      while (idx <= len) {
        let code = 0;
        let nextState = 0;
        if (idx < len) {
          code = string.charCodeAt(idx++);
          if (55296 <= code && code <= 56319 && idx < len) {
            let next = string.charCodeAt(idx);
            if (56320 <= next && next <= 57343) {
              idx++;
              code = ((code & 1023) << 10) + (next & 1023) + 65536;
            }
          }
          nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
        } else
          idx++;
        if (state === 0 && nextState === 1)
          glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last2, code), [
            last2,
            code
          ]));
        else if (state === 0 && nextState === 0)
          glyphs.push(this.glyphForCodePoint(last2));
        last2 = code;
        state = nextState;
      }
      return glyphs;
    }
    get _layoutEngine() {
      return new (0, $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039)(this);
    }
    /**
    * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
    *
    * @param {string} string
    * @param {string[]} [userFeatures]
    * @param {string} [script]
    * @param {string} [language]
    * @param {string} [direction]
    * @return {GlyphRun}
    */
    layout(string, userFeatures, script, language, direction) {
      return this._layoutEngine.layout(string, userFeatures, script, language, direction);
    }
    /**
    * Returns an array of strings that map to the given glyph id.
    * @param {number} gid - glyph id
    */
    stringsForGlyph(gid) {
      return this._layoutEngine.stringsForGlyph(gid);
    }
    /**
    * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
    * (or mapped AAT tags) supported by the font.
    * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
    * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
    *
    * @type {string[]}
    */
    get availableFeatures() {
      return this._layoutEngine.getAvailableFeatures();
    }
    getAvailableFeatures(script, language) {
      return this._layoutEngine.getAvailableFeatures(script, language);
    }
    _getBaseGlyph(glyph, characters = []) {
      if (!this._glyphs[glyph]) {
        if (this.directory.tables.glyf)
          this._glyphs[glyph] = new (0, $69aac16029968692$export$2e2bcd8739ae039)(glyph, characters, this);
        else if (this.directory.tables["CFF "] || this.directory.tables.CFF2)
          this._glyphs[glyph] = new (0, $62cc5109c6101893$export$2e2bcd8739ae039)(glyph, characters, this);
      }
      return this._glyphs[glyph] || null;
    }
    /**
    * Returns a glyph object for the given glyph id.
    * You can pass the array of code points this glyph represents for
    * your use later, and it will be stored in the glyph object.
    *
    * @param {number} glyph
    * @param {number[]} characters
    * @return {Glyph}
    */
    getGlyph(glyph, characters = []) {
      if (!this._glyphs[glyph]) {
        if (this.directory.tables.sbix)
          this._glyphs[glyph] = new (0, $25d8f049c222084c$export$2e2bcd8739ae039)(glyph, characters, this);
        else if (this.directory.tables.COLR && this.directory.tables.CPAL)
          this._glyphs[glyph] = new (0, $0d411f0165859681$export$2e2bcd8739ae039)(glyph, characters, this);
        else
          this._getBaseGlyph(glyph, characters);
      }
      return this._glyphs[glyph] || null;
    }
    /**
    * Returns a Subset for this font.
    * @return {Subset}
    */
    createSubset() {
      if (this.directory.tables["CFF "])
        return new (0, $001d739428a71d5a$export$2e2bcd8739ae039)(this);
      return new (0, $4abbb6a5dbdc441a$export$2e2bcd8739ae039)(this);
    }
    /**
    * Returns an object describing the available variation axes
    * that this font supports. Keys are setting tags, and values
    * contain the axis name, range, and default value.
    *
    * @type {object}
    */
    get variationAxes() {
      let res = {};
      if (!this.fvar)
        return res;
      for (let axis of this.fvar.axis)
        res[axis.axisTag.trim()] = {
          name: axis.name.en,
          min: axis.minValue,
          default: axis.defaultValue,
          max: axis.maxValue
        };
      return res;
    }
    /**
    * Returns an object describing the named variation instances
    * that the font designer has specified. Keys are variation names
    * and values are the variation settings for this instance.
    *
    * @type {object}
    */
    get namedVariations() {
      let res = {};
      if (!this.fvar)
        return res;
      for (let instance of this.fvar.instance) {
        let settings = {};
        for (let i = 0; i < this.fvar.axis.length; i++) {
          let axis = this.fvar.axis[i];
          settings[axis.axisTag.trim()] = instance.coord[i];
        }
        res[instance.name.en] = settings;
      }
      return res;
    }
    /**
    * Returns a new font with the given variation settings applied.
    * Settings can either be an instance name, or an object containing
    * variation tags as specified by the `variationAxes` property.
    *
    * @param {object} settings
    * @return {TTFFont}
    */
    getVariation(settings) {
      if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2)))
        throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
      if (typeof settings === "string")
        settings = this.namedVariations[settings];
      if (typeof settings !== "object")
        throw new Error("Variation settings must be either a variation name or settings object.");
      let coords = this.fvar.axis.map((axis, i) => {
        let axisTag = axis.axisTag.trim();
        if (axisTag in settings)
          return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
        else
          return axis.defaultValue;
      });
      let stream2 = new DecodeStream2(this.stream.buffer);
      stream2.pos = this._directoryPos;
      let font = new _$4c1709dee528ea76$export$2e2bcd8739ae039(stream2, coords);
      font._tables = this._tables;
      return font;
    }
    get _variationProcessor() {
      if (!this.fvar)
        return null;
      let variationCoords = this.variationCoords;
      if (!variationCoords && !this.CFF2)
        return null;
      if (!variationCoords)
        variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
      return new (0, $0bb840cac04e911b$export$2e2bcd8739ae039)(this, variationCoords);
    }
    // Standardized format plugin API
    getFont(name) {
      return this.getVariation(name);
    }
    constructor(stream2, variationCoords = null) {
      (0, _defineProperty)(this, "type", "TTF");
      this.defaultLanguage = null;
      this.stream = stream2;
      this.variationCoords = variationCoords;
      this._directoryPos = this.stream.pos;
      this._tables = {};
      this._glyphs = {};
      this._decodeDirectory();
      for (let tag in this.directory.tables) {
        let table = this.directory.tables[tag];
        if ((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag] && table.length > 0)
          Object.defineProperty(this, tag, {
            get: this._getTable.bind(this, table)
          });
      }
    }
  };
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "bbox", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "characterSet", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "variationAxes", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "namedVariations", null);
  (0, __decorate2)([
    (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
  ], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
  var $c1726355ecc5b889$var$WOFFDirectoryEntry = new Struct({
    tag: new StringT(4),
    offset: new Pointer(uint32, "void", {
      type: "global"
    }),
    compLength: uint32,
    length: uint32,
    origChecksum: uint32
  });
  var $c1726355ecc5b889$var$WOFFDirectory = new Struct({
    tag: new StringT(4),
    flavor: uint32,
    length: uint32,
    numTables: uint16,
    reserved: new Reserved(uint16),
    totalSfntSize: uint32,
    majorVersion: uint16,
    minorVersion: uint16,
    metaOffset: uint32,
    metaLength: uint32,
    metaOrigLength: uint32,
    privOffset: uint32,
    privLength: uint32,
    tables: new ArrayT($c1726355ecc5b889$var$WOFFDirectoryEntry, "numTables")
  });
  $c1726355ecc5b889$var$WOFFDirectory.process = function() {
    let tables1 = {};
    for (let table of this.tables)
      tables1[table.tag] = table;
    this.tables = tables1;
  };
  var $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;
  var $760785214b9fc52c$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
    static probe(buffer) {
      return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOFF";
    }
    _decodeDirectory() {
      this.directory = (0, $c1726355ecc5b889$export$2e2bcd8739ae039).decode(this.stream, {
        _startOffset: 0
      });
    }
    _getTableStream(tag) {
      let table = this.directory.tables[tag];
      if (table) {
        this.stream.pos = table.offset;
        if (table.compLength < table.length) {
          this.stream.pos += 2;
          let outBuffer = new Uint8Array(table.length);
          let buf = (0, import_tiny_inflate.default)(this.stream.readBuffer(table.compLength - 2), outBuffer);
          return new DecodeStream2(buf);
        } else
          return this.stream;
      }
      return null;
    }
    constructor(...args) {
      super(...args);
      (0, _defineProperty)(this, "type", "WOFF");
    }
  };
  var $8046190c9f1ad19e$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
    _decode() {
      return this._font._transformedGlyphs[this.id];
    }
    _getCBox() {
      return this.path.bbox;
    }
    constructor(...args) {
      super(...args);
      (0, _defineProperty)(this, "type", "WOFF2");
    }
  };
  var $c28ec7bbb3b8de3a$var$Base128 = {
    decode(stream2) {
      let result = 0;
      let iterable = [
        0,
        1,
        2,
        3,
        4
      ];
      for (let j = 0; j < iterable.length; j++) {
        let i = iterable[j];
        let code = stream2.readUInt8();
        if (result & 3758096384)
          throw new Error("Overflow");
        result = result << 7 | code & 127;
        if ((code & 128) === 0)
          return result;
      }
      throw new Error("Bad base 128 number");
    }
  };
  var $c28ec7bbb3b8de3a$var$knownTags = [
    "cmap",
    "head",
    "hhea",
    "hmtx",
    "maxp",
    "name",
    "OS/2",
    "post",
    "cvt ",
    "fpgm",
    "glyf",
    "loca",
    "prep",
    "CFF ",
    "VORG",
    "EBDT",
    "EBLC",
    "gasp",
    "hdmx",
    "kern",
    "LTSH",
    "PCLT",
    "VDMX",
    "vhea",
    "vmtx",
    "BASE",
    "GDEF",
    "GPOS",
    "GSUB",
    "EBSC",
    "JSTF",
    "MATH",
    "CBDT",
    "CBLC",
    "COLR",
    "CPAL",
    "SVG ",
    "sbix",
    "acnt",
    "avar",
    "bdat",
    "bloc",
    "bsln",
    "cvar",
    "fdsc",
    "feat",
    "fmtx",
    "fvar",
    "gvar",
    "hsty",
    "just",
    "lcar",
    "mort",
    "morx",
    "opbd",
    "prop",
    "trak",
    "Zapf",
    "Silf",
    "Glat",
    "Gloc",
    "Feat",
    "Sill"
  ];
  var $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new Struct({
    flags: uint8,
    customTag: new Optional(new StringT(4), (t) => (t.flags & 63) === 63),
    tag: (t) => t.customTag || $c28ec7bbb3b8de3a$var$knownTags[t.flags & 63],
    length: $c28ec7bbb3b8de3a$var$Base128,
    transformVersion: (t) => t.flags >>> 6 & 3,
    transformed: (t) => t.tag === "glyf" || t.tag === "loca" ? t.transformVersion === 0 : t.transformVersion !== 0,
    transformLength: new Optional($c28ec7bbb3b8de3a$var$Base128, (t) => t.transformed)
  });
  var $c28ec7bbb3b8de3a$var$WOFF2Directory = new Struct({
    tag: new StringT(4),
    flavor: uint32,
    length: uint32,
    numTables: uint16,
    reserved: new Reserved(uint16),
    totalSfntSize: uint32,
    totalCompressedSize: uint32,
    majorVersion: uint16,
    minorVersion: uint16,
    metaOffset: uint32,
    metaLength: uint32,
    metaOrigLength: uint32,
    privOffset: uint32,
    privLength: uint32,
    tables: new ArrayT($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, "numTables")
  });
  $c28ec7bbb3b8de3a$var$WOFF2Directory.process = function() {
    let tables = {};
    for (let i = 0; i < this.tables.length; i++) {
      let table = this.tables[i];
      tables[table.tag] = table;
    }
    return this.tables = tables;
  };
  var $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;
  var $21ee218f84ac7f32$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
    static probe(buffer) {
      return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOF2";
    }
    _decodeDirectory() {
      this.directory = (0, $c28ec7bbb3b8de3a$export$2e2bcd8739ae039).decode(this.stream);
      this._dataPos = this.stream.pos;
    }
    _decompress() {
      if (!this._decompressed) {
        this.stream.pos = this._dataPos;
        let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
        let decompressedSize = 0;
        for (let tag in this.directory.tables) {
          let entry = this.directory.tables[tag];
          entry.offset = decompressedSize;
          decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
        }
        let decompressed = (0, import_decompress.default)(buffer, decompressedSize);
        if (!decompressed)
          throw new Error("Error decoding compressed data in WOFF2");
        this.stream = new DecodeStream2(decompressed);
        this._decompressed = true;
      }
    }
    _decodeTable(table) {
      this._decompress();
      return super._decodeTable(table);
    }
    // Override this method to get a glyph and return our
    // custom subclass if there is a glyf table.
    _getBaseGlyph(glyph, characters = []) {
      if (!this._glyphs[glyph]) {
        if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
          if (!this._transformedGlyphs)
            this._transformGlyfTable();
          return this._glyphs[glyph] = new (0, $8046190c9f1ad19e$export$2e2bcd8739ae039)(glyph, characters, this);
        } else
          return super._getBaseGlyph(glyph, characters);
      }
    }
    _transformGlyfTable() {
      this._decompress();
      this.stream.pos = this.directory.tables.glyf.offset;
      let table = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);
      let glyphs = [];
      for (let index = 0; index < table.numGlyphs; index++) {
        let glyph = {};
        let nContours = table.nContours.readInt16BE();
        glyph.numberOfContours = nContours;
        if (nContours > 0) {
          let nPoints = [];
          let totalPoints = 0;
          for (let i = 0; i < nContours; i++) {
            let r1 = $21ee218f84ac7f32$var$read255UInt16(table.nPoints);
            totalPoints += r1;
            nPoints.push(totalPoints);
          }
          glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table.flags, table.glyphs, totalPoints);
          for (let i1 = 0; i1 < nContours; i1++)
            glyph.points[nPoints[i1] - 1].endContour = true;
          var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
        } else if (nContours < 0) {
          let haveInstructions = (0, $69aac16029968692$export$2e2bcd8739ae039).prototype._decodeComposite.call({
            _font: this
          }, glyph, table.composites);
          if (haveInstructions)
            var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
        }
        glyphs.push(glyph);
      }
      this._transformedGlyphs = glyphs;
    }
    constructor(...args) {
      super(...args);
      (0, _defineProperty)(this, "type", "WOFF2");
    }
  };
  var $21ee218f84ac7f32$var$Substream = class {
    decode(stream2, parent) {
      return new DecodeStream2(this._buf.decode(stream2, parent));
    }
    constructor(length) {
      this.length = length;
      this._buf = new BufferT(length);
    }
  };
  var $21ee218f84ac7f32$var$GlyfTable = new Struct({
    version: uint32,
    numGlyphs: uint16,
    indexFormat: uint16,
    nContourStreamSize: uint32,
    nPointsStreamSize: uint32,
    flagStreamSize: uint32,
    glyphStreamSize: uint32,
    compositeStreamSize: uint32,
    bboxStreamSize: uint32,
    instructionStreamSize: uint32,
    nContours: new $21ee218f84ac7f32$var$Substream("nContourStreamSize"),
    nPoints: new $21ee218f84ac7f32$var$Substream("nPointsStreamSize"),
    flags: new $21ee218f84ac7f32$var$Substream("flagStreamSize"),
    glyphs: new $21ee218f84ac7f32$var$Substream("glyphStreamSize"),
    composites: new $21ee218f84ac7f32$var$Substream("compositeStreamSize"),
    bboxes: new $21ee218f84ac7f32$var$Substream("bboxStreamSize"),
    instructions: new $21ee218f84ac7f32$var$Substream("instructionStreamSize")
  });
  var $21ee218f84ac7f32$var$WORD_CODE = 253;
  var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;
  var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;
  var $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;
  function $21ee218f84ac7f32$var$read255UInt16(stream2) {
    let code = stream2.readUInt8();
    if (code === $21ee218f84ac7f32$var$WORD_CODE)
      return stream2.readUInt16BE();
    if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1)
      return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;
    if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2)
      return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;
    return code;
  }
  function $21ee218f84ac7f32$var$withSign(flag3, baseval) {
    return flag3 & 1 ? baseval : -baseval;
  }
  function $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {
    let y;
    let x = y = 0;
    let res = [];
    for (let i = 0; i < nPoints; i++) {
      let dx = 0, dy = 0;
      let flag3 = flags.readUInt8();
      let onCurve = !(flag3 >> 7);
      flag3 &= 127;
      if (flag3 < 10) {
        dx = 0;
        dy = $21ee218f84ac7f32$var$withSign(flag3, ((flag3 & 14) << 7) + glyphs.readUInt8());
      } else if (flag3 < 20) {
        dx = $21ee218f84ac7f32$var$withSign(flag3, ((flag3 - 10 & 14) << 7) + glyphs.readUInt8());
        dy = 0;
      } else if (flag3 < 84) {
        var b0 = flag3 - 20;
        var b1 = glyphs.readUInt8();
        dx = $21ee218f84ac7f32$var$withSign(flag3, 1 + (b0 & 48) + (b1 >> 4));
        dy = $21ee218f84ac7f32$var$withSign(flag3 >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
      } else if (flag3 < 120) {
        var b0 = flag3 - 84;
        dx = $21ee218f84ac7f32$var$withSign(flag3, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
        dy = $21ee218f84ac7f32$var$withSign(flag3 >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
      } else if (flag3 < 124) {
        var b1 = glyphs.readUInt8();
        let b2 = glyphs.readUInt8();
        dx = $21ee218f84ac7f32$var$withSign(flag3, (b1 << 4) + (b2 >> 4));
        dy = $21ee218f84ac7f32$var$withSign(flag3 >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
      } else {
        dx = $21ee218f84ac7f32$var$withSign(flag3, glyphs.readUInt16BE());
        dy = $21ee218f84ac7f32$var$withSign(flag3 >> 1, glyphs.readUInt16BE());
      }
      x += dx;
      y += dy;
      res.push(new (0, $69aac16029968692$export$baf26146a414f24a)(onCurve, false, x, y));
    }
    return res;
  }
  var $cd5853a56c68fec7$var$TTCHeader = new VersionedStruct(uint32, {
    65536: {
      numFonts: uint32,
      offsets: new ArrayT(uint32, "numFonts")
    },
    131072: {
      numFonts: uint32,
      offsets: new ArrayT(uint32, "numFonts"),
      dsigTag: uint32,
      dsigLength: uint32,
      dsigOffset: uint32
    }
  });
  var $cd5853a56c68fec7$export$2e2bcd8739ae039 = class {
    static probe(buffer) {
      return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "ttcf";
    }
    getFont(name) {
      for (let offset of this.header.offsets) {
        let stream2 = new DecodeStream2(this.stream.buffer);
        stream2.pos = offset;
        let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
        if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v, i) => name[i] === v))
          return font;
      }
      return null;
    }
    get fonts() {
      let fonts = [];
      for (let offset of this.header.offsets) {
        let stream2 = new DecodeStream2(this.stream.buffer);
        stream2.pos = offset;
        fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
      }
      return fonts;
    }
    constructor(stream2) {
      (0, _defineProperty)(this, "type", "TTC");
      this.stream = stream2;
      if (stream2.readString(4) !== "ttcf")
        throw new Error("Not a TrueType collection");
      this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream2);
    }
  };
  var $05f49f930186144e$var$DFontName = new StringT(uint8);
  var $05f49f930186144e$var$DFontData = new Struct({
    len: uint32,
    buf: new BufferT("len")
  });
  var $05f49f930186144e$var$Ref = new Struct({
    id: uint16,
    nameOffset: int16,
    attr: uint8,
    dataOffset: uint24,
    handle: uint32
  });
  var $05f49f930186144e$var$Type = new Struct({
    name: new StringT(4),
    maxTypeIndex: uint16,
    refList: new Pointer(uint16, new ArrayT($05f49f930186144e$var$Ref, (t) => t.maxTypeIndex + 1), {
      type: "parent"
    })
  });
  var $05f49f930186144e$var$TypeList = new Struct({
    length: uint16,
    types: new ArrayT($05f49f930186144e$var$Type, (t) => t.length + 1)
  });
  var $05f49f930186144e$var$DFontMap = new Struct({
    reserved: new Reserved(uint8, 24),
    typeList: new Pointer(uint16, $05f49f930186144e$var$TypeList),
    nameListOffset: new Pointer(uint16, "void")
  });
  var $05f49f930186144e$var$DFontHeader = new Struct({
    dataOffset: uint32,
    map: new Pointer(uint32, $05f49f930186144e$var$DFontMap),
    dataLength: uint32,
    mapLength: uint32
  });
  var $05f49f930186144e$export$2e2bcd8739ae039 = class {
    static probe(buffer) {
      let stream2 = new DecodeStream2(buffer);
      try {
        var header = $05f49f930186144e$var$DFontHeader.decode(stream2);
      } catch (e) {
        return false;
      }
      for (let type of header.map.typeList.types) {
        if (type.name === "sfnt")
          return true;
      }
      return false;
    }
    getFont(name) {
      if (!this.sfnt)
        return null;
      for (let ref of this.sfnt.refList) {
        let pos = this.header.dataOffset + ref.dataOffset + 4;
        let stream2 = new DecodeStream2(this.stream.buffer.slice(pos));
        let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
        if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v, i) => name[i] === v))
          return font;
      }
      return null;
    }
    get fonts() {
      let fonts = [];
      for (let ref of this.sfnt.refList) {
        let pos = this.header.dataOffset + ref.dataOffset + 4;
        let stream2 = new DecodeStream2(this.stream.buffer.slice(pos));
        fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
      }
      return fonts;
    }
    constructor(stream2) {
      (0, _defineProperty)(this, "type", "DFont");
      this.stream = stream2;
      this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);
      for (let type of this.header.map.typeList.types) {
        for (let ref of type.refList)
          if (ref.nameOffset >= 0) {
            this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
            ref.name = $05f49f930186144e$var$DFontName.decode(this.stream);
          } else
            ref.name = null;
        if (type.name === "sfnt")
          this.sfnt = type;
      }
    }
  };
  (0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $4c1709dee528ea76$export$2e2bcd8739ae039));
  (0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $760785214b9fc52c$export$2e2bcd8739ae039));
  (0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $21ee218f84ac7f32$export$2e2bcd8739ae039));
  (0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $cd5853a56c68fec7$export$2e2bcd8739ae039));
  (0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $05f49f930186144e$export$2e2bcd8739ae039));

  // node_modules/@pdfme/common/dist/esm/src/constants.js
  var DEFAULT_FONT_NAME = "Roboto";
  var DEFAULT_FONT_SIZE = 13;
  var DEFAULT_ALIGNMENT = "left";
  var DEFAULT_LINE_HEIGHT = 1;
  var DEFAULT_CHARACTER_SPACING = 0;
  var DEFAULT_FONT_COLOR = "#000";
  var DEFAULT_TOLERANCE = 1;
  var DEFAULT_FONT_SIZE_ADJUSTMENT = 0.25;
  var DEFAULT_PT_TO_MM_RATIO = 0.3528;
  var BLANK_PDF = "data:application/pdf;base64,JVBERi0xLjcKJeLjz9MKNSAwIG9iago8PAovRmlsdGVyIC9GbGF0ZURlY29kZQovTGVuZ3RoIDM4Cj4+CnN0cmVhbQp4nCvkMlAwUDC1NNUzMVGwMDHUszRSKErlCtfiyuMK5AIAXQ8GCgplbmRzdHJlYW0KZW5kb2JqCjQgMCBvYmoKPDwKL1R5cGUgL1BhZ2UKL01lZGlhQm94IFswIDAgNTk1LjQ0IDg0MS45Ml0KL1Jlc291cmNlcyA8PAo+PgovQ29udGVudHMgNSAwIFIKL1BhcmVudCAyIDAgUgo+PgplbmRvYmoKMiAwIG9iago8PAovVHlwZSAvUGFnZXMKL0tpZHMgWzQgMCBSXQovQ291bnQgMQo+PgplbmRvYmoKMSAwIG9iago8PAovVHlwZSAvQ2F0YWxvZwovUGFnZXMgMiAwIFIKPj4KZW5kb2JqCjMgMCBvYmoKPDwKL3RyYXBwZWQgKGZhbHNlKQovQ3JlYXRvciAoU2VyaWYgQWZmaW5pdHkgRGVzaWduZXIgMS4xMC40KQovVGl0bGUgKFVudGl0bGVkLnBkZikKL0NyZWF0aW9uRGF0ZSAoRDoyMDIyMDEwNjE0MDg1OCswOScwMCcpCi9Qcm9kdWNlciAoaUxvdmVQREYpCi9Nb2REYXRlIChEOjIwMjIwMTA2MDUwOTA5WikKPj4KZW5kb2JqCjYgMCBvYmoKPDwKL1NpemUgNwovUm9vdCAxIDAgUgovSW5mbyAzIDAgUgovSUQgWzwyODhCM0VENTAyOEU0MDcyNERBNzNCOUE0Nzk4OUEwQT4gPEY1RkJGNjg4NkVERDZBQUNBNDRCNEZDRjBBRDUxRDlDPl0KL1R5cGUgL1hSZWYKL1cgWzEgMiAyXQovRmlsdGVyIC9GbGF0ZURlY29kZQovSW5kZXggWzAgN10KL0xlbmd0aCAzNgo+PgpzdHJlYW0KeJxjYGD4/5+RUZmBgZHhFZBgDAGxakAEP5BgEmFgAABlRwQJCmVuZHN0cmVhbQplbmRvYmoKc3RhcnR4cmVmCjUzMgolJUVPRgo=";
  var DEFAULT_FONT_VALUE = "data:font/ttf;base64,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G7EDGj5ZsCfcMDEA//8Aev/sBNwHGQImACsAAAEHAKIBpQFXABQAsABFWLALLxuxCx4+WbEnBPQwMf//AGD+VgPyBcICJgBLAAABBwCiATIAAAAUALAARViwAy8bsQMaPlmxLAH0MDH//wB6/fYE3AXEAiYAKwAAAAcBugHa/pf//wBg/lYD8gaTAiYASwAAAQcBzwErAFgAEwCwAEVYsAMvG7EDGj5ZsCrcMDEA//8AqQAABQgHQgImACwAAAEHAJ4A8QFCABQAsABFWLAHLxuxBx4+WbEQBvQwMf//AIwAAAPfB0ECJgBMAAABBwCeAB0BQQAJALARL7AU3DAxAP///7cAAAJ6By4CJgAtAAABBwCl/zwBRgAUALAARViwAy8bsQMePlmxBwT0MDH///+dAAACYAXqAiYAjQAAAQcApf8iAAIAFACwAEVYsAMvG7EDGj5ZsQcB9DAx////zAAAAmwG7wImAC0AAAEHAHD/PgFKABMAsABFWLACLxuxAh4+WbAF3DAxAP///7IAAAJSBasCJgCNAAABBwBw/yQABgATALAARViwAi8bsQIaPlmwBdwwMQD////sAAACQwcaAiYALQAAAQcAof9rAUMAEwCwAEVYsAIvG7ECHj5ZsAfcMDEA////0gAAAikF1wImAI0AAAEHAKH/UQAAABMAsABFWLACLxuxAho+WbAH3DAxAP//ABj+WAF4BbACJgAtAAAABgCk5gn////7/k8BaAXEAiYATQAAAAYApMkA//8AqQAAAYQHBAImAC0AAAEHAKIAHAFCABQAsABFWLACLxuxAh4+WbELBPQwMf//ALf/7AX5BbAAJgAtAAAABwAuAi0AAP//AI3+SwNKBcQAJgBNAAAABwBOAfEAAP//ADX/7ASCBzUCJgAuAAABBwCeAXwBNQAUALAARViwAC8bsQAePlmxFAb0MDH///+0/ksCOQXYAiYAnAAAAQcAnv8z/9gAFACwAEVYsA0vG7ENGj5ZsRIE9DAx//8Aqf5YBQUFsAImAC8AAAAHAboBlP75//8Ajf5FBAwGAAImAE8AAAAHAboBEf7m//8AoQAABBwHMQImADAAAAEHAHUAJgExABQAsABFWLAFLxuxBR4+WbEICPQwMf//AJMAAAI0B5YCJgBQAAABBwB1ABgBlgAUALAARViwAy8bsQMgPlmxBgn0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AHUBhwE2ABQAsABFWLAHLxuxBx4+WbEMCPQwMf//AFgAAAOzBgACJgBeAAABBwB1ASEAAAAUALAARViwBy8bsQcaPlmxDAn0MDH//wBWAAAEegb4AiYAPgAAAQcAogFuATYAFACwAEVYsAcvG7EHHj5ZsREE9DAx//8AWAAAA7MFwgImAF4AAAEHAKIBCAAAABQAsABFWLAHLxuxBxo+WbERAfQwMf//AFYAAAR6BzYCJgA+AAABBwCfAKYBNwAUALAARViwBy8bsQcePlmxDwb0MDH//wBYAAADswYAAiYAXgAAAQYAn0ABABQAsABFWLAHLxuxBxo+WbEPAfQwMf////IAAAdXB0ICJgCBAAABBwB1AskBQgAUALAARViwBi8bsQYePlmxFQj0MDH//wBO/+wGfAYBAiYAhgAAAQcAdQJ6AAEAFACwAEVYsB0vG7EdGj5ZsUAJ9DAx//8Adv+jBR0HgAImAIMAAAEHAHUB6QGAABQAsABFWLAQLxuxEB4+WbEsCPQwMf//AFv/egQ0BgACJgCJAAABBwB1ATcAAAAUALAARViwBC8bsQQaPlmxKQn0MDH//wAcAAAFHQY/AiYAJQAAAAYArgQA////KQAABEYGPwImACkAAAAHAK7+cgAA////NwAABQgGQQImACwAAAAHAK7+gAAC////PQAAAXcGQAImAC0AAAAHAK7+hgAB////5v/sBR0GPwAmADMUAAAHAK7/LwAA////FAAABR8GPwAmAD1kAAAHAK7+XQAA////6QAABN8GPwAmALoUAAAHAK7/MgAA////m//0Aq0GdAImAMMAAAEHAK//Kv/sAB0AsABFWLAMLxuxDBo+WbEYAfSwD9CwGBCwIdAwMQD//wAcAAAFHQWwAgYAJQAA//8AqQAABIgFsAIGACYAAP//AKkAAARGBbACBgApAAD//wBWAAAEegWwAgYAPgAA//8AqQAABQgFsAIGACwAAP//ALcAAAF3BbACBgAtAAD//wCpAAAFBQWwAgYALwAA//8AqQAABlIFsAIGADEAAP//AKkAAAUIBbACBgAyAAD//wB2/+wFCQXEAgYAMwAA//8AqQAABMAFsAIGADQAAP//ADEAAASXBbACBgA4AAD//wAPAAAEuwWwAgYAPQAA//8AOQAABM4FsAIGADwAAP///9UAAAJeBwcCJgAt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BH4AZAHwAIYBsQApBBEASARkAJgELgCGA8cASwcvAGoFOAAcBPsAqQU1AHcFPwCpBIwAqQRsAKkFcwB6BbQAqQItALcEagA1BQQAqQROAKkG/ACpBbQAqQWAAHYFDACpBYAAbQTtAKgEvwBQBMYAMQUwAIwFFwAcBxkAPQUEADkEzgAPBMoAVgIfAJIDSAAoAh8ACQNYAEADnAAEAnkAOQRaAG0EfQCMBDAAXASDAF8EPQBdAscAPAR9AGAEaACMAfEAjQHp/78EDgCNAfEAnAcDAIsEagCMBJAAWwR9AIwEjABfArUAjAQgAF8CnQAJBGkAiAPgACEGAwArA/cAKQPJABYD9wBYArUAQAHzAK8CtQATBXEAgwHzAIsEYABpBKYAWwW0AGkEMwAPAesAkwToAFoDWABlBkkAWwOTAJMDwQBmBG4AfwZKAFoDqgCOAv0AggRGAGEC7wBCAu8APgKCAHsEiACaA+kAQwIWAJMB+wB0Au8AegOjAHoDwABmBdwAVQY1AFAGOQBvA8kARAd6//IERABZBYAAdgS6AKYEwgCLBsEATgSwAH4EkQBHBIgAWwScAJUExwBfBZoAHQH6AJsEcwCaBE8AIgIpACIFiwCiBIgAkQehAGgHRABhAfwAoAWHAF0Cuf/kBX4AZQSSAFsFkACMBPMAiAID/7QENwBiA8QAqQONAI0DqwCOA2oAgQHxAI0CrQB5AioAMgPGAHsC/ABeAloAfgAA/KcAAP1vAAD8iwAA/V4AAPwnAAD9OAINALcECwBxAhcAkwRzALEFpAAfBXEAZwU+ADIEkQB4BbUAsgSRAEUFuwBNBYkAWgVSAHEEhQBkBL0AoAQCAC4EiABgBFAAYwQlAG0EiACRBI4AegKXAMMEbgAlA+wAZQTEACkEiACRBE0AZQSIAGAELABRBF0AjwWjAFcFmgBfBpcAegShAHkEQv/aBkgASgX/ACoFZAB7CJEAMQikALEGggA+BbQAsAULAKIGBAAyB0MAGwS/AFAFtACxBakALwUHAE0GLABTBdkArwV6AJYHhwCwB8AAsAYSABAG6wCyBQUAowVkAJMHJwC3BRgAWQRsAGEEkgCdA1sAmgTUAC4GIAAVBBAAWASeAJwEUgCcBKAALAXvAJ0EnQCcBJ4AnAPYACgFzQBkBL0AnARZAGcGeACcBp4AkQT3AB4GNgCdBFgAnQRNAGQGhwCdBGQALwRo/+gETQBnBskAJwbkAJwEif/9BJ4AnAcIAJwGKwCBBFb/3AcrALcF+ACZBNIAKARGAA8HCwDJBgsAvAbRAJMF4QCWCQQAtgfRAJsEIwBQA9sATAVxAGcEiwBbBQoAFgQDAC4FcQBnBIgAWwcBAJwGJAB+BwgAnAYrAIEFMgB1BEcAZAT9AHQAAPxnAAD8cQAA/WYAAP2kAAD6GwAA+iwGCQCxBO0AnARW/9wFGwCoBIkAjARjAKIDkACRBNsAsQQFAJEHogAbBmEAFQWaALIEuACcBQkAowR+AJoGjABEBYMAPgX/AKkE2QCcB88AqAW0AJEIMQCwBvQAkQXuAHEE0wBtBRgAOQQqACkHLAA0BVwAHwW8AJYElgBnBW8AlgRqAIMFbwCJBi8APwS9/94FCQCjBFoAmgX+AC8E7wAsBbIAsQSIAJEGEgCpBOwAnAdPAKkGPgCdBYcAXQSoAGgEqABpBLcAOgOrADsFLgA5BEAAKQT2AFcGlABZBuQAZAZWADYFKwAxBEkAUgQHAHkHwQBEBnUAPwf7AKkGoQCQBPYAdgQdAGUFrQAjBSAARgVkAJYGAgAvBPIALAMgAG8EFAAACCkAAAQUAAAIKQAAArkAAAIKAAABXAAABH8AAAIwAAABogAAAQAAAADRAAAAAAAAAjQAJQI0ACUFQACiBj8AkAOlAA0BmQBgAZkAMAGXACQBmQBPAtQAaALbADwCwQAkBGkARgSPAFcCsgCKA8QAlAVaAJQBfgBSB6oARAJmAGwCZgBZA6MAOwLvADYDYAB6BKYAWwZVAB8GkACnCHYAqAXrAB8GKwCMBH4AXwXaAB8EIgAqBHQAIAVIAF0FTwAfBecAegPOAGgIOgCiBQEAZwUXAJgGJgBUBtcAZAbPAGMGagBZBI8AagWOAKkErwBFBJIAqATFAD8IOgBiAgz/sASCAGUEZACYBBEAPgQvAIUECAArAkwAtQKPAG4CAwBcBG4AHwSLADwG1AA8BtQAPAAAAAAIMwBbCDUAXALvAEIC7wB6Au8AUALvAD4C7wA2Au8AWwLvAFYC7wA6Au8ATwLvAEkDlgCPArUAngUkALIB/QCfA6QAgQAA/KQD7wBuA/P/XgQOAGkD9ABpA58AgQOeAIEC7wBQAu8ANgLvAFsC7wBWAu8AOgLvAE8C7wBJA6QAgwGRAGcB/P+2BH8AfgR/AHACBv+0AgT/tAH7AJsB+//6AfsAmwQgADsDeQBXAfsAAAI1ACUFXQAHBV0ABwSG/+IExgAxAp3/9AU4ABwFOAAcBTgAHAU4ABwFOAAcBTgAHAU4ABwFNQB3BIwAqQSMAKkEjACpBIwAqQIt/+ACLQCwAi3/6QIt/9UFtACpBYAAdgWAAHYFgAB2BYAAdgWAAHYFMACMBTAAjAUwAIwFMACMBM4ADwRaAG0EWgBtBFoAbQRaAG0EWgBtBFoAbQRaAG0EMABcBD0AXQQ9AF0EPQBdBD0AXQH6/8YB+gCWAfr/zwH6/7sEagCMBJAAWwSQAFsEkABbBJAAWwSQAFsEaQCIBGkAiARpAIgEaQCIA8kAFgPJABYFOAAcBFoAbQU4ABwEWgBtBTgAHARaAG0FNQB3BDAAXAU1AHcEMABcBTUAdwQwAFwFNQB3BDAAXAU/AKkFGQBfBIwAqQQ9AF0EjACpBD0AXQSMAKkEPQBdBIwAqQQ9AF0EjACpBD0AXQVzAHoEfQBgBXMAegR9AGAFcwB6BH0AYAVzAHoEfQBgBbQAqQRoAIwCLf+3Afr/nQIt/8wB+v+yAi3/7AH6/9ICLQAYAfH/+wItAKkGlwC3A9oAjQRqADUCA/+0BQQAqQQOAI0ETgChAfEAkwROAKkB8QBXBE4AqQKHAJwETgCpAs0AnAW0AKkEagCMBbQAqQRqAIwFtACpBGoAjARq/7wFgAB2BJAAWwWAAHYEkABbBYAAdgSQAFsE7QCoArUAjATtAKgCtQBTBO0AqAK1AGMEvwBQBCAAXwS/AFAEIABfBL8AUAQgAF8EvwBQBCAAXwS/AFAEIABfBMYAMQKdAAkExgAxAp0ACQTGADECxQAJBTAAjARpAIgFMACMBGkAiAUwAIwEaQCIBTAAjARpAIgFMACMBGkAiAUwAIwEaQCIBxkAPQYDACsEzgAPA8kAFgTOAA8EygBWA/cAWATKAFYD9wBYBMoAVgP3AFgHev/yBsEATgWAAHYEiABbBTgAHASM/ykFtP83Ai3/PQWU/+YFMv8UBWb/6QKX/5sFOAAcBPsAqQSMAKkEygBWBbQAqQItALcFBACpBvwAqQW0AKkFgAB2BQwAqQTGADEEzgAPBQQAOQIt/9UEzgAPBIUAZARQAGMEiACRApcAwwRdAI8EcwCaBJAAWwSIAJoD4AAhA/cAKQKX/+UEXQCPBJAAWwRdAI8GlwB6BIwAqQRzALEEvwBQAi0AtwIt/9UEagA1BSQAsgUEAKkFBwBNBTgAHAT7AKkEcwCxBIwAqQW0ALEG/ACpBbQAqQWAAHYFtQCyBQwAqQU1AHcExgAxBQQAOQRaAG0EPQBdBJ4AnASQAFsEfQCMBDAAXAPJABYD9wApBD0AXQNbAJoEIABfAfEAjQH6/7sB6f+/BFIAnAPJABYHGQA9BgMAKwcZAD0GAwArBxkAPQYDACsEzgAPA8kAFgFlAGcCjwCIBB4AoAID/7QBmQAwBvwAqQcDAIsFOAAcBFoAbQSMAKkFtACxBD0AXQSeAJwFiQBaBZoAXwUKABYEA//7CFkAWwlJAHYEvwBQBBAAWAU1AHcEMABcBM4ADwQCAC4CLQC3B0MAGwYgABUCLQC3BTgAHARaAG0FOAAcBFoAbQd6//IGwQBOBIwAqQQ9AF0FhwBdBDcAYgQ3AGIHQwAbBiAAFQS/AFAEEABYBbQAsQSeAJwFtACxBJ4AnAWAAHYEkABbBXEAZwSLAFsFcQBnBIsAWwVkAJMETQBkBQcATQPJABYFBwBNA8kAFgUHAE0DyQAWBXoAlgRZAGcG6wCyBjYAnQSDAF8FOAAcBFoAbQU4ABwEWgBtBTgAHARaAG0FOAAcBFr/ygU4ABwEWgBtBTgAHARaAG0FOAAcBFoAbQU4ABwEWgBtBTgAHARaAG0FOAAcBFoAbQU4ABwEWgBtBTgAHARaAG0EjACpBD0AXQSMAKkEPQBdBIwAqQQ9AF0EjACpBD0AXQSM//AEPf+6BIwAqQQ9AF0EjACpBD0AXQSMAKkEPQBdAi0AtwH6AJsCLQCjAfEAhQWAAHYEkABbBYAAdgSQAFsFgAB2BJAAWwWAAEcEkP/EBYAAdgSQAFsFgAB2BJAAWwWAAHYEkABbBX4AZQSSAFsFfgBlBJIAWwV+AGUEkgBbBX4AZQSSAFsFfgBlBJIAWwUwAIwEaQCIBTAAjARpAIgFkACMBPMAiAWQAIwE8wCIBZAAjATzAIgFkACMBPMAiAWQAIwE8wCIBM4ADwPJABYEzgAPA8kAFgTOAA8DyQAWBKEAXwTGADED2AAoBXoAlgRZAGcEcwCxA1sAmgYvAD8Evf/eBGgAjAUF/9QFBf/UBHMAAwNb//wFOP/3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AYcBiQCJAe0B7gCMAfAB8ACOAfICBwCPAgwCEwClAhUCGACtAh0CIgCxAicCLwC3AjECMQDAAjMCMwDBAjUCNQDCAjcCNwDDAjkCQgDEAksCTQDOAk8CTwDRAlECUQDSAlMCUwDTAlUCVQDUAloCWgDVAlwCXADWAl4CXgDXAmACYADYAmICYgDZAmQCcADaAnICcgDnAnQCdADoAnYCdgDpAoECgQDqAoMCgwDrAoUChQDsApMCkwDtApUCmADuApoCmgDyApwCnADzAqICpwD0AqoCuQD6ArwCvAEKAsACwAELAsICwgEMAsYCxgENAskCygEOAswCzQEQAs8C1QESAtcC2QEZAtsC4AEcAuIC4wEiAuUC6AEkAu4C7wEoAvEC8QEqAvMC8wErAvUC+AEsAvsDAAEwAwIDAgE2AwYDBwE3AwwDDAE5Aw4DFwE6AxoDGwFEAx0DIAFGAycDKAFKAywDLAFMAy4DNAFNAzoDYgFUA2QDZAF9A2YDcwF+A3sDewGMA4wDkQGNA5MDkwGTA5cDmAGUA5sDmwGWA50DngGXA6ADoAGZA6IDogGaA7MDtwGbA7kDuQGgA7sDvAGhA74DvgGjA8IDxAGkA8YDxgGnA8gDygGoA8wDzAGrA84DzgGsA9AD1gGtA9gD2AG0A9sD2wG1A94D4gG2A+QD5AG7A+YD5gG8AAsAOP/YANL/2ADW/9gBOf/YAUX/2AKB/9gCg//YAoX/2ALd/9gDk//YA9v/2AAYADoAFAA7ABIAPQAWARkAFAIMABYCkwASApUAFgKXABYCpwAWArYAFgK5ABYC7wASAvEAEgLzABIC9QAWAwYAFAMOABYDjAAWA44AFgOQABYDogAWA94AFAPgABQD4gASAAEAE/8gANcAEP8WABL/FgAl/1YALv74ADgAFABF/94AR//rAEj/6wBJ/+sAS//rAFP/6wBV/+sAVv/mAFn/6gBa/+gAXf/oAJT/6wCZ/+sAm//qALL/VgC0/1YAu//rAL3/6ADI/+sAyf/rAMv/6gDSABQA1gAUAPf/6wED/+sBDf9WARj/6wEa/+gBHv/rASL/6wE5ABQBQv/rAUUAFAFg/+sBYf/rAWv/6wGG/xYBiv8WAY7/FgGP/xYB8v9WAfP/VgH0/1YB9f9WAfb/VgH3/1YB+P9WAg3/3gIO/94CD//eAhD/3gIR/94CEv/eAhP/3gIU/+sCFf/rAhb/6wIX/+sCGP/rAh7/6wIf/+sCIP/rAiH/6wIi/+sCI//qAiT/6gIl/+oCJv/qAif/6AIo/+gCKf9WAir/3gIr/1YCLP/eAi3/VgIu/94CMP/rAjL/6wI0/+sCNv/rAjj/6wI6/+sCPP/rAj7/6wJA/+sCQv/rAkT/6wJG/+sCSP/rAkr/6wJY/vgCbP/rAm7/6wJw/+sCgQAUAoMAFAKFABQCiP/qAor/6gKM/+oCjv/qApD/6gKS/+oClv/oAqL/VgKq/1YCuv/rAr7/6gLA/+sCwv/oAsX/6gLG/+sCx//qAs7++ALS/1YC3QAUAt//3gLg/+sC4v/rAuT/6wLl/+gC5//rAu7/6AL2/+gC/v9WAv//3gMC/+sDB//oAwj/6wMN/+sDD//oAxT/VgMV/94DFv9WAxf/3gMb/+sDHf/rAx7/6wMo/+sDKv/rAyz/6wMw/+gDMv/oAzT/6AM5/+sDOv9WAzv/3gM8/1YDPf/eAz7/VgM//94DQP9WA0H/3gNC/1YDQ//eA0T/VgNF/94DRv9WA0f/3gNI/1YDSf/eA0r/VgNL/94DTP9WA03/3gNO/1YDT//eA1D/VgNR/94DU//rA1X/6wNX/+sDWf/rA1v/6wNd/+sDX//rA2H/6wNn/+sDaf/rA2v/6wNt/+sDb//rA3H/6wNz/+sDdf/rA3f/6wN5/+sDe//rA33/6wN//+oDgf/qA4P/6gOF/+oDh//qA4n/6gOL/+oDjf/oA4//6AOR/+gDkwAUA7X/VgO2/94DuP/rA7z/6wPA/+oDxf/rA8f/6wPbABQD3//oA+H/6AAjADj/1QA6/+QAO//sAD3/3QDS/9UA1v/VARn/5AE5/9UBRf/VAgz/3QKB/9UCg//VAoX/1QKT/+wClf/dApf/3QKn/90Ctv/dArn/3QLd/9UC7//sAvH/7ALz/+wC9f/dAwb/5AMO/90DjP/dA47/3QOQ/90Dk//VA6L/3QPb/9UD3v/kA+D/5APi/+wAHQA4/7AAOv/tAD3/0ADS/7AA1v+wARn/7QE5/7ABRf+wAgz/0AKB/7ACg/+wAoX/sAKV/9ACl//QAqf/0AK2/9ACuf/QAt3/sAL1/9ADBv/tAw7/0AOM/9ADjv/QA5D/0AOT/7ADov/QA9v/sAPe/+0D4P/tABEALv/uADn/7gII/+4CCf/uAgr/7gIL/+4CWP/uAof/7gKJ/+4Ci//uAo3/7gKP/+4Ckf/uAs7/7gN+/+4DgP/uA93/7gBNAAYAEAALABAADQAUAEEAEgBH/+gASP/oAEn/6ABL/+gAVf/oAGEAEwCU/+gAmf/oALv/6ADI/+gAyf/oAPf/6AED/+gBHv/oASL/6AFC/+gBYP/oAWH/6AFr/+gBhAAQAYUAEAGHABABiAAQAYkAEAIU/+gCFf/oAhb/6AIX/+gCGP/oAjD/6AIy/+gCNP/oAjb/6AI4/+gCOv/oAjz/6AI+/+gCQP/oAkL/6AJE/+gCRv/oAkj/6AJK/+gCuv/oAuD/6ALk/+gC5//oAvcAEAL4ABAC+wAQAwL/6AMI/+gDDf/oAxv/6AMd/+gDHv/oAyr/6AM5/+gDU//oA1X/6ANX/+gDWf/oA1v/6ANd/+gDX//oA2H/6AN1/+gDd//oA3n/6AN9/+gDuP/oA8X/6APH/+gAQABH/+wASP/sAEn/7ABL/+wAVf/sAJT/7ACZ/+wAu//sAMj/7ADJ/+wA9//sAQP/7AEe/+wBIv/sAUL/7AFg/+wBYf/sAWv/7AIU/+wCFf/sAhb/7AIX/+wCGP/sAjD/7AIy/+wCNP/sAjb/7AI4/+wCOv/sAjz/7AI+/+wCQP/sAkL/7AJE/+wCRv/sAkj/7AJK/+wCuv/sAuD/7ALk/+wC5//sAwL/7AMI/+wDDf/sAxv/7AMd/+wDHv/sAyr/7AM5/+wDU//sA1X/7ANX/+wDWf/sA1v/7ANd/+wDX//sA2H/7AN1/+wDd//sA3n/7AN9/+wDuP/sA8X/7APH/+wAGABT/+wBGP/sAh7/7AIf/+wCIP/sAiH/7AIi/+wCbP/sAm7/7AJw/+wCwP/sAsb/7ALi/+wDKP/sAyz/7ANn/+wDaf/sA2v/7ANt/+wDb//sA3H/7ANz/+wDe//sA7z/7AAGABD/hAAS/4QBhv+EAYr/hAGO/4QBj/+EABEALv/sADn/7AII/+wCCf/sAgr/7AIL/+wCWP/sAof/7AKJ/+wCi//sAo3/7AKP/+wCkf/sAs7/7AN+/+wDgP/sA93/7AAgAAb/8gAL//IAWv/zAF3/8wC9//MA9v/1ARr/8wGE//IBhf/yAYf/8gGI//IBif/yAif/8wIo//MClv/zAsL/8wLl//MC7v/zAvb/8wL3//IC+P/yAvv/8gMH//MDD//zAzD/8wMy//MDNP/zA43/8wOP//MDkf/zA9//8wPh//MAOwAn//MAK//zADP/8wA1//MAg//zAJP/8wCY//MAs//zAMQADQDT//MBCP/zARf/8wEb//MBHf/zAR//8wEh//MBQf/zAWr/8wH5//MCA//zAgT/8wIF//MCBv/zAgf/8wIv//MCMf/zAjP/8wI1//MCQ//zAkX/8wJH//MCSf/zAmv/8wJt//MCb//zAqD/8wKm//MCs//zAtn/8wLc//MDCf/zAwz/8wMn//MDKf/zAyv/8wNm//MDaP/zA2r/8wNs//MDbv/zA3D/8wNy//MDdP/zA3b/8wN4//MDev/zA3z/8wO7//MD1P/zADwAJ//mACv/5gAz/+YANf/mAIP/5gCT/+YAmP/mALP/5gC4/8IAxAAQANP/5gEI/+YBF//mARv/5gEd/+YBH//mASH/5gFB/+YBav/mAfn/5gID/+YCBP/mAgX/5gIG/+YCB//mAi//5gIx/+YCM//mAjX/5gJD/+YCRf/mAkf/5gJJ/+YCa//mAm3/5gJv/+YCoP/mAqb/5gKz/+YC2f/mAtz/5gMJ/+YDDP/mAyf/5gMp/+YDK//mA2b/5gNo/+YDav/mA2z/5gNu/+YDcP/mA3L/5gN0/+YDdv/mA3j/5gN6/+YDfP/mA7v/5gPU/+YAOAAl/+QAPP/SAD3/0wCy/+QAtP/kAMT/4gDa/9IBDf/kATP/0gFD/9IBXf/SAfL/5AHz/+QB9P/kAfX/5AH2/+QB9//kAfj/5AIM/9MCKf/kAiv/5AIt/+QClf/TApf/0wKi/+QCp//TAqr/5AK2/9MCt//SArn/0wLS/+QC3v/SAvX/0wL+/+QDDv/TAxH/0gMU/+QDFv/kAx//0gM6/+QDPP/kAz7/5ANA/+QDQv/kA0T/5ANG/+QDSP/kA0r/5ANM/+QDTv/kA1D/5AOM/9MDjv/TA5D/0wOi/9MDtf/kACgAEP8eABL/HgAl/80Asv/NALT/zQDH//IBDf/NAYb/HgGK/x4Bjv8eAY//HgHy/80B8//NAfT/zQH1/80B9v/NAff/zQH4/80CKf/NAiv/zQIt/80Cov/NAqr/zQLS/80C/v/NAxT/zQMW/80DOv/NAzz/zQM+/80DQP/NA0L/zQNE/80DRv/NA0j/zQNK/80DTP/NA07/zQNQ/80Dtf/NAAEAxAAOAAIAyv/tAPb/wAC6AEf/3ABI/9wASf/cAEv/3ABR//MAUv/zAFP/1gBU//MAVf/cAFn/3QBa/+EAXf/hAJT/3ACZ/9wAm//dALv/3AC9/+EAvv/uAL//5gDB//MAwv/rAMP/6QDF//AAxv/nAMj/3ADJ/9wAyv/jAMv/3QDM/84Azf/UAM7/2wDs//MA8P/zAPH/8wDz//MA9P/zAPX/8wD3/9wA+P/zAPr/8wD7//MA/v/zAQD/8wED/9wBBf/zARj/1gEa/+EBHv/cASL/3AEr//MBNv/zATz/8wE+//MBQv/cAVP/8wFV//MBV//zAVz/8wFg/9wBYf/cAWv/3AIU/9wCFf/cAhb/3AIX/9wCGP/cAh3/8wIe/9YCH//WAiD/1gIh/9YCIv/WAiP/3QIk/90CJf/dAib/3QIn/+ECKP/hAjD/3AIy/9wCNP/cAjb/3AI4/9wCOv/cAjz/3AI+/9wCQP/cAkL/3AJE/9wCRv/cAkj/3AJK/9wCZf/zAmf/8wJp//MCav/zAmz/1gJu/9YCcP/WAoj/3QKK/90CjP/dAo7/3QKQ/90Ckv/dApb/4QK6/9wCvP/zAr7/3QLA/9YCwv/hAsX/3QLG/9YCx//dAuD/3ALh//MC4v/WAuP/8wLk/9wC5f/hAuf/3ALo//MC7f/zAu7/4QL2/+EC/f/zAwL/3AMD//MDB//hAwj/3AMN/9wDD//hAxv/3AMd/9wDHv/cAyT/8wMm//MDKP/WAyr/3AMs/9YDMP/hAzL/4QM0/+EDOP/zAzn/3ANT/9wDVf/cA1f/3ANZ/9wDW//cA13/3ANf/9wDYf/cA2f/1gNp/9YDa//WA23/1gNv/9YDcf/WA3P/1gN1/9wDd//cA3n/3AN7/9YDff/cA3//3QOB/90Dg//dA4X/3QOH/90Dif/dA4v/3QON/+EDj//hA5H/4QOY//MDtP/zA7j/3AO8/9YDwP/dA8X/3APH/9wD0f/zA9P/8wPf/+ED4f/hAHwABv/aAAv/2gBH//AASP/wAEn/8ABL//AAVf/wAFn/7wBa/9wAXf/cAJT/8ACZ//AAm//vALv/8AC9/9wAwv/sAMQADwDG/+oAyP/wAMn/8ADK/8QAy//vAMz/5wD3//ABA//wARr/3AEe//ABIv/wAUL/8AFg//ABYf/wAWv/8AGE/9oBhf/aAYf/2gGI/9oBif/aAhT/8AIV//ACFv/wAhf/8AIY//ACI//vAiT/7wIl/+8CJv/vAif/3AIo/9wCMP/wAjL/8AI0//ACNv/wAjj/8AI6//ACPP/wAj7/8AJA//ACQv/wAkT/8AJG//ACSP/wAkr/8AKI/+8Civ/vAoz/7wKO/+8CkP/vApL/7wKW/9wCuv/wAr7/7wLC/9wCxf/vAsf/7wLg//AC5P/wAuX/3ALn//AC7v/cAvb/3AL3/9oC+P/aAvv/2gMC//ADB//cAwj/8AMN//ADD//cAxv/8AMd//ADHv/wAyr/8AMw/9wDMv/cAzT/3AM5//ADU//wA1X/8ANX//ADWf/wA1v/8ANd//ADX//wA2H/8AN1//ADd//wA3n/8AN9//ADf//vA4H/7wOD/+8Dhf/vA4f/7wOJ/+8Di//vA43/3AOP/9wDkf/cA7j/8APA/+8Dxf/wA8f/8APf/9wD4f/cADwABv+gAAv/oABK/+kAWf/xAFr/xQBd/8UAm//xAL3/xQDC/+4AxAAQAMb/7ADK/yAAy//xARr/xQGE/6ABhf+gAYf/oAGI/6ABif+gAiP/8QIk//ECJf/xAib/8QIn/8UCKP/FAoj/8QKK//ECjP/xAo7/8QKQ//ECkv/xApb/xQK+//ECwv/FAsX/8QLH//EC5f/FAu7/xQL2/8UC9/+gAvj/oAL7/6ADB//FAw//xQMw/8UDMv/FAzT/xQN///EDgf/xA4P/8QOF//EDh//xA4n/8QOL//EDjf/FA4//xQOR/8UDwP/xA9//xQPh/8UAQQBH/+cASP/nAEn/5wBL/+cAVf/nAJT/5wCZ/+cAu//nAMQADwDI/+cAyf/nAPf/5wED/+cBHv/nASL/5wFC/+cBYP/nAWH/5wFr/+cCFP/nAhX/5wIW/+cCF//nAhj/5wIw/+cCMv/nAjT/5wI2/+cCOP/nAjr/5wI8/+cCPv/nAkD/5wJC/+cCRP/nAkb/5wJI/+cCSv/nArr/5wLg/+cC5P/nAuf/5wMC/+cDCP/nAw3/5wMb/+cDHf/nAx7/5wMq/+cDOf/nA1P/5wNV/+cDV//nA1n/5wNb/+cDXf/nA1//5wNh/+cDdf/nA3f/5wN5/+cDff/nA7j/5wPF/+cDx//nAAUAyv/qAO3/7gD2/6sBOv/sAW3/7AABAPb/1QABAMoACwB7AAYADAALAAwAR//oAEj/6ABJ/+gASgAMAEv/6ABT/+oAVf/oAFoACwBdAAsAlP/oAJn/6AC7/+gAvQALAL7/7QDGAAsAyP/oAMn/6ADKAAwA9//oAQP/6AEY/+oBGgALAR7/6AEi/+gBQv/oAWD/6AFh/+gBa//oAYQADAGFAAwBhwAMAYgADAGJAAwCFP/oAhX/6AIW/+gCF//oAhj/6AIe/+oCH//qAiD/6gIh/+oCIv/qAicACwIoAAsCMP/oAjL/6AI0/+gCNv/oAjj/6AI6/+gCPP/oAj7/6AJA/+gCQv/oAkT/6AJG/+gCSP/oAkr/6AJs/+oCbv/qAnD/6gKWAAsCuv/oAsD/6gLCAAsCxv/qAuD/6ALi/+oC5P/oAuUACwLn/+gC7gALAvYACwL3AAwC+AAMAvsADAMC/+gDBwALAwj/6AMN/+gDDwALAxv/6AMd/+gDHv/oAyj/6gMq/+gDLP/qAzAACwMyAAsDNAALAzn/6ANT/+gDVf/oA1f/6ANZ/+gDW//oA13/6ANf/+gDYf/oA2f/6gNp/+oDa//qA23/6gNv/+oDcf/qA3P/6gN1/+gDd//oA3n/6AN7/+oDff/oA40ACwOPAAsDkQALA7j/6AO8/+oDxf/oA8f/6APfAAsD4QALAAEA9v/YAA4AXP/tAF7/7QDu/+0A9v+qATT/7QFE/+0BXv/tApn/7QKb/+0Cnf/tAub/7QMS/+0DIP/tA+X/7QANAFz/8gBe//IA7v/yATT/8gFE//IBXv/yApn/8gKb//ICnf/yAub/8gMS//IDIP/yA+X/8gAiAFr/9ABc//IAXf/0AF7/8wC9//QA7v/yARr/9AE0//IBRP/yAV7/8gIn//QCKP/0Apb/9AKZ//MCm//zAp3/8wLC//QC5f/0Aub/8gLu//QC9v/0Awf/9AMP//QDEv/yAyD/8gMw//QDMv/0AzT/9AON//QDj//0A5H/9APf//QD4f/0A+X/8wCMAAb/ygAL/8oAOP/SADr/1AA8//QAPf/TAFH/0QBS/9EAVP/RAFr/5gBc/+8AXf/mAL3/5gDB/9EA0v/SANb/0gDa//QA3v/tAOH/4QDm/9QA7P/RAO7/7wDw/9EA8f/RAPP/0QD0/9EA9f/RAPb/yQD4/9EA+v/RAPv/0QD+/9EBAP/RAQX/0QEJ/+UBGf/UARr/5gEg/+MBK//RATP/9AE0/+8BNv/RATn/0gE6/8QBPP/RAT7/0QFD//QBRP/vAUX/0gFH/+EBSf/hAVP/0QFV/9EBV//RAVz/0QFd//QBXv/vAWL/1AFj//UBZP/nAWz/0gFt/8kBhP/KAYX/ygGH/8oBiP/KAYn/ygIM/9MCHf/RAif/5gIo/+YCZf/RAmf/0QJp/9ECav/RAoH/0gKD/9IChf/SApX/0wKW/+YCl//TAqf/0wK2/9MCt//0Arn/0wK8/9ECwv/mAtH/7QLd/9IC3v/0AuH/0QLj/9EC5f/mAub/7wLo/9EC7f/RAu7/5gL1/9MC9v/mAvf/ygL4/8oC+//KAv3/0QMD/9EDBv/UAwf/5gMO/9MDD//mAxH/9AMS/+8DH//0AyD/7wMk/9EDJv/RAy//7QMw/+YDMf/tAzL/5gMz/+0DNP/mAzX/4QM4/9EDjP/TA43/5gOO/9MDj//mA5D/0wOR/+YDk//SA5X/4QOY/9EDov/TA7T/0QPR/9ED0//RA9v/0gPe/9QD3//mA+D/1APh/+YAKAA4/74AWv/vAF3/7wC9/+8A0v++ANb/vgDm/8kA9v/fAQn/7QEa/+8BIP/rATn/vgE6/98BRf++AUz/6QFj//UBbf/gAif/7wIo/+8Cgf++AoP/vgKF/74Clv/vAsL/7wLd/74C5f/vAu7/7wL2/+8DB//vAw//7wMw/+8DMv/vAzT/7wON/+8Dj//vA5H/7wOT/74D2/++A9//7wPh/+8APwA4/+YAOv/nADz/8gA9/+cAXP/xANL/5gDW/+YA2v/yAN7/7gDh/+gA5v/mAO7/8QD2/9ABGf/nATP/8gE0//EBOf/mATr/zgFD//IBRP/xAUX/5gFH/+gBSf/oAV3/8gFe//EBYv/nAWT/7QFs/+YBbf/QAgz/5wKB/+YCg//mAoX/5gKV/+cCl//nAqf/5wK2/+cCt//yArn/5wLR/+4C3f/mAt7/8gLm//EC9f/nAwb/5wMO/+cDEf/yAxL/8QMf//IDIP/xAy//7gMx/+4DM//uAzX/6AOM/+cDjv/nA5D/5wOT/+YDlf/oA6L/5wPb/+YD3v/nA+D/5wCUACUAEAAn/+gAK//oADP/6AA1/+gAOP/gADr/4AA9/98Ag//oAJP/6ACY/+gAsgAQALP/6AC0ABAA0v/gANP/6ADUABAA1v/gANkAFADdABAA4f/hAOb/4ADtABMA8gAQAPn/4AEEABABCP/oAQ0AEAEX/+gBGf/gARv/6AEd/+gBH//oASH/6AE5/+ABQf/oAUX/4AFH/+EBSP/gAUn/4QFK/+ABTf/hAVAAEAFRABABWP/pAWL/3wFk/94BZgAQAWr/6AFs/98Bbv/yAW8AEAFwABAB8gAQAfMAEAH0ABAB9QAQAfYAEAH3ABAB+AAQAfn/6AID/+gCBP/oAgX/6AIG/+gCB//oAgz/3wIpABACKwAQAi0AEAIv/+gCMf/oAjP/6AI1/+gCQ//oAkX/6AJH/+gCSf/oAmv/6AJt/+gCb//oAoH/4AKD/+AChf/gApX/3wKX/98CoP/oAqIAEAKm/+gCp//fAqoAEAKz/+gCtv/fArn/3wLSABAC2f/oAtz/6ALd/+AC9f/fAv4AEAMG/+ADCf/oAwz/6AMO/98DFAAQAxYAEAMn/+gDKf/oAyv/6AM1/+EDNv/gAzoAEAM8ABADPgAQA0AAEANCABADRAAQA0YAEANIABADSgAQA0wAEANOABADUAAQA2b/6ANo/+gDav/oA2z/6ANu/+gDcP/oA3L/6AN0/+gDdv/oA3j/6AN6/+gDfP/oA4z/3wOO/98DkP/fA5P/4AOV/+EDlv/gA6L/3wO1ABADu//oA9T/6APb/+AD3v/gA+D/4AA1ABv/8gA4//EAOv/0ADz/9AA9//AA0v/xANT/9QDW//EA2v/0AN3/9QDe//MA5v/xARn/9AEz//QBOf/xAUP/9AFF//EBUP/1AV3/9AFi//IBZP/yAWb/9QFs//IBb//1Agz/8AKB//ECg//xAoX/8QKV//ACl//wAqf/8AK2//ACt//0Arn/8ALR//MC3f/xAt7/9AL1//ADBv/0Aw7/8AMR//QDH//0Ay//8wMx//MDM//zA4z/8AOO//ADkP/wA5P/8QOi//AD2//xA97/9APg//QAagAlAA8AOP/mADr/5gA8AA4APf/mALIADwC0AA8A0v/mANQADgDW/+YA2QATANoADgDdAA4A3gALAOH/5QDm/+YA5//0AO0AEgDyAA8A9v/nAPn/6AEEAA8BDQAPARn/5gEzAA4BOf/mATr/5wFDAA4BRf/mAUf/5QFI/+gBSf/lAUr/6AFM/+QBUAAOAVEADwFdAA4BYv/mAWT/5gFmAA4BbP/mAW3/5wFvAA4BcAAPAfIADwHzAA8B9AAPAfUADwH2AA8B9wAPAfgADwIM/+YCKQAPAisADwItAA8Cgf/mAoP/5gKF/+YClf/mApf/5gKiAA8Cp//mAqoADwK2/+YCtwAOArn/5gLRAAsC0gAPAt3/5gLeAA4C9f/mAv4ADwMG/+YDDv/mAxEADgMUAA8DFgAPAx8ADgMvAAsDMQALAzMACwM1/+UDNv/oAzoADwM8AA8DPgAPA0AADwNCAA8DRAAPA0YADwNIAA8DSgAPA0wADwNOAA8DUAAPA4z/5gOO/+YDkP/mA5P/5gOV/+UDlv/oA6L/5gO1AA8D2//mA97/5gPg/+YAMQA4/+MAPP/lAD3/5ADS/+MA1P/lANb/4wDZ/+IA2v/lAN3/5QDe/+kA8v/qAQT/6gEz/+UBOf/jAUP/5QFF/+MBUP/lAVH/6gFd/+UBZv/lAWz/5AFv/+UBcP/qAgz/5AKB/+MCg//jAoX/4wKV/+QCl//kAqf/5AK2/+QCt//lArn/5ALR/+kC3f/jAt7/5QL1/+QDDv/kAxH/5QMf/+UDL//pAzH/6QMz/+kDjP/kA47/5AOQ/+QDk//jA6L/5APb/+MAJAA4/+IAPP/kANL/4gDU/+QA1v/iANn/4QDa/+QA3f/kAN7/6QDt/+QA8v/rAQT/6wEz/+QBOf/iAUP/5AFF/+IBUP/kAVH/6wFd/+QBZv/kAW//5AFw/+sCgf/iAoP/4gKF/+ICt//kAtH/6QLd/+IC3v/kAxH/5AMf/+QDL//pAzH/6QMz/+kDk//iA9v/4gAYADj/6wA9//MA0v/rANb/6wE5/+sBRf/rAgz/8wKB/+sCg//rAoX/6wKV//MCl//zAqf/8wK2//MCuf/zAt3/6wL1//MDDv/zA4z/8wOO//MDkP/zA5P/6wOi//MD2//rADkAUf/vAFL/7wBU/+8AXP/wAMH/7wDs/+8A7f/uAO7/8ADw/+8A8f/vAPP/7wD0/+8A9f/vAPb/7gD4/+8A+v/vAPv/7wD+/+8BAP/vAQX/7wEJ//QBIP/xASv/7wE0//ABNv/vATr/7wE8/+8BPv/vAUT/8AFT/+8BVf/vAVf/7wFc/+8BXv/wAW3/7wId/+8CZf/vAmf/7wJp/+8Cav/vArz/7wLh/+8C4//vAub/8ALo/+8C7f/vAv3/7wMD/+8DEv/wAyD/8AMk/+8DJv/vAzj/7wOY/+8DtP/vA9H/7wPT/+8AIwAG//IAC//yAFr/9QBd//UAvf/1APb/9AEJ//UBGv/1ATr/9QFt//UBhP/yAYX/8gGH//IBiP/yAYn/8gIn//UCKP/1Apb/9QLC//UC5f/1Au7/9QL2//UC9//yAvj/8gL7//IDB//1Aw//9QMw//UDMv/1AzT/9QON//UDj//1A5H/9QPf//UD4f/1AAoA7QAUAPb/7QD5/+0A/P/iATr/7QFI/+0BSv/tAW3/7QM2/+0Dlv/tAFkAR//wAEj/8ABJ//AAS//wAFP/6wBV//AAlP/wAJn/8AC7//AAyP/wAMn/8AD3//ABA//wARj/6wEc/+sBHv/wASL/8AFC//ABYP/wAWH/8AFr//ACFP/wAhX/8AIW//ACF//wAhj/8AIe/+sCH//rAiD/6wIh/+sCIv/rAjD/8AIy//ACNP/wAjb/8AI4//ACOv/wAjz/8AI+//ACQP/wAkL/8AJE//ACRv/wAkj/8AJK//ACbP/rAm7/6wJw/+sCuv/wAsD/6wLG/+sC4P/wAuL/6wLk//AC5//wAwL/8AMI//ADDf/wAxv/8AMd//ADHv/wAyj/6wMq//ADLP/rAzn/8ANT//ADVf/wA1f/8ANZ//ADW//wA13/8ANf//ADYf/wA2f/6wNp/+sDa//rA23/6wNv/+sDcf/rA3P/6wN1//ADd//wA3n/8AN7/+sDff/wA7j/8AO8/+sDxf/wA8f/8ACgAAYADQALAA0ARf/wAEf/sABI/7AASf+wAEoADQBL/7AAU//WAFX/sABaAAsAXQALAJT/sACZ/7AAu/+wAL0ACwC+/7AAx/+rAMj/wADJ/7AAzP/VAO3/qgDy/68A9/+wAQP/sAEE/68BGP/WARoACwEc/+IBHv+wASAADAEi/7ABQv+wAVH/rwFg/7ABYf+wAWMACwFlAAsBa/+wAXD/rwGEAA0BhQANAYcADQGIAA0BiQANAg3/8AIO//ACD//wAhD/8AIR//ACEv/wAhP/8AIU/7ACFf+wAhb/sAIX/7ACGP+wAh7/1gIf/9YCIP/WAiH/1gIi/9YCJwALAigACwIq//ACLP/wAi7/8AIw/7ACMv+wAjT/sAI2/7ACOP+wAjr/sAI8/7ACPv+wAkD/sAJC/7ACRP+wAkb/sAJI/7ACSv+wAmz/1gJu/9YCcP/WApYACwK6/7ACwP/WAsIACwLG/9YC3//wAuD/sALi/9YC5P+wAuUACwLn/7AC7gALAvYACwL3AA0C+AANAvsADQL///ADAv+wAwcACwMI/7ADDf+wAw8ACwMV//ADF//wAxv/sAMd/7ADHv+wAyj/1gMq/7ADLP/WAzAACwMyAAsDNAALAzn/sAM7//ADPf/wAz//8ANB//ADQ//wA0X/8ANH//ADSf/wA0v/8ANN//ADT//wA1H/8ANT/7ADVf+wA1f/sANZ/7ADW/+wA13/sANf/7ADYf+wA2f/1gNp/9YDa//WA23/1gNv/9YDcf/WA3P/1gN1/7ADd/+wA3n/sAN7/9YDff+wA40ACwOPAAsDkQALA7b/8AO4/7ADvP/WA8X/sAPH/7AD3wALA+EACwAOAO0AFADyABAA9v/wAPn/8AEBAAwBBAAQATr/8AFI//ABSv/mAVEAEAFt//ABcAAQAzb/8AOW//AATQBHAAwASAAMAEkADABLAAwAVQAMAJQADACZAAwAuwAMAMgADADJAAwA7QA6APIAGAD2/+MA9wAMAPn/9wEDAAwBBAAYAR4ADAEiAAwBOv/iAUIADAFI//cBSv/jAVEAGAFgAAwBYQAMAWsADAFt/+MBcAAYAhQADAIVAAwCFgAMAhcADAIYAAwCMAAMAjIADAI0AAwCNgAMAjgADAI6AAwCPAAMAj4ADAJAAAwCQgAMAkQADAJGAAwCSAAMAkoADAK6AAwC4AAMAuQADALnAAwDAgAMAwgADAMNAAwDGwAMAx0ADAMeAAwDKgAMAzb/9wM5AAwDUwAMA1UADANXAAwDWQAMA1sADANdAAwDXwAMA2EADAN1AAwDdwAMA3kADAN9AAwDlv/3A7gADAPFAAwDxwAMACIAWv/0AFz/8ABd//QAvf/0AO3/7wDu//AA8v/zAQT/8wEa//QBNP/wAUT/8AFR//MBXv/wAXD/8wIn//QCKP/0Apb/9ALC//QC5f/0Aub/8ALu//QC9v/0Awf/9AMP//QDEv/wAyD/8AMw//QDMv/0AzT/9AON//QDj//0A5H/9APf//QD4f/0AAoABv/WAAv/1gGE/9YBhf/WAYf/1gGI/9YBif/WAvf/1gL4/9YC+//WAAgA9v+6AQn/zwEg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AAAAHAAAABwABwAAAAAAAAAAABwAHAAAAAAAAAAAABwAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAADABsACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAHwAYAAAAAAAQABIACwAAAAsAAAALAAAAAAAAAAAAAAAAAAAAAAAAABAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAGAAQABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXABcAHgAXABcAFwAeAAAAAAAAAB4AHgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAAANAAAAAgACAAIAAgACAAIAAgARAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQAKAAoACgAKAAwABgAGAAYABgAGAAYABgAVAAgACAAIAAgAAAAAAAAAAAAEAAMAAwADAAMAAwAAAAAAAAAAAAkACQACAAYAAgAGAAIABgARABUAEQAVABEAFQARABUAAQAAAAUACAAFAAgABQAIAAUACAAFAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAsAAAAWAAAAFgAAABYAAAAWAAAAAAAEAAAABAAAAAQABAABAAMAAQADAAEAAwAAABMAAAATAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAANAAAADQAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAABkAAAAMAAkADAAPAA4ADwAOAA8ADgAAAAAAAAAAAAIABQAAAAAAAQAMAAAAAAACABoABQAPAAAAAAALAAAAAAABABQADQAMABAAAAAMAAAAAAAEAAAAAAAAAAMAAAAJAAAAAAAAAAMAAAAAAAUAHwAAAAAAAAAKAAsACwAgAAIAGgAfAAUAAAAAAAAAAQAAABQAEQANABAABgAIAAAAAwAHABUACQASAAgAGAAAAAAAAAAAAAAACQAZAAAAGQAAABkAAAAMAAkAFwAXAAAAAAAXAAAABAACAAYABQAAAAgAAAAAAAAAGwAJAAAAAAAAAAAAEQAVAAwACQAAABAAEgAAAAIABgACAAYAAAAAAAUACAAAAAgACAAQABIAAAAAAAAAAAAAAAAAAQADAAAAAAAAAAMAAAAHACAACQAgAAkAIAAJAAAAAAAAAAAAAAACAAYAAgAGAAIABgACAAYAAgAGAAIABgACAAYAAgAGAAIABgACAAYAAgAGAAIABgAFAAgABQAIAAUACAAFAAgABQAIAAUACAAFAAgABQAIAAAAAAAAAAAAAQADAAEAAwABAAMAAQADAAEAAwABAAMAAQADAAAAAAAAAAAAAAAAAAAAAwAAAAAACgAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwACQAMAAkADAAJAAAADQAAAAAAAAAfABgAAAAAAAQAAAAdAB8AAAALAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAACAAYABQAAAAAAAAABAAMAAAATAAAAAAAAABoABwABAAAAAQAAAAAABAALAAAACwAAABYAAAAAAAQAAAAEAAEAFAAHAAAAEwAAAAAADQAAAAoAGwAJABsACQAZAAAADwAOAAEAAQAGA+AAEQAAAAAAAAAAABEAAAAAAAAAAAAVABgAFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAACAAAAAAAcAAAAAAAAAAAAAgAAAAIAAAAOAAoACQAXABMADwALABAAAAAAAAAAAAAAAAAABwAAAAEAAQABAAAAAQAAAAAAAAAAAAAAAwADAAQAAwABAAAADAAAAAUACAAAABIACAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgABAAAAAAAAAAIAAQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAIABgAAAAAAAAAAAAAAAAABAAAACAAAAAAAAAADAAAAAAAAAAAAAAAAAAEAAQAAAAUAAAAAAAAAAAAAAAAACgACABQAAAAKAAAAAAAAAA8AAAAAABQAGwAAAAAAGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAASAAAAAwADABYAAwADAAMAAAABAAMAGgADAAMAAAAAAAMAAAADAAAAAAABABYAAwAAAAAAAgAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAgAEABcACAACAAAAAgABAAIAAAACAAEAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAPABIAAAADAAAAAAAKAAAAAAADAAAAAwAAAAAAAgABAA8AEgAKAAAAGQAaAAAAAAAAAAAAAAAAAAAAFAAWAAAAAwAAAAMAAAADAAAAAAAAAAAAAwAPABIAAAABAAEAAAAAAAAAAAAUAAAAAAAAAAIAAQAAAAAAAAAUABYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYABgAAAARABEAFQARABEAEQAVAAAAAAAAABUAFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAABgAGAAYABgAGAAYABgACAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgACAAIAAgAJAAkACQAJAAsABwAHAAcABwAHAAcABwABAAEAAQABAAEAAAAAAAAAAAADAAQABAAEAAQABAAFAAUABQAFAAgACAAGAAcABgAHAAYABwACAAEAAgABAAIAAQACAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAgABAAIAAQACAAEAAgABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAA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";

  // node_modules/zod/lib/index.mjs
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs2(_arg) {
    }
    util2.assertIs = assertIs2;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error2) => {
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error2 = new ZodError(issues);
    return error2;
  };
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (typeof value.value !== "undefined" || pair.alwaysSet) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x) => x.status === "aborted";
  var isDirty = (x) => x.status === "dirty";
  var isValid = (x) => x.status === "valid";
  var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error2 = new ZodError(ctx.common.issues);
          this._error = error2;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[a-z][a-z0-9]*$/;
  var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
  var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
  var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
  var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
  var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
      }
    }
  };
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    constructor() {
      super(...arguments);
      this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
      this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
      this.trim = () => new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
      this.toLowerCase = () => new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
      this.toUpperCase = () => new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx2,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _addCheck(check) {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error2) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error2
          }
        });
      }
      function makeReturnsIssue(returns, error2) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error2
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        return OK(async (...args) => {
          const error2 = new ZodError([]);
          const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
            error2.addIssue(makeArgsIssue(args, e));
            throw error2;
          });
          const result = await fn(...parsedArgs);
          const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error2.addIssue(makeReturnsIssue(result, e));
            throw error2;
          });
          return parsedReturns;
        });
      } else {
        return OK((...args) => {
          const parsedArgs = this._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = fn(...parsedArgs.data);
          const parsedReturns = this._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values2, params) {
    return new ZodEnum({
      values: values2,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values2) {
      return _ZodEnum.create(values2);
    }
    exclude(values2) {
      return _ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
    }
  };
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values2, params) => {
    return new ZodNativeEnum({
      values: values2,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data);
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new _ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var custom = (check, params = {}, fatal) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        if (!check(data)) {
          const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
          const p2 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });

  // node_modules/@pdfme/common/dist/esm/src/schema.js
  var langs = ["en", "ja", "ar", "th"];
  var Lang = z.enum(langs);
  var Size = z.object({ height: z.number(), width: z.number() });
  var alignments = ["left", "center", "right"];
  var Alignment = z.enum(alignments);
  var barcodeSchemaTypes = ["qrcode", "japanpost", "ean13", "ean8", "code39", "code128", "nw7", "itf14", "upca", "upce", "gs1datamatrix"];
  var notBarcodeSchemaTypes = ["text", "image"];
  var schemaTypes = [...notBarcodeSchemaTypes, ...barcodeSchemaTypes];
  var BarcodeSchemaType = z.enum(barcodeSchemaTypes);
  var SchemaType = z.enum(schemaTypes);
  var CommonSchema = z.object({
    type: SchemaType,
    position: z.object({ x: z.number(), y: z.number() }),
    width: z.number(),
    height: z.number(),
    rotate: z.number().optional()
  });
  var TextSchema = CommonSchema.extend({
    type: z.literal(SchemaType.Enum.text),
    alignment: Alignment.optional(),
    fontSize: z.number().optional(),
    fontName: z.string().optional(),
    fontColor: z.string().optional(),
    backgroundColor: z.string().optional(),
    characterSpacing: z.number().optional(),
    lineHeight: z.number().optional(),
    dynamicFontSize: z.object({
      max: z.number(),
      min: z.number()
    }).optional()
  });
  var ImageSchema = CommonSchema.extend({ type: z.literal(SchemaType.Enum.image) });
  var BarcodeSchema = CommonSchema.extend({ type: BarcodeSchemaType });
  var Schema = z.union([TextSchema, ImageSchema, BarcodeSchema]);
  var SchemaForUIAdditionalInfo = z.object({
    id: z.string(),
    key: z.string(),
    data: z.string()
  });
  var SchemaForUI = z.union([
    TextSchema.merge(SchemaForUIAdditionalInfo),
    ImageSchema.merge(SchemaForUIAdditionalInfo),
    BarcodeSchema.merge(SchemaForUIAdditionalInfo)
  ]);
  var ArrayBufferSchema = z.any().refine((v) => v instanceof ArrayBuffer);
  var Uint8ArraySchema = z.any().refine((v) => v instanceof Uint8Array);
  var Font2 = z.record(z.object({
    data: z.union([z.string(), ArrayBufferSchema, Uint8ArraySchema]),
    fallback: z.boolean().optional(),
    subset: z.boolean().optional()
  }));
  var BasePdf = z.union([z.string(), ArrayBufferSchema, Uint8ArraySchema]);
  var Template = z.object({
    schemas: z.array(z.record(Schema)),
    basePdf: BasePdf,
    sampledata: z.array(z.record(z.string())).length(1).optional(),
    columns: z.array(z.string()).optional()
  });
  var Inputs = z.array(z.record(z.string())).min(1);
  var CommonOptions = z.object({ font: Font2.optional() });
  var CommonProps = z.object({
    template: Template,
    options: CommonOptions.optional()
  });
  var GeneratorOptions = CommonOptions;
  var GenerateProps = CommonProps.extend({
    inputs: Inputs,
    options: GeneratorOptions.optional()
  }).strict();
  var SchemaInputs = z.record(z.string());
  var UIOptions = CommonOptions.extend({ lang: Lang.optional() });
  var HTMLElementSchema = z.any().refine((v) => v instanceof HTMLElement);
  var UIProps = CommonProps.extend({
    domContainer: HTMLElementSchema,
    options: UIOptions.optional()
  });
  var PreviewProps = UIProps.extend({ inputs: Inputs }).strict();
  var PreviewReactProps = PreviewProps.omit({ domContainer: true }).extend({
    onChangeInput: z.function().args(z.object({ index: z.number(), value: z.string(), key: z.string() })).returns(z.void()).optional(),
    size: Size
  });
  var DesignerProps = UIProps.extend({}).strict();
  var DesignerReactProps = DesignerProps.omit({ domContainer: true }).extend({
    onSaveTemplate: z.function().args(Template).returns(z.void()),
    size: Size
  });

  // node_modules/@pdfme/common/dist/esm/src/type.js
  var schemaTypes2 = schemaTypes;
  var isTextSchema = (arg) => arg.type === "text";
  var isImageSchema = (arg) => arg.type === "image";
  var isBarcodeSchema = (arg) => barcodeSchemaTypes.map((t) => t).includes(arg.type);

  // node_modules/@pdfme/common/dist/esm/src/helper.js
  var import_buffer = __toESM(require_buffer());
  var blob2Base64Pdf = (blob) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (reader.result.startsWith("data:application/pdf;")) {
          resolve(reader.result);
        } else {
          reject(Error("template.basePdf must be pdf data."));
        }
      };
      reader.readAsDataURL(blob);
    });
  };
  var getB64BasePdf = (basePdf) => {
    const needFetchFromNetwork = typeof basePdf === "string" && !basePdf.startsWith("data:application/pdf;");
    if (needFetchFromNetwork && typeof window !== "undefined") {
      return fetch(basePdf).then((res) => res.blob()).then(blob2Base64Pdf).catch((e) => {
        throw e;
      });
    }
    return basePdf;
  };
  var getByteString = (base64) => import_buffer.Buffer.from(base64, "base64").toString("binary");
  var b64toUint8Array = (base64) => {
    const data = base64.split(";base64,")[1] ? base64.split(";base64,")[1] : base64;
    const byteString = getByteString(data);
    const unit8arr = new Uint8Array(byteString.length);
    for (let i = 0; i < byteString.length; i += 1) {
      unit8arr[i] = byteString.charCodeAt(i);
    }
    return unit8arr;
  };
  var getFallbackFontName = (font) => {
    const initial = "";
    const fallbackFontName = Object.entries(font).reduce((acc, cur) => {
      const [fontName, fontValue] = cur;
      return !acc && fontValue.fallback ? fontName : acc;
    }, initial);
    if (fallbackFontName === initial) {
      throw Error(`fallback flag is not found in font. true fallback flag must be only one.`);
    }
    return fallbackFontName;
  };
  var getDefaultFont = () => ({
    [DEFAULT_FONT_NAME]: { data: b64toUint8Array(DEFAULT_FONT_VALUE), fallback: true }
  });
  var uniq = (array) => Array.from(new Set(array));
  var getFontNamesInSchemas = (schemas) => uniq(schemas.map((s) => Object.values(s).map((v) => isTextSchema(v) ? v.fontName : "")).reduce((acc, cur) => acc.concat(cur), []).filter(Boolean));
  var checkFont = (arg) => {
    const { font, template: { schemas } } = arg;
    const fontValues = Object.values(font);
    const fallbackFontNum = fontValues.reduce((acc, cur) => cur.fallback ? acc + 1 : acc, 0);
    if (fallbackFontNum === 0) {
      throw Error(`fallback flag is not found in font. true fallback flag must be only one.`);
    }
    if (fallbackFontNum > 1) {
      throw Error(`${fallbackFontNum} fallback flags found in font. true fallback flag must be only one.`);
    }
    const fontNamesInSchemas = getFontNamesInSchemas(schemas);
    const fontNames = Object.keys(font);
    if (fontNamesInSchemas.some((f) => !fontNames.includes(f))) {
      throw Error(`${fontNamesInSchemas.filter((f) => !fontNames.includes(f)).join()} of template.schemas is not found in font.`);
    }
  };
  var checkProps = (data, zodSchema) => {
    try {
      zodSchema.parse(data);
    } catch (e) {
      if (e instanceof z.ZodError) {
        const messages = e.issues.map((issue) => `ERROR POSITION: ${issue.path.join(".")}
ERROR MESSAGE: ${issue.message}
--------------------------`);
        const message = messages.join("\n");
        throw Error(`Invalid argument:
--------------------------
${message}`);
      }
    }
    const commonProps = data;
    const { template: template2, options } = commonProps;
    const font = options === null || options === void 0 ? void 0 : options.font;
    if (font) {
      checkFont({ font, template: template2 });
    }
  };
  var checkInputs = (data) => checkProps(data, Inputs);
  var checkUIOptions = (data) => checkProps(data, UIOptions);
  var checkTemplate = (data) => checkProps(data, Template);
  var checkUIProps = (data) => checkProps(data, UIProps);
  var checkPreviewProps = (data) => checkProps(data, PreviewProps);
  var checkDesignerProps = (data) => checkProps(data, DesignerProps);
  var checkGenerateProps = (data) => checkProps(data, GenerateProps);
  var validateCheckDigit = (input, checkDigitPos) => {
    let passCheckDigit = true;
    if (input.length === checkDigitPos) {
      const ds = input.slice(0, -1).replace(/[^0-9]/g, "");
      let sum2 = 0;
      let odd = 1;
      for (let i = ds.length - 1; i > -1; i -= 1) {
        sum2 += Number(ds[i]) * (odd ? 3 : 1);
        odd ^= 1;
        if (sum2 > 281474976710655) {
          sum2 %= 10;
        }
      }
      passCheckDigit = String(10 - sum2 % 10).slice(-1) === input.slice(-1);
    }
    return passCheckDigit;
  };
  var validateBarcodeInput = (type, input) => {
    if (!input)
      return false;
    if (type === "qrcode") {
      return input.length < 500;
    }
    if (type === "japanpost") {
      const regexp = /^(\d{7})(\d|[A-Z]|-)+$/;
      return regexp.test(input);
    }
    if (type === "ean13") {
      const regexp = /^\d{12}$|^\d{13}$/;
      return regexp.test(input) && validateCheckDigit(input, 13);
    }
    if (type === "ean8") {
      const regexp = /^\d{7}$|^\d{8}$/;
      return regexp.test(input) && validateCheckDigit(input, 8);
    }
    if (type === "code39") {
      const regexp = /^(\d|[A-Z]|\-|\.|\$|\/|\+|\%|\s)+$/;
      return regexp.test(input);
    }
    if (type === "code128") {
      return !input.match(/([\u30a0-\u30ff\u3040-\u309f\u3005-\u3006\u30e0-\u9fcf]|[---])+/);
    }
    if (type === "nw7") {
      const regexp = /^[A-Da-d]([0-9\-\.\$\:\/\+])+[A-Da-d]$/;
      return regexp.test(input);
    }
    if (type === "itf14") {
      const regexp = /^\d{13}$|^\d{14}$/;
      return regexp.test(input) && validateCheckDigit(input, 14);
    }
    if (type === "upca") {
      const regexp = /^\d{11}$|^\d{12}$/;
      return regexp.test(input) && validateCheckDigit(input, 12);
    }
    if (type === "upce") {
      const regexp = /^0(\d{6}$|\d{7}$)/;
      return regexp.test(input) && validateCheckDigit(input, 8);
    }
    if (type === "gs1datamatrix") {
      let ret = false;
      const regexp = /\((01)\)(\d*)(\(|$)/;
      let res = input.match(regexp);
      if (res != null && res[1] === "01" && (res[2].length === 14 || res[2].length === 8 || res[2].length === 12 || res[2].length === 13)) {
        let gtin = res[2];
        ret = validateCheckDigit(gtin, gtin.length);
      }
      return ret;
    }
    return false;
  };

  // node_modules/@pdfme/common/dist/esm/src/calculateDynamicFontSize.js
  var import_buffer2 = __toESM(require_buffer());
  var __awaiter3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var widthOfTextAtSize = (input, fontKitFont, fontSize) => {
    const { glyphs } = fontKitFont.layout(input);
    const scale2 = 1e3 / fontKitFont.unitsPerEm;
    return glyphs.reduce((totalWidth, glyph) => totalWidth + glyph.advanceWidth * scale2, 0) * (fontSize / 1e3);
  };
  var calculateCharacterSpacing = (textContent, textCharacterSpacing) => {
    const numberOfCharacters = textContent.length;
    return (numberOfCharacters - 1) * textCharacterSpacing;
  };
  var calculateTextWidthInMm = (textContent, textWidth, textCharacterSpacing) => (textWidth + calculateCharacterSpacing(textContent, textCharacterSpacing)) * DEFAULT_PT_TO_MM_RATIO;
  var getLongestLine = (textContentRows, fontKitFont, fontSize, characterSpacingCount) => {
    let longestLine = "";
    let maxLineWidth = 0;
    textContentRows.forEach((line) => {
      const textWidth = widthOfTextAtSize(line, fontKitFont, fontSize);
      const lineWidth = calculateTextWidthInMm(line, textWidth, characterSpacingCount);
      if (lineWidth > maxLineWidth) {
        longestLine = line;
        maxLineWidth = lineWidth;
      }
    });
    return longestLine;
  };
  var fontKitFontCache = {};
  var createFontKitFont = (font, fontName = DEFAULT_FONT_NAME) => __awaiter3(void 0, void 0, void 0, function* () {
    var _a;
    if (fontKitFontCache[fontName]) {
      return fontKitFontCache[fontName];
    }
    let fontData = ((_a = font[fontName]) === null || _a === void 0 ? void 0 : _a.data) || DEFAULT_FONT_VALUE;
    if (typeof fontData === "string") {
      fontData = fontData.startsWith("http") ? yield fetch(fontData).then((res) => res.arrayBuffer()) : b64toUint8Array(fontData);
    }
    const fontKitFont = $d636bc798e7178db$export$185802fd694ee1f5(fontData instanceof import_buffer2.Buffer ? fontData : import_buffer2.Buffer.from(fontData));
    fontKitFontCache[fontName] = fontKitFont;
    return fontKitFont;
  });
  var getTextContent = (input, fontKitFont, fontSize, characterSpacingCount) => {
    const textContentRows = input.split("\n");
    return textContentRows.length > 1 ? getLongestLine(textContentRows, fontKitFont, fontSize, characterSpacingCount) : input;
  };
  var calculateDynamicFontSize = ({ textSchema, font, input }) => __awaiter3(void 0, void 0, void 0, function* () {
    const { fontName, fontSize: _fontSize, dynamicFontSize: dynamicFontSizeSetting, characterSpacing, width } = textSchema;
    const fontSize = _fontSize || DEFAULT_FONT_SIZE;
    if (!dynamicFontSizeSetting)
      return fontSize;
    const characterSpacingCount = characterSpacing !== null && characterSpacing !== void 0 ? characterSpacing : DEFAULT_CHARACTER_SPACING;
    const fontKitFont = yield createFontKitFont(font, fontName);
    const textContent = getTextContent(input, fontKitFont, fontSize, characterSpacingCount);
    const textWidth = widthOfTextAtSize(textContent, fontKitFont, fontSize);
    let dynamicFontSize = fontSize;
    let textWidthInMm = calculateTextWidthInMm(textContent, textWidth, characterSpacingCount);
    while (textWidthInMm > width - DEFAULT_TOLERANCE && dynamicFontSize > dynamicFontSizeSetting.min) {
      dynamicFontSize -= DEFAULT_FONT_SIZE_ADJUSTMENT;
      textWidthInMm = calculateTextWidthInMm(textContent, widthOfTextAtSize(textContent, fontKitFont, dynamicFontSize), characterSpacingCount);
    }
    while (textWidthInMm < width - DEFAULT_TOLERANCE && dynamicFontSize < dynamicFontSizeSetting.max) {
      dynamicFontSize += DEFAULT_FONT_SIZE_ADJUSTMENT;
      textWidthInMm = calculateTextWidthInMm(textContent, widthOfTextAtSize(textContent, fontKitFont, dynamicFontSize), characterSpacingCount);
    }
    return dynamicFontSize;
  });

  // node_modules/bwip-js/dist/bwipp.mjs
  var $$ = null;
  var $j = 0;
  var $k = [];
  var $0 = {};
  function $a(a) {
    if (!arguments.length) {
      for (var i = $j - 1; i >= 0 && $k[i] !== Infinity; i--)
        ;
      if (i < 0) {
        throw new Error("array-marker-not-found");
      }
      a = $k.splice(i + 1, $j - 1 - i);
      $j = i;
    } else if (!(a instanceof Array)) {
      a = new Array(+arguments[0]);
      for (var i = 0, l = a.length; i < l; i++) {
        a[i] = null;
      }
    }
    a.b = a;
    a.o = 0;
    return a;
  }
  function $d() {
    for (var mark = $j - 1; mark >= 0 && $k[mark] !== Infinity; mark -= 2) {
      if ($k[mark - 1] === Infinity) {
        throw new Error("dict-malformed-stack");
      }
    }
    if (mark < 0) {
      throw "dict-marker-not-found";
    }
    var d = /* @__PURE__ */ new Map();
    for (var i = mark + 1; i < $j; i += 2) {
      var k = $k[i];
      var t = typeof k;
      if (t == "number" || t == "string") {
        d.set(k, $k[i + 1]);
      } else if (k instanceof Uint8Array) {
        d.set($z(k), $k[i + 1]);
      } else {
        throw "dict-not-a-valid-key(" + k + ")";
      }
    }
    $j = mark;
    return d;
  }
  function $s(v) {
    var t = typeof v;
    if (t === "number") {
      return new Uint8Array(v);
    }
    if (t !== "string") {
      v = "" + v;
    }
    var s = new Uint8Array(v.length);
    for (var i = 0; i < v.length; i++) {
      s[i] = v.charCodeAt(i);
    }
    return s;
  }
  function $r(n, c) {
    if ($j < n) {
      throw "roll: --stack-underflow--";
    }
    if (!c) {
      return;
    }
    if (c < 0) {
      var t = $k.splice($j - n, -c);
    } else {
      var t = $k.splice($j - n, n - c);
    }
    $k.splice.apply($k, [$j - t.length, 0].concat(t));
  }
  function $z(s) {
    if (s instanceof Uint8Array) {
      return String.fromCharCode.apply(null, s);
    }
    return "" + s;
  }
  function $strcpy(dst, src) {
    if (typeof dst === "string") {
      dst = $s(dst);
    }
    if (src instanceof Uint8Array) {
      for (var i = 0, l = src.length; i < l; i++) {
        dst[i] = src[i];
      }
    } else {
      for (var i = 0, l = src.length; i < l; i++) {
        dst[i] = src.charCodeAt(i);
      }
    }
    return src.length < dst.length ? dst.subarray(0, src.length) : dst;
  }
  function $arrcpy(dst, src) {
    for (var i = 0, l = src.length; i < l; i++) {
      dst[i] = src[i];
    }
    dst.length = src.length;
    return dst;
  }
  function $cvs(s, v) {
    var t = typeof v;
    if (t == "number" || t == "boolean" || v === null) {
      v = "" + v;
    } else if (t !== "string") {
      v = "--nostringval--";
    }
    for (var i = 0, l = v.length; i < l; i++) {
      s[i] = v.charCodeAt(i);
    }
    $k[$j++] = i < s.length ? s.subarray(0, i) : s;
  }
  function $cvi(s) {
    if (s instanceof Uint8Array) {
      return String.fromCharCode.apply(null, s).replace(/\0+$/, "") | 0;
    }
    return "" + s | 0;
  }
  function $cvrs(s, n, r) {
    return $strcpy(s, (~~n).toString(r).toUpperCase());
  }
  function $cvx(s) {
    s = $z(s);
    var m = /^\s*<((?:[0-9a-fA-F]{2})+)>\s*$/.exec(s);
    if (!m) {
      throw "cvx: not a <HH> hex string literal";
    }
    var h = m[1];
    var l = h.length >> 1;
    var u = new Uint8Array(l);
    for (var i = 0, j = 0; i < l; i++) {
      var c0 = h.charCodeAt(j++);
      var c1 = h.charCodeAt(j++);
      u[i] = ((c0 < 58 ? c0 - 48 : (c0 & 15) + 9) << 4) + (c1 < 58 ? c1 - 48 : (c1 & 15) + 9);
    }
    return u;
  }
  function $get(s, k) {
    if (s instanceof Uint8Array) {
      return s[k];
    }
    if (typeof s === "string") {
      return s.charCodeAt(k);
    }
    if (s instanceof Array) {
      return s.b[s.o + k];
    }
    if (k instanceof Uint8Array) {
      return s.get($z(k));
    }
    return s.get(k);
  }
  function $put(d, k, v) {
    if (d instanceof Uint8Array) {
      d[k] = v;
    } else if (d instanceof Array) {
      d.b[d.o + k] = v;
    } else if (typeof d == "object") {
      if (k instanceof Uint8Array) {
        d.set($z(k), v);
      } else {
        d.set(k, v);
      }
    } else {
      throw "put-not-writable-" + typeof d;
    }
  }
  function $geti(s, o, l) {
    if (s instanceof Uint8Array) {
      return s.subarray(o, o + l);
    }
    if (s instanceof Array) {
      var a = new Array(l);
      a.b = s.b;
      a.o = s.o + o;
      return a;
    }
    return s.substr(o, l);
  }
  function $puti(d, o, s) {
    if (d instanceof Uint8Array) {
      if (typeof s == "string") {
        for (var i = 0, l = s.length; i < l; i++) {
          d[o + i] = s.charCodeAt(i);
        }
      } else {
        for (var i = s.length - 1; i >= 0; i--) {
          d[o + i] = s[i];
        }
      }
    } else if (d instanceof Array) {
      var darr = d.b;
      var doff = o + d.o;
      var sarr = s.b;
      var soff = s.o;
      for (var i = 0, l = s.length; i < l; i++) {
        darr[doff + i] = sarr[soff + i];
      }
    } else {
      throw "putinterval-not-writable-" + typeof d;
    }
  }
  function $type(v) {
    if (v == null) {
      return "nulltype";
    }
    var t = typeof v;
    if (t == "number") {
      return v % 1 ? "realtype" : "integertype";
    }
    if (t == "boolean") {
      return "booleantype";
    }
    if (t == "string" || v instanceof Uint8Array) {
      return "stringtype";
    }
    if (t == "function") {
      return "operatortype";
    }
    if (v instanceof Array) {
      return "arraytype";
    }
    return "dicttype";
  }
  function $anchorsearch(str, seek) {
    if (!(str instanceof Uint8Array)) {
      str = $s(str);
    }
    var i = 0, ls = str.length, lk = seek.length;
    if (lk == 1) {
      var cd = seek instanceof Uint8Array ? seek[0] : seek.charCodeAt(0);
      i = str[0] == cd ? 1 : ls;
    } else if (seek.length <= ls) {
      if (!(seek instanceof Uint8Array)) {
        seek = $s(seek);
      }
      for (; i < lk && str[i] == seek[i]; i++)
        ;
    }
    if (i == lk) {
      $k[$j++] = str.subarray(lk);
      $k[$j++] = str.subarray(0, lk);
      $k[$j++] = true;
    } else {
      $k[$j++] = str;
      $k[$j++] = false;
    }
  }
  function $search(str, seek) {
    if (!(str instanceof Uint8Array)) {
      str = $s(str);
    }
    var ls = str.length;
    if (seek.length == 1) {
      var lk = 1;
      var cd = seek instanceof Uint8Array ? seek[0] : seek.charCodeAt(0);
      for (var i = 0; i < ls && str[i] != cd; i++)
        ;
    } else {
      if (!(seek instanceof Uint8Array)) {
        seek = $s(seek);
      }
      var lk = seek.length;
      var cd = seek[0];
      for (var i = 0; i < ls && str[i] != cd; i++)
        ;
      while (i < ls) {
        for (var j = 1; j < lk && str[i + j] === seek[j]; j++)
          ;
        if (j === lk) {
          break;
        }
        for (i++; i < ls && str[i] != cd; i++)
          ;
      }
    }
    if (i < ls) {
      $k[$j++] = str.subarray(i + lk);
      $k[$j++] = str.subarray(i, i + lk);
      $k[$j++] = str.subarray(0, i);
      $k[$j++] = true;
    } else {
      $k[$j++] = str;
      $k[$j++] = false;
    }
  }
  function $forall(o, cb) {
    if (o instanceof Uint8Array) {
      for (var i = 0, l = o.length; i < l; i++) {
        $k[$j++] = o[i];
        if (cb && cb())
          break;
      }
    } else if (o instanceof Array) {
      for (var a = o.b, i = o.o, l = o.o + o.length; i < l; i++) {
        $k[$j++] = a[i];
        if (cb && cb())
          break;
      }
    } else if (typeof o === "string") {
      for (var i = 0, l = o.length; i < l; i++) {
        $k[$j++] = o.charCodeAt(i);
        if (cb && cb())
          break;
      }
    } else if (o instanceof Map) {
      for (var keys = o.keys(), i = 0, l = o.size; i < l; i++) {
        var id = keys.next().value;
        $k[$j++] = id;
        $k[$j++] = o.get(id);
        if (cb && cb())
          break;
      }
    } else {
      for (var id in o) {
        $k[$j++] = id;
        $k[$j++] = o[id];
        if (cb && cb())
          break;
      }
    }
  }
  function $cleartomark() {
    while ($j > 0 && $k[--$j] !== Infinity)
      ;
  }
  function $counttomark() {
    for (var i = $j - 1; i >= 0 && $k[i] !== Infinity; i--)
      ;
    return $j - i - 1;
  }
  function $aload(a) {
    for (var i = 0, l = a.length, b = a.b, o = a.o; i < l; i++) {
      $k[$j++] = b[o + i];
    }
  }
  function $astore(a) {
    for (var i = 0, l = a.length, b = a.b, o = a.o + l - 1; i < l; i++) {
      b[o - i] = $k[--$j];
    }
    $k[$j++] = a;
  }
  function $eq(a, b) {
    if (typeof a === "string" && typeof b === "string") {
      return a == b;
    }
    if (a instanceof Uint8Array && b instanceof Uint8Array) {
      if (a.length != b.length) {
        return false;
      }
      for (var i = 0, l = a.length; i < l; i++) {
        if (a[i] != b[i]) {
          return false;
        }
      }
      return true;
    }
    if (a instanceof Uint8Array && typeof b === "string" || b instanceof Uint8Array && typeof a === "string") {
      if (a instanceof Uint8Array) {
        a = $z(a);
      } else {
        b = $z(b);
      }
      return a == b;
    }
    return a == b;
  }
  function $ne(a, b) {
    return !$eq(a, b);
  }
  function $lt(a, b) {
    if (a instanceof Uint8Array) {
      a = $z(a);
    }
    if (b instanceof Uint8Array) {
      b = $z(b);
    }
    return a < b;
  }
  function $le(a, b) {
    if (a instanceof Uint8Array) {
      a = $z(a);
    }
    if (b instanceof Uint8Array) {
      b = $z(b);
    }
    return a <= b;
  }
  function $gt(a, b) {
    if (a instanceof Uint8Array) {
      a = $z(a);
    }
    if (b instanceof Uint8Array) {
      b = $z(b);
    }
    return a > b;
  }
  function $ge(a, b) {
    if (a instanceof Uint8Array) {
      a = $z(a);
    }
    if (b instanceof Uint8Array) {
      b = $z(b);
    }
    return a >= b;
  }
  function $an(a, b) {
    return typeof a === "boolean" ? a && b : a & b;
  }
  function $or(a, b) {
    return typeof a === "boolean" ? a || b : a | b;
  }
  function $xo(a, b) {
    return typeof a === "boolean" ? !a && b || a && !b : a ^ b;
  }
  function $nt(a) {
    return typeof a == "boolean" ? !a : ~a;
  }
  var $f = function(fa) {
    return function(v) {
      return Number.isInteger(v) ? v : (fa[0] = v, fa[0]);
    };
  }(new Float32Array(1));
  function bwipp_raiseerror() {
    var info = $k[--$j];
    var name = $k[--$j];
    throw new Error($z(name) + ": " + $z(info));
  }
  function bwipp_processoptions() {
    var dict = $k[--$j];
    var opts = $k[$j - 1];
    var map = opts instanceof Map;
    for (var id in dict) {
      var val;
      if (map) {
        if (!opts.has(id)) {
          continue;
        }
        val = opts.get(id);
      } else {
        if (!opts.hasOwnProperty(id)) {
          continue;
        }
        val = opts[id];
      }
      var def = dict[id];
      var typ = typeof def;
      if (def == null || typ == "number") {
        if (!isFinite(+val)) {
          throw new Error("bwipp.invalidOptionType: " + id + ": not a realtype: " + val);
        }
        if (typeof val == "string") {
          val = +val;
          map ? opts.set(id, val) : opts[id] = val;
        }
      } else if (typ == "boolean") {
        if (val !== true && val !== false) {
          if (val == null || (val | 0) === val) {
            val = !!val;
          } else if (val == "true") {
            val = true;
          } else if (val == "false") {
            val = false;
          } else {
            throw new Error("bwipp.invalidOptionType: " + id + ": not a booleantype: " + val);
          }
          map ? opts.set(id, val) : opts[id] = val;
        }
      } else if (typ == "string" || def instanceof Uint8Array) {
        if (typeof val == "number") {
          val = "" + val;
          map ? opts.set(id, val) : opts[id] = val;
        } else if (typeof val != "string" && !(val instanceof Uint8Array)) {
          throw new Error("bwipp.invalidOptionType: " + id + ": not a stringtype: " + val);
        }
      }
      dict[id] = val;
    }
  }
  function $stack() {
    console.log("[[[");
    for (var i = $j - 1; i >= 0; i--) {
      console.log(tostring($k[i]));
    }
    console.log("]]]");
    function tostring(v) {
      if (v === null) {
        return "null";
      } else if (v === void 0) {
        return "<undefined>";
      } else if (v instanceof Array) {
        var s = "<array," + v.o + "," + v.length + ">[";
        for (var j = v.o, a = v.b, l = v.length + v.o; j < l; j++) {
          s += (j == v.o ? "" : ",") + tostring(a[j]);
        }
        return s + "]";
      } else if (v instanceof Uint8Array) {
        return "(" + $z[v] + ")";
      } else if (v instanceof Map) {
        var s = "<<";
        for (var elt of v) {
          s += (s.length == 2 ? "" : ",") + elt[0] + ":" + tostring(elt[1]);
        }
        return s + ">>";
      } else if (typeof v === "object") {
        var s = "<<";
        for (var id in v) {
          s += (s.length == 2 ? "" : ",") + id + ":" + tostring(v[id]);
        }
        return s + ">>";
      } else if (typeof v === "string") {
        return '"' + v + '"';
      } else {
        return "" + v;
      }
    }
  }
  function bwipp_parseinput() {
    var $1 = Object.create(bwipp_parseinput.$ctx || (bwipp_parseinput.$ctx = {}));
    $1.fncvals = $k[--$j];
    $1.barcode = $k[--$j];
    var _2 = "parse";
    $1[_2] = $get($1.fncvals, _2);
    delete $1.fncvals[_2];
    var _6 = "parsefnc";
    $1[_6] = $get($1.fncvals, _6);
    delete $1.fncvals[_6];
    var _A = "parseonly";
    var _C = $get($1.fncvals, _A) !== void 0;
    $1[_A] = _C;
    delete $1.fncvals[_A];
    var _E = "eci";
    var _G = $get($1.fncvals, _E) !== void 0;
    $1[_E] = _G;
    delete $1.fncvals[_E];
    if (!bwipp_parseinput.__225__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        var _I = $a(["NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL", "BS", "TAB", "LF", "VT", "FF", "CR", "", "", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US"]);
        $k[$j++] = 0;
        for (var _J = 0, _K = _I.length; _J < _K; _J++) {
          var _M = $k[--$j];
          $k[$j++] = $get(_I, _J);
          $k[$j++] = _M;
          $k[$j++] = $f(_M + 1);
        }
        $j--;
        $ctx.ctrl = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_parseinput.$ctx[id] = $ctx[id]);
        bwipp_parseinput.__225__ = 1;
      })();
    }
    $1.msg = $a($1.barcode.length);
    $1.j = 0;
    $k[$j++] = $1.barcode;
    for (; ; ) {
      $search($k[--$j], "^");
      var _T = $k[--$j];
      var _U = $k[--$j];
      $k[$j++] = _T;
      $k[$j++] = _U.length;
      $k[$j++] = $1.msg;
      $k[$j++] = $1.j;
      $k[$j++] = _U;
      $k[$j++] = Infinity;
      var _X = $k[--$j];
      var _Y = $k[--$j];
      $k[$j++] = _X;
      $forall(_Y);
      var _Z = $a();
      var _a = $k[--$j];
      $puti($k[--$j], _a, _Z);
      $1.j = $f($k[--$j] + $1.j);
      if ($k[--$j]) {
        $j--;
        for (var _f = 0, _g = 1; _f < _g; _f++) {
          if ($an($nt($1.parse), $nt($1.parsefnc))) {
            $put($1.msg, $1.j, 94);
            $1.j = $f($1.j + 1);
            break;
          }
          $put($1.msg, $1.j, 94);
          $1.j = $f($1.j + 1);
          if ($1.parse) {
            var _q = $k[--$j];
            $k[$j++] = _q;
            if (_q.length >= 3) {
              var _r = $k[--$j];
              var _s = $geti(_r, 0, 3);
              var _t = $1.ctrl;
              var _u = $get(_t, _s) !== void 0;
              $k[$j++] = _r;
              $k[$j++] = _t;
              $k[$j++] = _s;
              if (_u) {
                $1.j = $f($1.j - 1);
                var _w = $k[--$j];
                $put($1.msg, $1.j, $get($k[--$j], _w));
                $1.j = $f($1.j + 1);
                var _12 = $k[--$j];
                $k[$j++] = $geti(_12, 3, _12.length - 3);
                break;
              } else {
                $j -= 2;
              }
            }
            var _14 = $k[--$j];
            $k[$j++] = _14;
            if (_14.length >= 2) {
              var _15 = $k[--$j];
              var _16 = $geti(_15, 0, 2);
              var _17 = $1.ctrl;
              var _18 = $get(_17, _16) !== void 0;
              $k[$j++] = _15;
              $k[$j++] = _17;
              $k[$j++] = _16;
              if (_18) {
                $1.j = $f($1.j - 1);
                var _1A = $k[--$j];
                $put($1.msg, $1.j, $get($k[--$j], _1A));
                $1.j = $f($1.j + 1);
                var _1G = $k[--$j];
                $k[$j++] = $geti(_1G, 2, _1G.length - 2);
                break;
              } else {
                $j -= 2;
              }
            }
            var _1I = $k[--$j];
            $k[$j++] = _1I;
            if (_1I.length >= 3) {
              var _1J = $k[--$j];
              var _1K = $geti(_1J, 0, 3);
              $k[$j++] = _1J;
              $k[$j++] = true;
              for (var _1L = 0, _1M = _1K.length; _1L < _1M; _1L++) {
                var _1N = $get(_1K, _1L);
                if (_1N < 48 || _1N > 57) {
                  $j--;
                  $k[$j++] = false;
                }
              }
              if ($k[--$j]) {
                var _1P = $k[--$j];
                var _1R = $cvi($geti(_1P, 0, 3));
                $k[$j++] = _1P;
                $k[$j++] = _1R;
                if (_1R > 255) {
                  $j -= 2;
                  $k[$j++] = "bwipp.invalidOrdinal#282";
                  $k[$j++] = "Ordinal must be 000 to 255";
                  bwipp_raiseerror();
                }
                $1.j = $f($1.j - 1);
                $put($1.msg, $1.j, $k[--$j]);
                $1.j = $f($1.j + 1);
                var _1X = $k[--$j];
                $k[$j++] = $geti(_1X, 3, _1X.length - 3);
              }
            }
          }
          if ($or($1.parseonly, $nt($1.parsefnc)) || $get($1.msg, $f($1.j - 1)) != 94) {
            break;
          }
          $1.j = $f($1.j - 1);
          var _1f = $k[--$j];
          $k[$j++] = _1f;
          if (_1f.length < 3) {
            $j--;
            $k[$j++] = "bwipp.truncatedFNC#301";
            $k[$j++] = "Function character truncated";
            bwipp_raiseerror();
          }
          var _1g = $k[--$j];
          $k[$j++] = _1g;
          if ($get(_1g, 0) == 94) {
            $put($1.msg, $1.j, 94);
            $1.j = $f($1.j + 1);
            var _1l = $k[--$j];
            $k[$j++] = $geti(_1l, 1, _1l.length - 1);
            break;
          }
          var _1n = $k[--$j];
          $k[$j++] = _1n;
          if ($eq($geti(_1n, 0, 3), "ECI") && $1.eci) {
            var _1q = $k[--$j];
            $k[$j++] = _1q;
            if (_1q.length < 9) {
              $j--;
              $k[$j++] = "bwipp.truncatedECI#312";
              $k[$j++] = "ECI truncated";
              bwipp_raiseerror();
            }
            var _1r = $k[--$j];
            var _1s = $geti(_1r, 3, 6);
            $k[$j++] = _1r;
            $k[$j++] = _1s;
            for (var _1t = 0, _1u = _1s.length; _1t < _1u; _1t++) {
              var _1v = $get(_1s, _1t);
              if (_1v < 48 || _1v > 57) {
                $j -= 2;
                $k[$j++] = "bwipp.invalidECI#318";
                $k[$j++] = "ECI must be 000000 to 999999";
                bwipp_raiseerror();
              }
            }
            var _1w = $k[--$j];
            $k[$j++] = 0;
            $forall(_1w, function() {
              var _1x = $k[--$j];
              var _1y = $k[--$j];
              $k[$j++] = $f(_1y - $f(_1x - 48)) * 10;
            });
            $put($1.msg, $1.j, ~~($k[--$j] / 10) - 1e6);
            $1.j = $f($1.j + 1);
            var _23 = $k[--$j];
            $k[$j++] = $geti(_23, 9, _23.length - 9);
            break;
          }
          var _25 = $k[--$j];
          $k[$j++] = _25;
          if (_25.length < 4) {
            $j--;
            $k[$j++] = "bwipp.truncatedFNC#329";
            $k[$j++] = "Function character truncated";
            bwipp_raiseerror();
          }
          var _26 = $k[--$j];
          var _27 = $geti(_26, 0, 4);
          var _29 = $get($1.fncvals, _27) !== void 0;
          $k[$j++] = _26;
          $k[$j++] = _27;
          if (!_29) {
            var _2A = $k[--$j];
            var _2B = $s(_2A.length + 28);
            $puti(_2B, 28, _2A);
            $puti(_2B, 0, "Unknown function character: ");
            var _2C = $k[--$j];
            $k[$j++] = _2B;
            $k[$j++] = _2C;
            $j--;
            var _2D = $k[--$j];
            $k[$j++] = "bwipp.unknownFNC#335";
            $k[$j++] = _2D;
            bwipp_raiseerror();
          }
          $put($1.msg, $1.j, $get($1.fncvals, $k[--$j]));
          $1.j = $f($1.j + 1);
          var _2K = $k[--$j];
          $k[$j++] = $geti(_2K, 4, _2K.length - 4);
          break;
        }
      } else {
        break;
      }
    }
    if ($nt($1.parseonly)) {
      $k[$j++] = $geti($1.msg, 0, $1.j);
    } else {
      $k[$j++] = $s($1.j);
      for (var _2U = 0, _2T = $f($1.j - 1); _2U <= _2T; _2U += 1) {
        var _2V = $k[--$j];
        $put(_2V, _2U, $get($1.msg, _2U));
        $k[$j++] = _2V;
      }
    }
  }
  function bwipp_gs1process() {
    var $1 = Object.create(bwipp_gs1process.$ctx || (bwipp_gs1process.$ctx = {}));
    if (!bwipp_gs1process.__2289__) {
      (function() {
        var $ctx = Object.create($1);
        var _1 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 18],
          ["max", 18],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _2 = $a([_1]);
        var _3 = $a([]);
        var _4 = /* @__PURE__ */ new Map([
          ["parts", _2],
          ["dlpkey", _3]
        ]);
        var _5 = $a(["lintcsum", "lintkey"]);
        var _6 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 14],
          ["max", 14],
          ["opt", false],
          ["linters", _5]
        ]);
        var _7 = $a([_6]);
        var _8 = $a(["02", "255", "37"]);
        var _9 = $a(["22", "10", "21"]);
        var _A = $a(["235"]);
        var _B = $a([_9, _A]);
        var _C = /* @__PURE__ */ new Map([
          ["parts", _7],
          ["ex", _8],
          ["dlpkey", _B]
        ]);
        var _D = $a(["lintcsum", "lintkey"]);
        var _E = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 14],
          ["max", 14],
          ["opt", false],
          ["linters", _D]
        ]);
        var _F = $a([_E]);
        var _G = $a(["37"]);
        var _H = $a([_G]);
        var _I = /* @__PURE__ */ new Map([
          ["parts", _F],
          ["req", _H]
        ]);
        var _K = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _O = /* @__PURE__ */ new Map([
          ["parts", $a([_K])],
          ["req", $a([$a(["01", "02", "8006", "8026"])])]
        ]);
        var _Q = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmd0"])]
        ]);
        var _U = /* @__PURE__ */ new Map([
          ["parts", $a([_Q])],
          ["req", $a([$a(["01", "02", "8006", "8026"])])]
        ]);
        var _W = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmd0"])]
        ]);
        var _a = /* @__PURE__ */ new Map([
          ["parts", $a([_W])],
          ["req", $a([$a(["8020"])])]
        ]);
        var _c = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmd0"])]
        ]);
        var _g = /* @__PURE__ */ new Map([
          ["parts", $a([_c])],
          ["req", $a([$a(["01", "02", "8006", "8026"])])]
        ]);
        var _i = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmd0"])]
        ]);
        var _m = /* @__PURE__ */ new Map([
          ["parts", $a([_i])],
          ["req", $a([$a(["01", "02", "255", "8006", "8026"])])]
        ]);
        var _o = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 2],
          ["max", 2],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _s = /* @__PURE__ */ new Map([
          ["parts", $a([_o])],
          ["req", $a([$a(["01", "02", "8006", "8026"])])]
        ]);
        var _u = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _z = /* @__PURE__ */ new Map([
          ["parts", $a([_u])],
          ["ex", $a(["235"])],
          ["req", $a([$a(["01", "8006"])])]
        ]);
        var _11 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _15 = /* @__PURE__ */ new Map([
          ["parts", $a([_11])],
          ["req", $a([$a(["01"])])]
        ]);
        var _17 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 28],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _1B = /* @__PURE__ */ new Map([
          ["parts", $a([_17])],
          ["req", $a([$a(["01"])])]
        ]);
        var _1D = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _1H = /* @__PURE__ */ new Map([
          ["parts", $a([_1D])],
          ["req", $a([$a(["01", "02", "8006", "8026"])])]
        ]);
        var _1J = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _1N = /* @__PURE__ */ new Map([
          ["parts", $a([_1J])],
          ["req", $a([$a(["01", "02", "8006", "8026"])])]
        ]);
        var _1P = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _1T = /* @__PURE__ */ new Map([
          ["parts", $a([_1P])],
          ["req", $a([$a(["01"])])]
        ]);
        var _1V = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _1a = /* @__PURE__ */ new Map([
          ["parts", $a([_1V])],
          ["req", $a([$a(["01", "8006"]), $a(["21"])])]
        ]);
        var _1c = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _1g = /* @__PURE__ */ new Map([
          ["parts", $a([_1c])],
          ["req", $a([$a(["01", "8006"])])]
        ]);
        var _1i = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _1k = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 17],
          ["opt", true],
          ["linters", $a([])]
        ]);
        var _1n = /* @__PURE__ */ new Map([
          ["parts", $a([_1i, _1k])],
          ["dlpkey", $a([])]
        ]);
        var _1p = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _1t = /* @__PURE__ */ new Map([
          ["parts", $a([_1p])],
          ["req", $a([$a(["414"])])]
        ]);
        var _1v = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _1x = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 12],
          ["opt", true],
          ["linters", $a([])]
        ]);
        var _21 = /* @__PURE__ */ new Map([
          ["parts", $a([_1v, _1x])],
          ["ex", $a(["01", "02", "415", "8006", "8020", "8026"])],
          ["dlpkey", $a([])]
        ]);
        var _22 = $a([]);
        var _23 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 8],
          ["opt", false],
          ["linters", _22]
        ]);
        var _27 = /* @__PURE__ */ new Map([
          ["parts", $a([_23])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _29 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _2E = /* @__PURE__ */ new Map([
          ["parts", $a([_29])],
          ["ex", $a(["310n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _2G = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _2L = /* @__PURE__ */ new Map([
          ["parts", $a([_2G])],
          ["ex", $a(["311n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _2N = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _2S = /* @__PURE__ */ new Map([
          ["parts", $a([_2N])],
          ["ex", $a(["312n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _2U = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _2Z = /* @__PURE__ */ new Map([
          ["parts", $a([_2U])],
          ["ex", $a(["313n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _2b = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _2g = /* @__PURE__ */ new Map([
          ["parts", $a([_2b])],
          ["ex", $a(["314n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _2i = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _2n = /* @__PURE__ */ new Map([
          ["parts", $a([_2i])],
          ["ex", $a(["315n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _2p = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _2u = /* @__PURE__ */ new Map([
          ["parts", $a([_2p])],
          ["ex", $a(["316n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _2w = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _31 = /* @__PURE__ */ new Map([
          ["parts", $a([_2w])],
          ["ex", $a(["320n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _33 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _38 = /* @__PURE__ */ new Map([
          ["parts", $a([_33])],
          ["ex", $a(["321n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _3A = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _3F = /* @__PURE__ */ new Map([
          ["parts", $a([_3A])],
          ["ex", $a(["322n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _3H = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _3M = /* @__PURE__ */ new Map([
          ["parts", $a([_3H])],
          ["ex", $a(["323n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _3O = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _3T = /* @__PURE__ */ new Map([
          ["parts", $a([_3O])],
          ["ex", $a(["324n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _3V = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _3a = /* @__PURE__ */ new Map([
          ["parts", $a([_3V])],
          ["ex", $a(["325n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _3c = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _3h = /* @__PURE__ */ new Map([
          ["parts", $a([_3c])],
          ["ex", $a(["326n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _3j = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _3o = /* @__PURE__ */ new Map([
          ["parts", $a([_3j])],
          ["ex", $a(["327n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _3q = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _3v = /* @__PURE__ */ new Map([
          ["parts", $a([_3q])],
          ["ex", $a(["328n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _3x = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _42 = /* @__PURE__ */ new Map([
          ["parts", $a([_3x])],
          ["ex", $a(["329n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _44 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _49 = /* @__PURE__ */ new Map([
          ["parts", $a([_44])],
          ["ex", $a(["330n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _4B = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _4G = /* @__PURE__ */ new Map([
          ["parts", $a([_4B])],
          ["ex", $a(["331n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _4I = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _4N = /* @__PURE__ */ new Map([
          ["parts", $a([_4I])],
          ["ex", $a(["332n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _4P = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _4U = /* @__PURE__ */ new Map([
          ["parts", $a([_4P])],
          ["ex", $a(["333n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _4W = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _4b = /* @__PURE__ */ new Map([
          ["parts", $a([_4W])],
          ["ex", $a(["334n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _4d = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _4i = /* @__PURE__ */ new Map([
          ["parts", $a([_4d])],
          ["ex", $a(["335n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _4k = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _4p = /* @__PURE__ */ new Map([
          ["parts", $a([_4k])],
          ["ex", $a(["336n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _4r = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _4w = /* @__PURE__ */ new Map([
          ["parts", $a([_4r])],
          ["ex", $a(["337n"])],
          ["req", $a([$a(["01"])])]
        ]);
        var _4y = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _53 = /* @__PURE__ */ new Map([
          ["parts", $a([_4y])],
          ["ex", $a(["340n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _55 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _5A = /* @__PURE__ */ new Map([
          ["parts", $a([_55])],
          ["ex", $a(["341n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _5C = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _5H = /* @__PURE__ */ new Map([
          ["parts", $a([_5C])],
          ["ex", $a(["342n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _5J = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _5O = /* @__PURE__ */ new Map([
          ["parts", $a([_5J])],
          ["ex", $a(["343n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _5Q = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _5V = /* @__PURE__ */ new Map([
          ["parts", $a([_5Q])],
          ["ex", $a(["344n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _5X = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _5c = /* @__PURE__ */ new Map([
          ["parts", $a([_5X])],
          ["ex", $a(["345n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _5e = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _5j = /* @__PURE__ */ new Map([
          ["parts", $a([_5e])],
          ["ex", $a(["346n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _5l = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _5q = /* @__PURE__ */ new Map([
          ["parts", $a([_5l])],
          ["ex", $a(["347n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _5s = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _5x = /* @__PURE__ */ new Map([
          ["parts", $a([_5s])],
          ["ex", $a(["348n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _5z = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _64 = /* @__PURE__ */ new Map([
          ["parts", $a([_5z])],
          ["ex", $a(["349n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _66 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _6B = /* @__PURE__ */ new Map([
          ["parts", $a([_66])],
          ["ex", $a(["350n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _6D = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _6I = /* @__PURE__ */ new Map([
          ["parts", $a([_6D])],
          ["ex", $a(["351n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _6K = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _6P = /* @__PURE__ */ new Map([
          ["parts", $a([_6K])],
          ["ex", $a(["352n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _6R = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _6W = /* @__PURE__ */ new Map([
          ["parts", $a([_6R])],
          ["ex", $a(["353n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _6Y = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _6d = /* @__PURE__ */ new Map([
          ["parts", $a([_6Y])],
          ["ex", $a(["354n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _6f = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _6k = /* @__PURE__ */ new Map([
          ["parts", $a([_6f])],
          ["ex", $a(["355n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _6m = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _6r = /* @__PURE__ */ new Map([
          ["parts", $a([_6m])],
          ["ex", $a(["356n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _6t = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _6y = /* @__PURE__ */ new Map([
          ["parts", $a([_6t])],
          ["ex", $a(["357n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _70 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _75 = /* @__PURE__ */ new Map([
          ["parts", $a([_70])],
          ["ex", $a(["360n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _77 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _7C = /* @__PURE__ */ new Map([
          ["parts", $a([_77])],
          ["ex", $a(["361n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _7E = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _7J = /* @__PURE__ */ new Map([
          ["parts", $a([_7E])],
          ["ex", $a(["362n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _7L = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _7Q = /* @__PURE__ */ new Map([
          ["parts", $a([_7L])],
          ["ex", $a(["363n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _7S = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _7X = /* @__PURE__ */ new Map([
          ["parts", $a([_7S])],
          ["ex", $a(["364n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _7Z = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _7e = /* @__PURE__ */ new Map([
          ["parts", $a([_7Z])],
          ["ex", $a(["365n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _7g = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _7l = /* @__PURE__ */ new Map([
          ["parts", $a([_7g])],
          ["ex", $a(["366n"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _7n = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _7s = /* @__PURE__ */ new Map([
          ["parts", $a([_7n])],
          ["ex", $a(["367n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _7u = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _7z = /* @__PURE__ */ new Map([
          ["parts", $a([_7u])],
          ["ex", $a(["368n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _81 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _86 = /* @__PURE__ */ new Map([
          ["parts", $a([_81])],
          ["ex", $a(["369n"])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _88 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 8],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _8D = /* @__PURE__ */ new Map([
          ["parts", $a([_88])],
          ["req", $a([$a(["00"]), $a(["02", "8026"])])]
        ]);
        var _8F = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 15],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _8K = /* @__PURE__ */ new Map([
          ["parts", $a([_8F])],
          ["ex", $a(["390n", "391n", "394n", "8111"])],
          ["req", $a([$a(["255", "8020"])])]
        ]);
        var _8M = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 3],
          ["max", 3],
          ["opt", false],
          ["linters", $a(["lintiso4217"])]
        ]);
        var _8O = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 15],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _8T = /* @__PURE__ */ new Map([
          ["parts", $a([_8M, _8O])],
          ["ex", $a(["391n"])],
          ["req", $a([$a(["8020"])])]
        ]);
        var _8V = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 15],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _8b = /* @__PURE__ */ new Map([
          ["parts", $a([_8V])],
          ["ex", $a(["392n", "393n"])],
          ["req", $a([$a(["01"]), $a(["30", "31nn", "32nn", "35nn", "36nn"])])]
        ]);
        var _8d = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 3],
          ["max", 3],
          ["opt", false],
          ["linters", $a(["lintiso4217"])]
        ]);
        var _8f = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 15],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _8k = /* @__PURE__ */ new Map([
          ["parts", $a([_8d, _8f])],
          ["ex", $a(["393n"])],
          ["req", $a([$a(["30", "31nn", "32nn", "35nn", "36nn"])])]
        ]);
        var _8m = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 4],
          ["max", 4],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _8r = /* @__PURE__ */ new Map([
          ["parts", $a([_8m])],
          ["ex", $a(["394n", "8111"])],
          ["req", $a([$a(["255"])])]
        ]);
        var _8t = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _8y = /* @__PURE__ */ new Map([
          ["parts", $a([_8t])],
          ["ex", $a(["392n", "393n", "395n", "8005"])],
          ["req", $a([$a(["30", "31nn", "32nn", "35nn", "36nn"])])]
        ]);
        var _90 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _92 = /* @__PURE__ */ new Map([
          ["parts", $a([_90])]
        ]);
        var _94 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a(["lintkey"])]
        ]);
        var _97 = /* @__PURE__ */ new Map([
          ["parts", $a([_94])],
          ["dlpkey", $a([])]
        ]);
        var _99 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 17],
          ["max", 17],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _9C = /* @__PURE__ */ new Map([
          ["parts", $a([_99])],
          ["dlpkey", $a([])]
        ]);
        var _9E = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _9I = /* @__PURE__ */ new Map([
          ["parts", $a([_9E])],
          ["req", $a([$a(["00"])])]
        ]);
        var _9K = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _9M = /* @__PURE__ */ new Map([
          ["parts", $a([_9K])]
        ]);
        var _9O = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _9T = /* @__PURE__ */ new Map([
          ["parts", $a([_9O])],
          ["dlpkey", $a([$a(["254"]), $a(["7040"])])]
        ]);
        var _9V = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _9b = /* @__PURE__ */ new Map([
          ["parts", $a([_9V])],
          ["req", $a([$a(["8020"])])],
          ["dlpkey", $a([$a(["8020"])])]
        ]);
        var _9d = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _9f = /* @__PURE__ */ new Map([
          ["parts", $a([_9d])]
        ]);
        var _9h = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _9l = /* @__PURE__ */ new Map([
          ["parts", $a([_9h])],
          ["dlpkey", $a([$a(["7040"])])]
        ]);
        var _9n = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _9q = /* @__PURE__ */ new Map([
          ["parts", $a([_9n])],
          ["ex", $a(["421"])]
        ]);
        var _9s = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 3],
          ["max", 3],
          ["opt", false],
          ["linters", $a(["lintiso3166"])]
        ]);
        var _9u = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 9],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _9x = /* @__PURE__ */ new Map([
          ["parts", $a([_9s, _9u])],
          ["ex", $a(["4307"])]
        ]);
        var _9z = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 3],
          ["max", 3],
          ["opt", false],
          ["linters", $a(["lintiso3166"])]
        ]);
        var _A4 = /* @__PURE__ */ new Map([
          ["parts", $a([_9z])],
          ["ex", $a(["426"])],
          ["req", $a([$a(["01", "02", "8006", "8026"])])]
        ]);
        var _A6 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 15],
          ["opt", false],
          ["linters", $a(["lintiso3166list"])]
        ]);
        var _AB = /* @__PURE__ */ new Map([
          ["parts", $a([_A6])],
          ["ex", $a(["426"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _AD = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 3],
          ["max", 3],
          ["opt", false],
          ["linters", $a(["lintiso3166"])]
        ]);
        var _AI = /* @__PURE__ */ new Map([
          ["parts", $a([_AD])],
          ["ex", $a(["426"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _AK = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 15],
          ["opt", false],
          ["linters", $a(["lintiso3166list"])]
        ]);
        var _AP = /* @__PURE__ */ new Map([
          ["parts", $a([_AK])],
          ["ex", $a(["426"])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _AR = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 3],
          ["max", 3],
          ["opt", false],
          ["linters", $a(["lintiso3166"])]
        ]);
        var _AV = /* @__PURE__ */ new Map([
          ["parts", $a([_AR])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _AX = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 3],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Ac = /* @__PURE__ */ new Map([
          ["parts", $a([_AX])],
          ["req", $a([$a(["01", "02"]), $a(["422"])])]
        ]);
        var _Ae = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 35],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _Ai = /* @__PURE__ */ new Map([
          ["parts", $a([_Ae])],
          ["req", $a([$a(["00"])])]
        ]);
        var _Ak = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _Ao = /* @__PURE__ */ new Map([
          ["parts", $a([_Ak])],
          ["req", $a([$a(["00"])])]
        ]);
        var _Aq = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _Au = /* @__PURE__ */ new Map([
          ["parts", $a([_Aq])],
          ["req", $a([$a(["4302"])])]
        ]);
        var _Aw = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _B0 = /* @__PURE__ */ new Map([
          ["parts", $a([_Aw])],
          ["req", $a([$a(["00"])])]
        ]);
        var _B2 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 2],
          ["max", 2],
          ["opt", false],
          ["linters", $a(["lintiso3166alpha2"])]
        ]);
        var _B6 = /* @__PURE__ */ new Map([
          ["parts", $a([_B2])],
          ["req", $a([$a(["00"])])]
        ]);
        var _B8 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _BC = /* @__PURE__ */ new Map([
          ["parts", $a([_B8])],
          ["req", $a([$a(["00"])])]
        ]);
        var _BE = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 20],
          ["max", 20],
          ["opt", false],
          ["linters", $a(["lintlatlong"])]
        ]);
        var _BI = /* @__PURE__ */ new Map([
          ["parts", $a([_BE])],
          ["req", $a([$a(["00"])])]
        ]);
        var _BK = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 35],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _BO = /* @__PURE__ */ new Map([
          ["parts", $a([_BK])],
          ["req", $a([$a(["00"])])]
        ]);
        var _BQ = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _BU = /* @__PURE__ */ new Map([
          ["parts", $a([_BQ])],
          ["req", $a([$a(["00"])])]
        ]);
        var _BW = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _Ba = /* @__PURE__ */ new Map([
          ["parts", $a([_BW])],
          ["req", $a([$a(["4312"])])]
        ]);
        var _Bc = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _Bg = /* @__PURE__ */ new Map([
          ["parts", $a([_Bc])],
          ["req", $a([$a(["00"])])]
        ]);
        var _Bi = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 2],
          ["max", 2],
          ["opt", false],
          ["linters", $a(["lintiso3166alpha2"])]
        ]);
        var _Bm = /* @__PURE__ */ new Map([
          ["parts", $a([_Bi])],
          ["req", $a([$a(["00"])])]
        ]);
        var _Bo = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Bs = /* @__PURE__ */ new Map([
          ["parts", $a([_Bo])],
          ["req", $a([$a(["00"])])]
        ]);
        var _Bu = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _By = /* @__PURE__ */ new Map([
          ["parts", $a([_Bu])],
          ["req", $a([$a(["00"])])]
        ]);
        var _C0 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 35],
          ["opt", false],
          ["linters", $a(["lintpcenc"])]
        ]);
        var _C4 = /* @__PURE__ */ new Map([
          ["parts", $a([_C0])],
          ["req", $a([$a(["00"])])]
        ]);
        var _C6 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 1],
          ["opt", false],
          ["linters", $a(["lintyesno"])]
        ]);
        var _CA = /* @__PURE__ */ new Map([
          ["parts", $a([_C6])],
          ["req", $a([$a(["00"])])]
        ]);
        var _CC = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmd0"])]
        ]);
        var _CE = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 4],
          ["max", 4],
          ["opt", false],
          ["linters", $a(["linthhmm"])]
        ]);
        var _CI = /* @__PURE__ */ new Map([
          ["parts", $a([_CC, _CE])],
          ["req", $a([$a(["00"])])]
        ]);
        var _CK = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmdd"])]
        ]);
        var _CO = /* @__PURE__ */ new Map([
          ["parts", $a([_CK])],
          ["req", $a([$a(["00"])])]
        ]);
        var _CQ = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _CU = /* @__PURE__ */ new Map([
          ["parts", $a([_CQ])],
          ["req", $a([$a(["01", "02", "8006", "8026"])])]
        ]);
        var _CW = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Ca = /* @__PURE__ */ new Map([
          ["parts", $a([_CW])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _Cc = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmdd"])]
        ]);
        var _Ce = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 4],
          ["max", 4],
          ["opt", false],
          ["linters", $a(["linthhmm"])]
        ]);
        var _Ci = /* @__PURE__ */ new Map([
          ["parts", $a([_Cc, _Ce])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _Ck = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 4],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Cp = /* @__PURE__ */ new Map([
          ["parts", $a([_Ck])],
          ["req", $a([$a(["01"]), $a(["10"])])]
        ]);
        var _Cr = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 12],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Cv = /* @__PURE__ */ new Map([
          ["parts", $a([_Cr])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _Cx = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmdd"])]
        ]);
        var _D1 = /* @__PURE__ */ new Map([
          ["parts", $a([_Cx])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _D3 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmdd"])]
        ]);
        var _D5 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", true],
          ["linters", $a(["lintyymmdd"])]
        ]);
        var _D9 = /* @__PURE__ */ new Map([
          ["parts", $a([_D3, _D5])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _DB = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 3],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _DF = /* @__PURE__ */ new Map([
          ["parts", $a([_DB])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _DH = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 10],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _DL = /* @__PURE__ */ new Map([
          ["parts", $a([_DH])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _DN = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 2],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _DR = /* @__PURE__ */ new Map([
          ["parts", $a([_DN])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _DT = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a(["lintyymmdd"])]
        ]);
        var _DV = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 4],
          ["max", 4],
          ["opt", true],
          ["linters", $a(["linthhmm"])]
        ]);
        var _DZ = /* @__PURE__ */ new Map([
          ["parts", $a([_DT, _DV])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _Db = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Dg = /* @__PURE__ */ new Map([
          ["parts", $a([_Db])],
          ["req", $a([$a(["01", "8006"]), $a(["416"])])]
        ]);
        var _Di = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Dm = /* @__PURE__ */ new Map([
          ["parts", $a([_Di])],
          ["req", $a([$a(["01", "8006"])])]
        ]);
        var _Do = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Ds = /* @__PURE__ */ new Map([
          ["parts", $a([_Do])],
          ["req", $a([$a(["7021"])])]
        ]);
        var _Du = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a(["lintkey"])]
        ]);
        var _Dw = /* @__PURE__ */ new Map([
          ["parts", $a([_Du])]
        ]);
        var _Dy = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 3],
          ["max", 3],
          ["opt", false],
          ["linters", $a(["lintiso3166999"])]
        ]);
        var _E0 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 27],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _E4 = /* @__PURE__ */ new Map([
          ["parts", $a([_Dy, _E0])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _E6 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 1],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _E8 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 1],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _EA = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 1],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _EC = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 1],
          ["opt", false],
          ["linters", $a(["lintimporteridx"])]
        ]);
        var _EE = /* @__PURE__ */ new Map([
          ["parts", $a([_E6, _E8, _EA, _EC])]
        ]);
        var _EG = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _EK = /* @__PURE__ */ new Map([
          ["parts", $a([_EG])],
          ["req", $a([$a(["01"])])]
        ]);
        var _EM = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 2],
          ["max", 2],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _EO = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 28],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _ES = /* @__PURE__ */ new Map([
          ["parts", $a([_EM, _EO])],
          ["req", $a([$a(["01", "8004"])])]
        ]);
        var _EU = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _EY = /* @__PURE__ */ new Map([
          ["parts", $a([_EU])],
          ["req", $a([$a(["01", "8006"])])]
        ]);
        var _Ea = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 2],
          ["max", 2],
          ["opt", false],
          ["linters", $a(["lintmediatype"])]
        ]);
        var _Ee = /* @__PURE__ */ new Map([
          ["parts", $a([_Ea])],
          ["req", $a([$a(["8017", "8018"])])]
        ]);
        var _Eg = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 25],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Ek = /* @__PURE__ */ new Map([
          ["parts", $a([_Eg])],
          ["req", $a([$a(["8017", "8018"])])]
        ]);
        var _Em = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 4],
          ["max", 4],
          ["opt", false],
          ["linters", $a(["lintnonzero"])]
        ]);
        var _Eo = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 5],
          ["max", 5],
          ["opt", false],
          ["linters", $a(["lintnonzero"])]
        ]);
        var _Eq = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 3],
          ["max", 3],
          ["opt", false],
          ["linters", $a(["lintnonzero"])]
        ]);
        var _Es = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 1],
          ["opt", false],
          ["linters", $a(["lintwinding"])]
        ]);
        var _Eu = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 1],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Ey = /* @__PURE__ */ new Map([
          ["parts", $a([_Em, _Eo, _Eq, _Es, _Eu])],
          ["req", $a([$a(["01"])])]
        ]);
        var _F0 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _F2 = /* @__PURE__ */ new Map([
          ["parts", $a([_F0])]
        ]);
        var _F4 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 1],
          ["opt", false],
          ["linters", $a(["lintzero"])]
        ]);
        var _F6 = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 13],
          ["max", 13],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _F8 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 16],
          ["opt", true],
          ["linters", $a([])]
        ]);
        var _FB = /* @__PURE__ */ new Map([
          ["parts", $a([_F4, _F6, _F8])],
          ["dlpkey", $a([])]
        ]);
        var _FD = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a(["lintkey"])]
        ]);
        var _FH = /* @__PURE__ */ new Map([
          ["parts", $a([_FD])],
          ["dlpkey", $a([$a(["7040"])])]
        ]);
        var _FJ = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 6],
          ["max", 6],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _FN = /* @__PURE__ */ new Map([
          ["parts", $a([_FJ])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _FP = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 14],
          ["max", 14],
          ["opt", false],
          ["linters", $a(["lintcsum"])]
        ]);
        var _FR = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 4],
          ["max", 4],
          ["opt", false],
          ["linters", $a(["lintpieceoftotal"])]
        ]);
        var _FW = /* @__PURE__ */ new Map([
          ["parts", $a([_FP, _FR])],
          ["ex", $a(["01", "37"])],
          ["dlpkey", $a([$a(["22", "10", "21"])])]
        ]);
        var _FY = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 34],
          ["opt", false],
          ["linters", $a(["lintiban"])]
        ]);
        var _Fc = /* @__PURE__ */ new Map([
          ["parts", $a([_FY])],
          ["req", $a([$a(["415"])])]
        ]);
        var _Fe = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 8],
          ["max", 8],
          ["opt", false],
          ["linters", $a(["lintyymmddhh"])]
        ]);
        var _Fg = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 4],
          ["opt", true],
          ["linters", $a(["lintmmoptss"])]
        ]);
        var _Fk = /* @__PURE__ */ new Map([
          ["parts", $a([_Fe, _Fg])],
          ["req", $a([$a(["01", "02"])])]
        ]);
        var _Fm = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 50],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Fq = /* @__PURE__ */ new Map([
          ["parts", $a([_Fm])],
          ["req", $a([$a(["00", "01"])])]
        ]);
        var _Fs = /* @__PURE__ */ new Map([
          ["cset", "Y"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a(["lintkey"])]
        ]);
        var _Fw = /* @__PURE__ */ new Map([
          ["parts", $a([_Fs])],
          ["dlpkey", $a([$a(["8011"])])]
        ]);
        var _Fy = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 12],
          ["opt", false],
          ["linters", $a(["lintnozeroprefix"])]
        ]);
        var _G2 = /* @__PURE__ */ new Map([
          ["parts", $a([_Fy])],
          ["req", $a([$a(["8010"])])]
        ]);
        var _G4 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 20],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _G8 = /* @__PURE__ */ new Map([
          ["parts", $a([_G4])],
          ["req", $a([$a(["01", "8006"])])]
        ]);
        var _GA = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 25],
          ["opt", false],
          ["linters", $a(["lintcsumalpha", "lintkey"])]
        ]);
        var _GD = /* @__PURE__ */ new Map([
          ["parts", $a([_GA])],
          ["dlpkey", $a([])]
        ]);
        var _GF = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 18],
          ["max", 18],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _GK = /* @__PURE__ */ new Map([
          ["parts", $a([_GF])],
          ["ex", $a(["8018"])],
          ["dlpkey", $a([$a(["8019"])])]
        ]);
        var _GM = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 18],
          ["max", 18],
          ["opt", false],
          ["linters", $a(["lintcsum", "lintkey"])]
        ]);
        var _GR = /* @__PURE__ */ new Map([
          ["parts", $a([_GM])],
          ["ex", $a(["8017"])],
          ["dlpkey", $a([$a(["8019"])])]
        ]);
        var _GT = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 1],
          ["max", 10],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _GX = /* @__PURE__ */ new Map([
          ["parts", $a([_GT])],
          ["req", $a([$a(["8017", "8018"])])]
        ]);
        var _GZ = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 25],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Gd = /* @__PURE__ */ new Map([
          ["parts", $a([_GZ])],
          ["req", $a([$a(["415"])])]
        ]);
        var _Gf = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 14],
          ["max", 14],
          ["opt", false],
          ["linters", $a(["lintcsum"])]
        ]);
        var _Gh = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 4],
          ["max", 4],
          ["opt", false],
          ["linters", $a(["lintpieceoftotal"])]
        ]);
        var _Gm = /* @__PURE__ */ new Map([
          ["parts", $a([_Gf, _Gh])],
          ["ex", $a(["02", "8006"])],
          ["req", $a([$a(["37"])])]
        ]);
        var _Go = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a(["lintcouponcode"])]
        ]);
        var _Gq = /* @__PURE__ */ new Map([
          ["parts", $a([_Go])]
        ]);
        var _Gs = /* @__PURE__ */ new Map([
          ["cset", "N"],
          ["min", 4],
          ["max", 4],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _Gw = /* @__PURE__ */ new Map([
          ["parts", $a([_Gs])],
          ["req", $a([$a(["255"])])]
        ]);
        var _Gy = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a(["lintcouponposoffer"])]
        ]);
        var _H0 = /* @__PURE__ */ new Map([
          ["parts", $a([_Gy])]
        ]);
        var _H2 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 70],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _H6 = /* @__PURE__ */ new Map([
          ["parts", $a([_H2])],
          ["req", $a([$a(["01"])])]
        ]);
        var _H8 = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 30],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _HA = /* @__PURE__ */ new Map([
          ["parts", $a([_H8])]
        ]);
        var _HC = /* @__PURE__ */ new Map([
          ["cset", "X"],
          ["min", 1],
          ["max", 90],
          ["opt", false],
          ["linters", $a([])]
        ]);
        var _HE = /* @__PURE__ */ new Map([
          ["parts", $a([_HC])]
        ]);
        var _HF = /* @__PURE__ */ new Map([
          ["00", _4],
          ["01", _C],
          ["02", _I],
          ["10", _O],
          ["11", _U],
          ["12", _a],
          ["13", _g],
          ["15", _g],
          ["16", _g],
          ["17", _m],
          ["20", _s],
          ["21", _z],
          ["22", _15],
          ["235", _1B],
          ["240", _1H],
          ["241", _1H],
          ["242", _1N],
          ["243", _1T],
          ["250", _1a],
          ["251", _1g],
          ["253", _1n],
          ["254", _1t],
          ["255", _21],
          ["30", _27],
          ["3100", _2E],
          ["3101", _2E],
          ["3102", _2E],
          ["3103", _2E],
          ["3104", _2E],
          ["3105", _2E],
          ["3110", _2L],
          ["3111", _2L],
          ["3112", _2L],
          ["3113", _2L],
          ["3114", _2L],
          ["3115", _2L],
          ["3120", _2S],
          ["3121", _2S],
          ["3122", _2S],
          ["3123", _2S],
          ["3124", _2S],
          ["3125", _2S],
          ["3130", _2Z],
          ["3131", _2Z],
          ["3132", _2Z],
          ["3133", _2Z],
          ["3134", _2Z],
          ["3135", _2Z],
          ["3140", _2g],
          ["3141", _2g],
          ["3142", _2g],
          ["3143", _2g],
          ["3144", _2g],
          ["3145", _2g],
          ["3150", _2n],
          ["3151", _2n],
          ["3152", _2n],
          ["3153", _2n],
          ["3154", _2n],
          ["3155", _2n],
          ["3160", _2u],
          ["3161", _2u],
          ["3162", _2u],
          ["3163", _2u],
          ["3164", _2u],
          ["3165", _2u],
          ["3200", _31],
          ["3201", _31],
          ["3202", _31],
          ["3203", _31],
          ["3204", _31],
          ["3205", _31],
          ["3210", _38],
          ["3211", _38],
          ["3212", _38],
          ["3213", _38],
          ["3214", _38],
          ["3215", _38],
          ["3220", _3F],
          ["3221", _3F],
          ["3222", _3F],
          ["3223", _3F],
          ["3224", _3F],
          ["3225", _3F],
          ["3230", _3M],
          ["3231", _3M],
          ["3232", _3M],
          ["3233", _3M],
          ["3234", _3M],
          ["3235", _3M],
          ["3240", _3T],
          ["3241", _3T],
          ["3242", _3T],
          ["3243", _3T],
          ["3244", _3T],
          ["3245", _3T],
          ["3250", _3a],
          ["3251", _3a],
          ["3252", _3a],
          ["3253", _3a],
          ["3254", _3a],
          ["3255", _3a],
          ["3260", _3h],
          ["3261", _3h],
          ["3262", _3h],
          ["3263", _3h],
          ["3264", _3h],
          ["3265", _3h],
          ["3270", _3o],
          ["3271", _3o],
          ["3272", _3o],
          ["3273", _3o],
          ["3274", _3o],
          ["3275", _3o],
          ["3280", _3v],
          ["3281", _3v],
          ["3282", _3v],
          ["3283", _3v],
          ["3284", _3v],
          ["3285", _3v],
          ["3290", _42],
          ["3291", _42],
          ["3292", _42],
          ["3293", _42],
          ["3294", _42],
          ["3295", _42],
          ["3300", _49],
          ["3301", _49],
          ["3302", _49],
          ["3303", _49],
          ["3304", _49],
          ["3305", _49],
          ["3310", _4G],
          ["3311", _4G],
          ["3312", _4G],
          ["3313", _4G],
          ["3314", _4G],
          ["3315", _4G],
          ["3320", _4N],
          ["3321", _4N],
          ["3322", _4N],
          ["3323", _4N],
          ["3324", _4N],
          ["3325", _4N],
          ["3330", _4U],
          ["3331", _4U],
          ["3332", _4U],
          ["3333", _4U],
          ["3334", _4U],
          ["3335", _4U],
          ["3340", _4b],
          ["3341", _4b],
          ["3342", _4b],
          ["3343", _4b],
          ["3344", _4b],
          ["3345", _4b],
          ["3350", _4i],
          ["3351", _4i],
          ["3352", _4i],
          ["3353", _4i],
          ["3354", _4i],
          ["3355", _4i],
          ["3360", _4p],
          ["3361", _4p],
          ["3362", _4p],
          ["3363", _4p],
          ["3364", _4p],
          ["3365", _4p],
          ["3370", _4w],
          ["3371", _4w],
          ["3372", _4w],
          ["3373", _4w],
          ["3374", _4w],
          ["3375", _4w],
          ["3400", _53],
          ["3401", _53],
          ["3402", _53],
          ["3403", _53],
          ["3404", _53],
          ["3405", _53],
          ["3410", _5A],
          ["3411", _5A],
          ["3412", _5A],
          ["3413", _5A],
          ["3414", _5A],
          ["3415", _5A],
          ["3420", _5H],
          ["3421", _5H],
          ["3422", _5H],
          ["3423", _5H],
          ["3424", _5H],
          ["3425", _5H],
          ["3430", _5O],
          ["3431", _5O],
          ["3432", _5O],
          ["3433", _5O],
          ["3434", _5O],
          ["3435", _5O],
          ["3440", _5V],
          ["3441", _5V],
          ["3442", _5V],
          ["3443", _5V],
          ["3444", _5V],
          ["3445", _5V],
          ["3450", _5c],
          ["3451", _5c],
          ["3452", _5c],
          ["3453", _5c],
          ["3454", _5c],
          ["3455", _5c],
          ["3460", _5j],
          ["3461", _5j],
          ["3462", _5j],
          ["3463", _5j],
          ["3464", _5j],
          ["3465", _5j],
          ["3470", _5q],
          ["3471", _5q],
          ["3472", _5q],
          ["3473", _5q],
          ["3474", _5q],
          ["3475", _5q],
          ["3480", _5x],
          ["3481", _5x],
          ["3482", _5x],
          ["3483", _5x],
          ["3484", _5x],
          ["3485", _5x],
          ["3490", _64],
          ["3491", _64],
          ["3492", _64],
          ["3493", _64],
          ["3494", _64],
          ["3495", _64],
          ["3500", _6B],
          ["3501", _6B],
          ["3502", _6B],
          ["3503", _6B],
          ["3504", _6B],
          ["3505", _6B],
          ["3510", _6I],
          ["3511", _6I],
          ["3512", _6I],
          ["3513", _6I],
          ["3514", _6I],
          ["3515", _6I],
          ["3520", _6P],
          ["3521", _6P],
          ["3522", _6P],
          ["3523", _6P],
          ["3524", _6P],
          ["3525", _6P],
          ["3530", _6W],
          ["3531", _6W],
          ["3532", _6W],
          ["3533", _6W],
          ["3534", _6W],
          ["3535", _6W],
          ["3540", _6d],
          ["3541", _6d],
          ["3542", _6d],
          ["3543", _6d],
          ["3544", _6d],
          ["3545", _6d],
          ["3550", _6k],
          ["3551", _6k],
          ["3552", _6k],
          ["3553", _6k],
          ["3554", _6k],
          ["3555", _6k],
          ["3560", _6r],
          ["3561", _6r],
          ["3562", _6r],
          ["3563", _6r],
          ["3564", _6r],
          ["3565", _6r],
          ["3570", _6y],
          ["3571", _6y],
          ["3572", _6y],
          ["3573", _6y],
          ["3574", _6y],
          ["3575", _6y],
          ["3600", _75],
          ["3601", _75],
          ["3602", _75],
          ["3603", _75],
          ["3604", _75],
          ["3605", _75],
          ["3610", _7C],
          ["3611", _7C],
          ["3612", _7C],
          ["3613", _7C],
          ["3614", _7C],
          ["3615", _7C],
          ["3620", _7J],
          ["3621", _7J],
          ["3622", _7J],
          ["3623", _7J],
          ["3624", _7J],
          ["3625", _7J],
          ["3630", _7Q],
          ["3631", _7Q],
          ["3632", _7Q],
          ["3633", _7Q],
          ["3634", _7Q],
          ["3635", _7Q],
          ["3640", _7X],
          ["3641", _7X],
          ["3642", _7X],
          ["3643", _7X],
          ["3644", _7X],
          ["3645", _7X],
          ["3650", _7e],
          ["3651", _7e],
          ["3652", _7e],
          ["3653", _7e],
          ["3654", _7e],
          ["3655", _7e],
          ["3660", _7l],
          ["3661", _7l],
          ["3662", _7l],
          ["3663", _7l],
          ["3664", _7l],
          ["3665", _7l],
          ["3670", _7s],
          ["3671", _7s],
          ["3672", _7s],
          ["3673", _7s],
          ["3674", _7s],
          ["3675", _7s],
          ["3680", _7z],
          ["3681", _7z],
          ["3682", _7z],
          ["3683", _7z],
          ["3684", _7z],
          ["3685", _7z],
          ["3690", _86],
          ["3691", _86],
          ["3692", _86],
          ["3693", _86],
          ["3694", _86],
          ["3695", _86],
          ["37", _8D],
          ["3900", _8K],
          ["3901", _8K],
          ["3902", _8K],
          ["3903", _8K],
          ["3904", _8K],
          ["3905", _8K],
          ["3906", _8K],
          ["3907", _8K],
          ["3908", _8K],
          ["3909", _8K],
          ["3910", _8T],
          ["3911", _8T],
          ["3912", _8T],
          ["3913", _8T],
          ["3914", _8T],
          ["3915", _8T],
          ["3916", _8T],
          ["3917", _8T],
          ["3918", _8T],
          ["3919", _8T],
          ["3920", _8b],
          ["3921", _8b],
          ["3922", _8b],
          ["3923", _8b],
          ["3924", _8b],
          ["3925", _8b],
          ["3926", _8b],
          ["3927", _8b],
          ["3928", _8b],
          ["3929", _8b],
          ["3930", _8k],
          ["3931", _8k],
          ["3932", _8k],
          ["3933", _8k],
          ["3934", _8k],
          ["3935", _8k],
          ["3936", _8k],
          ["3937", _8k],
          ["3938", _8k],
          ["3939", _8k],
          ["3940", _8r],
          ["3941", _8r],
          ["3942", _8r],
          ["3943", _8r],
          ["3950", _8y],
          ["3951", _8y],
          ["3952", _8y],
          ["3953", _8y],
          ["3954", _8y],
          ["3955", _8y],
          ["400", _92],
          ["401", _97],
          ["402", _9C],
          ["403", _9I],
          ["410", _9M],
          ["411", _9M],
          ["412", _9M],
          ["413", _9M],
          ["414", _9T],
          ["415", _9b],
          ["416", _9f],
          ["417", _9l],
          ["420", _9q],
          ["421", _9x],
          ["422", _A4],
          ["423", _AB],
          ["424", _AI],
          ["425", _AP],
          ["426", _AV],
          ["427", _Ac],
          ["4300", _Ai],
          ["4301", _Ai],
          ["4302", _Ao],
          ["4303", _Au],
          ["4304", _B0],
          ["4305", _B0],
          ["4306", _B0],
          ["4307", _B6],
          ["4308", _BC],
          ["4309", _BI],
          ["4310", _BO],
          ["4311", _BO],
          ["4312", _BU],
          ["4313", _Ba],
          ["4314", _Bg],
          ["4315", _Bg],
          ["4316", _Bg],
          ["4317", _Bm],
          ["4318", _Bs],
          ["4319", _By],
          ["4320", _C4],
          ["4321", _CA],
          ["4322", _CA],
          ["4323", _CA],
          ["4324", _CI],
          ["4325", _CI],
          ["4326", _CO],
          ["7001", _CU],
          ["7002", _Ca],
          ["7003", _Ci],
          ["7004", _Cp],
          ["7005", _Cv],
          ["7006", _D1],
          ["7007", _D9],
          ["7008", _DF],
          ["7009", _DL],
          ["7010", _DR],
          ["7011", _DZ],
          ["7020", _Dg],
          ["7021", _Dm],
          ["7022", _Ds],
          ["7023", _Dw],
          ["7030", _E4],
          ["7031", _E4],
          ["7032", _E4],
          ["7033", _E4],
          ["7034", _E4],
          ["7035", _E4],
          ["7036", _E4],
          ["7037", _E4],
          ["7038", _E4],
          ["7039", _E4],
          ["7040", _EE],
          ["710", _EK],
          ["711", _EK],
          ["712", _EK],
          ["713", _EK],
          ["714", _EK],
          ["715", _EK],
          ["7230", _ES],
          ["7231", _ES],
          ["7232", _ES],
          ["7233", _ES],
          ["7234", _ES],
          ["7235", _ES],
          ["7236", _ES],
          ["7237", _ES],
          ["7238", _ES],
          ["7239", _ES],
          ["7240", _EY],
          ["7241", _Ee],
          ["7242", _Ek],
          ["8001", _Ey],
          ["8002", _F2],
          ["8003", _FB],
          ["8004", _FH],
          ["8005", _FN],
          ["8006", _FW],
          ["8007", _Fc],
          ["8008", _Fk],
          ["8009", _Fq],
          ["8010", _Fw],
          ["8011", _G2],
          ["8012", _G8],
          ["8013", _GD],
          ["8017", _GK],
          ["8018", _GR],
          ["8019", _GX],
          ["8020", _Gd],
          ["8026", _Gm],
          ["8110", _Gq],
          ["8111", _Gw],
          ["8112", _H0],
          ["8200", _H6],
          ["90", _HA],
          ["91", _HE],
          ["92", _HE],
          ["93", _HE],
          ["94", _HE],
          ["95", _HE],
          ["96", _HE],
          ["97", _HE],
          ["98", _HE],
          ["99", _HE]
        ]);
        $ctx.gs1syntax = _HF;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1process.$ctx[id] = $ctx[id]);
        bwipp_gs1process.__2289__ = 1;
      })();
    }
    if ($eq($k[--$j], "ai")) {
      $anchorsearch($k[--$j], "(");
      if ($nt($k[--$j])) {
        $j--;
        $k[$j++] = "bwipp.GS1aiMissingOpenParen#2297";
        $k[$j++] = "AIs must start with '('";
        bwipp_raiseerror();
      }
      $j--;
      $k[$j++] = Infinity;
      var _HK = $k[--$j];
      var _HL = $k[--$j];
      $k[$j++] = _HK;
      $k[$j++] = _HL;
      for (; ; ) {
        var _HM = $k[--$j];
        $k[$j++] = _HM;
        if ($eq(_HM, "")) {
          $j--;
          break;
        }
        $search($k[--$j], ")");
        if ($nt($k[--$j])) {
          $cleartomark();
          $k[$j++] = "bwipp.GS1aiMissingCloseParen#2303";
          $k[$j++] = "AIs must end with ')'";
          bwipp_raiseerror();
        }
        var _HP = $k[--$j];
        var _HQ = $k[--$j];
        $k[$j++] = _HP;
        $k[$j++] = _HQ;
        $j--;
        var _HR = $k[--$j];
        var _HS = $k[--$j];
        $k[$j++] = _HR;
        $search(_HS, "(");
        if ($k[--$j]) {
          var _HU = $k[--$j];
          var _HV = $k[--$j];
          $k[$j++] = _HU;
          $k[$j++] = _HV;
          $j--;
          var _HW = $k[--$j];
          var _HX = $k[--$j];
          $k[$j++] = _HW;
          $k[$j++] = _HX;
        } else {
          $k[$j++] = "";
        }
      }
      var _HY = $counttomark();
      $k[$j++] = _HY;
      if (_HY > 0) {
        var _HZ = $k[--$j];
        for (var _Hb = _HZ, _Ha = ~~(_HZ / 2) + 1; _Hb >= _Ha; _Hb -= 1) {
          $r(_Hb, -1);
        }
      } else {
        $j--;
      }
      $astore($a(~~($counttomark() / 2)));
      $1.ais = $k[--$j];
      $astore($a($counttomark()));
      $k[$j++] = Infinity;
      var _Hh = $k[--$j];
      var _Hi = $k[--$j];
      $k[$j++] = _Hh;
      $forall(_Hi, function() {
        var _Hk = /* @__PURE__ */ new Map([
          ["parse", $1.parse],
          ["parseonly", true],
          ["parsefnc", false]
        ]);
        $k[$j++] = _Hk;
        bwipp_parseinput();
      });
      $1.vals = $a();
      $j--;
    } else {
      $anchorsearch($k[--$j], "http://");
      if ($nt($k[--$j])) {
        $anchorsearch($k[--$j], "https://");
        if ($nt($k[--$j])) {
          $j--;
          $k[$j++] = "bwipp.GS1dlURIbadScheme#2320";
          $k[$j++] = "Scheme must be http:// or https://";
          bwipp_raiseerror();
        }
      }
      $j--;
      $search($k[--$j], "/");
      if ($nt($k[--$j])) {
        $j--;
        $k[$j++] = "bwipp.GS1dlMissingDomainOrPathInfo#2326";
        $k[$j++] = "URI must contain a domain and path info";
        bwipp_raiseerror();
      }
      $j -= 2;
      $search($k[--$j], "#");
      if ($k[--$j]) {
        var _Hu = $k[--$j];
        var _Hv = $k[--$j];
        $k[$j++] = _Hu;
        $k[$j++] = _Hv;
        $j--;
        var _Hw = $k[--$j];
        var _Hx = $k[--$j];
        $k[$j++] = _Hw;
        $k[$j++] = _Hx;
        $j--;
      }
      $search($k[--$j], "?");
      if ($nt($k[--$j])) {
        var _I0 = $k[--$j];
        $k[$j++] = "";
        $k[$j++] = null;
        $k[$j++] = _I0;
      }
      $1.pp = $k[--$j];
      $j--;
      $1.qp = $k[--$j];
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = $1.pp;
      for (; ; ) {
        $search($k[--$j], "/");
        if ($nt($k[--$j])) {
          $j--;
          break;
        }
        var _I6 = $k[--$j];
        var _I7 = $k[--$j];
        $k[$j++] = _I6.length + 1;
        $k[$j++] = _I7;
        $j--;
        var _I8 = $k[--$j];
        var _I9 = $k[--$j];
        var _IA = $k[--$j];
        $k[$j++] = _IA;
        $k[$j++] = $f(_I8 + _IA);
        $k[$j++] = _I9;
      }
      $astore($a($counttomark() - 1));
      $1.pipos = $k[--$j];
      $j -= 2;
      if ($1.pipos.length <= 1) {
        $k[$j++] = "bwipp.GS1dlNoAIinfo#2351";
        $k[$j++] = "The path was too short to contain AI info";
        bwipp_raiseerror();
      }
      $k[$j++] = false;
      for (var _IG = $1.pipos.length - 2; _IG >= 0; _IG -= 2) {
        var _II = $get($1.pipos, _IG);
        var _IM = $geti($1.pp, _II, $f($f($get($1.pipos, _IG + 1) - _II) - 1));
        var _IO = $get($1.gs1syntax, _IM) !== void 0;
        $k[$j++] = _IG;
        $k[$j++] = _IM;
        if (_IO) {
          var _IS = $get($get($1.gs1syntax, $k[--$j]), "dlpkey") !== void 0;
          if (_IS) {
            var _IT = $k[--$j];
            var _IU = $k[--$j];
            $k[$j++] = _IT;
            $k[$j++] = _IU;
            $j--;
            $k[$j++] = true;
            break;
          }
        } else {
          $j--;
        }
        $j--;
      }
      if ($nt($k[--$j])) {
        $k[$j++] = "bwipp.GS1dlNoAIinfo#2370";
        $k[$j++] = "The path does not contain a valid primary key";
        bwipp_raiseerror();
      }
      var _IY = $get($1.pipos, $k[--$j]);
      $1.pp = $geti($1.pp, _IY, $f($1.pp.length - _IY));
      $1.uriunescape = function() {
        $1.in = $k[--$j];
        $1.out = $s($1.in.length);
        $k[$j++] = 0;
        $k[$j++] = 0;
        for (; ; ) {
          var _If = $k[--$j];
          var _Ig = $k[--$j];
          $k[$j++] = _Ig;
          $k[$j++] = _If;
          if (_Ig >= $1.in.length) {
            break;
          }
          var _Ij = $k[--$j];
          var _Ik = $k[--$j];
          var _Il = $get($1.in, _Ik);
          $k[$j++] = _Ik;
          $k[$j++] = _Ij;
          $k[$j++] = _Il;
          if (_Il == 43) {
            $j--;
            var _In = $k[--$j];
            $put($1.out, _In, 32);
            var _Io = $k[--$j];
            $k[$j++] = $f(_Io + 1);
            $k[$j++] = $f(_In + 1);
          } else {
            var _Ip = $k[--$j];
            var _Iq = $k[--$j];
            var _Ir = $k[--$j];
            $k[$j++] = _Ir;
            $k[$j++] = _Iq;
            $k[$j++] = _Ip;
            if (_Ip == 37 && _Ir < $1.in.length - 2) {
              $j--;
              var _Iu = $strcpy($s(4), "<  >");
              var _Iw = $k[--$j];
              var _Ix = $k[--$j];
              $puti(_Iu, 1, $geti($1.in, $f(_Ix + 1), 2));
              try {
                $k[$j++] = _Ix;
                $k[$j++] = _Iw;
                $k[$j++] = $cvx(_Iu);
                $k[$j++] = false;
              } catch (e) {
                $k[$j++] = true;
              }
              if ($k[--$j]) {
                $j -= 2;
                $k[$j++] = "bwipp.GS1dlBadHexCharacter#2388";
                $k[$j++] = "Invalid hex character";
                bwipp_raiseerror();
              }
              var _J1 = $get($k[--$j], 0);
              var _J3 = $k[--$j];
              $put($1.out, _J3, _J1);
              var _J4 = $k[--$j];
              $k[$j++] = $f(_J4 + 3);
              $k[$j++] = $f(_J3 + 1);
            } else {
              var _J6 = $k[--$j];
              var _J7 = $k[--$j];
              $put($1.out, _J7, _J6);
              var _J8 = $k[--$j];
              $k[$j++] = $f(_J8 + 1);
              $k[$j++] = $f(_J7 + 1);
            }
          }
        }
        $1.out = $geti($1.out, 0, $k[--$j]);
        $j--;
        $k[$j++] = $1.out;
      };
      $1.ais = $a(99);
      $1.vals = $a(99);
      $k[$j++] = 0;
      $k[$j++] = $1.pp;
      for (; ; ) {
        $search($k[--$j], "/");
        if ($k[--$j]) {
          var _JJ = $k[--$j];
          var _JK = $k[--$j];
          var _JL = $k[--$j];
          var _JM = $k[--$j];
          $put($1.ais, _JM, _JJ);
          $k[$j++] = _JM;
          $search(_JL, "/");
          if ($k[--$j]) {
            var _JO = $k[--$j];
            var _JP = $k[--$j];
            $k[$j++] = _JO;
            $k[$j++] = _JP;
            $j--;
          } else {
            var _JQ = $k[--$j];
            $k[$j++] = "";
            $k[$j++] = _JQ;
          }
          var _JS = $k[--$j];
          var _JT = $k[--$j];
          var _JU = $k[--$j];
          $k[$j++] = _JU;
          $k[$j++] = _JT;
          $k[$j++] = $1.vals;
          $k[$j++] = _JU;
          $k[$j++] = _JS;
          $1.uriunescape();
          var _JV = $k[--$j];
          var _JW = $k[--$j];
          $put($k[--$j], _JW, _JV);
        } else {
          $j--;
          break;
        }
        var _JY = $k[--$j];
        var _JZ = $k[--$j];
        $k[$j++] = $f(_JZ + 1);
        $k[$j++] = _JY;
      }
      var _Ja = $k[--$j];
      $k[$j++] = _Ja;
      if (_Ja > 1) {
        $k[$j++] = false;
        $forall($get($get($1.gs1syntax, $get($1.ais, 0)), "dlpkey"), function() {
          $1.seq = $k[--$j];
          $1.i = 1;
          $1.j = 0;
          for (; ; ) {
            if ($1.i >= $1.ais.length) {
              break;
            }
            if ($1.j >= $1.seq.length) {
              break;
            }
            if ($eq($get($1.ais, $1.i), $get($1.seq, $1.j))) {
              $1.i = $1.i + 1;
            }
            $1.j = $1.j + 1;
          }
          var _Ju = $k[--$j];
          var _Jv = $k[--$j];
          $k[$j++] = _Jv;
          $k[$j++] = _Ju;
          if ($1.i == _Jv) {
            $j--;
            $k[$j++] = true;
            return true;
          }
        });
        if ($nt($k[--$j])) {
          $j--;
          $k[$j++] = "bwipp.GS1dlBadPathInfo#2436";
          $k[$j++] = "The AIs in the path are not a valid key-qualifier sequence for the key";
          bwipp_raiseerror();
        }
      }
      $k[$j++] = $1.qp;
      for (; ; ) {
        var _Jy = $k[--$j];
        $k[$j++] = _Jy;
        if ($eq(_Jy, "")) {
          $j--;
          break;
        }
        $search($k[--$j], "&");
        if ($k[--$j]) {
          var _K1 = $k[--$j];
          var _K2 = $k[--$j];
          $k[$j++] = _K1;
          $k[$j++] = _K2;
          $j--;
        } else {
          var _K3 = $k[--$j];
          $k[$j++] = "";
          $k[$j++] = _K3;
        }
        $search($k[--$j], "=");
        if ($k[--$j]) {
          var _K6 = $k[--$j];
          $k[$j++] = _K6;
          $k[$j++] = true;
          $forall(_K6, function() {
            var _K7 = $k[--$j];
            var _K8 = $k[--$j];
            $k[$j++] = _K8 && (_K7 >= 48 && _K7 <= 57);
          });
          if ($k[--$j]) {
            var _KB = $k[--$j];
            var _KC = $k[--$j];
            var _KD = $k[--$j];
            var _KE = $k[--$j];
            var _KF = $k[--$j];
            $put($1.ais, _KF, _KB);
            $k[$j++] = _KF;
            $k[$j++] = _KE;
            $k[$j++] = $1.vals;
            $k[$j++] = _KF;
            $k[$j++] = _KD;
            $1.uriunescape();
            var _KH = $k[--$j];
            var _KI = $k[--$j];
            $put($k[--$j], _KI, _KH);
            var _KK = $k[--$j];
            var _KL = $k[--$j];
            $k[$j++] = $f(_KL + 1);
            $k[$j++] = _KK;
          } else {
            $j -= 3;
          }
        } else {
          $j--;
        }
      }
      var _KN = $k[--$j];
      $1.ais = $geti($1.ais, 0, _KN);
      $1.vals = $geti($1.vals, 0, _KN);
      for (var _KT = 0, _KS = $1.ais.length - 1; _KT <= _KS; _KT += 1) {
        $k[$j++] = _KT;
        if ($eq($get($1.ais, _KT), "01")) {
          var _KW = $k[--$j];
          var _KY = $get($1.vals, _KW);
          var _KZ = _KY.length;
          $k[$j++] = _KW;
          $k[$j++] = _KY;
          if (_KZ == 8 || (_KZ == 12 || _KZ == 13)) {
            var _Kb = $strcpy($s(14), "00000000000000");
            var _Kc = $k[--$j];
            $puti(_Kb, 14 - _Kc.length, _Kc);
            var _Ke = $k[--$j];
            $put($1.vals, _Ke, _Kb);
            $k[$j++] = _Ke;
          } else {
            $j--;
          }
        }
        $j--;
      }
    }
    if (!bwipp_gs1process.__2487__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        var _Kf = $a(["00", "01", "02", "03", "04", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "31", "32", "33", "34", "35", "36", "41"]);
        for (var _Kg = 0, _Kh = _Kf.length; _Kg < _Kh; _Kg++) {
          var _Ki = $get(_Kf, _Kg);
          $k[$j++] = _Ki;
          $k[$j++] = _Ki;
        }
        $ctx.aifixed = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1process.$ctx[id] = $ctx[id]);
        bwipp_gs1process.__2487__ = 1;
      })();
    }
    $k[$j++] = Infinity;
    var _Kl = $1.ais;
    for (var _Km = 0, _Kn = _Kl.length; _Km < _Kn; _Km++) {
      var _Ko = $get(_Kl, _Km);
      $k[$j++] = true;
      $k[$j++] = _Ko;
      if (_Ko.length >= 2) {
        var _Ks = $get($1.aifixed, $geti($k[--$j], 0, 2)) !== void 0;
        if (_Ks) {
          $j--;
          $k[$j++] = false;
        }
      } else {
        $j--;
      }
    }
    $1.fncs = $a();
    $1.lintnumeric = function() {
      var _Ku = $k[--$j];
      $k[$j++] = true;
      $forall(_Ku, function() {
        var _Kv = $k[--$j];
        if (_Kv < 48 || _Kv > 57) {
          $j--;
          $k[$j++] = false;
          return true;
        }
      });
      if ($nt($k[--$j])) {
        $j--;
        $k[$j++] = "bwipp.GS1notNumeric#2507";
        $k[$j++] = "Not numeric";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintcset82 = function() {
      var _Kx = $k[--$j];
      $k[$j++] = true;
      $forall(_Kx, function() {
        var _Ky = $s(1);
        $put(_Ky, 0, $k[--$j]);
        $search(`!"%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz`, _Ky);
        if ($nt($k[--$j])) {
          $j -= 2;
          $k[$j++] = false;
          return true;
        }
        $j -= 3;
      });
      if ($nt($k[--$j])) {
        $j--;
        $k[$j++] = "bwipp.GS1badCSET82character#2517";
        $k[$j++] = "Invalid CSET 82 character";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintcset39 = function() {
      var _L2 = $k[--$j];
      $k[$j++] = true;
      $forall(_L2, function() {
        var _L3 = $s(1);
        $put(_L3, 0, $k[--$j]);
        $search("#-/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", _L3);
        if ($nt($k[--$j])) {
          $j -= 2;
          $k[$j++] = false;
          return true;
        }
        $j -= 3;
      });
      if ($nt($k[--$j])) {
        $j--;
        $k[$j++] = "bwipp.GS1badCSET39character#2527";
        $k[$j++] = "Invalid CSET 39 character";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintkey = function() {
      var _L7 = $k[--$j];
      $k[$j++] = _L7;
      if (_L7.length < 2) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1keyTooShort#2531";
        $k[$j++] = "Key is too short";
        $k[$j++] = false;
        return true;
      }
      var _L8 = $k[--$j];
      var _L9 = $get(_L8, 0);
      var _LA = $get(_L8, 1);
      if (_L9 < 48 || _L9 > 57 || (_LA < 48 || _LA > 57)) {
        $j--;
        $k[$j++] = "bwipp.GS1badGCP#2534";
        $k[$j++] = "Non-numeric company prefix";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintimporteridx = function() {
      $search("-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz", $k[--$j]);
      if ($nt($k[--$j])) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badImporterIndex#2540";
        $k[$j++] = "Invalid importer index";
        $k[$j++] = false;
        return true;
      }
      $j -= 3;
    };
    $1.lintcsum = function() {
      $k[$j++] = Infinity;
      var _LD = $k[--$j];
      var _LE = $k[--$j];
      var _LF = _LE.length % 2 == 0 ? 3 : 1;
      $k[$j++] = _LD;
      $k[$j++] = _LF;
      $forall(_LE, function() {
        var _LG = $k[--$j];
        var _LH = $k[--$j];
        $k[$j++] = $f(_LG - 48) * _LH;
        $k[$j++] = $f(4 - _LH);
      });
      $j--;
      var _LI = $counttomark() + 1;
      $k[$j++] = 0;
      for (var _LJ = 0, _LK = _LI - 1; _LJ < _LK; _LJ++) {
        var _LL = $k[--$j];
        var _LM = $k[--$j];
        $k[$j++] = $f(_LM + _LL);
      }
      var _LN = $k[--$j];
      var _LO = $k[--$j];
      $k[$j++] = _LN;
      $k[$j++] = _LO;
      $j--;
      if ($k[--$j] % 10 != 0) {
        $j--;
        $k[$j++] = "bwipp.GS1badChecksum#2549";
        $k[$j++] = "Bad checksum";
        $k[$j++] = false;
        return true;
      }
    };
    if (!bwipp_gs1process.__2562__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        $k[$j++] = 0;
        for (var _LQ = 0, _LR = `!"%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz`.length; _LQ < _LR; _LQ++) {
          var _LT = $k[--$j];
          $k[$j++] = $get(`!"%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz`, _LQ);
          $k[$j++] = _LT;
          $k[$j++] = $f(_LT + 1);
        }
        $j--;
        $ctx.cset82 = $d();
        $k[$j++] = Infinity;
        $k[$j++] = 0;
        for (var _LV = 0, _LW = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ".length; _LV < _LW; _LV++) {
          var _LY = $k[--$j];
          $k[$j++] = $get("23456789ABCDEFGHJKLMNPQRSTUVWXYZ", _LV);
          $k[$j++] = _LY;
          $k[$j++] = $f(_LY + 1);
        }
        $j--;
        $ctx.cset32 = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1process.$ctx[id] = $ctx[id]);
        bwipp_gs1process.__2562__ = 1;
      })();
    }
    $1.lintcsumalpha = function() {
      var _Lb = $k[--$j];
      $k[$j++] = _Lb;
      if (_Lb.length < 2) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1alphaTooShort#2565";
        $k[$j++] = "Alphanumeric string is too short to check";
        $k[$j++] = false;
        return true;
      }
      var _Lc = $k[--$j];
      $k[$j++] = _Lc;
      $k[$j++] = _Lc.length - 2;
      $k[$j++] = $geti(_Lc, 0, _Lc.length - 2);
      $k[$j++] = Infinity;
      var _Le = $k[--$j];
      var _Lf = $k[--$j];
      $k[$j++] = _Le;
      $forall(_Lf, function() {
        var _Lg = $k[--$j];
        var _Li = $get($1.cset82, _Lg) !== void 0;
        $k[$j++] = _Lg;
        if (_Li) {
          var _Ll = $get($1.cset82, $k[--$j]);
          $k[$j++] = _Ll;
        } else {
          $k[$j++] = -1;
          return true;
        }
      });
      var _Lm = $k[--$j];
      $k[$j++] = _Lm;
      if (_Lm == -1) {
        $cleartomark();
        $j -= 3;
        $k[$j++] = "bwipp.GS1UnknownCSET82Character#2571";
        $k[$j++] = "Unknown CSET 82 character";
        $k[$j++] = false;
        return true;
      }
      $astore($a($counttomark()));
      var _Lp = $k[--$j];
      var _Lq = $k[--$j];
      $k[$j++] = _Lp;
      $k[$j++] = _Lq;
      $j--;
      var _Lr = $k[--$j];
      var _Ls = $k[--$j];
      var _Lu = $geti($k[--$j], _Ls, 2);
      $k[$j++] = _Lr;
      $k[$j++] = _Lu;
      $k[$j++] = Infinity;
      var _Lv = $k[--$j];
      var _Lw = $k[--$j];
      $k[$j++] = _Lv;
      $forall(_Lw, function() {
        var _Lx = $k[--$j];
        var _Lz = $get($1.cset32, _Lx) !== void 0;
        $k[$j++] = _Lx;
        if (_Lz) {
          var _M2 = $get($1.cset32, $k[--$j]);
          $k[$j++] = _M2;
        } else {
          $k[$j++] = -1;
          return true;
        }
      });
      var _M3 = $k[--$j];
      $k[$j++] = _M3;
      if (_M3 == -1) {
        $cleartomark();
        $j -= 2;
        $k[$j++] = "bwipp.GS1UnknownCSET32Character#2577";
        $k[$j++] = "Unknown CSET 32 character";
        $k[$j++] = false;
        return true;
      }
      $astore($a($counttomark()));
      var _M6 = $k[--$j];
      var _M7 = $k[--$j];
      $k[$j++] = _M6;
      $k[$j++] = _M7;
      $j--;
      var _M8 = $k[--$j];
      var _MB = $k[--$j];
      var _MC = $a([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83]);
      var _MD = _MB.length;
      $k[$j++] = $f(($get(_M8, 0) << 5) + $get(_M8, 1));
      $k[$j++] = _MB;
      $k[$j++] = _MC;
      $k[$j++] = _MD;
      if (_MD > _MC.length) {
        $j -= 5;
        $k[$j++] = "bwipp.GS1alphaTooLong#2582";
        $k[$j++] = "Alphanumeric string is too long to check";
        $k[$j++] = false;
        return true;
      }
      var _ME = $k[--$j];
      var _MG = $geti($k[--$j], 0, _ME);
      for (var _MH = 0, _MI = _MG.length; _MH < _MI; _MH++) {
        var _MK = $k[--$j];
        $k[$j++] = $get(_MG, _MH);
        $k[$j++] = _MK;
      }
      var _ML = $k[--$j];
      $k[$j++] = 0;
      $forall(_ML, function() {
        var _MM = $k[--$j];
        var _MN = $k[--$j];
        var _MO = $k[--$j];
        $k[$j++] = $f(_MN + _MO * _MM);
      });
      var _MP = $k[--$j];
      if ($k[--$j] != _MP % 1021) {
        $j--;
        $k[$j++] = "bwipp.GS1badAlphaCheckCharacters#2585";
        $k[$j++] = "Bad alphanumeric check characters";
        $k[$j++] = false;
        return true;
      }
    };
    if (!bwipp_gs1process.__2609__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        var _MR = $a(["004", "008", "010", "012", "016", "020", "024", "028", "031", "032", "036", "040", "044", "048", "050", "051", "052", "056", "060", "064", "068", "070", "072", "074", "076", "084", "086", "090", "092", "096", "100", "104", "108", "112", "116", "120", "124", "132", "136", "140", "144", "148", "152", "156", "158", "162", "166", "170", "174", "175", "178", "180", "184", "188", "191", "192", "196", "203", "204", "208", "212", "214", "218", "222", "226", "231", "232", "233", "234", "238", "239", "242", "246", "248", "250", "254", "258", "260", "262", "266", "268", "270", "275", "276", "288", "292", "296", "300", "304", "308", "312", "316", "320", "324", "328", "332", "334", "336", "340", "344", "348", "352", "356", "360", "364", "368", "372", "376", "380", "384", "388", "392", "398", "400", "404", "408", "410", "414", "417", "418", "422", "426", "428", "430", "434", "438", "440", "442", "446", "450", "454", "458", "462", "466", "470", "474", "478", "480", "484", "492", "496", "498", "499", "500", "504", "508", "512", "516", "520", "524", "528", "531", "533", "534", "535", "540", "548", "554", "558", "562", "566", "570", "574", "578", "580", "581", "583", "584", "585", "586", "591", "598", "600", "604", "608", "612", "616", "620", "624", "626", "630", "634", "638", "642", "643", "646", "652", "654", "659", "660", "662", "663", "666", "670", "674", "678", "682", "686", "688", "690", "694", "702", "703", "704", "705", "706", "710", "716", "724", "728", "729", "732", "740", "744", "748", "752", "756", "760", "762", "764", "768", "772", "776", "780", "784", "788", "792", "795", "796", "798", "800", "804", "807", "818", "826", "831", "832", "833", "834", "840", "850", "854", "858", "860", "862", "876", "882", "887", "894"]);
        for (var _MS = 0, _MT = _MR.length; _MS < _MT; _MS++) {
          var _MU = $get(_MR, _MS);
          $k[$j++] = _MU;
          $k[$j++] = _MU;
        }
        $ctx.iso3166 = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1process.$ctx[id] = $ctx[id]);
        bwipp_gs1process.__2609__ = 1;
      })();
    }
    $1.lintiso3166 = function() {
      var _MZ = $get($1.iso3166, $k[--$j]) !== void 0;
      if (!_MZ) {
        $j--;
        $k[$j++] = "bwipp.GS1UnknownCountry#2612";
        $k[$j++] = "Unknown country code";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintiso3166999 = function() {
      var _Ma = $k[--$j];
      $k[$j++] = _Ma;
      if ($ne(_Ma, "999")) {
        var _Md = $get($1.iso3166, $k[--$j]) !== void 0;
        if (!_Md) {
          $j--;
          $k[$j++] = "bwipp.GS1UnknownCountryOr999#2617";
          $k[$j++] = "Unknown country code or not 999";
          $k[$j++] = false;
          return true;
        }
      } else {
        $j--;
      }
    };
    $1.lintiso3166list = function() {
      var _Me = $k[--$j];
      $k[$j++] = _Me;
      if (_Me.length % 3 != 0) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1BadCountryListLength#2625";
        $k[$j++] = "Not a group of three-digit country codes";
        $k[$j++] = false;
        return true;
      }
      var _Mf = $k[--$j];
      $k[$j++] = _Mf;
      $k[$j++] = true;
      for (var _Mh = 0, _Mg = _Mf.length - 1; _Mh <= _Mg; _Mh += 3) {
        var _Mi = $k[--$j];
        var _Mj = $k[--$j];
        var _Mm = $get($1.iso3166, $geti(_Mj, _Mh, 3)) !== void 0;
        $k[$j++] = _Mj;
        $k[$j++] = _Mi;
        if (!_Mm) {
          $j -= 2;
          $k[$j++] = false;
          break;
        }
      }
      if ($nt($k[--$j])) {
        $j--;
        $k[$j++] = "bwipp.GS1UnknownCountry#2632";
        $k[$j++] = "Unknown country code";
        $k[$j++] = false;
        return true;
      }
      $j--;
    };
    if (!bwipp_gs1process.__2663__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        var _Mo = $a(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
        for (var _Mp = 0, _Mq = _Mo.length; _Mp < _Mq; _Mp++) {
          var _Mr = $get(_Mo, _Mp);
          $k[$j++] = _Mr;
          $k[$j++] = _Mr;
        }
        $ctx.iso3166alpha2 = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1process.$ctx[id] = $ctx[id]);
        bwipp_gs1process.__2663__ = 1;
      })();
    }
    $1.lintiso3166alpha2 = function() {
      var _Mw = $get($1.iso3166alpha2, $k[--$j]) !== void 0;
      if (!_Mw) {
        $j--;
        $k[$j++] = "bwipp.GS1UnknownCountryAlpha#2666";
        $k[$j++] = "Unknown country alpha code";
        $k[$j++] = false;
        return true;
      }
    };
    if (!bwipp_gs1process.__2694__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        var _Mx = $a(["008", "012", "032", "036", "044", "048", "050", "051", "052", "060", "064", "068", "072", "084", "090", "096", "104", "108", "116", "124", "132", "136", "144", "152", "156", "170", "174", "188", "191", "192", "203", "208", "214", "222", "230", "232", "238", "242", "262", "270", "292", "320", "324", "328", "332", "340", "344", "348", "352", "356", "360", "364", "368", "376", "388", "392", "398", "400", "404", "408", "410", "414", "417", "418", "422", "426", "430", "434", "446", "454", "458", "462", "480", "484", "496", "498", "504", "512", "516", "524", "532", "533", "548", "554", "558", "566", "578", "586", "590", "598", "600", "604", "608", "634", "643", "646", "654", "682", "690", "694", "702", "704", "706", "710", "728", "748", "752", "756", "760", "764", "776", "780", "784", "788", "800", "807", "818", "826", "834", "840", "858", "860", "882", "886", "901", "925", "927", "928", "929", "930", "931", "932", "933", "934", "936", "938", "940", "941", "943", "944", "946", "947", "948", "949", "950", "951", "952", "953", "955", "956", "957", "958", "959", "960", "961", "962", "963", "964", "965", "967", "968", "969", "970", "971", "972", "973", "975", "976", "977", "978", "979", "980", "981", "984", "985", "986", "990", "994", "997", "999"]);
        for (var _My = 0, _Mz = _Mx.length; _My < _Mz; _My++) {
          var _N0 = $get(_Mx, _My);
          $k[$j++] = _N0;
          $k[$j++] = _N0;
        }
        $ctx.iso4217 = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1process.$ctx[id] = $ctx[id]);
        bwipp_gs1process.__2694__ = 1;
      })();
    }
    $1.lintiso4217 = function() {
      var _N5 = $get($1.iso4217, $k[--$j]) !== void 0;
      if (!_N5) {
        $j--;
        $k[$j++] = "bwipp.GS1UnknownCurrency#2697";
        $k[$j++] = "Unknown currency code";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintiban = function() {
      var _N6 = $k[--$j];
      $k[$j++] = _N6;
      if (_N6.length <= 4) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1tooShort#2701";
        $k[$j++] = "IBAN too short";
        $k[$j++] = false;
        return true;
      }
      var _N7 = $k[--$j];
      $k[$j++] = _N7;
      $k[$j++] = true;
      $forall(_N7, function() {
        var _N8 = $s(1);
        $put(_N8, 0, $k[--$j]);
        $search("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", _N8);
        if ($nt($k[--$j])) {
          $j -= 2;
          $k[$j++] = false;
          return true;
        }
        $j -= 3;
      });
      if ($nt($k[--$j])) {
        $j--;
        $k[$j++] = "bwipp.GS1badIBANcharacter#2708";
        $k[$j++] = "Invalid IBAN character";
        $k[$j++] = false;
        return true;
      }
      var _NC = $k[--$j];
      $k[$j++] = _NC;
      $k[$j++] = _NC;
      $k[$j++] = Infinity;
      var _ND = $k[--$j];
      var _NE = $k[--$j];
      $k[$j++] = _ND;
      $k[$j++] = _NE;
      $k[$j++] = Infinity;
      var _NF = $k[--$j];
      var _NG = $k[--$j];
      $k[$j++] = _NF;
      $forall(_NG);
      $r($counttomark(), -4);
      $astore($a($counttomark()));
      var _NK = $k[--$j];
      var _NL = $k[--$j];
      $k[$j++] = _NK;
      $k[$j++] = _NL;
      $j--;
      $forall($k[--$j], function() {
        var _NO = $f($k[--$j] - 48);
        $k[$j++] = _NO;
        if (_NO > 9) {
          var _NQ = $f($k[--$j] - 7);
          $k[$j++] = ~~(_NQ / 10);
          $k[$j++] = _NQ % 10;
        }
      });
      $astore($a($counttomark()));
      var _NT = $k[--$j];
      var _NU = $k[--$j];
      $k[$j++] = _NT;
      $k[$j++] = _NU;
      $j--;
      var _NV = $k[--$j];
      $k[$j++] = 0;
      $forall(_NV, function() {
        var _NW = $k[--$j];
        var _NX = $k[--$j];
        $k[$j++] = $f(_NW + _NX * 10) % 97;
      });
      if ($k[--$j] != 1) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badIBANchecksum#2713";
        $k[$j++] = "IBAN checksum incorrect";
        $k[$j++] = false;
        return true;
      }
      var _Na = $geti($k[--$j], 0, 2);
      $k[$j++] = _Na;
      $1.lintiso3166alpha2();
    };
    $1.lintzero = function() {
      if ($ne($k[--$j], "0")) {
        $j--;
        $k[$j++] = "bwipp.GS1zeroRequired#2718";
        $k[$j++] = "Zero is required";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintnonzero = function() {
      var _Nc = $k[--$j];
      $k[$j++] = false;
      $forall(_Nc, function() {
        if ($k[--$j] != 48) {
          $j--;
          $k[$j++] = true;
        }
      });
      if ($nt($k[--$j])) {
        $j--;
        $k[$j++] = "bwipp.GS1zeroNotPermitted#2723";
        $k[$j++] = "Zero not permitted";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintnozeroprefix = function() {
      var _Nf = $k[--$j];
      if (_Nf.length > 1 && $get(_Nf, 0) == 48) {
        $j--;
        $k[$j++] = "bwipp.GS1badZeroPrefix#2728";
        $k[$j++] = "Zero prefix is not permitted";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintyymmd0 = function() {
      var _Nh = $k[--$j];
      var _Nj = $cvi($geti(_Nh, 2, 2));
      $k[$j++] = _Nh;
      if (_Nj < 1 || _Nj > 12) {
        $j--;
        $k[$j++] = "bwipp.GS1badMonth#2733";
        $k[$j++] = "Invalid month";
        $k[$j++] = false;
        return true;
      }
      var _Nk = $k[--$j];
      var _Nm = $cvi($geti(_Nk, 0, 2));
      var _Nn = _Nm - 21;
      $k[$j++] = _Nk;
      $k[$j++] = _Nm;
      $k[$j++] = _Nn;
      if (_Nn >= 51) {
        $j--;
        var _No = $k[--$j];
        $k[$j++] = $f(_No + 1900);
      } else {
        if ($k[--$j] <= -50) {
          var _Nq = $k[--$j];
          $k[$j++] = $f(_Nq + 2100);
        } else {
          var _Nr = $k[--$j];
          $k[$j++] = $f(_Nr + 2e3);
        }
      }
      var _Ns = $k[--$j];
      $k[$j++] = _Ns % 400 == 0 || _Ns % 4 == 0 && _Ns % 100 != 0;
      $k[$j++] = Infinity;
      var _Nt = $k[--$j];
      var _Nv = $k[--$j] ? 29 : 28;
      $k[$j++] = _Nt;
      $k[$j++] = 31;
      $k[$j++] = _Nv;
      $k[$j++] = 31;
      $k[$j++] = 30;
      $k[$j++] = 31;
      $k[$j++] = 30;
      $k[$j++] = 31;
      $k[$j++] = 31;
      $k[$j++] = 30;
      $k[$j++] = 31;
      $k[$j++] = 30;
      $k[$j++] = 31;
      var _Nw = $a();
      var _Nx = $k[--$j];
      if ($get(_Nw, $cvi($geti(_Nx, 2, 2)) - 1) < $cvi($geti(_Nx, 4, 2))) {
        $j--;
        $k[$j++] = "bwipp.GS1badDay#2739";
        $k[$j++] = "Invalid day of month";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintyymmdd = function() {
      var _O1 = $k[--$j];
      $k[$j++] = _O1;
      if (_O1.length != 6) {
        $j--;
        $k[$j++] = "bwipp.GS1badDateLength#2743";
        $k[$j++] = "Invalid length for date";
        $k[$j++] = false;
        return true;
      }
      var _O2 = $k[--$j];
      $k[$j++] = _O2;
      if ($cvi($geti(_O2, 4, 2)) < 1) {
        $j--;
        $k[$j++] = "bwipp.GS1badDay#2744";
        $k[$j++] = "Invalid day of month";
        $k[$j++] = false;
        return true;
      }
      $1.lintyymmd0();
    };
    $1.lintyymmddhh = function() {
      var _O4 = $k[--$j];
      $k[$j++] = _O4;
      if (_O4.length != 8) {
        $j--;
        $k[$j++] = "bwipp.GS1badYYMMDDHHLength#2749";
        $k[$j++] = "Invalid length for date with hour";
        $k[$j++] = false;
        return true;
      }
      var _O5 = $k[--$j];
      $k[$j++] = _O5;
      if ($cvi($geti(_O5, 6, 2)) > 23) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badHour#2750";
        $k[$j++] = "Invalid hour of day";
        $k[$j++] = false;
        return true;
      }
      var _O8 = $geti($k[--$j], 0, 6);
      $k[$j++] = _O8;
      $1.lintyymmdd();
    };
    $1.linthhmm = function() {
      var _O9 = $k[--$j];
      $k[$j++] = _O9;
      if ($cvi($geti(_O9, 0, 2)) > 23) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badHour#2755";
        $k[$j++] = "Invalid hour of day";
        $k[$j++] = false;
        return true;
      }
      if ($cvi($geti($k[--$j], 2, 2)) > 59) {
        $j--;
        $k[$j++] = "bwipp.GS1badMinute#2756";
        $k[$j++] = "Invalid minute in the hour";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintmmoptss = function() {
      var _OD = $k[--$j];
      var _OE = _OD.length;
      $k[$j++] = _OD;
      if (_OE != 2 && _OE != 4) {
        $j--;
        $k[$j++] = "bwipp.GS1badTimeLength#2761";
        $k[$j++] = "Invalid length for optional minutes and seconds";
        $k[$j++] = false;
        return true;
      }
      var _OF = $k[--$j];
      $k[$j++] = _OF;
      if ($cvi($geti(_OF, 0, 2)) > 59) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badMinute#2763";
        $k[$j++] = "Invalid minute in the hour";
        $k[$j++] = false;
        return true;
      }
      var _OH = $k[--$j];
      $k[$j++] = _OH;
      if (_OH.length >= 4) {
        var _OI = $k[--$j];
        $k[$j++] = _OI;
        if ($cvi($geti(_OI, 2, 2)) > 59) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1badSecond#2765";
          $k[$j++] = "Invalid second in the minute";
          $k[$j++] = false;
          return true;
        }
      }
      $j--;
    };
    $1.lintyesno = function() {
      var _OK = $k[--$j];
      if ($ne(_OK, "0") && $ne(_OK, "1")) {
        $j--;
        $k[$j++] = "bwipp.GS1badBoolean#2772";
        $k[$j++] = "Neither 0 nor 1 for yes or no";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintwinding = function() {
      var _OL = $k[--$j];
      if ($ne(_OL, "0") && ($ne(_OL, "1") && $ne(_OL, "9"))) {
        $j--;
        $k[$j++] = "bwipp.GS1badWinding#2778";
        $k[$j++] = "Invalid winding direction";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintpieceoftotal = function() {
      var _OM = $k[--$j];
      $k[$j++] = _OM;
      if (_OM.length % 2 != 0) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badPieceTotalLength#2783";
        $k[$j++] = "Invalid piece/total length";
        $k[$j++] = false;
        return true;
      }
      var _ON = $k[--$j];
      var _OP = $cvi($geti(_ON, 0, ~~(_ON.length / 2)));
      $k[$j++] = _ON;
      $k[$j++] = _OP;
      if (_OP == 0) {
        $j -= 3;
        $k[$j++] = "bwipp.GS1badPieceNumber#2785";
        $k[$j++] = "Invalid piece number";
        $k[$j++] = false;
        return true;
      }
      var _OQ = $k[--$j];
      var _OR = $k[--$j];
      var _OS = ~~(_OR.length / 2);
      var _OU = $cvi($geti(_OR, _OS, _OS));
      $k[$j++] = _OQ;
      $k[$j++] = _OU;
      if (_OU == 0) {
        $j -= 3;
        $k[$j++] = "bwipp.GS1badPieceTotal#2787";
        $k[$j++] = "Invalid total number";
        $k[$j++] = false;
        return true;
      }
      var _OV = $k[--$j];
      if ($gt($k[--$j], _OV)) {
        $j--;
        $k[$j++] = "bwipp.GS1pieceExceedsTotal#2788";
        $k[$j++] = "Piece number exceeds total";
        $k[$j++] = false;
        return true;
      }
    };
    $1.lintpcenc = function() {
      for (; ; ) {
        $search($k[--$j], "%");
        if ($nt($k[--$j])) {
          $j--;
          break;
        }
        $j -= 2;
        var _OZ = $k[--$j];
        $k[$j++] = _OZ;
        if (_OZ.length < 2) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1badPercentEscape#2794";
          $k[$j++] = "Invalid % escape";
          $k[$j++] = false;
          break;
        }
        var _Oa = $k[--$j];
        var _Ob = $geti(_Oa, 0, 2);
        $k[$j++] = _Oa;
        $k[$j++] = true;
        for (var _Oc = 0, _Od = _Ob.length; _Oc < _Od; _Oc++) {
          var _Of = $s(1);
          $put(_Of, 0, $get(_Ob, _Oc));
          $search("0123456789ABCDEFabcdef", _Of);
          if ($nt($k[--$j])) {
            $j -= 2;
            $k[$j++] = false;
            break;
          }
          $j -= 3;
        }
        if ($nt($k[--$j])) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1badPercentChars#2801";
          $k[$j++] = "Invalid characters for percent encoding";
          $k[$j++] = false;
          break;
        }
      }
    };
    $1.lintcouponcode = function() {
      var _Oi = $k[--$j];
      $k[$j++] = _Oi;
      $k[$j++] = true;
      $forall(_Oi, function() {
        var _Oj = $k[--$j];
        if (_Oj < 48 || _Oj > 57) {
          $j--;
          $k[$j++] = false;
          return true;
        }
      });
      if ($nt($k[--$j])) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponNotNumeric#2809";
        $k[$j++] = "Coupon not numeric";
        $k[$j++] = false;
        return true;
      }
      var _Ol = $k[--$j];
      $k[$j++] = _Ol;
      if (_Ol.length < 1) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShortGCPVLI#2813";
        $k[$j++] = "Coupon too short: Missing GCP VLI";
        $k[$j++] = false;
        return true;
      }
      var _Om = $k[--$j];
      var _Oo = $cvi($geti(_Om, 0, 1));
      $k[$j++] = _Om;
      $k[$j++] = _Oo;
      if (_Oo > 6) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponBadGCPVLI#2816";
        $k[$j++] = "Coupon GCP length indicator must be 0-6";
        $k[$j++] = false;
        return true;
      }
      var _Op = $k[--$j];
      var _Oq = $k[--$j];
      $k[$j++] = _Oq;
      $k[$j++] = $f($f(_Op + 6) + 1);
      if ($f($f(_Op + 6) + 1) > _Oq.length) {
        $j -= 3;
        $k[$j++] = "bwipp.GS1couponTooShortGCP#2820";
        $k[$j++] = "Coupon too short: GCP truncated";
        $k[$j++] = false;
        return true;
      }
      var _Or = $k[--$j];
      var _Os = $k[--$j];
      var _Ot = $geti(_Os, _Or, $f(_Os.length - _Or));
      $k[$j++] = _Ot;
      if (_Ot.length < 6) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShortOfferCode#2826";
        $k[$j++] = "Coupon too short: Offer Code truncated";
        $k[$j++] = false;
        return true;
      }
      var _Ou = $k[--$j];
      var _Ov = $geti(_Ou, 6, _Ou.length - 6);
      $k[$j++] = _Ov;
      if (_Ov.length < 1) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShortSaveValueVLI#2832";
        $k[$j++] = "Coupon too short: Missing Save Value VLI";
        $k[$j++] = false;
        return true;
      }
      var _Ow = $k[--$j];
      var _Oy = $cvi($geti(_Ow, 0, 1));
      $k[$j++] = _Ow;
      $k[$j++] = _Oy;
      if (_Oy < 1 || _Oy > 5) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponBadSaveValueVLI#2835";
        $k[$j++] = "Coupon Save Value length indicator must be 1-5";
        $k[$j++] = false;
        return true;
      }
      var _Oz = $k[--$j];
      var _P0 = $k[--$j];
      $k[$j++] = _P0;
      $k[$j++] = $f(_Oz + 1);
      if ($f(_Oz + 1) > _P0.length) {
        $j -= 3;
        $k[$j++] = "bwipp.GS1couponTooShortSaveValue#2839";
        $k[$j++] = "Coupon too short: Save Value truncated";
        $k[$j++] = false;
        return true;
      }
      var _P1 = $k[--$j];
      var _P2 = $k[--$j];
      var _P3 = $geti(_P2, _P1, $f(_P2.length - _P1));
      $k[$j++] = _P3;
      if (_P3.length < 1) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShort1stPurchaseRequirementVLI#2845";
        $k[$j++] = "Coupon too short: Missing 1st Purchase Requirement VLI";
        $k[$j++] = false;
        return true;
      }
      var _P4 = $k[--$j];
      var _P6 = $cvi($geti(_P4, 0, 1));
      $k[$j++] = _P4;
      $k[$j++] = _P6;
      if (_P6 < 1 || _P6 > 5) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponBad1stPurchaseRequirementVLI#2848";
        $k[$j++] = "Coupon 1st Purchase Requirement length indicator must be 1-5";
        $k[$j++] = false;
        return true;
      }
      var _P7 = $k[--$j];
      var _P8 = $k[--$j];
      $k[$j++] = _P8;
      $k[$j++] = $f(_P7 + 1);
      if ($f(_P7 + 1) > _P8.length) {
        $j -= 3;
        $k[$j++] = "bwipp.GS1couponTooShort1stPurchaseRequirement#2852";
        $k[$j++] = "Coupon too short: 1st Purchase Requirement truncated";
        $k[$j++] = false;
        return true;
      }
      var _P9 = $k[--$j];
      var _PA = $k[--$j];
      var _PB = $geti(_PA, _P9, $f(_PA.length - _P9));
      $k[$j++] = _PB;
      if (_PB.length < 1) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShort1stPurchaseRequirementCode#2858";
        $k[$j++] = "Coupon too short: Missing 1st Purchase Requirement Code";
        $k[$j++] = false;
        return true;
      }
      var _PC = $k[--$j];
      var _PE = $cvi($geti(_PC, 0, 1));
      $k[$j++] = _PC;
      if (_PE > 4 && _PE != 9) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponBad1stPurchaseRequirementCode#2861";
        $k[$j++] = "Coupon 1st Purchase Requirement Code must be 0-4 or 9";
        $k[$j++] = false;
        return true;
      }
      var _PF = $k[--$j];
      var _PG = $geti(_PF, 1, _PF.length - 1);
      $k[$j++] = _PG;
      if (_PG.length < 3) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShort1stPurchaseFamilyCode#2867";
        $k[$j++] = "Coupon too short: 1st Purchase Family Code truncated";
        $k[$j++] = false;
        return true;
      }
      var _PH = $k[--$j];
      var _PI = $geti(_PH, 3, _PH.length - 3);
      $k[$j++] = _PI;
      if (_PI.length >= 1) {
        var _PJ = $k[--$j];
        $k[$j++] = _PJ;
        if ($cvi($geti(_PJ, 0, 1)) == 1) {
          var _PL = $k[--$j];
          var _PM = $geti(_PL, 1, _PL.length - 1);
          $k[$j++] = _PM;
          if (_PM.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortAdditionalPurchaseRulesCode#2877";
            $k[$j++] = "Coupon too short: Missing Additional Purchase Rules Code";
            $k[$j++] = false;
            return true;
          }
          var _PN = $k[--$j];
          $k[$j++] = _PN;
          if ($cvi($geti(_PN, 0, 1)) > 3) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBadAdditionalPurchaseRulesCode#2880";
            $k[$j++] = "Coupon Additional Purchase Rules Code must be 0-3";
            $k[$j++] = false;
            return true;
          }
          var _PP = $k[--$j];
          var _PQ = $geti(_PP, 1, _PP.length - 1);
          $k[$j++] = _PQ;
          if (_PQ.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseRequirementVLI#2886";
            $k[$j++] = "Coupon too short: Missing 2nd Purchase Requirement VLI";
            $k[$j++] = false;
            return true;
          }
          var _PR = $k[--$j];
          var _PT = $cvi($geti(_PR, 0, 1));
          $k[$j++] = _PR;
          $k[$j++] = _PT;
          if (_PT < 1 || _PT > 5) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBad2ndPurchaseRequirementVLI#2889";
            $k[$j++] = "Coupon 2nd Purchase Requirement length indicator must be 1-5";
            $k[$j++] = false;
            return true;
          }
          var _PU = $k[--$j];
          var _PV = $k[--$j];
          $k[$j++] = _PV;
          $k[$j++] = $f(_PU + 1);
          if ($f(_PU + 1) > _PV.length) {
            $j -= 3;
            $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseRequirement#2893";
            $k[$j++] = "Coupon too short: 2nd Purchase Requirement truncated";
            $k[$j++] = false;
            return true;
          }
          var _PW = $k[--$j];
          var _PX = $k[--$j];
          var _PY = $geti(_PX, _PW, $f(_PX.length - _PW));
          $k[$j++] = _PY;
          if (_PY.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseRequirementCode#2899";
            $k[$j++] = "Coupon too short: Missing 2nd Purchase Requirement Code";
            $k[$j++] = false;
            return true;
          }
          var _PZ = $k[--$j];
          var _Pb = $cvi($geti(_PZ, 0, 1));
          $k[$j++] = _PZ;
          if (_Pb > 4 && _Pb != 9) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBad2ndPurchaseRequirementCode#2902";
            $k[$j++] = "Coupon 2nd Purchase Requirement Code must be 0-4 or 9";
            $k[$j++] = false;
            return true;
          }
          var _Pc = $k[--$j];
          var _Pd = $geti(_Pc, 1, _Pc.length - 1);
          $k[$j++] = _Pd;
          if (_Pd.length < 3) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseFamilyCode#2908";
            $k[$j++] = "Coupon too short: 2nd Purchase Family Code truncated";
            $k[$j++] = false;
            return true;
          }
          var _Pe = $k[--$j];
          var _Pf = $geti(_Pe, 3, _Pe.length - 3);
          $k[$j++] = _Pf;
          if (_Pf.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseGCPVLI#2914";
            $k[$j++] = "Coupon too short: Missing 2nd Purchase GCP VLI";
            $k[$j++] = false;
            return true;
          }
          var _Pg = $k[--$j];
          var _Pi = $cvi($geti(_Pg, 0, 1));
          $k[$j++] = _Pg;
          $k[$j++] = _Pi;
          if (_Pi > 6 && _Pi != 9) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBad2ndPurchaseGCPVLI#2917";
            $k[$j++] = "Coupon 2nd Purchase GCP length indicator must be 0-6 or 9";
            $k[$j++] = false;
            return true;
          }
          var _Pj = $k[--$j];
          $k[$j++] = _Pj;
          if (_Pj != 9) {
            var _Pk = $k[--$j];
            $k[$j++] = $f(_Pk + 6);
          } else {
            $j--;
            $k[$j++] = 0;
          }
          var _Pl = $k[--$j];
          var _Pm = $k[--$j];
          $k[$j++] = _Pm;
          $k[$j++] = $f(_Pl + 1);
          if ($f(_Pl + 1) > _Pm.length) {
            $j -= 3;
            $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseGCP#2921";
            $k[$j++] = "Coupon too short: 2nd Purchase GCP truncated";
            $k[$j++] = false;
            return true;
          }
          var _Pn = $k[--$j];
          var _Po = $k[--$j];
          $k[$j++] = $geti(_Po, _Pn, $f(_Po.length - _Pn));
        }
      }
      var _Pq = $k[--$j];
      $k[$j++] = _Pq;
      if (_Pq.length >= 1) {
        var _Pr = $k[--$j];
        $k[$j++] = _Pr;
        if ($cvi($geti(_Pr, 0, 1)) == 2) {
          var _Pt = $k[--$j];
          var _Pu = $geti(_Pt, 1, _Pt.length - 1);
          $k[$j++] = _Pu;
          if (_Pu.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseRequirementVLI#2933";
            $k[$j++] = "Coupon too short: Missing 3rd Purchase Requirement VLI";
            $k[$j++] = false;
            return true;
          }
          var _Pv = $k[--$j];
          var _Px = $cvi($geti(_Pv, 0, 1));
          $k[$j++] = _Pv;
          $k[$j++] = _Px;
          if (_Px < 1 || _Px > 5) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBad3rdPurchaseRequirementVLI#2936";
            $k[$j++] = "Coupon 3rd Purchase Requirement length indicator must be 1-5";
            $k[$j++] = false;
            return true;
          }
          var _Py = $k[--$j];
          var _Pz = $k[--$j];
          $k[$j++] = _Pz;
          $k[$j++] = $f(_Py + 1);
          if ($f(_Py + 1) > _Pz.length) {
            $j -= 3;
            $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseRequirement#2940";
            $k[$j++] = "Coupon too short: 3rd Purchase Requirement truncated";
            $k[$j++] = false;
            return true;
          }
          var _Q0 = $k[--$j];
          var _Q1 = $k[--$j];
          var _Q2 = $geti(_Q1, _Q0, $f(_Q1.length - _Q0));
          $k[$j++] = _Q2;
          if (_Q2.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseRequirementCode#2946";
            $k[$j++] = "Coupon too short: Missing 3rd Purchase Requirement Code";
            $k[$j++] = false;
            return true;
          }
          var _Q3 = $k[--$j];
          var _Q5 = $cvi($geti(_Q3, 0, 1));
          $k[$j++] = _Q3;
          if (_Q5 > 4 && _Q5 != 9) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBad3rdPurchaseRequirementCode#2949";
            $k[$j++] = "Coupon 3rd Purchase Requirement Code must be 0-4 or 9";
            $k[$j++] = false;
            return true;
          }
          var _Q6 = $k[--$j];
          var _Q7 = $geti(_Q6, 1, _Q6.length - 1);
          $k[$j++] = _Q7;
          if (_Q7.length < 3) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseFamilyCode#2955";
            $k[$j++] = "Coupon too short: 3rd Purchase Family Code truncated";
            $k[$j++] = false;
            return true;
          }
          var _Q8 = $k[--$j];
          var _Q9 = $geti(_Q8, 3, _Q8.length - 3);
          $k[$j++] = _Q9;
          if (_Q9.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseGCPVLI#2961";
            $k[$j++] = "Coupon too short: Missing 3rd Purchase GCP VLI";
            $k[$j++] = false;
            return true;
          }
          var _QA = $k[--$j];
          var _QC = $cvi($geti(_QA, 0, 1));
          $k[$j++] = _QA;
          $k[$j++] = _QC;
          if (_QC > 6 && _QC != 9) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBad3rdPurchaseGCPVLI#2964";
            $k[$j++] = "Coupon 3rd Purchase GCP length indicator must be 0-6 or 9";
            $k[$j++] = false;
            return true;
          }
          var _QD = $k[--$j];
          $k[$j++] = _QD;
          if (_QD != 9) {
            var _QE = $k[--$j];
            $k[$j++] = $f(_QE + 6);
          } else {
            $j--;
            $k[$j++] = 0;
          }
          var _QF = $k[--$j];
          var _QG = $k[--$j];
          $k[$j++] = _QG;
          $k[$j++] = $f(_QF + 1);
          if ($f(_QF + 1) > _QG.length) {
            $j -= 3;
            $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseGCP#2968";
            $k[$j++] = "Coupon too short: 3rd Purchase GCP truncated";
            $k[$j++] = false;
            return true;
          }
          var _QH = $k[--$j];
          var _QI = $k[--$j];
          $k[$j++] = $geti(_QI, _QH, $f(_QI.length - _QH));
        }
      }
      $1.couponexpire = -1;
      var _QK = $k[--$j];
      $k[$j++] = _QK;
      if (_QK.length >= 1) {
        var _QL = $k[--$j];
        $k[$j++] = _QL;
        if ($cvi($geti(_QL, 0, 1)) == 3) {
          var _QN = $k[--$j];
          var _QO = $geti(_QN, 1, _QN.length - 1);
          $k[$j++] = _QO;
          if (_QO.length < 6) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortExpirationDate#2981";
            $k[$j++] = "Coupon too short: Expiration date";
            $k[$j++] = false;
            return true;
          }
          var _QP = $k[--$j];
          var _QR = $cvi($geti(_QP, 2, 2));
          $k[$j++] = _QP;
          if (_QR < 1 || _QR > 12) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponExpirationDateBadMonth#2983";
            $k[$j++] = "Invalid month in expiration date";
            $k[$j++] = false;
            return true;
          }
          var _QS = $k[--$j];
          var _QU = $cvi($geti(_QS, 0, 2));
          var _QV = _QU - 21;
          $k[$j++] = _QS;
          $k[$j++] = _QU;
          $k[$j++] = _QV;
          if (_QV >= 51) {
            $j--;
            var _QW = $k[--$j];
            $k[$j++] = $f(_QW + 1900);
          } else {
            if ($k[--$j] <= -50) {
              var _QY = $k[--$j];
              $k[$j++] = $f(_QY + 2100);
            } else {
              var _QZ = $k[--$j];
              $k[$j++] = $f(_QZ + 2e3);
            }
          }
          var _Qa = $k[--$j];
          $k[$j++] = _Qa % 400 == 0 || _Qa % 4 == 0 && _Qa % 100 != 0;
          $k[$j++] = Infinity;
          var _Qb = $k[--$j];
          var _Qd = $k[--$j] ? 29 : 28;
          $k[$j++] = _Qb;
          $k[$j++] = 31;
          $k[$j++] = _Qd;
          $k[$j++] = 31;
          $k[$j++] = 30;
          $k[$j++] = 31;
          $k[$j++] = 30;
          $k[$j++] = 31;
          $k[$j++] = 31;
          $k[$j++] = 30;
          $k[$j++] = 31;
          $k[$j++] = 30;
          $k[$j++] = 31;
          var _Qe = $a();
          var _Qf = $k[--$j];
          var _Qj = $cvi($geti(_Qf, 4, 2));
          $k[$j++] = _Qf;
          if ($get(_Qe, $cvi($geti(_Qf, 2, 2)) - 1) < _Qj || _Qj < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponExpirationDateBadDay#2990";
            $k[$j++] = "Invalid day of month in expiration date";
            $k[$j++] = false;
            return true;
          }
          var _Qk = $k[--$j];
          $1.couponexpire = $cvi($geti(_Qk, 0, 6));
          $k[$j++] = $geti(_Qk, 6, _Qk.length - 6);
        }
      }
      var _Qn = $k[--$j];
      $k[$j++] = _Qn;
      if (_Qn.length >= 1) {
        var _Qo = $k[--$j];
        $k[$j++] = _Qo;
        if ($cvi($geti(_Qo, 0, 1)) == 4) {
          var _Qq = $k[--$j];
          var _Qr = $geti(_Qq, 1, _Qq.length - 1);
          $k[$j++] = _Qr;
          if (_Qr.length < 6) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortStartDate#3002";
            $k[$j++] = "Coupon too short: Start date";
            $k[$j++] = false;
            return true;
          }
          var _Qs = $k[--$j];
          var _Qu = $cvi($geti(_Qs, 2, 2));
          $k[$j++] = _Qs;
          if (_Qu < 1 || _Qu > 12) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponStartDateBadMonth#3004";
            $k[$j++] = "Invalid month in start date";
            $k[$j++] = false;
            return true;
          }
          var _Qv = $k[--$j];
          var _Qx = $cvi($geti(_Qv, 0, 2));
          var _Qy = _Qx - 21;
          $k[$j++] = _Qv;
          $k[$j++] = _Qx;
          $k[$j++] = _Qy;
          if (_Qy >= 51) {
            $j--;
            var _Qz = $k[--$j];
            $k[$j++] = $f(_Qz + 1900);
          } else {
            if ($k[--$j] <= -50) {
              var _R1 = $k[--$j];
              $k[$j++] = $f(_R1 + 2100);
            } else {
              var _R2 = $k[--$j];
              $k[$j++] = $f(_R2 + 2e3);
            }
          }
          var _R3 = $k[--$j];
          $k[$j++] = _R3 % 400 == 0 || _R3 % 4 == 0 && _R3 % 100 != 0;
          $k[$j++] = Infinity;
          var _R4 = $k[--$j];
          var _R6 = $k[--$j] ? 29 : 28;
          $k[$j++] = _R4;
          $k[$j++] = 31;
          $k[$j++] = _R6;
          $k[$j++] = 31;
          $k[$j++] = 30;
          $k[$j++] = 31;
          $k[$j++] = 30;
          $k[$j++] = 31;
          $k[$j++] = 31;
          $k[$j++] = 30;
          $k[$j++] = 31;
          $k[$j++] = 30;
          $k[$j++] = 31;
          var _R7 = $a();
          var _R8 = $k[--$j];
          var _RC = $cvi($geti(_R8, 4, 2));
          $k[$j++] = _R8;
          if ($get(_R7, $cvi($geti(_R8, 2, 2)) - 1) < _RC || _RC < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponStartDateBadDay#3011";
            $k[$j++] = "Invalid day of month in start date";
            $k[$j++] = false;
            return true;
          }
          var _RD = $k[--$j];
          $1.couponstart = $cvi($geti(_RD, 0, 6));
          $k[$j++] = _RD;
          if ($1.couponexpire != -1 && $1.couponexpire < $1.couponstart) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponExpireDateBeforeStartDate#3014";
            $k[$j++] = "Coupon expires before it starts";
            $k[$j++] = false;
            return true;
          }
          var _RI = $k[--$j];
          $k[$j++] = $geti(_RI, 6, _RI.length - 6);
        }
      }
      var _RK = $k[--$j];
      $k[$j++] = _RK;
      if (_RK.length >= 1) {
        var _RL = $k[--$j];
        $k[$j++] = _RL;
        if ($cvi($geti(_RL, 0, 1)) == 5) {
          var _RN = $k[--$j];
          var _RO = $geti(_RN, 1, _RN.length - 1);
          $k[$j++] = _RO;
          if (_RO.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortSerialNumberVLI#3026";
            $k[$j++] = "Coupon too short: Missing Serial Number VLI";
            $k[$j++] = false;
            return true;
          }
          var _RP = $k[--$j];
          var _RQ = $geti(_RP, 0, 1);
          $k[$j++] = _RP;
          $k[$j++] = $cvi(_RQ) + 6 + 1;
          if ($cvi(_RQ) + 6 + 1 > _RP.length) {
            $j -= 3;
            $k[$j++] = "bwipp.GS1couponTooShortSerialNumber#3030";
            $k[$j++] = "Coupon too short: Serial Number truncated";
            $k[$j++] = false;
            return true;
          }
          var _RR = $k[--$j];
          var _RS = $k[--$j];
          $k[$j++] = $geti(_RS, _RR, $f(_RS.length - _RR));
        }
      }
      var _RU = $k[--$j];
      $k[$j++] = _RU;
      if (_RU.length >= 1) {
        var _RV = $k[--$j];
        $k[$j++] = _RV;
        if ($cvi($geti(_RV, 0, 1)) == 6) {
          var _RX = $k[--$j];
          var _RY = $geti(_RX, 1, _RX.length - 1);
          $k[$j++] = _RY;
          if (_RY.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortRetailerGCPGLNVLI#3042";
            $k[$j++] = "Coupon too short: Missing Retailer GCP/GLN VLI";
            $k[$j++] = false;
            return true;
          }
          var _RZ = $k[--$j];
          var _Rb = $cvi($geti(_RZ, 0, 1));
          $k[$j++] = _RZ;
          $k[$j++] = _Rb;
          if (_Rb < 1 || _Rb > 7) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBadRetailerGCPGLNVLI#3045";
            $k[$j++] = "Coupon Retailer GCP/GLN length indicator must be 1-7";
            $k[$j++] = false;
            return true;
          }
          var _Rc = $k[--$j];
          var _Rd = $k[--$j];
          $k[$j++] = _Rd;
          $k[$j++] = $f($f(_Rc + 6) + 1);
          if ($f($f(_Rc + 6) + 1) > _Rd.length) {
            $j -= 3;
            $k[$j++] = "bwipp.GS1couponTooShortRetailerGCPGLN#3049";
            $k[$j++] = "Coupon too short: Retailer GCP/GLN truncated";
            $k[$j++] = false;
            return true;
          }
          var _Re = $k[--$j];
          var _Rf = $k[--$j];
          $k[$j++] = $geti(_Rf, _Re, $f(_Rf.length - _Re));
        }
      }
      var _Rh = $k[--$j];
      $k[$j++] = _Rh;
      if (_Rh.length >= 1) {
        var _Ri = $k[--$j];
        $k[$j++] = _Ri;
        if ($cvi($geti(_Ri, 0, 1)) == 9) {
          var _Rk = $k[--$j];
          var _Rl = $geti(_Rk, 1, _Rk.length - 1);
          $k[$j++] = _Rl;
          if (_Rl.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortSaveValueCode#3061";
            $k[$j++] = "Coupon too short: Missing Save Value Code";
            $k[$j++] = false;
            return true;
          }
          var _Rm = $k[--$j];
          var _Ro = $cvi($geti(_Rm, 0, 1));
          $k[$j++] = _Rm;
          if (_Ro > 6 || (_Ro == 3 || _Ro == 4)) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBadSaveValueCode#3064";
            $k[$j++] = "Coupon Save Value Code must be 0,1,2,5 or 6";
            $k[$j++] = false;
            return true;
          }
          var _Rp = $k[--$j];
          var _Rq = $geti(_Rp, 1, _Rp.length - 1);
          $k[$j++] = _Rq;
          if (_Rq.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortSaveValueAppliesToItem#3070";
            $k[$j++] = "Coupon too short: Missing Save Value Applies to Item";
            $k[$j++] = false;
            return true;
          }
          var _Rr = $k[--$j];
          $k[$j++] = _Rr;
          if ($cvi($geti(_Rr, 0, 1)) > 2) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBadSaveValueAppliesToItem#3073";
            $k[$j++] = "Coupon Save Value Applies to Item must be 0-2";
            $k[$j++] = false;
            return true;
          }
          var _Rt = $k[--$j];
          var _Ru = $geti(_Rt, 1, _Rt.length - 1);
          $k[$j++] = _Ru;
          if (_Ru.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortStoreCouponFlag#3079";
            $k[$j++] = "Coupon too short: Missing Store Coupon Flag";
            $k[$j++] = false;
            return true;
          }
          var _Rv = $k[--$j];
          var _Rw = $geti(_Rv, 1, _Rv.length - 1);
          $k[$j++] = _Rw;
          if (_Rw.length < 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponTooShortDontMultiplyFlag#3085";
            $k[$j++] = "Coupon too short: Missing Don't Multiply Flag";
            $k[$j++] = false;
            return true;
          }
          var _Rx = $k[--$j];
          $k[$j++] = _Rx;
          if ($cvi($geti(_Rx, 0, 1)) > 1) {
            $j -= 2;
            $k[$j++] = "bwipp.GS1couponBadDontMultiplyFlag#3088";
            $k[$j++] = "Don't Multiply Flag must be 0 or 1";
            $k[$j++] = false;
            return true;
          }
          var _Rz = $k[--$j];
          $k[$j++] = $geti(_Rz, 1, _Rz.length - 1);
        }
      }
      var _S1 = $k[--$j];
      $k[$j++] = _S1;
      if (_S1.length != 0) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponUnrecognisedOptionalField#3095";
        $k[$j++] = "Coupon fields must be 1,2,3,4,5,6 or 9, increasing order";
        $k[$j++] = false;
        return true;
      }
      $j--;
    };
    $1.lintcouponposoffer = function() {
      var _S2 = $k[--$j];
      $k[$j++] = _S2;
      $k[$j++] = true;
      $forall(_S2, function() {
        var _S3 = $k[--$j];
        if (_S3 < 48 || _S3 > 57) {
          $j--;
          $k[$j++] = false;
          return true;
        }
      });
      if ($nt($k[--$j])) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponNotNumeric#3104";
        $k[$j++] = "Coupon not numeric";
        $k[$j++] = false;
        return true;
      }
      var _S5 = $k[--$j];
      $k[$j++] = _S5;
      if (_S5.length < 1) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShortFormatCode#3107";
        $k[$j++] = "Coupon too short: Missing Format Code";
        $k[$j++] = false;
        return true;
      }
      var _S6 = $k[--$j];
      var _S7 = $geti(_S6, 0, 1);
      $k[$j++] = _S6;
      if ($ne(_S7, "0") && $ne(_S7, "1")) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponBadFormatCode#3110";
        $k[$j++] = "Coupon format must be 0 or 1";
        $k[$j++] = false;
        return true;
      }
      var _S8 = $k[--$j];
      var _S9 = $geti(_S8, 1, _S8.length - 1);
      $k[$j++] = _S9;
      if (_S9.length < 1) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShortFunderVLI#3115";
        $k[$j++] = "Coupon too short: Missing Funder VLI";
        $k[$j++] = false;
        return true;
      }
      var _SA = $k[--$j];
      var _SC = $cvi($geti(_SA, 0, 1));
      $k[$j++] = _SA;
      $k[$j++] = _SC;
      if (_SC > 6) {
        $j -= 3;
        $k[$j++] = "bwipp.GS1couponBadFunderVLI#3118";
        $k[$j++] = "Coupon Funder length indicator must be 0-6";
        $k[$j++] = false;
        return true;
      }
      var _SD = $k[--$j];
      var _SE = $k[--$j];
      $k[$j++] = _SE;
      $k[$j++] = $f($f(_SD + 6) + 1);
      if ($f($f(_SD + 6) + 1) > _SE.length) {
        $j -= 3;
        $k[$j++] = "bwipp.GS1couponTooShortFunder#3122";
        $k[$j++] = "Coupon too short: Truncated Funder ID";
        $k[$j++] = false;
        return true;
      }
      var _SF = $k[--$j];
      var _SG = $k[--$j];
      var _SH = $geti(_SG, _SF, $f(_SG.length - _SF));
      $k[$j++] = _SH;
      if (_SH.length < 6) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShortOfferCode#3127";
        $k[$j++] = "Coupon too short: Truncated Offer Code";
        $k[$j++] = false;
        return true;
      }
      var _SI = $k[--$j];
      var _SJ = $geti(_SI, 6, _SI.length - 6);
      $k[$j++] = _SJ;
      if (_SJ.length < 1) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooShortSnVLI#3132";
        $k[$j++] = "Coupon too short: Missing SN VLI";
        $k[$j++] = false;
        return true;
      }
      var _SK = $k[--$j];
      var _SL = $geti(_SK, 0, 1);
      $k[$j++] = _SK;
      $k[$j++] = $cvi(_SL) + 6 + 1;
      if ($cvi(_SL) + 6 + 1 > _SK.length) {
        $j -= 3;
        $k[$j++] = "bwipp.GS1couponTooShortSn#3137";
        $k[$j++] = "Coupon too short: Truncated SN";
        $k[$j++] = false;
        return true;
      }
      var _SM = $k[--$j];
      var _SN = $k[--$j];
      var _SO = $geti(_SN, _SM, $f(_SN.length - _SM));
      $k[$j++] = _SO;
      if (_SO.length != 0) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1couponTooLong#3141";
        $k[$j++] = "Coupon too long";
        $k[$j++] = false;
        return true;
      }
      $j--;
    };
    $1.lintlatlong = function() {
      var _SP = $k[--$j];
      $k[$j++] = _SP;
      if (_SP.length != 20) {
        $j--;
        $k[$j++] = "bwipp.GS1badGeoLength#3148";
        $k[$j++] = "Invalid length for a geo-location";
        $k[$j++] = false;
        return true;
      }
      var _SQ = $k[--$j];
      $k[$j++] = _SQ;
      if ($cvi($geti(_SQ, 0, 10)) > 18e8) {
        $j--;
        $k[$j++] = "bwipp.GS1badLatitude#3150";
        $k[$j++] = "Invalid value for latitude";
        $k[$j++] = false;
        return true;
      }
      var _SS = $k[--$j];
      $k[$j++] = _SS;
      if ($cvi($geti(_SS, 10, 10)) > 36e8) {
        $j--;
        $k[$j++] = "bwipp.GS1badLongitude#3151";
        $k[$j++] = "Invalid value for longitude";
        $k[$j++] = false;
        return true;
      }
      $j--;
    };
    if (!bwipp_gs1process.__3161__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        var _SU = $a(["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"]);
        for (var _SV = 0, _SW = _SU.length; _SV < _SW; _SV++) {
          var _SX = $get(_SU, _SV);
          $k[$j++] = _SX;
          $k[$j++] = _SX;
        }
        $ctx.aidcmediatype = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1process.$ctx[id] = $ctx[id]);
        bwipp_gs1process.__3161__ = 1;
      })();
    }
    $1.lintmediatype = function() {
      var _Sc = $get($1.aidcmediatype, $k[--$j]) !== void 0;
      if (!_Sc) {
        $j--;
        $k[$j++] = "bwipp.GS1UnknownMediaType#3164";
        $k[$j++] = "Unknown AIDC media type";
        $k[$j++] = false;
        return true;
      }
    };
    if (!$1.dontlint) {
      $k[$j++] = true;
      for (var _Sg = 0, _Sf = $1.vals.length - 1; _Sg <= _Sf; _Sg += 1) {
        $1.ai = $get($1.ais, _Sg);
        $1.val = $get($1.vals, _Sg);
        var _Sn = $get($1.gs1syntax, $1.ai) !== void 0;
        if (_Sn) {
          var _Sr = $get($get($1.gs1syntax, $1.ai), "parts");
          $k[$j++] = _Sr;
          $k[$j++] = 0;
          $forall(_Sr, function() {
            var _Ss = $k[--$j];
            $k[$j++] = _Ss;
            if ($get(_Ss, "opt")) {
              $j--;
              $k[$j++] = 0;
            } else {
              var _Sv = $get($k[--$j], "min");
              $k[$j++] = _Sv;
            }
            var _Sw = $k[--$j];
            var _Sx = $k[--$j];
            $k[$j++] = $f(_Sx + _Sw);
          });
          if ($k[--$j] > $1.val.length) {
            $j--;
            $k[$j++] = "bwipp.GS1valueTooShort#3178";
            $k[$j++] = "Too short";
            $k[$j++] = false;
            break;
          }
          var _T0 = $k[--$j];
          $k[$j++] = _T0;
          $k[$j++] = 0;
          $forall(_T0, function() {
            var _T2 = $get($k[--$j], "max");
            var _T3 = $k[--$j];
            $k[$j++] = $f(_T3 + _T2);
          });
          if ($k[--$j] < $1.val.length) {
            $j--;
            $k[$j++] = "bwipp.GS1valueTooLong#3181";
            $k[$j++] = "Too long";
            $k[$j++] = false;
            break;
          }
          $forall($k[--$j], function() {
            $1.props = $k[--$j];
            var _T9 = $get($1.props, "max");
            var _TA = $1.val;
            var _TB = _TA.length;
            if (_T9 > _TA.length) {
              var _ = _TB;
              _TB = _T9;
              _T9 = _;
            }
            $1.eval = $geti($1.val, 0, _T9);
            var _TG = $1.eval.length;
            $1.val = $geti($1.val, _TG, $1.val.length - _TG);
            if ($1.eval.length == 0) {
              if ($nt($get($1.props, "opt"))) {
                $j--;
                $k[$j++] = "bwipp.GS1valueTooShort#3190";
                $k[$j++] = "Too short";
                $k[$j++] = false;
                return true;
              }
            } else {
              if ($1.eval.length < $get($1.props, "min")) {
                $j--;
                $k[$j++] = "bwipp.GS1valueTooShort#3194";
                $k[$j++] = "Too short";
                $k[$j++] = false;
                return true;
              }
              var _TP = /* @__PURE__ */ new Map([
                ["N", "lintnumeric"],
                ["X", "lintcset82"],
                ["Y", "lintcset39"]
              ]);
              $k[$j++] = $1.eval;
              if ($1[$get(_TP, $get($1.props, "cset"))]() === true) {
                return true;
              }
              $forall($get($1.props, "linters"), function() {
                var _TZ = $1[$k[--$j]];
                $k[$j++] = $1.eval;
                if (_TZ() === true) {
                  return true;
                }
              });
            }
          });
          var _Ta = $k[--$j];
          $k[$j++] = _Ta;
          if ($nt(_Ta)) {
            break;
          }
          if ($1.val.length != 0) {
            $j--;
            $k[$j++] = "bwipp.GS1valueTooLong#3202";
            $k[$j++] = "Too long";
            $k[$j++] = false;
            break;
          }
        } else {
          $j--;
          $k[$j++] = "bwipp.GS1unknownAI#3205";
          $k[$j++] = "Unrecognised AI";
          $k[$j++] = false;
          break;
        }
      }
      if ($nt($k[--$j])) {
        var _Td = $k[--$j];
        var _Tf = $s(_Td.length + $1.ai.length + 5);
        $puti(_Tf, 0, "AI ");
        $puti(_Tf, 3, $1.ai);
        $puti(_Tf, 3 + $1.ai.length, ": ");
        $puti(_Tf, 5 + $1.ai.length, _Td);
        $k[$j++] = _Tf;
        bwipp_raiseerror();
      }
      $1.aiexists = function() {
        $1.this = $k[--$j];
        $1.patt = $k[--$j];
        for (var _Tl = 0, _Tm = 1; _Tl < _Tm; _Tl++) {
          var _Tp = $get($1.aivals, $1.patt) !== void 0;
          if (_Tp) {
            $k[$j++] = true;
            break;
          }
          if ($1.patt.length == 4) {
            if ($eq($geti($1.patt, 3, 1), "n")) {
              var _Tv = $eq($geti($1.patt, 2, 1), "n") ? 2 : 3;
              $1.pfxlen = _Tv;
              var _Tw = $1.ais;
              $k[$j++] = false;
              for (var _Tx = 0, _Ty = _Tw.length; _Tx < _Ty; _Tx++) {
                var _Tz = $get(_Tw, _Tx);
                $k[$j++] = _Tz;
                if ($ne(_Tz, $1.this) && _Tz.length == 4) {
                  if ($eq($geti($k[--$j], 0, $1.pfxlen), $geti($1.patt, 0, $1.pfxlen))) {
                    $j--;
                    $k[$j++] = true;
                  }
                } else {
                  $j--;
                }
              }
              break;
            }
            $k[$j++] = false;
            break;
          }
          $k[$j++] = false;
          break;
        }
      };
      var _U7 = $1.vals;
      $1.aivals = /* @__PURE__ */ new Map();
      for (var _UA = 0, _U9 = $1.vals.length - 1; _UA <= _U9; _UA += 1) {
        $1.ai = $get($1.ais, _UA);
        $1.val = $get($1.vals, _UA);
        var _UH = $get($1.aivals, $1.ai) !== void 0;
        if (_UH) {
          if ($ne($get($1.aivals, $1.ai), $1.val)) {
            var _UN = $s($1.ai.length + 40);
            $puti(_UN, 0, "Repeated AIs (");
            $puti(_UN, 14, $1.ai);
            $puti(_UN, 14 + $1.ai.length, ") must have the same value");
            $k[$j++] = "bwipp.GS1repeatedDifferingAIs#3255";
            $k[$j++] = _UN;
            bwipp_raiseerror();
          }
        } else {
          $put($1.aivals, $1.ai, $1.val);
        }
      }
      for (var _UV = 0, _UU = $1.vals.length - 1; _UV <= _UU; _UV += 1) {
        $1.ai = $get($1.ais, _UV);
        var _Ua = $get($1.gs1syntax, $1.ai);
        var _Ub = $get(_Ua, "ex") !== void 0;
        $k[$j++] = _Ua;
        $k[$j++] = "ex";
        if (_Ub) {
          var _Uc = $k[--$j];
          $forall($get($k[--$j], _Uc), function() {
            $1.patt = $k[--$j];
            $k[$j++] = $1.patt;
            $k[$j++] = $1.ai;
            $1.aiexists();
            if ($k[--$j]) {
              var _Ul = $s($1.ai.length + $1.patt.length + 36);
              $puti(_Ul, 0, "AIs (");
              $puti(_Ul, 5, $1.ai);
              $puti(_Ul, 5 + $1.ai.length, ") and (");
              $puti(_Ul, 12 + $1.ai.length, $1.patt);
              $puti(_Ul, 12 + $1.ai.length + $1.patt.length, ") are mutually exclusive");
              $k[$j++] = "bwipp.GS1exclusiveAIs#3275";
              $k[$j++] = _Ul;
              bwipp_raiseerror();
            }
          });
        } else {
          $j -= 2;
        }
        if ($1.lintreqs) {
          var _Uv = $get($1.gs1syntax, $1.ai);
          var _Uw = $get(_Uv, "req") !== void 0;
          $k[$j++] = _Uv;
          $k[$j++] = "req";
          if (_Uw) {
            var _Ux = $k[--$j];
            $forall($get($k[--$j], _Ux), function() {
              var _V0 = $k[--$j];
              $k[$j++] = false;
              $forall(_V0, function() {
                $k[$j++] = $1.ai;
                $1.aiexists();
                if ($k[--$j]) {
                  $j--;
                  $k[$j++] = true;
                }
              });
              if ($nt($k[--$j])) {
                var _V5 = $s($1.ai.length + 47);
                $puti(_V5, 0, "One of more requisite AIs for AI (");
                $puti(_V5, 34, $1.ai);
                $puti(_V5, 34 + $1.ai.length, ") are missing");
                $k[$j++] = "bwipp.GS1missingAIs#3292";
                $k[$j++] = _V5;
                bwipp_raiseerror();
              }
            });
          } else {
            $j -= 2;
          }
        }
      }
    }
    $k[$j++] = $1.ais;
    $k[$j++] = $1.vals;
    $k[$j++] = $1.fncs;
  }
  function bwipp_renmatrix() {
    if ($0.bwipjs_dontdraw) {
      return;
    }
    var $1 = Object.create(bwipp_renmatrix.$ctx || (bwipp_renmatrix.$ctx = {}));
    $1.width = 1;
    $1.height = 1;
    $1.barcolor = "unset";
    $1.backgroundcolor = "unset";
    $1.colormap = "unset";
    $1.dotty = false;
    $1.inkspread = 0;
    $1.inkspreadh = 0;
    $1.inkspreadv = 0;
    $1.includetext = false;
    $1.txt = $a([]);
    $1.textcolor = "unset";
    $1.textxalign = "unset";
    $1.textyalign = "unset";
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = 0;
    $1.textgaps = 0;
    $1.alttext = "";
    $forall($k[--$j], function() {
      var _3 = $k[--$j];
      $1[$k[--$j]] = _3;
    });
    $k[$j++] = $1.opt;
    delete $1["opt"];
    $k[$j++] = $1;
    bwipp_processoptions();
    $j--;
    if ($1.inkspread != 0) {
      $1.inkspreadh = $1.inkspread;
    }
    if ($1.inkspread != 0) {
      $1.inkspreadv = $1.inkspread;
    }
    if ($1.textsize <= 0) {
      $k[$j++] = "bwipp.renmatrixBadTextsize#3602";
      $k[$j++] = "The font size must be greater than zero";
      bwipp_raiseerror();
    }
    $1.xyget = function() {
      var _C = $k[--$j];
      var _F = $get($1.pixs, $f($k[--$j] + _C * $1.pixx));
      $k[$j++] = _F;
    };
    $1.cget = function() {
      var _H = $k[--$j];
      var _K = $get($1.cache, $f($k[--$j] + _H * $1.pixx));
      var _L = $k[--$j];
      $k[$j++] = $an(_L, _K);
    };
    $1.cput = function() {
      var _M = $k[--$j];
      $k[$j++] = _M;
      if (_M % 4 == 0) {
        var _N = $k[--$j];
        var _O = $k[--$j];
        var _P = $k[--$j];
        var _Q = $1.pixx;
        var _R = $1.cache;
        $put(_R, $f(_P + _O * _Q), $or($get(_R, $f(_P + _O * _Q)), _N));
      } else {
        $j -= 3;
      }
    };
    $1.abcd = function() {
      $k[$j++] = $s(4);
      $k[$j++] = 0;
      $k[$j++] = Infinity;
      var _U = $k[--$j];
      var _V = $k[--$j];
      var _W = $k[--$j];
      var _X = $k[--$j];
      var _a = $f($k[--$j] + _X * $1.pixx);
      $k[$j++] = _W;
      $k[$j++] = _V;
      $k[$j++] = _U;
      $k[$j++] = _a;
      $aload($geti($1.pixs, _a, 2));
      var _d = $k[--$j];
      var _e = $k[--$j];
      var _i = $geti($1.pixs, $f($k[--$j] + $1.pixx), 2);
      $k[$j++] = _e;
      $k[$j++] = _d;
      $aload(_i);
      var _j = $a();
      for (var _k = 0, _l = _j.length; _k < _l; _k++) {
        var _n = $k[--$j];
        var _o = $k[--$j];
        $put(_o, _n, $f($get(_j, _k) + 48));
        $k[$j++] = _o;
        $k[$j++] = $f(_n + 1);
      }
      $j--;
    };
    $1.right = function() {
      if ($1.dir != 1) {
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $k[$j++] = $1.dir;
        $1.cput();
        $k[$j++] = $a([$1.x, $1.y]);
      }
      $1.x = $1.x + 1;
      $1.dir = 1;
    };
    $1.down = function() {
      if ($1.dir != 2) {
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $k[$j++] = $1.dir;
        $1.cput();
        $k[$j++] = $a([$1.x, $1.y]);
      }
      $1.y = $1.y + 1;
      $1.dir = 2;
    };
    $1.left = function() {
      if ($1.dir != 4) {
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $k[$j++] = $1.dir;
        $1.cput();
        $k[$j++] = $a([$1.x, $1.y]);
      }
      $1.x = $1.x - 1;
      $1.dir = 4;
    };
    $1.up = function() {
      if ($1.dir != 8) {
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $k[$j++] = $1.dir;
        $1.cput();
        $k[$j++] = $a([$1.x, $1.y]);
      }
      $1.y = $1.y - 1;
      $1.dir = 8;
    };
    $1.trace = function() {
      $1.y = $k[--$j];
      $1.x = $k[--$j];
      $k[$j++] = "dir";
      $k[$j++] = $f($1.x + 1);
      $k[$j++] = $f($1.y + 1);
      $1.xyget();
      var _1Q = $k[--$j] == 1 ? 8 : 4;
      $1[$k[--$j]] = _1Q;
      $1.sx = $1.x;
      $1.sy = $1.y;
      $1.sdir = $1.dir;
      $k[$j++] = Infinity;
      for (; ; ) {
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $1.abcd();
        for (var _1X = 0, _1Y = 1; _1X < _1Y; _1X++) {
          var _1Z = $k[--$j];
          $k[$j++] = _1Z;
          if ($eq(_1Z, "0001") || ($eq(_1Z, "0011") || $eq(_1Z, "1011"))) {
            $j--;
            $1.right();
            break;
          }
          var _1a = $k[--$j];
          $k[$j++] = _1a;
          if ($eq(_1a, "0010") || ($eq(_1a, "1010") || $eq(_1a, "1110"))) {
            $j--;
            $1.down();
            break;
          }
          var _1b = $k[--$j];
          $k[$j++] = _1b;
          if ($eq(_1b, "1000") || ($eq(_1b, "1100") || $eq(_1b, "1101"))) {
            $j--;
            $1.left();
            break;
          }
          var _1c = $k[--$j];
          $k[$j++] = _1c;
          if ($eq(_1c, "0100") || ($eq(_1c, "0101") || $eq(_1c, "0111"))) {
            $j--;
            $1.up();
            break;
          }
          var _1d = $k[--$j];
          $k[$j++] = _1d;
          if ($eq(_1d, "1001")) {
            if ($1.dir == 2) {
              $j--;
              $1.left();
              break;
            } else {
              $j--;
              $1.right();
              break;
            }
          } else {
            if ($1.dir == 1) {
              $j--;
              $1.down();
              break;
            } else {
              $j--;
              $1.up();
              break;
            }
          }
        }
        if ($eq($1.x, $1.sx) && $eq($1.y, $1.sy) && $1.dir == $1.sdir) {
          break;
        }
      }
      $astore($a($counttomark()));
      var _1o = $k[--$j];
      var _1p = $k[--$j];
      $k[$j++] = _1o;
      $k[$j++] = _1p;
      $j--;
    };
    $1.drawlayer = function() {
      $1.pixsorig = $1.pixs;
      $1.pixs = $k[--$j];
      $k[$j++] = Infinity;
      for (var _1t = 0, _1u = $1.pixx + 2; _1t < _1u; _1t++) {
        $k[$j++] = 0;
      }
      for (var _1y = 0, _1z = $1.pixx, _1x = $1.pixs.length - 1; _1z < 0 ? _1y >= _1x : _1y <= _1x; _1y += _1z) {
        $k[$j++] = 0;
        $aload($geti($1.pixs, _1y, $1.pixx));
        $k[$j++] = 0;
      }
      for (var _24 = 0, _25 = $1.pixx + 2; _24 < _25; _24++) {
        $k[$j++] = 0;
      }
      $1.pixs = $a();
      $1.pixx = $1.pixx + 2;
      $1.pixy = $1.pixy + 2;
      $k[$j++] = Infinity;
      for (var _2A = 0, _2B = $1.pixs.length; _2A < _2B; _2A++) {
        $k[$j++] = 0;
      }
      $1.cache = $a();
      $k[$j++] = Infinity;
      for (var _2F = 0, _2E = $1.pixy - 2; _2F <= _2E; _2F += 1) {
        $1.j = _2F;
        for (var _2I = 0, _2H = $1.pixx - 2; _2I <= _2H; _2I += 1) {
          $1.i = _2I;
          $k[$j++] = "k";
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.abcd();
          var _2L = $k[--$j];
          $1[$k[--$j]] = _2L;
          if ($eq($1.k, "0001") || $eq($1.k, "1001")) {
            $k[$j++] = 8;
            $k[$j++] = $1.i;
            $k[$j++] = $1.j;
            $1.cget();
            if ($k[--$j] == 0) {
              $k[$j++] = $1.i;
              $k[$j++] = $1.j;
              $1.trace();
            }
          }
          if ($eq($1.k, "1110")) {
            $k[$j++] = 4;
            $k[$j++] = $1.i;
            $k[$j++] = $1.j;
            $1.cget();
            if ($k[--$j] == 0) {
              $k[$j++] = $1.i;
              $k[$j++] = $1.j;
              $1.trace();
            }
          }
        }
      }
      $1.paths = $a();
      $1.pixx = $1.pixx - 2;
      $1.pixy = $1.pixy - 2;
      $$.newpath();
      var _2d = $1.paths;
      for (var _2e = 0, _2f = _2d.length; _2e < _2f; _2e++) {
        $1.p = $get(_2d, _2e);
        $1.len = $1.p.length;
        $aload($get($1.p, $1.len - 1));
        $aload($get($1.p, 0));
        for (var _2p = 0, _2o = $1.len - 1; _2p <= _2o; _2p += 1) {
          $1.i = _2p;
          $aload($get($1.p, ($1.i + 1) % $1.len));
          var _2u = $k[--$j];
          var _2v = $k[--$j];
          var _2w = $k[--$j];
          var _2x = $k[--$j];
          var _2y = $k[--$j];
          var _2z = $k[--$j];
          $k[$j++] = _2x;
          $k[$j++] = _2w;
          $k[$j++] = _2v;
          $k[$j++] = _2u;
          $k[$j++] = _2z;
          $k[$j++] = _2x;
          $k[$j++] = $1.inkspreadh;
          if ($lt(_2u, _2y)) {
            var _31 = $k[--$j];
            var _32 = $k[--$j];
            $k[$j++] = $f(_32 + _31);
          } else {
            var _33 = $k[--$j];
            var _34 = $k[--$j];
            $k[$j++] = $f(_34 - _33);
          }
          var _35 = $k[--$j];
          var _36 = $k[--$j];
          var _37 = $k[--$j];
          var _38 = $k[--$j];
          var _39 = $k[--$j];
          $k[$j++] = _39;
          $k[$j++] = _35;
          $k[$j++] = _38;
          $k[$j++] = _37;
          $k[$j++] = _39;
          $k[$j++] = $1.inkspreadv;
          if ($gt(_38, _36)) {
            var _3B = $k[--$j];
            var _3C = $k[--$j];
            $k[$j++] = $f(_3C + _3B);
          } else {
            var _3D = $k[--$j];
            var _3E = $k[--$j];
            $k[$j++] = $f(_3E - _3D);
          }
          var _3F = $k[--$j];
          var _3G = $k[--$j];
          var _3H = $k[--$j];
          var _3I = $k[--$j];
          $k[$j++] = _3H;
          $k[$j++] = _3G;
          $k[$j++] = _3I;
          $k[$j++] = $f($1.pixy - _3F);
          if ($1.i == 0) {
            var _3L = $k[--$j];
            $$.moveto($k[--$j], _3L);
          } else {
            var _3N = $k[--$j];
            $$.lineto($k[--$j], _3N);
          }
        }
        $$.closepath();
        $j -= 4;
      }
      $$.fill();
      $1.pixs = $1.pixsorig;
    };
    $1.drawlayerdots = function() {
      $1.pixsorig = $1.pixs;
      $1.pixs = $k[--$j];
      $$.newpath();
      for (var _3U = 0, _3T = $1.pixs.length - 1; _3U <= _3T; _3U += 1) {
        $1.x = _3U % $1.pixx;
        $1.y = ~~(_3U / $1.pixx);
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $1.xyget();
        if ($k[--$j] == 1) {
          $$.moveto($f($1.x + 0.5), $f($1.pixy - $1.y - 0.5));
          $$.arc($f($1.x + 0.5), $f($1.pixy - $1.y - 0.5), $f(0.5 - $1.inkspread), 0, 360, 1);
        }
      }
      $$.fill();
      $1.pixs = $1.pixsorig;
    };
    $$.save();
    $1.inkspread = $1.inkspread / 2;
    $1.inkspreadh = $1.inkspreadh / 2;
    $1.inkspreadv = $1.inkspreadv / 2;
    var _3l = $$.currpos();
    $$.translate(_3l.x, _3l.y);
    $$.scale($1.width / $1.pixx * 72, $1.height / $1.pixy * 72);
    $$.moveto(0, 0);
    $$.lineto($1.pixx, 0);
    $$.lineto($1.pixx, $1.pixy);
    $$.lineto(0, $1.pixy);
    $$.closepath();
    if ($eq($1.colormap, "unset")) {
      var _3w = /* @__PURE__ */ new Map([
        [1, $1.barcolor]
      ]);
      $1.colormap = _3w;
    }
    var _3x = $1.colormap;
    for (var _42 = _3x.size, _41 = _3x.keys(), _40 = 0; _40 < _42; _40++) {
      var _3y = _41.next().value;
      var _3z = _3x.get(_3y);
      $k[$j++] = _3y;
      $k[$j++] = _3z;
      if ($ne(_3z, "unset")) {
        $$.setcolor($k[--$j]);
      } else {
        $j--;
      }
      $1.key = $k[--$j];
      $k[$j++] = Infinity;
      var _45 = $1.pixs;
      for (var _46 = 0, _47 = _45.length; _46 < _47; _46++) {
        var _4A = $eq($get(_45, _46), $1.key) ? 1 : 0;
        $k[$j++] = _4A;
      }
      var _4B = $a();
      $k[$j++] = _4B;
      if ($1.dotty) {
        $1.drawlayerdots();
      } else {
        $1.drawlayer();
      }
    }
    if ($ne($1.textcolor, "unset")) {
      $$.setcolor($1.textcolor);
    }
    if ($1.includetext) {
      if ($eq($1.textxalign, "unset") && $eq($1.textyalign, "unset") && $eq($1.alttext, "")) {
        $1.s = 0;
        $1.fn = "";
        var _4J = $1.txt;
        for (var _4K = 0, _4L = _4J.length; _4K < _4L; _4K++) {
          $forall($get(_4J, _4K));
          var _4N = $k[--$j];
          var _4O = $k[--$j];
          $k[$j++] = _4O;
          $k[$j++] = _4N;
          if (_4N != $1.s || $ne(_4O, $1.fn)) {
            var _4R = $k[--$j];
            $k[$j++] = _4R;
            if (_4R <= 0) {
              $j -= 5;
              $k[$j++] = "bwipp.renmatrixFontTooSmall#3803";
              $k[$j++] = "The font size is too small";
              bwipp_raiseerror();
            }
            var _4S = $k[--$j];
            var _4T = $k[--$j];
            $1.s = _4S;
            $1.fn = _4T;
            $$.selectfont(_4T, _4S);
          } else {
            $j -= 2;
          }
          var _4U = $k[--$j];
          $$.moveto($k[--$j], _4U);
          $$.show($k[--$j], 0, 0);
        }
      } else {
        $$.selectfont($1.textfont, $1.textsize);
        if ($eq($1.alttext, "")) {
          $k[$j++] = Infinity;
          var _4a = $1.txt;
          for (var _4b = 0, _4c = _4a.length; _4b < _4c; _4b++) {
            $forall($get($get(_4a, _4b), 0));
          }
          $1.txt = $a();
          $1.tstr = $s($1.txt.length);
          for (var _4k = 0, _4j = $1.txt.length - 1; _4k <= _4j; _4k += 1) {
            $put($1.tstr, _4k, $get($1.txt, _4k));
          }
        } else {
          $1.tstr = $1.alttext;
        }
        if ($1.tstr.length == 0) {
          $k[$j++] = 0;
        } else {
          $$.save();
          $$.newpath();
          $$.moveto(0, 0);
          $$.charpath("0", false);
          var _4q = $$.pathbbox();
          $$.restore();
          $k[$j++] = _4q.ury;
        }
        $1.textascent = $k[--$j];
        var _4t = $$.stringwidth($1.tstr);
        $1.textwidth = $f(_4t.w + ($1.tstr.length - 1) * $1.textgaps);
        $1.textxpos = $f($1.textxoffset + $f($1.pixx - $1.textwidth) / 2);
        if ($eq($1.textxalign, "left")) {
          $1.textxpos = $1.textxoffset;
        }
        if ($eq($1.textxalign, "right")) {
          $1.textxpos = $f($1.pixx - $1.textxoffset - $1.textwidth);
        }
        if ($eq($1.textxalign, "offleft")) {
          $1.textxpos = -$f($1.textwidth + $1.textxoffset);
        }
        if ($eq($1.textxalign, "offright")) {
          $1.textxpos = $1.pixx + $1.textxoffset;
        }
        if ($eq($1.textxalign, "justify") && $1.textwidth < $1.pixx) {
          $1.textxpos = 0;
          $1.textgaps = $f($1.pixx - $1.textwidth) / ($1.tstr.length - 1);
        }
        $1.textypos = -$f($f($1.textyoffset + $1.textascent) + 1);
        if ($eq($1.textyalign, "above")) {
          $1.textypos = $1.textyoffset + $1.pixy + 1;
        }
        if ($eq($1.textyalign, "center")) {
          $1.textypos = $f($1.textyoffset + $f($1.pixy - $1.textascent) / 2);
        }
        $$.moveto($1.textxpos, $1.textypos);
        $$.show($1.tstr, $1.textgaps, 0);
      }
    }
    $$.restore();
  }
  function bwipp_ean5() {
    var $1 = Object.create(bwipp_ean5.$ctx || (bwipp_ean5.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 12;
    $1.textxoffset = 0;
    $1.textyoffset = null;
    $1.height = 0.7;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.textyoffset, null)) {
      $1.textyoffset = $f($1.height * 72 + 1);
    }
    if ($1.barcode.length != 5) {
      $k[$j++] = "bwipp.ean5badLength#4003";
      $k[$j++] = "EAN-5 add-on must be 5 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _6 = $k[--$j];
      if (_6 < 48 || _6 > 57) {
        $k[$j++] = "bwipp.ean5badCharacter#4007";
        $k[$j++] = "EAN-5 add-on must contain only digits";
        bwipp_raiseerror();
      }
    });
    if (!bwipp_ean5.__4027__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "112", "11"]);
        $ctx.barchars = "0123456789";
        $ctx.mirrormaps = $a(["11000", "10100", "10010", "10001", "01100", "00110", "00011", "01010", "01001", "00101"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_ean5.$ctx[id] = $ctx[id]);
        bwipp_ean5.__4027__ = 1;
      })();
    }
    $1.checksum = 0;
    for (var _A = 0; _A <= 4; _A += 1) {
      $1.i = _A;
      $1.barchar = $f($get($1.barcode, $1.i) - 48);
      if ($1.i % 2 == 0) {
        $1.checksum = $f($1.barchar * 3 + $1.checksum);
      } else {
        $1.checksum = $f($1.barchar * 9 + $1.checksum);
      }
    }
    $1.checksum = $1.checksum % 10;
    $1.mirrormap = $get($1.mirrormaps, $1.checksum);
    $1.sbs = $s(31);
    $1.txt = $a(5);
    for (var _P = 0; _P <= 4; _P += 1) {
      $1.i = _P;
      if ($1.i == 0) {
        $puti($1.sbs, 0, $get($1.encs, 10));
      } else {
        $puti($1.sbs, ($1.i - 1) * 6 + 7, $get($1.encs, 11));
      }
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      if ($get($1.mirrormap, $1.i) == 49) {
        $1.enclen = $1.enc.length;
        $1.revenc = $s($1.enclen);
        for (var _o = 0, _n = $1.enclen - 1; _o <= _n; _o += 1) {
          $1.j = _o;
          $1.char = $get($1.enc, $1.j);
          $put($1.revenc, $1.enclen - $1.j - 1, $1.char);
        }
        $1.enc = $1.revenc;
      }
      $puti($1.sbs, $1.i * 6 + 3, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.i - 1) * 9 + 13 + $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _1B = $1.sbs;
    for (var _1C = 0, _1D = _1B.length; _1C < _1D; _1C++) {
      $k[$j++] = $get(_1B, _1C) - 48;
    }
    var _1F = $a();
    $k[$j++] = Infinity;
    for (var _1G = 0, _1H = 16; _1G < _1H; _1G++) {
      $k[$j++] = $1.height;
    }
    var _1J = $a();
    $k[$j++] = Infinity;
    for (var _1K = 0, _1L = 16; _1K < _1L; _1K++) {
      $k[$j++] = 0;
    }
    var _1M = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _1F;
    $k[$j++] = "bhs";
    $k[$j++] = _1J;
    $k[$j++] = "bbs";
    $k[$j++] = _1M;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    $k[$j++] = "guardrightpos";
    $k[$j++] = 10;
    $k[$j++] = "guardrightypos";
    $k[$j++] = $f($1.textyoffset + 4);
    $k[$j++] = "bordertop";
    $k[$j++] = 10;
    var _1R = $d();
    $k[$j++] = _1R;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_ean2() {
    var $1 = Object.create(bwipp_ean2.$ctx || (bwipp_ean2.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 12;
    $1.textxoffset = 0;
    $1.textyoffset = null;
    $1.height = 0.7;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.textyoffset, null)) {
      $1.textyoffset = $f($1.height * 72 + 1);
    }
    if ($1.barcode.length != 2) {
      $k[$j++] = "bwipp.ean2badLength#4146";
      $k[$j++] = "EAN-2 add-on must be 2 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _6 = $k[--$j];
      if (_6 < 48 || _6 > 57) {
        $k[$j++] = "bwipp.ean2badCharacter#4150";
        $k[$j++] = "EAN-2 add-on must contain only digits";
        bwipp_raiseerror();
      }
    });
    if (!bwipp_ean2.__4167__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "112", "11"]);
        $ctx.barchars = "0123456789";
        $ctx.mirrormaps = $a(["00", "01", "10", "11"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_ean2.$ctx[id] = $ctx[id]);
        bwipp_ean2.__4167__ = 1;
      })();
    }
    $1.mirrormap = $get($1.mirrormaps, $cvi($geti($1.barcode, 0, 2)) % 4);
    $1.sbs = $s(13);
    $1.txt = $a(2);
    for (var _G = 0; _G <= 1; _G += 1) {
      $1.i = _G;
      if ($1.i == 0) {
        $puti($1.sbs, 0, $get($1.encs, 10));
      } else {
        $puti($1.sbs, ($1.i - 1) * 6 + 7, $get($1.encs, 11));
      }
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      if ($get($1.mirrormap, $1.i) == 49) {
        $1.enclen = $1.enc.length;
        $1.revenc = $s($1.enclen);
        for (var _f = 0, _e = $1.enclen - 1; _f <= _e; _f += 1) {
          $1.j = _f;
          $1.char = $get($1.enc, $1.j);
          $put($1.revenc, $1.enclen - $1.j - 1, $1.char);
        }
        $1.enc = $1.revenc;
      }
      $puti($1.sbs, $1.i * 6 + 3, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.i - 1) * 9 + 13 + $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _12 = $1.sbs;
    for (var _13 = 0, _14 = _12.length; _13 < _14; _13++) {
      $k[$j++] = $get(_12, _13) - 48;
    }
    var _16 = $a();
    $k[$j++] = Infinity;
    for (var _17 = 0, _18 = 12; _17 < _18; _17++) {
      $k[$j++] = $1.height;
    }
    var _1A = $a();
    $k[$j++] = Infinity;
    for (var _1B = 0, _1C = 12; _1B < _1C; _1B++) {
      $k[$j++] = 0;
    }
    var _1D = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _16;
    $k[$j++] = "bhs";
    $k[$j++] = _1A;
    $k[$j++] = "bbs";
    $k[$j++] = _1D;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    $k[$j++] = "guardrightpos";
    $k[$j++] = 10;
    $k[$j++] = "guardrightypos";
    $k[$j++] = $f($1.textyoffset + 4);
    $k[$j++] = "bordertop";
    $k[$j++] = 10;
    var _1I = $d();
    $k[$j++] = _1I;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_ean13() {
    var $1 = Object.create(bwipp_ean13.$ctx || (bwipp_ean13.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 12;
    $1.textxoffset = -10;
    $1.textyoffset = -4;
    $1.height = 1;
    $1.addongap = 12;
    $1.addontextfont = "unset";
    $1.addontextsize = null;
    $1.addontextxoffset = null;
    $1.addontextyoffset = null;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $search($1.barcode, " ");
    if ($k[--$j]) {
      $1.barcode = $k[--$j];
      $j--;
      $1.addon = $k[--$j];
    } else {
      $j--;
      $1.addon = "";
    }
    if ($1.barcode.length != 12 && $1.barcode.length != 13) {
      $k[$j++] = "bwipp.ean13badLength#4288";
      $k[$j++] = "EAN-13 must be 12 or 13 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _9 = $k[--$j];
      if (_9 < 48 || _9 > 57) {
        $k[$j++] = "bwipp.ean13badCharacter#4292";
        $k[$j++] = "EAN-13 must contain only digits";
        bwipp_raiseerror();
      }
    });
    if ($1.addon.length != 0 && $1.addon.length != 2 && $1.addon.length != 5) {
      $k[$j++] = "bwipp.ean13badAddOnLength#4296";
      $k[$j++] = "Add-on for EAN-13 must be 2 or 5 digits";
      bwipp_raiseerror();
    }
    $1.pad = $s(13);
    $1.checksum = 0;
    for (var _E = 0; _E <= 11; _E += 1) {
      $1.i = _E;
      $1.barchar = $f($get($1.barcode, $1.i) - 48);
      if ($1.i % 2 == 0) {
        $1.checksum = $f($1.barchar + $1.checksum);
      } else {
        $1.checksum = $f($1.barchar * 3 + $1.checksum);
      }
    }
    $1.checksum = $f(10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 13) {
      if ($get($1.barcode, 12) != $f($1.checksum + 48)) {
        $k[$j++] = "bwipp.ean13badCheckDigit#4314";
        $k[$j++] = "Incorrect EAN-13 check digit provided";
        bwipp_raiseerror();
      }
    }
    $puti($1.pad, 0, $1.barcode);
    $put($1.pad, 12, $f($1.checksum + 48));
    $1.barcode = $1.pad;
    if (!bwipp_ean13.__4337__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "111", "11111", "111"]);
        $ctx.barchars = "0123456789";
        $ctx.mirrormaps = $a(["000000", "001011", "001101", "001110", "010011", "011001", "011100", "010101", "010110", "011010"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_ean13.$ctx[id] = $ctx[id]);
        bwipp_ean13.__4337__ = 1;
      })();
    }
    $1.sbs = $s(59);
    $1.txt = $a(13);
    $puti($1.sbs, 0, $get($1.encs, 10));
    $1.mirrormap = $get($1.mirrormaps, $get($1.barcode, 0) - 48);
    $put($1.txt, 0, $a([$geti($1.barcode, 0, 1), $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize]));
    for (var _r = 1; _r <= 6; _r += 1) {
      $1.i = _r;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      if ($get($1.mirrormap, $1.i - 1) == 49) {
        $1.enclen = $1.enc.length;
        $1.revenc = $s($1.enclen);
        for (var _18 = 0, _17 = $1.enclen - 1; _18 <= _17; _18 += 1) {
          $1.j = _18;
          $1.char = $get($1.enc, $1.j);
          $put($1.revenc, $1.enclen - $1.j - 1, $1.char);
        }
        $1.enc = $1.revenc;
      }
      $puti($1.sbs, ($1.i - 1) * 4 + 3, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.i - 1) * 7 + 14 + $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $puti($1.sbs, (7 - 1) * 4 + 3, $get($1.encs, 11));
    for (var _1Y = 7; _1Y <= 12; _1Y += 1) {
      $1.i = _1Y;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, ($1.i - 1) * 4 + 8, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.i - 1) * 7 + 18 + $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $puti($1.sbs, 56, $get($1.encs, 12));
    $k[$j++] = Infinity;
    var _1y = $1.sbs;
    for (var _1z = 0, _20 = _1y.length; _1z < _20; _1z++) {
      $k[$j++] = $get(_1y, _1z) - 48;
    }
    $1.sbs = $a();
    if ($1.includetext) {
      $k[$j++] = Infinity;
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      for (var _26 = 0, _27 = 12; _26 < _27; _26++) {
        $k[$j++] = $f($1.height - 0.075);
      }
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      for (var _2B = 0, _2C = 12; _2B < _2C; _2B++) {
        $k[$j++] = $f($1.height - 0.075);
      }
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      $1.bhs = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _2H = 0, _2I = 12; _2H < _2I; _2H++) {
        $k[$j++] = 0.075;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _2J = 0, _2K = 12; _2J < _2K; _2J++) {
        $k[$j++] = 0.075;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $1.bbs = $a();
    } else {
      $k[$j++] = Infinity;
      for (var _2M = 0, _2N = 30; _2M < _2N; _2M++) {
        $k[$j++] = $1.height;
      }
      $1.bhs = $a();
      $k[$j++] = Infinity;
      for (var _2Q = 0, _2R = 30; _2Q < _2R; _2Q++) {
        $k[$j++] = 0;
      }
      $1.bbs = $a();
      $1.txt = $a([]);
    }
    $1.guardrightypos = 0;
    if ($ne($1.addon, "")) {
      $k[$j++] = Infinity;
      $k[$j++] = "dontdraw";
      $k[$j++] = true;
      $k[$j++] = "includetext";
      $k[$j++] = true;
      $k[$j++] = "height";
      $k[$j++] = $f($1.height - 0.15);
      $k[$j++] = "textxoffset";
      if ($ne($1.addontextxoffset, null)) {
        $k[$j++] = $1.addontextxoffset;
      } else {
        $k[$j++] = 95 + $1.addongap;
      }
      if ($ne($1.addontextyoffset, null)) {
        $k[$j++] = "textyoffset";
        $k[$j++] = $1.addontextyoffset;
      }
      $k[$j++] = "textsize";
      if ($ne($1.addontextsize, null)) {
        $k[$j++] = $1.addontextsize;
      } else {
        $k[$j++] = $1.textsize;
      }
      var _2f = $ne($1.addontextfont, "unset") ? $1.addontextfont : $1.textfont;
      $k[$j++] = "textfont";
      $k[$j++] = _2f;
      $1.addopts = $d();
      if ($1.addon.length == 2) {
        $k[$j++] = $1.addon;
        $k[$j++] = $1.addopts;
        bwipp_ean2();
      }
      if ($1.addon.length == 5) {
        $k[$j++] = $1.addon;
        $k[$j++] = $1.addopts;
        bwipp_ean5();
      }
      $1.addcode = $k[--$j];
      $k[$j++] = Infinity;
      $aload($1.sbs);
      $k[$j++] = $1.addongap;
      $aload($get($1.addcode, "sbs"));
      $1.sbs = $a();
      $k[$j++] = Infinity;
      $aload($1.bhs);
      $forall($get($1.addcode, "bhs"), function() {
        var _2w = $k[--$j];
        $k[$j++] = $f(_2w - 0.075);
      });
      $1.bhs = $a();
      $k[$j++] = Infinity;
      $aload($1.bbs);
      $forall($get($1.addcode, "bbs"), function() {
        var _31 = $k[--$j];
        $k[$j++] = $f(_31 + 0.075);
      });
      $1.bbs = $a();
      $k[$j++] = Infinity;
      $aload($1.txt);
      $aload($get($1.addcode, "txt"));
      $1.txt = $a();
      $1.guardrightypos = $1.height * 72 - 6;
    }
    var _3E = /* @__PURE__ */ new Map([
      ["ren", bwipp_renlinear],
      ["sbs", $1.sbs],
      ["bhs", $1.bhs],
      ["bbs", $1.bbs],
      ["txt", $1.txt],
      ["opt", $1.options],
      ["guardrightpos", 10],
      ["guardrightypos", $1.guardrightypos],
      ["borderbottom", 5]
    ]);
    $k[$j++] = _3E;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_ean8() {
    var $1 = Object.create(bwipp_ean8.$ctx || (bwipp_ean8.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 12;
    $1.textxoffset = 4;
    $1.textyoffset = -4;
    $1.height = 1;
    $1.addongap = 12;
    $1.addontextfont = "unset";
    $1.addontextsize = null;
    $1.addontextxoffset = null;
    $1.addontextyoffset = null;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $search($1.barcode, " ");
    if ($k[--$j]) {
      $1.barcode = $k[--$j];
      $j--;
      $1.addon = $k[--$j];
    } else {
      $j--;
      $1.addon = "";
    }
    if ($1.barcode.length != 7 && $1.barcode.length != 8) {
      $k[$j++] = "bwipp.ean8badLength#4505";
      $k[$j++] = "EAN-8 must be 7 or 8 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _9 = $k[--$j];
      if (_9 < 48 || _9 > 57) {
        $k[$j++] = "bwipp.ean8badCharacter#4509";
        $k[$j++] = "EAN-8 must contain only digits";
        bwipp_raiseerror();
      }
    });
    if ($1.addon.length != 0 && $1.addon.length != 2 && $1.addon.length != 5) {
      $k[$j++] = "bwipp.ean8badAddOnLength#4513";
      $k[$j++] = "Add-on for EAN-8 must be 2 or 5 digits";
      bwipp_raiseerror();
    }
    $1.pad = $s(8);
    $1.checksum = 0;
    for (var _E = 0; _E <= 6; _E += 1) {
      $1.i = _E;
      $1.barchar = $f($get($1.barcode, $1.i) - 48);
      if ($1.i % 2 != 0) {
        $1.checksum = $f($1.barchar + $1.checksum);
      } else {
        $1.checksum = $f($1.barchar * 3 + $1.checksum);
      }
    }
    $1.checksum = $f(10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 8) {
      if ($get($1.barcode, 7) != $f($1.checksum + 48)) {
        $k[$j++] = "bwipp.ean8badCheckDigit#4531";
        $k[$j++] = "Incorrect EAN-8 check digit provided";
        bwipp_raiseerror();
      }
    }
    $puti($1.pad, 0, $1.barcode);
    $put($1.pad, 7, $f($1.checksum + 48));
    $1.barcode = $1.pad;
    if (!bwipp_ean8.__4548__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "111", "11111", "111"]);
        $ctx.barchars = "0123456789";
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_ean8.$ctx[id] = $ctx[id]);
        bwipp_ean8.__4548__ = 1;
      })();
    }
    $1.sbs = $s(43);
    $1.txt = $a(8);
    $puti($1.sbs, 0, $get($1.encs, 10));
    for (var _e = 0; _e <= 3; _e += 1) {
      $1.i = _e;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * 4 + 3, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 7 + $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $puti($1.sbs, 4 * 4 + 3, $get($1.encs, 11));
    for (var _14 = 4; _14 <= 7; _14 += 1) {
      $1.i = _14;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * 4 + 8, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 7 + $1.textxoffset + 4, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $puti($1.sbs, 40, $get($1.encs, 12));
    $k[$j++] = Infinity;
    var _1U = $1.sbs;
    for (var _1V = 0, _1W = _1U.length; _1V < _1W; _1V++) {
      $k[$j++] = $get(_1U, _1V) - 48;
    }
    $1.sbs = $a();
    if ($1.includetext) {
      $k[$j++] = Infinity;
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      for (var _1c = 0, _1d = 8; _1c < _1d; _1c++) {
        $k[$j++] = $f($1.height - 0.075);
      }
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      for (var _1h = 0, _1i = 8; _1h < _1i; _1h++) {
        $k[$j++] = $f($1.height - 0.075);
      }
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      $1.bhs = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _1n = 0, _1o = 8; _1n < _1o; _1n++) {
        $k[$j++] = 0.075;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _1p = 0, _1q = 8; _1p < _1q; _1p++) {
        $k[$j++] = 0.075;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $1.bbs = $a();
    } else {
      $k[$j++] = Infinity;
      for (var _1s = 0, _1t = 22; _1s < _1t; _1s++) {
        $k[$j++] = $1.height;
      }
      $1.bhs = $a();
      $k[$j++] = Infinity;
      for (var _1w = 0, _1x = 22; _1w < _1x; _1w++) {
        $k[$j++] = 0;
      }
      $1.bbs = $a();
      $1.txt = $a([]);
    }
    $1.guardrightypos = 0;
    if ($ne($1.addon, "")) {
      $k[$j++] = Infinity;
      $k[$j++] = "dontdraw";
      $k[$j++] = true;
      $k[$j++] = "includetext";
      $k[$j++] = true;
      $k[$j++] = "height";
      $k[$j++] = $f($1.height - 0.15);
      $k[$j++] = "textxoffset";
      if ($ne($1.addontextxoffset, null)) {
        $k[$j++] = $1.addontextxoffset;
      } else {
        $k[$j++] = 67 + $1.addongap;
      }
      if ($ne($1.addontextyoffset, null)) {
        $k[$j++] = "textyoffset";
        $k[$j++] = $1.addontextyoffset;
      }
      $k[$j++] = "textsize";
      if ($ne($1.addontextsize, null)) {
        $k[$j++] = $1.addontextsize;
      } else {
        $k[$j++] = $1.textsize;
      }
      var _2B = $ne($1.addontextfont, "unset") ? $1.addontextfont : $1.textfont;
      $k[$j++] = "textfont";
      $k[$j++] = _2B;
      $1.addopts = $d();
      if ($1.addon.length == 2) {
        $k[$j++] = $1.addon;
        $k[$j++] = $1.addopts;
        bwipp_ean2();
      }
      if ($1.addon.length == 5) {
        $k[$j++] = $1.addon;
        $k[$j++] = $1.addopts;
        bwipp_ean5();
      }
      $1.addcode = $k[--$j];
      $k[$j++] = Infinity;
      $aload($1.sbs);
      $k[$j++] = $1.addongap;
      $aload($get($1.addcode, "sbs"));
      $1.sbs = $a();
      $k[$j++] = Infinity;
      $aload($1.bhs);
      $forall($get($1.addcode, "bhs"), function() {
        var _2S = $k[--$j];
        $k[$j++] = $f(_2S - 0.075);
      });
      $1.bhs = $a();
      $k[$j++] = Infinity;
      $aload($1.bbs);
      $forall($get($1.addcode, "bbs"), function() {
        var _2X = $k[--$j];
        $k[$j++] = $f(_2X + 0.075);
      });
      $1.bbs = $a();
      $k[$j++] = Infinity;
      $aload($1.txt);
      $aload($get($1.addcode, "txt"));
      $1.txt = $a();
      $1.guardrightypos = $1.height * 72 - 6;
    }
    var _2k = /* @__PURE__ */ new Map([
      ["ren", bwipp_renlinear],
      ["sbs", $1.sbs],
      ["bhs", $1.bhs],
      ["bbs", $1.bbs],
      ["txt", $1.txt],
      ["opt", $1.options],
      ["guardleftpos", 10],
      ["guardrightpos", 10],
      ["guardrightypos", $1.guardrightypos],
      ["borderbottom", 5]
    ]);
    $k[$j++] = _2k;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_upca() {
    var $1 = Object.create(bwipp_upca.$ctx || (bwipp_upca.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 12;
    $1.textxoffset = -7;
    $1.textyoffset = -4;
    $1.height = 1;
    $1.addongap = 12;
    $1.addontextfont = "unset";
    $1.addontextsize = null;
    $1.addontextxoffset = null;
    $1.addontextyoffset = null;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $search($1.barcode, " ");
    if ($k[--$j]) {
      $1.barcode = $k[--$j];
      $j--;
      $1.addon = $k[--$j];
    } else {
      $j--;
      $1.addon = "";
    }
    if ($1.barcode.length == 7 || $1.barcode.length == 8) {
      $forall($1.barcode, function() {
        var _9 = $k[--$j];
        if (_9 < 48 || _9 > 57) {
          $k[$j++] = "bwipp.upcAupcEbadCharacter#4706";
          $k[$j++] = "UPC-E must contain only digits";
          bwipp_raiseerror();
        }
      });
      var _B = $get($1.barcode, 0);
      if (_B != 48 && _B != 49) {
        $k[$j++] = "bwipp.upcAupcEbadNumberSystem#4710";
        $k[$j++] = "UPC-E must have number system 0 or 1";
        bwipp_raiseerror();
      }
      for (var _C = 0, _D = 1; _C < _D; _C++) {
        var _F = $1.barcode.length == 8 ? 12 : 11;
        $1.upcacode = $s(_F);
        if ($f($get($1.barcode, 6) - 48) <= 2) {
          $puti($1.upcacode, 0, $geti($1.barcode, 0, 3));
          $puti($1.upcacode, 3, $geti($1.barcode, 6, 1));
          $puti($1.upcacode, 4, "0000");
          $puti($1.upcacode, 8, $geti($1.barcode, 3, 3));
          break;
        }
        if ($f($get($1.barcode, 6) - 48) == 3) {
          $puti($1.upcacode, 0, $geti($1.barcode, 0, 4));
          $puti($1.upcacode, 4, "00000");
          $puti($1.upcacode, 9, $geti($1.barcode, 4, 2));
          break;
        }
        if ($f($get($1.barcode, 6) - 48) == 4) {
          $puti($1.upcacode, 0, $geti($1.barcode, 0, 5));
          $puti($1.upcacode, 5, "00000");
          $puti($1.upcacode, 10, $geti($1.barcode, 5, 1));
          break;
        }
        if ($f($get($1.barcode, 6) - 48) >= 5) {
          $puti($1.upcacode, 0, $geti($1.barcode, 0, 6));
          $puti($1.upcacode, 6, "0000");
          $puti($1.upcacode, 10, $geti($1.barcode, 6, 1));
          break;
        }
      }
      if ($1.barcode.length == 8) {
        $puti($1.upcacode, 11, $geti($1.barcode, 7, 1));
      }
      $1.barcode = $1.upcacode;
    }
    if ($1.barcode.length != 11 && $1.barcode.length != 12) {
      $k[$j++] = "bwipp.upcAbadLength#4748";
      $k[$j++] = "UPC-A must be 11 or 12 digits";
      bwipp_raiseerror();
    }
    var _11 = $1.barcode;
    for (var _12 = 0, _13 = _11.length; _12 < _13; _12++) {
      var _14 = $get(_11, _12);
      if (_14 < 48 || _14 > 57) {
        $k[$j++] = "bwipp.upcAbadCharacter#4752";
        $k[$j++] = "UPC-A must contain only digits";
        bwipp_raiseerror();
      }
    }
    if ($1.addon.length != 0 && $1.addon.length != 2 && $1.addon.length != 5) {
      $k[$j++] = "bwipp.upcAbadAddOnLength#4756";
      $k[$j++] = "Add-on for UPC-A must be 2 or 5 digits";
      bwipp_raiseerror();
    }
    $1.pad = $s(12);
    $1.checksum = 0;
    for (var _19 = 0; _19 <= 10; _19 += 1) {
      $1.i = _19;
      $1.barchar = $get($1.barcode, $1.i) - 48;
      if ($1.i % 2 != 0) {
        $1.checksum = $1.checksum + $1.barchar;
      } else {
        $1.checksum = $1.checksum + $1.barchar * 3;
      }
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 12) {
      if ($get($1.barcode, 11) != $1.checksum + 48) {
        $k[$j++] = "bwipp.upcAbadCheckDigit#4774";
        $k[$j++] = "Incorrect UPC check digit provided";
        bwipp_raiseerror();
      }
    }
    $puti($1.pad, 0, $1.barcode);
    $put($1.pad, 11, $1.checksum + 48);
    $1.barcode = $1.pad;
    if (!bwipp_upca.__4791__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "111", "11111", "111"]);
        $ctx.barchars = "0123456789";
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_upca.$ctx[id] = $ctx[id]);
        bwipp_upca.__4791__ = 1;
      })();
    }
    $1.sbs = $s(59);
    $1.txt = $a(12);
    $puti($1.sbs, 0, $get($1.encs, 10));
    for (var _1Z = 0; _1Z <= 5; _1Z += 1) {
      $1.i = _1Z;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * 4 + 3, $1.enc);
      if ($1.i == 0) {
        $put($1.txt, 0, $a([$geti($1.barcode, 0, 1), $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize - 2]));
      } else {
        $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 7 + 11 + $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize]));
      }
    }
    $puti($1.sbs, 6 * 4 + 3, $get($1.encs, 11));
    for (var _28 = 6; _28 <= 11; _28 += 1) {
      $1.i = _28;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * 4 + 8, $1.enc);
      if ($1.i == 11) {
        $put($1.txt, 11, $a([$geti($1.barcode, 11, 1), $1.textxoffset + 104, $1.textyoffset, $1.textfont, $1.textsize - 2]));
      } else {
        $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 7 + $1.textxoffset + 15, $1.textyoffset, $1.textfont, $1.textsize]));
      }
    }
    $puti($1.sbs, 56, $get($1.encs, 12));
    $k[$j++] = Infinity;
    var _2h = $1.sbs;
    for (var _2i = 0, _2j = _2h.length; _2i < _2j; _2i++) {
      $k[$j++] = $get(_2h, _2i) - 48;
    }
    $1.sbs = $a();
    if ($1.includetext) {
      $k[$j++] = Infinity;
      for (var _2n = 0, _2o = 4; _2n < _2o; _2n++) {
        $k[$j++] = $1.height;
      }
      for (var _2q = 0, _2r = 10; _2q < _2r; _2q++) {
        $k[$j++] = $f($1.height - 0.075);
      }
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      for (var _2v = 0, _2w = 10; _2v < _2w; _2v++) {
        $k[$j++] = $f($1.height - 0.075);
      }
      for (var _2y = 0, _2z = 4; _2y < _2z; _2y++) {
        $k[$j++] = $1.height;
      }
      $1.bhs = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _32 = 0, _33 = 10; _32 < _33; _32++) {
        $k[$j++] = 0.075;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _34 = 0, _35 = 10; _34 < _35; _34++) {
        $k[$j++] = 0.075;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $1.bbs = $a();
    } else {
      $k[$j++] = Infinity;
      for (var _37 = 0, _38 = 30; _37 < _38; _37++) {
        $k[$j++] = $1.height;
      }
      $1.bhs = $a();
      $k[$j++] = Infinity;
      for (var _3B = 0, _3C = 30; _3B < _3C; _3B++) {
        $k[$j++] = 0;
      }
      $1.bbs = $a();
      $1.txt = $a([]);
    }
    $1.guardrightypos = 0;
    if ($ne($1.addon, "")) {
      $k[$j++] = Infinity;
      $k[$j++] = "dontdraw";
      $k[$j++] = true;
      $k[$j++] = "includetext";
      $k[$j++] = true;
      $k[$j++] = "height";
      $k[$j++] = $f($1.height - 0.15);
      $k[$j++] = "textxoffset";
      if ($ne($1.addontextxoffset, null)) {
        $k[$j++] = $1.addontextxoffset;
      } else {
        $k[$j++] = 95 + $1.addongap;
      }
      if ($ne($1.addontextyoffset, null)) {
        $k[$j++] = "textyoffset";
        $k[$j++] = $1.addontextyoffset;
      }
      $k[$j++] = "textsize";
      if ($ne($1.addontextsize, null)) {
        $k[$j++] = $1.addontextsize;
      } else {
        $k[$j++] = $1.textsize;
      }
      var _3Q = $ne($1.addontextfont, "unset") ? $1.addontextfont : $1.textfont;
      $k[$j++] = "textfont";
      $k[$j++] = _3Q;
      $1.addopts = $d();
      if ($1.addon.length == 2) {
        $k[$j++] = $1.addon;
        $k[$j++] = $1.addopts;
        bwipp_ean2();
      }
      if ($1.addon.length == 5) {
        $k[$j++] = $1.addon;
        $k[$j++] = $1.addopts;
        bwipp_ean5();
      }
      $1.addcode = $k[--$j];
      $k[$j++] = Infinity;
      $aload($1.sbs);
      $k[$j++] = $1.addongap;
      $aload($get($1.addcode, "sbs"));
      $1.sbs = $a();
      $k[$j++] = Infinity;
      $aload($1.bhs);
      $forall($get($1.addcode, "bhs"), function() {
        var _3h = $k[--$j];
        $k[$j++] = $f(_3h - 0.075);
      });
      $1.bhs = $a();
      $k[$j++] = Infinity;
      $aload($1.bbs);
      $forall($get($1.addcode, "bbs"), function() {
        var _3m = $k[--$j];
        $k[$j++] = $f(_3m + 0.075);
      });
      $1.bbs = $a();
      $k[$j++] = Infinity;
      $aload($1.txt);
      $aload($get($1.addcode, "txt"));
      $1.txt = $a();
      $1.guardrightypos = $1.height * 72 - 6;
    }
    var _3z = /* @__PURE__ */ new Map([
      ["ren", bwipp_renlinear],
      ["sbs", $1.sbs],
      ["bhs", $1.bhs],
      ["bbs", $1.bbs],
      ["txt", $1.txt],
      ["opt", $1.options],
      ["guardrightpos", 10],
      ["guardrightypos", $1.guardrightypos],
      ["borderbottom", 5]
    ]);
    $k[$j++] = _3z;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_upce() {
    var $1 = Object.create(bwipp_upce.$ctx || (bwipp_upce.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 12;
    $1.textxoffset = -7;
    $1.textyoffset = -4;
    $1.height = 1;
    $1.addongap = 12;
    $1.addontextfont = "unset";
    $1.addontextsize = null;
    $1.addontextxoffset = null;
    $1.addontextyoffset = null;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $search($1.barcode, " ");
    if ($k[--$j]) {
      $1.barcode = $k[--$j];
      $j--;
      $1.addon = $k[--$j];
    } else {
      $j--;
      $1.addon = "";
    }
    if ($1.barcode.length == 11 || $1.barcode.length == 12) {
      $forall($1.barcode, function() {
        var _9 = $k[--$j];
        if (_9 < 48 || _9 > 57) {
          $k[$j++] = "bwipp.upcEupcAbadCharacter#4956";
          $k[$j++] = "UPC-A must contain only digits";
          bwipp_raiseerror();
        }
      });
      for (var _A = 0, _B = 1; _A < _B; _A++) {
        var _D = $1.barcode.length == 12 ? 8 : 7;
        $1.upcecode = $s(_D);
        if ($f($get($1.barcode, 3) - 48) <= 2 && $eq($geti($1.barcode, 4, 4), "0000")) {
          $puti($1.upcecode, 0, $geti($1.barcode, 0, 3));
          $puti($1.upcecode, 3, $geti($1.barcode, 8, 3));
          $puti($1.upcecode, 6, $geti($1.barcode, 3, 1));
          break;
        }
        if ($eq($geti($1.barcode, 4, 5), "00000")) {
          $puti($1.upcecode, 0, $geti($1.barcode, 0, 4));
          $puti($1.upcecode, 4, $geti($1.barcode, 9, 2));
          $puti($1.upcecode, 6, "3");
          break;
        }
        if ($eq($geti($1.barcode, 5, 5), "00000")) {
          $puti($1.upcecode, 0, $geti($1.barcode, 0, 5));
          $puti($1.upcecode, 5, $geti($1.barcode, 10, 1));
          $puti($1.upcecode, 6, "4");
          break;
        }
        if ($f($get($1.barcode, 10) - 48) >= 5 && $eq($geti($1.barcode, 6, 4), "0000")) {
          $puti($1.upcecode, 0, $geti($1.barcode, 0, 6));
          $puti($1.upcecode, 6, $geti($1.barcode, 10, 1));
          break;
        }
        $k[$j++] = "bwipp.upcEupcAnotCompressible#4984";
        $k[$j++] = "UPC-A cannot be converted to a UPC-E";
        bwipp_raiseerror();
      }
      if ($1.barcode.length == 12) {
        $puti($1.upcecode, 7, $geti($1.barcode, 11, 1));
      }
      $1.barcode = $1.upcecode;
    }
    if ($1.barcode.length != 7 && $1.barcode.length != 8) {
      $k[$j++] = "bwipp.upcEbadLength#4994";
      $k[$j++] = "UPC-E must be 7 or 8 digits";
      bwipp_raiseerror();
    }
    var _11 = $1.barcode;
    for (var _12 = 0, _13 = _11.length; _12 < _13; _12++) {
      var _14 = $get(_11, _12);
      if (_14 < 48 || _14 > 57) {
        $k[$j++] = "bwipp.upcEbadCharacter#4998";
        $k[$j++] = "UPC-E must contain only digits";
        bwipp_raiseerror();
      }
    }
    if ($1.addon.length != 0 && $1.addon.length != 2 && $1.addon.length != 5) {
      $k[$j++] = "bwipp.upcEbadAddOnLength#5002";
      $k[$j++] = "Add-on for UPC-E must be 2 or 5 digits";
      bwipp_raiseerror();
    }
    var _19 = $get($1.barcode, 0);
    if (_19 != 48 && _19 != 49) {
      $k[$j++] = "bwipp.upcEbadNumberSystem#5007";
      $k[$j++] = "UPC-E must have number system 0 or 1";
      bwipp_raiseerror();
    }
    if (!bwipp_upce.__5025__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "111", "111111"]);
        $ctx.barchars = "0123456789";
        $ctx.mirrormaps = $a(["000111", "001011", "001101", "001110", "010011", "011001", "011100", "010101", "010110", "011010"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_upce.$ctx[id] = $ctx[id]);
        bwipp_upce.__5025__ = 1;
      })();
    }
    for (var _1D = 0, _1E = 1; _1D < _1E; _1D++) {
      $1.upcacode = $s(11);
      if ($get($1.barcode, 6) - 48 <= 2) {
        $puti($1.upcacode, 0, $geti($1.barcode, 0, 3));
        $puti($1.upcacode, 3, $geti($1.barcode, 6, 1));
        $puti($1.upcacode, 4, "0000");
        $puti($1.upcacode, 8, $geti($1.barcode, 3, 3));
        break;
      }
      if ($get($1.barcode, 6) - 48 == 3) {
        $puti($1.upcacode, 0, $geti($1.barcode, 0, 4));
        $puti($1.upcacode, 4, "00000");
        $puti($1.upcacode, 9, $geti($1.barcode, 4, 2));
        break;
      }
      if ($get($1.barcode, 6) - 48 == 4) {
        $puti($1.upcacode, 0, $geti($1.barcode, 0, 5));
        $puti($1.upcacode, 5, "00000");
        $puti($1.upcacode, 10, $geti($1.barcode, 5, 1));
        break;
      }
      if ($get($1.barcode, 6) - 48 >= 5) {
        $puti($1.upcacode, 0, $geti($1.barcode, 0, 6));
        $puti($1.upcacode, 6, "0000");
        $puti($1.upcacode, 10, $geti($1.barcode, 6, 1));
        break;
      }
    }
    $1.checksum = 0;
    for (var _1t = 0; _1t <= 10; _1t += 1) {
      $1.i = _1t;
      $1.barchar = $get($1.upcacode, $1.i) - 48;
      if ($1.i % 2 != 0) {
        $1.checksum = $1.checksum + $1.barchar;
      } else {
        $1.checksum = $1.checksum + $1.barchar * 3;
      }
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 8) {
      if ($get($1.barcode, 7) != $1.checksum + 48) {
        $k[$j++] = "bwipp.upcEbadCheckDigit#5069";
        $k[$j++] = "Incorrect UPC check digit provided";
        bwipp_raiseerror();
      }
    }
    $1.pad = $s(8);
    $puti($1.pad, 0, $1.barcode);
    $put($1.pad, 7, $1.checksum + 48);
    $1.barcode = $1.pad;
    $1.txt = $a(8);
    $put($1.txt, 0, $a([$geti($1.barcode, 0, 1), $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize - 2]));
    $1.mirrormap = $get($1.mirrormaps, $1.checksum);
    if ($get($1.barcode, 0) == 48) {
      $1.invt = $s($1.mirrormap.length);
      for (var _2V = 0, _2U = $1.mirrormap.length - 1; _2V <= _2U; _2V += 1) {
        $1.i = _2V;
        if ($get($1.mirrormap, $1.i) == 48) {
          $put($1.invt, $1.i, 49);
        } else {
          $put($1.invt, $1.i, 48);
        }
      }
      $1.mirrormap = $1.invt;
    }
    $1.sbs = $s(33);
    $puti($1.sbs, 0, $get($1.encs, 10));
    for (var _2i = 1; _2i <= 6; _2i += 1) {
      $1.i = _2i;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      if ($get($1.mirrormap, $1.i - 1) == 49) {
        $1.enclen = $1.enc.length;
        $1.revenc = $s($1.enclen);
        for (var _2z = 0, _2y = $1.enclen - 1; _2z <= _2y; _2z += 1) {
          $1.j = _2z;
          $1.char = $get($1.enc, $1.j);
          $put($1.revenc, $1.enclen - $1.j - 1, $1.char);
        }
        $1.enc = $1.revenc;
      }
      $puti($1.sbs, ($1.i - 1) * 4 + 3, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.i - 1) * 7 + 11 + $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $put($1.txt, 7, $a([$geti($1.barcode, 7, 1), 6 * 7 + 18 + $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize - 2]));
    $puti($1.sbs, 27, $get($1.encs, 11));
    $k[$j++] = Infinity;
    var _3X = $1.sbs;
    for (var _3Y = 0, _3Z = _3X.length; _3Y < _3Z; _3Y++) {
      $k[$j++] = $get(_3X, _3Y) - 48;
    }
    $1.sbs = $a();
    if ($1.includetext) {
      $k[$j++] = Infinity;
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      for (var _3f = 0, _3g = 12; _3f < _3g; _3f++) {
        $k[$j++] = $f($1.height - 0.075);
      }
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      $k[$j++] = $1.height;
      $1.bhs = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _3m = 0, _3n = 12; _3m < _3n; _3m++) {
        $k[$j++] = 0.075;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $1.bbs = $a();
    } else {
      $k[$j++] = Infinity;
      for (var _3p = 0, _3q = 17; _3p < _3q; _3p++) {
        $k[$j++] = $1.height;
      }
      $1.bhs = $a();
      $k[$j++] = Infinity;
      for (var _3t = 0, _3u = 17; _3t < _3u; _3t++) {
        $k[$j++] = 0;
      }
      $1.bbs = $a();
      $1.txt = $a([]);
    }
    $1.guardrightypos = 0;
    if ($ne($1.addon, "")) {
      $k[$j++] = Infinity;
      $k[$j++] = "dontdraw";
      $k[$j++] = true;
      $k[$j++] = "includetext";
      $k[$j++] = true;
      $k[$j++] = "height";
      $k[$j++] = $f($1.height - 0.15);
      $k[$j++] = "textxoffset";
      if ($ne($1.addontextxoffset, null)) {
        $k[$j++] = $1.addontextxoffset;
      } else {
        $k[$j++] = 51 + $1.addongap;
      }
      if ($ne($1.addontextyoffset, null)) {
        $k[$j++] = "textyoffset";
        $k[$j++] = $1.addontextyoffset;
      }
      $k[$j++] = "textsize";
      if ($ne($1.addontextsize, null)) {
        $k[$j++] = $1.addontextsize;
      } else {
        $k[$j++] = $1.textsize;
      }
      var _48 = $ne($1.addontextfont, "unset") ? $1.addontextfont : $1.textfont;
      $k[$j++] = "textfont";
      $k[$j++] = _48;
      $1.addopts = $d();
      if ($1.addon.length == 2) {
        $k[$j++] = $1.addon;
        $k[$j++] = $1.addopts;
        bwipp_ean2();
      }
      if ($1.addon.length == 5) {
        $k[$j++] = $1.addon;
        $k[$j++] = $1.addopts;
        bwipp_ean5();
      }
      $1.addcode = $k[--$j];
      $k[$j++] = Infinity;
      $aload($1.sbs);
      $k[$j++] = $1.addongap;
      $aload($get($1.addcode, "sbs"));
      $1.sbs = $a();
      $k[$j++] = Infinity;
      $aload($1.bhs);
      $forall($get($1.addcode, "bhs"), function() {
        var _4P = $k[--$j];
        $k[$j++] = $f(_4P - 0.075);
      });
      $1.bhs = $a();
      $k[$j++] = Infinity;
      $aload($1.bbs);
      $forall($get($1.addcode, "bbs"), function() {
        var _4U = $k[--$j];
        $k[$j++] = $f(_4U + 0.075);
      });
      $1.bbs = $a();
      $k[$j++] = Infinity;
      $aload($1.txt);
      $aload($get($1.addcode, "txt"));
      $1.txt = $a();
      $1.guardrightypos = $1.height * 72 - 6;
    }
    var _4h = /* @__PURE__ */ new Map([
      ["ren", bwipp_renlinear],
      ["sbs", $1.sbs],
      ["bhs", $1.bhs],
      ["bbs", $1.bbs],
      ["txt", $1.txt],
      ["opt", $1.options],
      ["guardrightpos", 10],
      ["guardrightypos", $1.guardrightypos],
      ["borderbottom", 5]
    ]);
    $k[$j++] = _4h;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_isbn() {
    var $1 = Object.create(bwipp_isbn.$ctx || (bwipp_isbn.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.isbntextfont = "OCR-A";
    $1.isbntextsize = 8;
    $1.isbntextxoffset = null;
    $1.isbntextyoffset = null;
    $1.height = 1;
    $1.addongap = 12;
    $1.legacy = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $search($1.barcode, " ");
    if ($k[--$j]) {
      $1.barcode = $k[--$j];
      $j--;
      $1.addon = $k[--$j];
    } else {
      $j--;
      $1.addon = "";
    }
    if ($1.barcode.length != 15 && $1.barcode.length != 17 && ($1.barcode.length != 11 && $1.barcode.length != 13)) {
      $k[$j++] = "bwipp.isbnBadLength#5235";
      $k[$j++] = "ISBN-13 must be 15 or 17 characters including dashes. ISBN-10 must be 11 or 13 characters including dashes";
      bwipp_raiseerror();
    }
    if ($1.addon.length != 0 && $1.addon.length != 2 && $1.addon.length != 5) {
      $k[$j++] = "bwipp.isbnBadAddOnLength#5238";
      $k[$j++] = "Add-on for ISBN must be 2 or 5 digits";
      bwipp_raiseerror();
    }
    if ($1.barcode.length >= 15) {
      var _F = $geti($1.barcode, 0, 4);
      if ($ne(_F, "978-") && $ne(_F, "979-")) {
        $k[$j++] = "bwipp.isbn13badPrefix#5242";
        $k[$j++] = "ISBN-13 prefix must be 978- or 979-";
        bwipp_raiseerror();
      }
      $1.wasdash = false;
      $1.numdash = 0;
      $1.numdigit = 0;
      var _H = $geti($1.barcode, 5, 9);
      for (var _I = 0, _J = _H.length; _I < _J; _I++) {
        var _K = $get(_H, _I);
        $k[$j++] = _K;
        if (_K == 45) {
          if ($1.wasdash) {
            $k[$j++] = "bwipp.isbn13adjacentDashes#5249";
            $k[$j++] = "ISBN-13 does not permit adjacent dashes";
            bwipp_raiseerror();
          }
          $1.wasdash = true;
          $1.numdash = $1.numdash + 1;
        }
        var _N = $k[--$j];
        if (_N >= 48 && _N <= 57) {
          $1.wasdash = false;
          $1.numdigit = $1.numdigit + 1;
        }
      }
      if ($1.numdash != 2 || $1.numdigit != 7) {
        $k[$j++] = "bwipp.isbn13numDashesDigits#5260";
        $k[$j++] = "Incorrect number of dashes and digits for ISBN-13";
        bwipp_raiseerror();
      }
      var _S = $get($1.barcode, 14);
      if (_S < 48 || _S > 57) {
        $k[$j++] = "bwipp.isbn13character15#5263";
        $k[$j++] = "ISBN-13 character 15 must be a digit";
        bwipp_raiseerror();
      }
      if ($1.barcode.length == 17) {
        if ($ne($geti($1.barcode, 15, 1), "-")) {
          $k[$j++] = "bwipp.isbn13character16#5267";
          $k[$j++] = "ISBN-13 penultimate character must be a dash";
          bwipp_raiseerror();
        }
        var _X = $get($1.barcode, 16);
        if (_X < 48 || _X > 57) {
          $k[$j++] = "bwipp.isbn13character17#5270";
          $k[$j++] = "ISBN-13 final character must be a digit";
          bwipp_raiseerror();
        }
      }
    } else {
      var _Z = $get($1.barcode, 0);
      if (_Z < 48 || _Z > 57) {
        $k[$j++] = "bwipp.isbn10FirstDigit#5275";
        $k[$j++] = "ISBN-10 first character must be a digit";
        bwipp_raiseerror();
      }
      $1.wasdash = false;
      $1.numdash = 0;
      $1.numdigit = 0;
      var _b = $geti($1.barcode, 1, 9);
      for (var _c = 0, _d = _b.length; _c < _d; _c++) {
        var _e = $get(_b, _c);
        $k[$j++] = _e;
        if (_e == 45) {
          if ($1.wasdash) {
            $k[$j++] = "bwipp.isbn10adjacentDashes#5282";
            $k[$j++] = "ISBN-10 does not permit adjacent dashes";
            bwipp_raiseerror();
          }
          $1.wasdash = true;
          $1.numdash = $1.numdash + 1;
        }
        var _h = $k[--$j];
        if (_h >= 48 && _h <= 57) {
          $1.wasdash = false;
          $1.numdigit = $1.numdigit + 1;
        }
      }
      if ($1.numdash != 2 || $1.numdigit != 7) {
        $k[$j++] = "bwipp.isbn10numDashesDigits#5293";
        $k[$j++] = "Incorrect number of dashes and digits for ISBN-10";
        bwipp_raiseerror();
      }
      var _m = $get($1.barcode, 10);
      if (_m < 48 || _m > 57) {
        $k[$j++] = "bwipp.isbn10character11#5296";
        $k[$j++] = "ISBN-10 character 11 must be a digit";
        bwipp_raiseerror();
      }
      if ($1.barcode.length == 13) {
        if ($ne($geti($1.barcode, 11, 1), "-")) {
          $k[$j++] = "bwipp.isbn10character12#5300";
          $k[$j++] = "ISBN-10 penultimate character must be a dash";
          bwipp_raiseerror();
        }
        var _r = $get($1.barcode, 12);
        if ((_r < 48 || _r > 57) && _r != 88) {
          $k[$j++] = "bwipp.isbn10character13#5303";
          $k[$j++] = "ISBN-10 final character must be a digit or X";
          bwipp_raiseerror();
        }
      }
    }
    $1.isbntxt = $1.barcode;
    if ($1.isbntxt.length <= 13) {
      $1.isbn = $s(10);
      $1.checksum = 0;
      $1.i = 0;
      $1.n = 0;
      for (; ; ) {
        $1.isbnchar = $f($get($1.isbntxt, $1.i) - 48);
        if ($1.isbnchar != -3) {
          $put($1.isbn, $1.n, $f($1.isbnchar + 48));
          if ($1.n < 9) {
            $1.checksum = $f($1.checksum + (10 - $1.n) * $1.isbnchar);
          }
          $1.n = $1.n + 1;
        }
        $1.i = $1.i + 1;
        if ($1.i == $1.isbntxt.length) {
          break;
        }
      }
      var _1B = $f(11 - $1.checksum % 11) % 11;
      $k[$j++] = "checksum";
      $k[$j++] = _1B;
      if (_1B == 10) {
        $j--;
        $k[$j++] = 40;
      }
      var _1C = $k[--$j];
      $1[$k[--$j]] = $f(_1C + 48);
      $1.isbn = $geti($1.isbn, 0, 9);
      if ($1.isbntxt.length == 13) {
        if ($get($1.isbntxt, 12) != $1.checksum) {
          $k[$j++] = "bwipp.isbn10badCheckDigit#5331";
          $k[$j++] = "Incorrect ISBN-10 check digit provided";
          bwipp_raiseerror();
        }
      }
    }
    if (!$1.legacy || $1.isbntxt.length >= 15) {
      if ($1.isbntxt.length <= 13) {
        $1.pad = $s(15);
        $puti($1.pad, 0, "978-");
        $puti($1.pad, 4, $geti($1.isbntxt, 0, 11));
        $1.isbntxt = $1.pad;
      }
      $1.isbn = $s(13);
      $1.checksum = 0;
      $1.i = 0;
      $1.n = 0;
      for (; ; ) {
        $1.isbnchar = $get($1.isbntxt, $1.i) - 48;
        if ($1.isbnchar != -3) {
          $put($1.isbn, $1.n, $1.isbnchar + 48);
          if ($1.n < 12) {
            $k[$j++] = "checksum";
            $k[$j++] = $1.isbnchar;
            if ($1.n % 2 != 0) {
              var _1e = $k[--$j];
              $k[$j++] = _1e * 3;
            }
            var _1g = $k[--$j];
            $1[$k[--$j]] = $f(_1g + $1.checksum);
          }
          $1.n = $1.n + 1;
        }
        $1.i = $1.i + 1;
        if ($1.i == $1.isbntxt.length) {
          break;
        }
      }
      $1.checksum = (10 - $1.checksum % 10) % 10 + 48;
      $1.isbn = $geti($1.isbn, 0, 12);
      if ($1.isbntxt.length == 17) {
        if ($get($1.isbntxt, 16) != $1.checksum) {
          $k[$j++] = "bwipp.isbn13badCheckDigit#5366";
          $k[$j++] = "Incorrect ISBN-13 check digit provided";
          bwipp_raiseerror();
        }
      }
    }
    var _1u = $1.isbn.length == 12 ? 22 : 18;
    $1.pad = $s(_1u);
    $puti($1.pad, 0, "ISBN ");
    $puti($1.pad, 5, $1.isbntxt);
    $put($1.pad, $1.pad.length - 2, 45);
    $put($1.pad, $1.pad.length - 1, $1.checksum);
    $1.isbntxt = $1.pad;
    $1.barcode = $s(12);
    if ($1.isbn.length == 9) {
      $puti($1.barcode, 0, "978");
      $puti($1.barcode, 3, $1.isbn);
    } else {
      $puti($1.barcode, 0, $1.isbn);
    }
    if ($ne($1.addon, "")) {
      var _2E = $s(12 + $1.addon.length + 1);
      $puti(_2E, 0, $1.barcode);
      $puti(_2E, 12, " ");
      $puti(_2E, 13, $1.addon);
      $1.barcode = _2E;
    }
    $put($1.options, "dontdraw", true);
    $put($1.options, "addongap", $1.addongap);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_ean13();
    var _2M = $k[--$j];
    $1[$k[--$j]] = _2M;
    if ($1.includetext) {
      if ($eq($1.isbntextxoffset, null)) {
        $k[$j++] = "isbntextxoffset";
        if ($1.isbn.length == 9) {
          $k[$j++] = -1;
        } else {
          $k[$j++] = -12;
        }
        var _2R = $k[--$j];
        $1[$k[--$j]] = _2R;
      }
      if ($eq($1.isbntextyoffset, null)) {
        $1.isbntextyoffset = $1.height * 72 + 3;
      }
      var _2W = $get($1.args, "txt") !== void 0;
      if (_2W) {
        $1.txt = $get($1.args, "txt");
        $1.newtxt = $a($1.txt.length + 1);
        $puti($1.newtxt, 0, $1.txt);
        $put($1.newtxt, $1.newtxt.length - 1, $a([$1.isbntxt, $1.isbntextxoffset, $1.isbntextyoffset, $1.isbntextfont, $1.isbntextsize]));
        $put($1.args, "txt", $1.newtxt);
      } else {
        $put($1.args, "txt", $a([$a([$1.isbntxt, $1.isbntextxoffset, $1.isbntextyoffset, $1.isbntextfont, $1.isbntextsize])]));
      }
    }
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_ismn() {
    var $1 = Object.create(bwipp_ismn.$ctx || (bwipp_ismn.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.ismntextfont = "OCR-A";
    $1.ismntextsize = 8;
    $1.ismntextxoffset = null;
    $1.ismntextyoffset = null;
    $1.height = 1;
    $1.addongap = 12;
    $1.legacy = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $search($1.barcode, " ");
    if ($k[--$j]) {
      $1.barcode = $k[--$j];
      $j--;
      $1.addon = $k[--$j];
    } else {
      $j--;
      $1.addon = "";
    }
    if ($1.barcode.length != 15 && $1.barcode.length != 17 && ($1.barcode.length != 11 && $1.barcode.length != 13)) {
      $k[$j++] = "bwipp.ismnBadLength#5485";
      $k[$j++] = "ISMN-13 must be 15 or 17 characters including dashes. ISMN-10 must be 11 or 13 characters including dashes";
      bwipp_raiseerror();
    }
    if ($1.addon.length != 0 && $1.addon.length != 2 && $1.addon.length != 5) {
      $k[$j++] = "bwipp.ismnBadAddOnLength#5488";
      $k[$j++] = "Add-on for ISMN must be 2 or 5 digits";
      bwipp_raiseerror();
    }
    if ($1.barcode.length >= 15) {
      if ($ne($geti($1.barcode, 0, 4), "979-")) {
        $k[$j++] = "bwipp.ismn13badPrefix#5492";
        $k[$j++] = "ISMN-13 prefix must be 979-";
        bwipp_raiseerror();
      }
      $1.wasdash = false;
      $1.numdash = 0;
      $1.numdigit = 0;
      var _H = $geti($1.barcode, 5, 9);
      for (var _I = 0, _J = _H.length; _I < _J; _I++) {
        var _K = $get(_H, _I);
        $k[$j++] = _K;
        if (_K == 45) {
          if ($1.wasdash) {
            $k[$j++] = "bwipp.ismn13adjacentDashes#5499";
            $k[$j++] = "ISMN-13 does not permit adjacent dashes";
            bwipp_raiseerror();
          }
          $1.wasdash = true;
          $1.numdash = $1.numdash + 1;
        }
        var _N = $k[--$j];
        if (_N >= 48 && _N <= 57) {
          $1.wasdash = false;
          $1.numdigit = $1.numdigit + 1;
        }
      }
      if ($1.numdash != 2 || $1.numdigit != 7) {
        $k[$j++] = "bwipp.ismn13numDashesDigits#5510";
        $k[$j++] = "Incorrect number of dashes and digits for ISMN-13";
        bwipp_raiseerror();
      }
      var _S = $get($1.barcode, 14);
      if (_S < 48 || _S > 57) {
        $k[$j++] = "bwipp.ismn13character15#5513";
        $k[$j++] = "ISMN-13 character 15 must be a digit";
        bwipp_raiseerror();
      }
      if ($1.barcode.length == 17) {
        if ($ne($geti($1.barcode, 15, 1), "-")) {
          $k[$j++] = "bwipp.ismn13character16#5517";
          $k[$j++] = "ISMN-13 penultimate character must be a dash";
          bwipp_raiseerror();
        }
        var _X = $get($1.barcode, 16);
        if (_X < 48 || _X > 57) {
          $k[$j++] = "bwipp.ismn13character17#5520";
          $k[$j++] = "ISMN-13 final character must be a digit";
          bwipp_raiseerror();
        }
      }
    } else {
      if ($ne($geti($1.barcode, 0, 2), "M-")) {
        $k[$j++] = "bwipp.ismn10badPrefix#5525";
        $k[$j++] = "ISMN-10 prefix must be M-";
        bwipp_raiseerror();
      }
      var _b = $get($1.barcode, 2);
      if (_b < 48 || _b > 57) {
        $k[$j++] = "bwipp.ismn10character3#5528";
        $k[$j++] = "ISMN-10 character 3 must be a digit";
        bwipp_raiseerror();
      }
      $1.wasdash = false;
      $1.numdash = 0;
      $1.numdigit = 0;
      var _d = $geti($1.barcode, 3, 7);
      for (var _e = 0, _f = _d.length; _e < _f; _e++) {
        var _g = $get(_d, _e);
        $k[$j++] = _g;
        if (_g == 45) {
          if ($1.wasdash) {
            $k[$j++] = "bwipp.ismn10adjacentDashes#5535";
            $k[$j++] = "ISMN-10 does not permit adjacent dashes";
            bwipp_raiseerror();
          }
          $1.wasdash = true;
          $1.numdash = $1.numdash + 1;
        }
        var _j = $k[--$j];
        if (_j >= 48 && _j <= 57) {
          $1.wasdash = false;
          $1.numdigit = $1.numdigit + 1;
        }
      }
      if ($1.numdash != 1 || $1.numdigit != 6) {
        $k[$j++] = "bwipp.ismn10numDashesDigits#5546";
        $k[$j++] = "Incorrect number of dashes and digits for ISMN-10";
        bwipp_raiseerror();
      }
      var _o = $get($1.barcode, 10);
      if (_o < 48 || _o > 57) {
        $k[$j++] = "bwipp.ismn10character11#5549";
        $k[$j++] = "ISMN-10 character 11 must be a digit";
        bwipp_raiseerror();
      }
      if ($1.barcode.length == 13) {
        var _r = $geti($1.barcode, 11, 1);
        if ($ne(_r, "-")) {
          $k[$j++] = "bwipp.ismn10character12#5553";
          $k[$j++] = "ISMN-10 penultimate character must be a dash";
          bwipp_raiseerror();
        }
        var _t = $get($1.barcode, 12);
        if ((_t < 48 || _t > 57) && _t != 88) {
          $k[$j++] = "bwipp.ismn10character13#5556";
          $k[$j++] = "ISMN-10 final character must be a digit or X";
          bwipp_raiseerror();
        }
      }
    }
    $1.ismntxt = $1.barcode;
    $1.legacytxt = "";
    if ($1.ismntxt.length <= 13) {
      $1.legacytxt = $1.ismntxt;
      $1.pad = $s($1.ismntxt.length + 4);
      $puti($1.pad, 0, "979-0-");
      $puti($1.pad, 6, $geti($1.ismntxt, 2, $1.ismntxt.length - 2));
      $1.ismntxt = $1.pad;
    }
    $1.ismn = $s(13);
    $1.checksum = 0;
    $1.i = 0;
    $1.n = 0;
    for (; ; ) {
      $1.ismnchar = $get($1.ismntxt, $1.i) - 48;
      if ($1.ismnchar != -3) {
        $put($1.ismn, $1.n, $1.ismnchar + 48);
        if ($1.n < 12) {
          if ($1.n % 2 == 0) {
            $1.checksum = $1.ismnchar + $1.checksum;
          } else {
            $1.checksum = $1.ismnchar * 3 + $1.checksum;
          }
        }
        $1.n = $1.n + 1;
      }
      $1.i = $1.i + 1;
      if ($1.i == $1.ismntxt.length) {
        break;
      }
    }
    $1.checksum = (10 - $1.checksum % 10) % 10 + 48;
    if ($1.barcode.length == 13 || $1.barcode.length == 17) {
      var _1Q = $1.barcode;
      if ($get(_1Q, _1Q.length - 1) != $1.checksum) {
        $k[$j++] = "bwipp.ismnBadCheckDigit#5598";
        $k[$j++] = "Incorrect ISMN check digit provided";
        bwipp_raiseerror();
      }
    }
    if ($1.legacy && $ne($1.legacytxt, "")) {
      $1.ismntxt = $1.legacytxt;
      $1.pad = $s(18);
    } else {
      $1.pad = $s(22);
    }
    $puti($1.pad, 0, "ISMN ");
    $puti($1.pad, 5, $1.ismntxt);
    $put($1.pad, $1.pad.length - 2, 45);
    $put($1.pad, $1.pad.length - 1, $1.checksum);
    $1.ismntxt = $1.pad;
    $1.barcode = $geti($1.ismn, 0, 12);
    if ($ne($1.addon, "")) {
      var _1l = $s(12 + $1.addon.length + 1);
      $puti(_1l, 0, $1.barcode);
      $puti(_1l, 12, " ");
      $puti(_1l, 13, $1.addon);
      $1.barcode = _1l;
    }
    $put($1.options, "dontdraw", true);
    $put($1.options, "addongap", $1.addongap);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_ean13();
    var _1t = $k[--$j];
    $1[$k[--$j]] = _1t;
    if ($1.includetext) {
      if ($eq($1.ismntextxoffset, null)) {
        $k[$j++] = "ismntextxoffset";
        if ($1.ismntxt.length == 18) {
          $k[$j++] = -1;
        } else {
          $k[$j++] = -12;
        }
        var _1y = $k[--$j];
        $1[$k[--$j]] = _1y;
      }
      if ($eq($1.ismntextyoffset, null)) {
        $1.ismntextyoffset = $1.height * 72 + 3;
      }
      var _23 = $get($1.args, "txt") !== void 0;
      if (_23) {
        $1.txt = $get($1.args, "txt");
        $1.newtxt = $a($1.txt.length + 1);
        $puti($1.newtxt, 0, $1.txt);
        $put($1.newtxt, $1.newtxt.length - 1, $a([$1.ismntxt, $1.ismntextxoffset, $1.ismntextyoffset, $1.ismntextfont, $1.ismntextsize]));
        $put($1.args, "txt", $1.newtxt);
      } else {
        $put($1.args, "txt", $a([$a([$1.ismntxt, $1.ismntextxoffset, $1.ismntextyoffset, $1.ismntextfont, $1.ismntextsize])]));
      }
    }
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_issn() {
    var $1 = Object.create(bwipp_issn.$ctx || (bwipp_issn.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.issntextfont = "OCR-A";
    $1.issntextsize = 8;
    $1.issntextxoffset = null;
    $1.issntextyoffset = null;
    $1.height = 1;
    $1.addongap = 12;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.issntxt = $k[--$j];
    $search($1.issntxt, " ");
    if ($k[--$j]) {
      $1.issntxt = $k[--$j];
      $j--;
      $1.seqvar = $k[--$j];
    } else {
      $j--;
      $1.seqvar = "00";
    }
    $search($1.seqvar, " ");
    if ($k[--$j]) {
      $1.seqvar = $k[--$j];
      $j--;
      $1.addon = $k[--$j];
    } else {
      $j--;
      $1.addon = "";
    }
    if ($1.issntxt.length != 8 && $1.issntxt.length != 9) {
      $k[$j++] = "bwipp.issnBadLength#5722";
      $k[$j++] = "ISSN must be 8 or 9 characters including dash, in the format XXXX-XXXX";
      bwipp_raiseerror();
    }
    var _D = $geti($1.issntxt, 0, 4);
    for (var _E = 0, _F = _D.length; _E < _F; _E++) {
      var _G = $get(_D, _E);
      if (_G < 48 || _G > 57) {
        $k[$j++] = "bwipp.issnFirstThroughFourthNotNumeric#5726";
        $k[$j++] = "ISSN first four characters must be numeral characters";
        bwipp_raiseerror();
      }
    }
    if ($ne($geti($1.issntxt, 4, 1), "-")) {
      $k[$j++] = "bwipp.issnNeedsDash#5730";
      $k[$j++] = "ISSN fifth character must be a dash";
      bwipp_raiseerror();
    }
    var _K = $geti($1.issntxt, 5, 3);
    for (var _L = 0, _M = _K.length; _L < _M; _L++) {
      var _N = $get(_K, _L);
      if (_N < 48 || _N > 57) {
        $k[$j++] = "bwipp.issnSixthThroughEighthNotNumeric#5734";
        $k[$j++] = "ISSN sixth through eighth characters must be numerals";
        bwipp_raiseerror();
      }
    }
    if ($1.issntxt.length == 9) {
      var _Q = $get($1.issntxt, 8);
      if ((_Q < 48 || _Q > 57) && _Q != 88) {
        $k[$j++] = "bwipp.issnNinthCharacterBadFormat#5739";
        $k[$j++] = "ISSN ninth character must be a number or the character X";
        bwipp_raiseerror();
      }
    }
    if ($1.seqvar.length != 2) {
      $k[$j++] = "bwipp.issnBadSequenceVariantLength#5743";
      $k[$j++] = "Sequence variant for ISSN must be 2 digits";
      bwipp_raiseerror();
    }
    $forall($1.seqvar, function() {
      var _T = $k[--$j];
      if (_T < 48 || _T > 57) {
        $k[$j++] = "bwipp.issnSequenceVariantBadCharacter#5747";
        $k[$j++] = "Sequence variant for ISSN must contain only digits";
        bwipp_raiseerror();
      }
    });
    if ($1.addon.length != 0 && $1.addon.length != 2 && $1.addon.length != 5) {
      $k[$j++] = "bwipp.issnBadAddOnLength#5751";
      $k[$j++] = "Add-on for ISSN must be 2 or 5 digits";
      bwipp_raiseerror();
    }
    $1.issn = $s(8);
    $1.checksum = 0;
    $1.i = 0;
    $1.n = 0;
    for (; ; ) {
      $1.issnchar = $f($get($1.issntxt, $1.i) - 48);
      if ($1.issnchar != -3) {
        $put($1.issn, $1.n, $f($1.issnchar + 48));
        if ($1.n < 7) {
          $1.checksum = $f($1.checksum + $1.issnchar * (8 - $1.n));
        }
        $1.n = $1.n + 1;
      }
      $1.i = $1.i + 1;
      if ($1.i == $1.issntxt.length) {
        break;
      }
    }
    $1.checksum = $f(11 - $1.checksum % 11) % 11;
    var _p = $f($1.checksum + 48);
    $k[$j++] = "checksum";
    $k[$j++] = _p;
    if (_p == 58) {
      $j--;
      $k[$j++] = 88;
    }
    var _q = $k[--$j];
    var _r = $k[--$j];
    $1[_r] = _q;
    if ($1.issntxt.length == 9) {
      if ($get($1.issntxt, 8) != $1.checksum) {
        $k[$j++] = "bwipp.issnBadCheckDigit#5774";
        $k[$j++] = "Incorrect ISSN check digit provided";
        bwipp_raiseerror();
      }
    }
    $1.pad = $s(14);
    $puti($1.pad, 0, "ISSN ");
    $puti($1.pad, 5, $1.issntxt);
    $put($1.pad, 13, $1.checksum);
    $1.issntxt = $1.pad;
    $1.barcode = $geti($1.issn, 0, 7);
    $1.barcode = $s(12);
    $puti($1.barcode, 0, "977");
    $puti($1.barcode, 3, $1.issn);
    $puti($1.barcode, 10, $1.seqvar);
    if ($ne($1.addon, "")) {
      var _1D = $s(12 + $1.addon.length + 1);
      $puti(_1D, 0, $1.barcode);
      $puti(_1D, 12, " ");
      $puti(_1D, 13, $1.addon);
      $1.barcode = _1D;
    }
    $put($1.options, "dontdraw", true);
    $put($1.options, "addongap", $1.addongap);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_ean13();
    var _1L = $k[--$j];
    $1[$k[--$j]] = _1L;
    if ($1.includetext) {
      if ($eq($1.issntextxoffset, null)) {
        $1.issntextxoffset = 10;
      }
      if ($eq($1.issntextyoffset, null)) {
        $1.issntextyoffset = $1.height * 72 + 3;
      }
      var _1S = $get($1.args, "txt") !== void 0;
      if (_1S) {
        $1.txt = $get($1.args, "txt");
        $1.newtxt = $a($1.txt.length + 1);
        $puti($1.newtxt, 0, $1.txt);
        $put($1.newtxt, $1.newtxt.length - 1, $a([$1.issntxt, $1.issntextxoffset, $1.issntextyoffset, $1.issntextfont, $1.issntextsize]));
        $put($1.args, "txt", $1.newtxt);
      } else {
        $put($1.args, "txt", $a([$a([$1.issntxt, $1.issntextxoffset, $1.issntextyoffset, $1.issntextfont, $1.issntextsize])]));
      }
    }
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_mands() {
    var $1 = Object.create(bwipp_mands.$ctx || (bwipp_mands.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $1.barlen = $1.barcode.length;
    if ($1.barlen != 7 && $1.barlen != 8) {
      $k[$j++] = "bwipp.MandSbadLength#5870";
      $k[$j++] = "M&S barcode must be 7 or 8 characters";
      bwipp_raiseerror();
    }
    if ($1.barlen == 7) {
      var _7 = $strcpy($s(8), "00000000");
      $puti(_7, 1, $1.barcode);
      $1.barcode = _7;
    }
    $put($1.options, "dontdraw", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_ean8();
    var _C = $k[--$j];
    $1[$k[--$j]] = _C;
    var _F = $get($1.args, "bbs");
    $put(_F, 10, $get(_F, 2));
    $put(_F, 11, $get(_F, 2));
    var _J = $get($1.args, "bhs");
    $put(_J, 10, $get(_J, 2));
    $put(_J, 11, $get(_J, 2));
    $1.txt = $get($1.args, "txt");
    if ($1.barlen == 7) {
      for (var _P = 0; _P <= 6; _P += 1) {
        var _Q = $1.txt;
        $puti($get($get(_Q, _P), 0), 0, $get($get(_Q, _P + 1), 0));
      }
      $puti($get($get($1.txt, 7), 0), 0, " ");
    }
    var _Y = $a(10);
    $puti(_Y, 0, $1.txt);
    $1.txt = _Y;
    var _b = $get($1.txt, 0);
    $put($1.txt, 8, $arrcpy($a(_b.length), _b));
    var _g = $get($1.txt, 0);
    $put($1.txt, 9, $arrcpy($a(_g.length), _g));
    $put($get($1.txt, 8), 0, "M");
    $put($get($1.txt, 8), 1, -12);
    $put($get($1.txt, 9), 0, "S");
    var _r = $get($1.txt, 9);
    $put(_r, 1, 69);
    $put($1.args, "txt", $1.txt);
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_code128() {
    var $1 = Object.create(bwipp_code128.$ctx || (bwipp_code128.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = -8;
    $1.height = 1;
    $1.encoding = "auto";
    $1.raw = false;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_code128.__5971__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.sta = -1;
        $ctx.stb = -2;
        $ctx.stc = -3;
        $ctx.swa = -4;
        $ctx.swb = -5;
        $ctx.swc = -6;
        $ctx.fn1 = -7;
        $ctx.fn2 = -8;
        $ctx.fn3 = -9;
        $ctx.fn4 = -10;
        $ctx.sft = -11;
        $ctx.stp = -12;
        $ctx.lka = -13;
        $ctx.lkc = -14;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code128.$ctx[id] = $ctx[id]);
        bwipp_code128.__5971__ = 1;
      })();
    }
    var _6 = $1.fn1;
    var _B = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["FNC1", $1.fn1],
      ["FNC1", _6],
      ["FNC2", $1.fn2],
      ["FNC3", $1.fn3],
      ["LNKA", $1.lka],
      ["LNKC", $1.lkc]
    ]);
    $1.fncvals = _B;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _E = $k[--$j];
    $1[$k[--$j]] = _E;
    $1.msglen = $1.msg.length;
    if (!bwipp_code128.__6044__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.charmaps = $a([$a([32, 32, "00"]), $a(["!", "!", "01"]), $a(['"', '"', "02"]), $a(["#", "#", "03"]), $a(["$", "$", "04"]), $a(["%", "%", "05"]), $a(["&", "&", "06"]), $a(["'", "'", "07"]), $a([40, 40, "08"]), $a([41, 41, "09"]), $a(["*", "*", "10"]), $a(["+", "+", "11"]), $a([",", ",", "12"]), $a(["-", "-", "13"]), $a([".", ".", "14"]), $a(["/", "/", "15"]), $a(["0", "0", "16"]), $a(["1", "1", "17"]), $a(["2", "2", "18"]), $a(["3", "3", "19"]), $a(["4", "4", "20"]), $a(["5", "5", "21"]), $a(["6", "6", "22"]), $a(["7", "7", "23"]), $a(["8", "8", "24"]), $a(["9", "9", "25"]), $a([":", ":", "26"]), $a([";", ";", "27"]), $a(["<", "<", "28"]), $a(["=", "=", "29"]), $a([">", ">", "30"]), $a(["?", "?", "31"]), $a(["@", "@", "32"]), $a(["A", "A", "33"]), $a(["B", "B", "34"]), $a(["C", "C", "35"]), $a(["D", "D", "36"]), $a(["E", "E", "37"]), $a(["F", "F", "38"]), $a(["G", "G", "39"]), $a(["H", "H", "40"]), $a(["I", "I", "41"]), $a(["J", "J", "42"]), $a(["K", "K", "43"]), $a(["L", "L", "44"]), $a(["M", "M", "45"]), $a(["N", "N", "46"]), $a(["O", "O", "47"]), $a(["P", "P", "48"]), $a(["Q", "Q", "49"]), $a(["R", "R", "50"]), $a(["S", "S", "51"]), $a(["T", "T", "52"]), $a(["U", "U", "53"]), $a(["V", "V", "54"]), $a(["W", "W", "55"]), $a(["X", "X", "56"]), $a(["Y", "Y", "57"]), $a(["Z", "Z", "58"]), $a(["[", "[", "59"]), $a([92, 92, "60"]), $a(["]", "]", "61"]), $a(["^", "^", "62"]), $a(["_", "_", "63"]), $a([0, "`", "64"]), $a([1, "a", "65"]), $a([2, "b", "66"]), $a([3, "c", "67"]), $a([4, "d", "68"]), $a([5, "e", "69"]), $a([6, "f", "70"]), $a([7, "g", "71"]), $a([8, "h", "72"]), $a([9, "i", "73"]), $a([10, "j", "74"]), $a([11, "k", "75"]), $a([12, "l", "76"]), $a([13, "m", "77"]), $a([14, "n", "78"]), $a([15, "o", "79"]), $a([16, "p", "80"]), $a([17, "q", "81"]), $a([18, "r", "82"]), $a([19, "s", "83"]), $a([20, "t", "84"]), $a([21, "u", "85"]), $a([22, "v", "86"]), $a([23, "w", "87"]), $a([24, "x", "88"]), $a([25, "y", "89"]), $a([26, "z", "90"]), $a([27, "{", "91"]), $a([28, "|", "92"]), $a([29, "}", "93"]), $a([30, "~", "94"]), $a([31, 127, "95"]), $a([$ctx.fn3, $ctx.fn3, "96"]), $a([$ctx.fn2, $ctx.fn2, "97"]), $a([$ctx.sft, $ctx.sft, "98"]), $a([$ctx.swc, $ctx.swc, "99"]), $a([$ctx.swb, $ctx.fn4, $ctx.swb]), $a([$ctx.fn4, $ctx.swa, $ctx.swa]), $a([$ctx.fn1, $ctx.fn1, $ctx.fn1]), $a([$ctx.sta, $ctx.sta, $ctx.sta]), $a([$ctx.stb, $ctx.stb, $ctx.stb]), $a([$ctx.stc, $ctx.stc, $ctx.stc]), $a([$ctx.stp, $ctx.stp, $ctx.stp])]);
        $ctx.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
        for (var _2X = 0, _2W = $ctx.charmaps.length - 1; _2X <= _2W; _2X += 1) {
          $ctx.i = _2X;
          $ctx.encs = $get($ctx.charmaps, $ctx.i);
          for (var _2b = 0; _2b <= 2; _2b += 1) {
            $ctx.j = _2b;
            var _2e = $get($ctx.encs, $ctx.j);
            $k[$j++] = _2e;
            if ($eq($type(_2e), "stringtype")) {
              var _2h = $get($k[--$j], 0);
              $k[$j++] = _2h;
            }
            $put($get($ctx.charvals, $ctx.j), $k[--$j], $ctx.i);
          }
        }
        $ctx.seta = $get($ctx.charvals, 0);
        $ctx.setb = $get($ctx.charvals, 1);
        $ctx.setc = $get($ctx.charvals, 2);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code128.$ctx[id] = $ctx[id]);
        bwipp_code128.__6044__ = 1;
      })();
    }
    $put($1.seta, $1.lka, $get($1.seta, $1.swb));
    $put($1.seta, $1.lkc, $get($1.seta, $1.swc));
    $put($1.setb, $1.lka, $get($1.setb, $1.swc));
    $put($1.setb, $1.lkc, $get($1.setb, $1.swa));
    $put($1.setc, $1.lka, $get($1.setc, $1.swa));
    $put($1.setc, $1.lkc, $get($1.setc, $1.swb));
    if ($1.raw) {
      $1.encoding = "raw";
    }
    if ($eq($1.encoding, "raw")) {
      $1.cws = $a($1.barcode.length);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i == $1.barcode.length) {
          break;
        }
        $1.cw = $cvi($geti($1.barcode, $1.i + 1, 3));
        $put($1.cws, $1.j, $1.cw);
        $1.i = $1.i + 4;
        $1.j = $1.j + 1;
      }
      $1.cws = $geti($1.cws, 0, $1.j);
      $1.text = "";
    }
    if ($eq($1.encoding, "auto")) {
      $1.text = $s($1.msglen);
      for (var _3k = 0, _3j = $1.msglen - 1; _3k <= _3j; _3k += 1) {
        $1.i = _3k;
        var _3p = $get($1.msg, $1.i);
        $k[$j++] = $1.text;
        $k[$j++] = $1.i;
        $k[$j++] = _3p;
        if (_3p < 0) {
          $j--;
          $k[$j++] = 32;
        }
        var _3q = $k[--$j];
        var _3r = $k[--$j];
        $put($k[--$j], _3r, _3q);
      }
      $k[$j++] = Infinity;
      for (var _3u = 0, _3v = $1.msglen; _3u < _3v; _3u++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numSA = $a();
      $k[$j++] = Infinity;
      for (var _3y = 0, _3z = $1.msglen; _3y < _3z; _3y++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numEA = $a();
      for (var _42 = $1.msglen - 1; _42 >= 0; _42 -= 1) {
        $1.i = _42;
        if ($get($1.msg, $1.i) >= 0) {
          if ($get($1.msg, $1.i) >= 128) {
            $put($1.numEA, $1.i, $f($get($1.numEA, $1.i + 1) + 1));
          } else {
            $put($1.numSA, $1.i, $f($get($1.numSA, $1.i + 1) + 1));
          }
        }
      }
      $1.ea = false;
      $1.msgtmp = $a([]);
      for (var _4M = 0, _4L = $1.msglen - 1; _4M <= _4L; _4M += 1) {
        $1.i = _4M;
        $1.c = $get($1.msg, $1.i);
        if (!$xo($1.ea, $1.c < 128) && $1.c >= 0) {
          if ($1.ea) {
            $k[$j++] = $1.numSA;
          } else {
            $k[$j++] = $1.numEA;
          }
          var _4Y = $get($k[--$j], $1.i);
          var _4b = $f(_4Y + $1.i) == $1.msglen ? 3 : 5;
          if (_4Y < _4b) {
            $k[$j++] = Infinity;
            $aload($1.msgtmp);
            $k[$j++] = $1.fn4;
            $1.msgtmp = $a();
          } else {
            $k[$j++] = Infinity;
            $aload($1.msgtmp);
            $k[$j++] = $1.fn4;
            $k[$j++] = $1.fn4;
            $1.msgtmp = $a();
            $1.ea = !$1.ea;
          }
        }
        $k[$j++] = Infinity;
        $aload($1.msgtmp);
        if ($1.c >= 0) {
          $k[$j++] = $1.c & 127;
        } else {
          $k[$j++] = $1.c;
        }
        $1.msgtmp = $a();
      }
      $1.msg = $1.msgtmp;
      $1.msglen = $1.msg.length;
      $1.numsscr = function() {
        $1.n = 0;
        $1.s = 0;
        $1.p = $k[--$j];
        for (; ; ) {
          if ($1.p >= $1.msglen) {
            break;
          }
          var _4w = $get($1.msg, $1.p);
          var _4y = $get($1.setc, _4w) !== void 0;
          $k[$j++] = _4w;
          if (!_4y) {
            $j--;
            break;
          }
          var _4z = $k[--$j];
          $k[$j++] = _4z;
          if (_4z <= -1) {
            var _51 = $k[--$j];
            if (_51 == $1.fn1 && $1.s % 2 == 0) {
              $1.s = $1.s + 1;
            } else {
              break;
            }
          } else {
            $j--;
          }
          $1.n = $1.n + 1;
          $1.s = $1.s + 1;
          $1.p = $f($1.p + 1);
        }
        $k[$j++] = $1.n;
        $k[$j++] = $1.s;
      };
      $1.enca = function() {
        $put($1.cws, $1.j, $get($1.seta, $k[--$j]));
        $1.j = $1.j + 1;
      };
      $1.encb = function() {
        $put($1.cws, $1.j, $get($1.setb, $k[--$j]));
        $1.j = $1.j + 1;
      };
      $1.encc = function() {
        var _5L = $k[--$j];
        $k[$j++] = _5L;
        if ($ne($type(_5L), "arraytype")) {
          var _5P = $get($1.setc, $k[--$j]);
          $k[$j++] = _5P;
        } else {
          $aload($k[--$j]);
          var _5R = $k[--$j];
          var _5S = $k[--$j];
          $k[$j++] = $f($f(_5R - 48) + $f(_5S - 48) * 10);
        }
        $put($1.cws, $1.j, $k[--$j]);
        $1.j = $1.j + 1;
      };
      $1.anotb = function() {
        var _5X = $k[--$j];
        var _5Z = $get($1.seta, _5X) !== void 0;
        var _5b = $get($1.setb, _5X) !== void 0;
        $k[$j++] = _5Z && !_5b;
      };
      $1.bnota = function() {
        var _5c = $k[--$j];
        var _5e = $get($1.setb, _5c) !== void 0;
        var _5g = $get($1.seta, _5c) !== void 0;
        $k[$j++] = _5e && !_5g;
      };
      $k[$j++] = Infinity;
      for (var _5i = 0, _5j = $1.msg.length; _5i < _5j; _5i++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 9999;
      $1.nextanotb = $a();
      $k[$j++] = Infinity;
      for (var _5m = 0, _5n = $1.msg.length; _5m < _5n; _5m++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 9999;
      $1.nextbnota = $a();
      for (var _5q = $1.msg.length - 1; _5q >= 0; _5q -= 1) {
        $1.i = _5q;
        $k[$j++] = $get($1.msg, $1.i);
        $1.anotb();
        if ($k[--$j]) {
          $put($1.nextanotb, $1.i, 0);
        } else {
          $put($1.nextanotb, $1.i, $f($get($1.nextanotb, $1.i + 1) + 1));
        }
        $k[$j++] = $get($1.msg, $1.i);
        $1.bnota();
        if ($k[--$j]) {
          $put($1.nextbnota, $1.i, 0);
        } else {
          $put($1.nextbnota, $1.i, $f($get($1.nextbnota, $1.i + 1) + 1));
        }
      }
      $1.abeforeb = function() {
        var _6D = $k[--$j];
        $k[$j++] = $lt($get($1.nextanotb, _6D), $get($1.nextbnota, _6D));
      };
      $1.bbeforea = function() {
        var _6I = $k[--$j];
        $k[$j++] = $lt($get($1.nextbnota, _6I), $get($1.nextanotb, _6I));
      };
      $1.cws = $a($1.barcode.length * 2 + 3);
      $1.j = 0;
      if ($1.msglen > 0) {
        $k[$j++] = 0;
        $1.numsscr();
      } else {
        $k[$j++] = -1;
        $k[$j++] = -1;
      }
      $1.nums = $k[--$j];
      $1.nchars = $k[--$j];
      for (; ; ) {
        if ($1.msglen == 0) {
          $k[$j++] = $1.stb;
          $1.enca();
          $1.cset = "setb";
          break;
        }
        if ($1.msglen == 2 && $1.nums == 2) {
          $k[$j++] = $1.stc;
          $1.enca();
          $1.cset = "setc";
          break;
        }
        if ($1.nums >= 4) {
          $k[$j++] = $1.stc;
          $1.enca();
          $1.cset = "setc";
          break;
        }
        $k[$j++] = 0;
        $1.abeforeb();
        if ($k[--$j]) {
          $k[$j++] = $1.sta;
          $1.enca();
          $1.cset = "seta";
          break;
        }
        $k[$j++] = $1.stb;
        $1.enca();
        $1.cset = "setb";
        break;
      }
      $1.i = 0;
      for (; ; ) {
        if ($1.i == $1.msglen) {
          break;
        }
        $k[$j++] = $1.i;
        $1.numsscr();
        $1.nums = $k[--$j];
        $1.nchars = $k[--$j];
        for (; ; ) {
          if (($eq($1.cset, "seta") || $eq($1.cset, "setb")) && $1.nums >= 4 && $get($1.msg, $1.i) != $1.fn1) {
            if ($1.nums % 2 == 0) {
              $k[$j++] = $1.swc;
              if ($eq($1.cset, "seta")) {
                $1.enca();
              } else {
                $1.encb();
              }
              $1.cset = "setc";
              break;
            } else {
              $k[$j++] = $get($1.msg, $1.i);
              if ($eq($1.cset, "seta")) {
                $1.enca();
              } else {
                $1.encb();
              }
              $1.i = $1.i + 1;
              $k[$j++] = $1.swc;
              if ($eq($1.cset, "seta")) {
                $1.enca();
              } else {
                $1.encb();
              }
              $1.cset = "setc";
              break;
            }
          }
          $k[$j++] = $eq($1.cset, "setb");
          $k[$j++] = $get($1.msg, $1.i);
          $1.anotb();
          var _72 = $k[--$j];
          var _73 = $k[--$j];
          if (_73 && _72) {
            if ($1.i < $1.msglen - 1) {
              $k[$j++] = $1.i + 1;
              $1.bbeforea();
              if ($k[--$j]) {
                $k[$j++] = $1.sft;
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i);
                $1.enca();
                $1.i = $1.i + 1;
                break;
              }
            }
            $k[$j++] = $1.swa;
            $1.encb();
            $1.cset = "seta";
            break;
          }
          $k[$j++] = $eq($1.cset, "seta");
          $k[$j++] = $get($1.msg, $1.i);
          $1.bnota();
          var _7I = $k[--$j];
          var _7J = $k[--$j];
          if (_7J && _7I) {
            if ($1.i < $1.msglen - 1) {
              $k[$j++] = $1.i + 1;
              $1.abeforeb();
              if ($k[--$j]) {
                $k[$j++] = $1.sft;
                $1.enca();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $1.i = $1.i + 1;
                break;
              }
            }
            $k[$j++] = $1.swb;
            $1.enca();
            $1.cset = "setb";
            break;
          }
          if ($eq($1.cset, "setc") && $1.nums < 2 && ($get($1.msg, $1.i) > -1 || $get($1.msg, $1.i) == $1.fn4)) {
            $k[$j++] = $1.i;
            $1.abeforeb();
            if ($k[--$j]) {
              $k[$j++] = $1.swa;
              $1.encc();
              $1.cset = "seta";
              break;
            }
            $k[$j++] = $1.swb;
            $1.encc();
            $1.cset = "setb";
            break;
          }
          if ($eq($1.cset, "seta")) {
            $k[$j++] = $get($1.msg, $1.i);
            $1.enca();
            $1.i = $1.i + 1;
            break;
          }
          if ($eq($1.cset, "setb")) {
            $k[$j++] = $get($1.msg, $1.i);
            $1.encb();
            $1.i = $1.i + 1;
            break;
          }
          if ($eq($1.cset, "setc")) {
            if ($get($1.msg, $1.i) <= -1) {
              $k[$j++] = $get($1.msg, $1.i);
              $1.encc();
              $1.i = $1.i + 1;
            } else {
              $k[$j++] = $geti($1.msg, $1.i, 2);
              $1.encc();
              $1.i = $1.i + 2;
            }
            break;
          }
          break;
        }
      }
      $1.cws = $geti($1.cws, 0, $1.j);
    }
    var _87 = $a($1.j + 2);
    $puti(_87, 0, $1.cws);
    $1.cws = _87;
    $1.csum = $get($1.cws, 0);
    for (var _8D = 1, _8C = $1.j - 1; _8D <= _8C; _8D += 1) {
      $1.i = _8D;
      $1.csum = $f($1.csum + $get($1.cws, $1.i) * $1.i);
    }
    $1.csum = $1.csum % 103;
    $put($1.cws, $1.j, $1.csum);
    $put($1.cws, $1.j + 1, $get($1.seta, $1.stp));
    var _8T = $get($1.options, "debugcws") !== void 0;
    if (_8T) {
      $k[$j++] = "bwipp.debugcws#6303";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    if (!bwipp_code128.__6325__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["212222", "222122", "222221", "121223", "121322", "131222", "122213", "122312", "132212", "221213", "221312", "231212", "112232", "122132", "122231", "113222", "123122", "123221", "223211", "221132", "221231", "213212", "223112", "312131", "311222", "321122", "321221", "312212", "322112", "322211", "212123", "212321", "232121", "111323", "131123", "131321", "112313", "132113", "132311", "211313", "231113", "231311", "112133", "112331", "132131", "113123", "113321", "133121", "313121", "211331", "231131", "213113", "213311", "213131", "311123", "311321", "331121", "312113", "312311", "332111", "314111", "221411", "431111", "111224", "111422", "121124", "121421", "141122", "141221", "112214", "112412", "122114", "122411", "142112", "142211", "241211", "221114", "413111", "241112", "134111", "111242", "121142", "121241", "114212", "124112", "124211", "411212", "421112", "421211", "212141", "214121", "412121", "111143", "111341", "131141", "114113", "114311", "411113", "411311", "113141", "114131", "311141", "411131", "211412", "211214", "211232", "2331112"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code128.$ctx[id] = $ctx[id]);
        bwipp_code128.__6325__ = 1;
      })();
    }
    $1.sbs = $s($1.cws.length * 6 + 1);
    for (var _8b = 0, _8a = $1.cws.length - 1; _8b <= _8a; _8b += 1) {
      $1.i = _8b;
      $puti($1.sbs, $1.i * 6, $get($1.encs, $get($1.cws, $1.i)));
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _8j = $1.sbs;
    for (var _8k = 0, _8l = _8j.length; _8k < _8l; _8k++) {
      $k[$j++] = $get(_8j, _8k) - 48;
    }
    var _8n = $a();
    $k[$j++] = Infinity;
    for (var _8p = 0, _8q = ~~(($1.sbs.length + 1) / 2); _8p < _8q; _8p++) {
      $k[$j++] = $1.height;
    }
    var _8s = $a();
    $k[$j++] = Infinity;
    for (var _8u = 0, _8v = ~~(($1.sbs.length + 1) / 2); _8u < _8v; _8u++) {
      $k[$j++] = 0;
    }
    var _8w = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _8n;
    $k[$j++] = "bhs";
    $k[$j++] = _8s;
    $k[$j++] = "bbs";
    $k[$j++] = _8w;
    $k[$j++] = "txt";
    $k[$j++] = $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]);
    $k[$j++] = "textxalign";
    $k[$j++] = "center";
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _95 = $d();
    $k[$j++] = _95;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_gs1_128() {
    var $1 = Object.create(bwipp_gs1_128.$ctx || (bwipp_gs1_128.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = -8;
    $1.height = 0.5;
    $1.linkagea = false;
    $1.linkagec = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.linkagea && $1.linkagec) {
      $k[$j++] = "bwipp.gs1128badLinkage#6400";
      $k[$j++] = "linkagea and linkagec cannot be used together";
      bwipp_raiseerror();
    }
    $1.text = $1.barcode;
    $k[$j++] = $1.barcode;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $1.fncs = $k[--$j];
    $1.vals = $k[--$j];
    $1.ais = $k[--$j];
    $1.fnc1 = -1;
    $1.c128 = $a([$1.fnc1]);
    for (var _D = 0, _C = $1.ais.length - 1; _D <= _C; _D += 1) {
      $1.i = _D;
      $1.ai = $get($1.ais, $1.i);
      $1.val = $get($1.vals, $1.i);
      var _N = $a($1.c128.length + $1.ai.length + $1.val.length);
      $puti(_N, 0, $1.c128);
      $k[$j++] = _N;
      $k[$j++] = _N;
      $k[$j++] = $1.c128.length;
      $k[$j++] = $1.ai;
      $k[$j++] = Infinity;
      var _R = $k[--$j];
      var _S = $k[--$j];
      $k[$j++] = _R;
      $forall(_S);
      var _T = $a();
      var _U = $k[--$j];
      $puti($k[--$j], _U, _T);
      var _W = $k[--$j];
      $k[$j++] = _W;
      $k[$j++] = _W;
      $k[$j++] = $1.c128.length + $1.ai.length;
      $k[$j++] = $1.val;
      $k[$j++] = Infinity;
      var _a = $k[--$j];
      var _b = $k[--$j];
      $k[$j++] = _a;
      $forall(_b);
      var _c = $a();
      var _d = $k[--$j];
      $puti($k[--$j], _d, _c);
      $1.c128 = $k[--$j];
      if ($1.i != $1.ais.length - 1 && $get($1.fncs, $1.i)) {
        var _m = $a($1.c128.length + 1);
        $puti(_m, 0, $1.c128);
        $put(_m, $1.c128.length, $1.fnc1);
        $1.c128 = _m;
      }
    }
    $1.barcode = $s(($1.c128.length + 1) * 5);
    $1.i = 0;
    $1.j = 0;
    for (; ; ) {
      if ($1.i == $1.c128.length) {
        break;
      }
      var _w = $get($1.c128, $1.i);
      $k[$j++] = _w;
      if (_w == $1.fnc1) {
        $j--;
        $puti($1.barcode, $1.j, "^FNC1");
        $1.j = $1.j + 4;
      } else {
        $put($1.barcode, $1.j, $k[--$j]);
      }
      $1.i = $1.i + 1;
      $1.j = $1.j + 1;
    }
    if ($1.linkagea || $1.linkagec) {
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.j;
      if ($1.linkagea) {
        $k[$j++] = "^LNKA";
      } else {
        $k[$j++] = "^LNKC";
      }
      var _1B = $k[--$j];
      var _1C = $k[--$j];
      $puti($k[--$j], _1C, _1B);
      $1.j = $1.j + 5;
    }
    $1.barcode = $geti($1.barcode, 0, $1.j);
    delete $1.options["parse"];
    $put($1.options, "height", $1.height);
    $put($1.options, "dontdraw", true);
    $put($1.options, "parsefnc", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code128();
    var _1P = $k[--$j];
    $1[$k[--$j]] = _1P;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_ean14() {
    var $1 = Object.create(bwipp_ean14.$ctx || (bwipp_ean14.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $1.text = $1.barcode;
    var _3 = $1.barcode;
    $k[$j++] = $s(_3.length);
    $k[$j++] = 0;
    $forall(_3, function() {
      var _5 = $k[--$j];
      $k[$j++] = _5;
      if (_5 != 32) {
        var _6 = $k[--$j];
        var _7 = $k[--$j];
        var _8 = $k[--$j];
        $put(_8, _7, _6);
        $k[$j++] = _8;
        $k[$j++] = $f(_7 + 1);
      } else {
        $j--;
      }
    });
    var _9 = $k[--$j];
    $1.barcode = $geti($k[--$j], 0, _9);
    $1.hasspace = $1.text.length != $1.barcode.length;
    if ($ne($geti($1.barcode, 0, 4), "(01)")) {
      $k[$j++] = "bwipp.ean14badAI#6515";
      $k[$j++] = "GS1-14 must begin with (01) application identifier";
      bwipp_raiseerror();
    }
    if ($1.barcode.length != 17 && $1.barcode.length != 18) {
      $k[$j++] = "bwipp.ean14badLength#6518";
      $k[$j++] = "GS1-14 must be 13 or 14 digits";
      bwipp_raiseerror();
    }
    var _K = $geti($1.barcode, 4, $1.barcode.length - 4);
    for (var _L = 0, _M = _K.length; _L < _M; _L++) {
      var _N = $get(_K, _L);
      if (_N < 48 || _N > 57) {
        $k[$j++] = "bwipp.ean14badCharacter#6522";
        $k[$j++] = "GS1-14 must contain only digits";
        bwipp_raiseerror();
      }
    }
    $1.checksum = 0;
    for (var _O = 0; _O <= 12; _O += 1) {
      $1.i = _O;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i + 4) - 48);
      if ($1.i % 2 == 0) {
        var _U = $k[--$j];
        $k[$j++] = _U * 3;
      }
      var _V = $k[--$j];
      var _W = $k[--$j];
      $1[$k[--$j]] = $f(_W + _V);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 18) {
      if ($get($1.barcode, 17) != $1.checksum + 48) {
        $k[$j++] = "bwipp.ean14badCheckDigit#6535";
        $k[$j++] = "Incorrect GS1-14 check digit provided";
        bwipp_raiseerror();
      }
    } else {
      var _d = $s(18);
      $puti(_d, 0, $1.barcode);
      $put(_d, 17, $1.checksum + 48);
      $1.barcode = _d;
      var _i = $1.hasspace ? 2 : 1;
      var _j = $s($1.text.length + _i);
      $puti(_j, _j.length - 2, " ");
      $put(_j, _j.length - 1, $1.checksum + 48);
      $puti(_j, 0, $1.text);
      $1.text = _j;
    }
    $1.gtin = $geti($1.barcode, 4, 14);
    $1.barcode = $s(21);
    $puti($1.barcode, 0, "^FNC101");
    var _r = $1.gtin;
    $puti($1.barcode, 7, _r);
    $put($1.options, "dontdraw", true);
    $put($1.options, "parsefnc", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code128();
    var _w = $k[--$j];
    $1[$k[--$j]] = _w;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_sscc18() {
    var $1 = Object.create(bwipp_sscc18.$ctx || (bwipp_sscc18.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $1.text = $1.barcode;
    var _3 = $1.barcode;
    $k[$j++] = $s(_3.length);
    $k[$j++] = 0;
    $forall(_3, function() {
      var _5 = $k[--$j];
      $k[$j++] = _5;
      if (_5 != 32) {
        var _6 = $k[--$j];
        var _7 = $k[--$j];
        var _8 = $k[--$j];
        $put(_8, _7, _6);
        $k[$j++] = _8;
        $k[$j++] = $f(_7 + 1);
      } else {
        $j--;
      }
    });
    var _9 = $k[--$j];
    $1.barcode = $geti($k[--$j], 0, _9);
    $1.hasspace = $1.text.length != $1.barcode.length;
    if ($ne($geti($1.barcode, 0, 4), "(00)")) {
      $k[$j++] = "bwipp.sscc18badAI#6619";
      $k[$j++] = "SSCC-18 must begin with (00) application identifier";
      bwipp_raiseerror();
    }
    if ($1.barcode.length != 21 && $1.barcode.length != 22) {
      $k[$j++] = "bwipp.sscc18badLength#6622";
      $k[$j++] = "SSCC-18 must be 17 or 18 digits";
      bwipp_raiseerror();
    }
    var _K = $geti($1.barcode, 4, $1.barcode.length - 4);
    for (var _L = 0, _M = _K.length; _L < _M; _L++) {
      var _N = $get(_K, _L);
      if (_N < 48 || _N > 57) {
        $k[$j++] = "bwipp.sscc18badCharacter#6626";
        $k[$j++] = "SSCC-18 must contain only digits";
        bwipp_raiseerror();
      }
    }
    $1.checksum = 0;
    for (var _O = 0; _O <= 16; _O += 1) {
      $1.i = _O;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i + 4) - 48);
      if ($1.i % 2 == 0) {
        var _U = $k[--$j];
        $k[$j++] = _U * 3;
      }
      var _V = $k[--$j];
      var _W = $k[--$j];
      $1[$k[--$j]] = $f(_W + _V);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 22) {
      if ($get($1.barcode, 21) != $1.checksum + 48) {
        $k[$j++] = "bwipp.sscc18badCheckDigit#6639";
        $k[$j++] = "Incorrect SSCC-18 check digit provided";
        bwipp_raiseerror();
      }
    } else {
      var _d = $s(22);
      $puti(_d, 0, $1.barcode);
      $put(_d, 21, $1.checksum + 48);
      $1.barcode = _d;
      var _i = $1.hasspace ? 2 : 1;
      var _j = $s($1.text.length + _i);
      $puti(_j, _j.length - 2, " ");
      $put(_j, _j.length - 1, $1.checksum + 48);
      $puti(_j, 0, $1.text);
      $1.text = _j;
    }
    $1.sscc = $geti($1.barcode, 4, 18);
    $1.barcode = $s(25);
    $puti($1.barcode, 0, "^FNC100");
    var _r = $1.sscc;
    $puti($1.barcode, 7, _r);
    $put($1.options, "dontdraw", true);
    $put($1.options, "parsefnc", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code128();
    var _w = $k[--$j];
    $1[$k[--$j]] = _w;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_code39() {
    var $1 = Object.create(bwipp_code39.$ctx || (bwipp_code39.$ctx = {}));
    $1.dontdraw = false;
    $1.includecheck = false;
    $1.validatecheck = false;
    $1.includetext = false;
    $1.includecheckintext = false;
    $1.hidestars = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_code39.__6738__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["1113313111", "3113111131", "1133111131", "3133111111", "1113311131", "3113311111", "1133311111", "1113113131", "3113113111", "1133113111", "3111131131", "1131131131", "3131131111", "1111331131", "3111331111", "1131331111", "1111133131", "3111133111", "1131133111", "1111333111", "3111111331", "1131111331", "3131111311", "1111311331", "3111311311", "1131311311", "1111113331", "3111113311", "1131113311", "1111313311", "3311111131", "1331111131", "3331111111", "1311311131", "3311311111", "1331311111", "1311113131", "3311113111", "1331113111", "1313131111", "1313111311", "1311131311", "1113131311", "1311313111"]);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _3 = 0; _3 <= 42; _3 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _3, 1), _3);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code39.$ctx[id] = $ctx[id]);
        bwipp_code39.__6738__ = 1;
      })();
    }
    for (var _A = 0, _9 = $1.barcode.length - 1; _A <= _9; _A += 1) {
      var _E = $get($1.charvals, $geti($1.barcode, _A, 1)) !== void 0;
      if (!_E) {
        $k[$j++] = "bwipp.code39badCharacter#6743";
        $k[$j++] = "Code 39 must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _H = $k[--$j];
      $k[$j++] = $f(_H - 1);
    }
    var _I = $k[--$j];
    $1[$k[--$j]] = _I;
    $1.checksum = 0;
    for (var _M = 0, _L = $f($1.barlen - 1); _M <= _L; _M += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _M, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.code39badCheckDigit#6757";
        $k[$j++] = "Incorrect Code 39 check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
      $1.includecheck = true;
    }
    var _f = $1.includecheck ? 3 : 2;
    $1.sbs = $s($f($1.barlen + _f) * 10);
    var _j = $1.includecheck ? 3 : 2;
    $1.txt = $a($f($1.barlen + _j));
    $puti($1.sbs, 0, $get($1.encs, 43));
    if (!$1.hidestars) {
      $put($1.txt, 0, $a(["*", 0, $1.textyoffset, $1.textfont, $1.textsize]));
    } else {
      $put($1.txt, 0, $a(["", 0, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    for (var _11 = 0, _10 = $f($1.barlen - 1); _11 <= _10; _11 += 1) {
      $1.i = _11;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $puti($1.sbs, $1.i * 10 + 10, $get($1.encs, $1.indx));
      $put($1.txt, $1.i + 1, $a([$geti($1.barcode, $1.i, 1), ($1.i + 1) * 16, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    if ($1.includecheck) {
      $puti($1.sbs, $f($1.barlen * 10 + 10), $get($1.encs, $1.checksum));
      if ($1.includecheckintext) {
        $put($1.txt, $f($1.barlen + 1), $a([$geti($1.barchars, $1.checksum, 1), $f($1.barlen + 1) * 16, $1.textyoffset, $1.textfont, $1.textsize]));
      } else {
        $put($1.txt, $f($1.barlen + 1), $a(["", $f($1.barlen + 1) * 16, $1.textyoffset, $1.textfont, $1.textsize]));
      }
      $puti($1.sbs, $f($1.barlen * 10 + 20), $get($1.encs, 43));
      if (!$1.hidestars) {
        $put($1.txt, $f($1.barlen + 2), $a(["*", $f($1.barlen + 2) * 16, $1.textyoffset, $1.textfont, $1.textsize]));
      } else {
        $put($1.txt, $f($1.barlen + 2), $a(["", $f($1.barlen + 2) * 16, $1.textyoffset, $1.textfont, $1.textsize]));
      }
    } else {
      $puti($1.sbs, $f($1.barlen * 10 + 10), $get($1.encs, 43));
      if (!$1.hidestars) {
        $put($1.txt, $f($1.barlen + 1), $a(["*", $f($1.barlen + 1) * 16, $1.textyoffset, $1.textfont, $1.textsize]));
      } else {
        $put($1.txt, $f($1.barlen + 1), $a(["", $f($1.barlen + 1) * 16, $1.textyoffset, $1.textfont, $1.textsize]));
      }
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _2M = $1.sbs;
    for (var _2N = 0, _2O = _2M.length; _2N < _2O; _2N++) {
      $k[$j++] = $get(_2M, _2N) - 48;
    }
    var _2Q = $a();
    $k[$j++] = Infinity;
    for (var _2S = 0, _2T = ~~(($1.sbs.length + 1) / 2); _2S < _2T; _2S++) {
      $k[$j++] = $1.height;
    }
    var _2V = $a();
    $k[$j++] = Infinity;
    for (var _2X = 0, _2Y = ~~(($1.sbs.length + 1) / 2); _2X < _2Y; _2X++) {
      $k[$j++] = 0;
    }
    var _2Z = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _2Q;
    $k[$j++] = "bhs";
    $k[$j++] = _2V;
    $k[$j++] = "bbs";
    $k[$j++] = _2Z;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2d = $d();
    $k[$j++] = _2d;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_code39ext() {
    var $1 = Object.create(bwipp_code39ext.$ctx || (bwipp_code39ext.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.parse = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _3 = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parseonly", true],
      ["parsefnc", false]
    ]);
    $1.fncvals = _3;
    $k[$j++] = "barcode";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $1.barlen = $1.barcode.length;
    delete $1.options["parse"];
    $forall($1.barcode, function() {
      if ($k[--$j] >= 128) {
        $k[$j++] = "bwipp.code39extBadCharacter#6877";
        $k[$j++] = "Code 39 Extended must contain only ASCII characters";
        bwipp_raiseerror();
      }
    });
    if (!bwipp_code39ext.__6893__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.extencs = $a(["%U", "$A", "$B", "$C", "$D", "$E", "$F", "$G", "$H", "$I", "$J", "$K", "$L", "$M", "$N", "$O", "$P", "$Q", "$R", "$S", "$T", "$U", "$V", "$W", "$X", "$Y", "$Z", "%A", "%B", "%C", "%D", "%E", " ", "/A", "/B", "/C", "/D", "/E", "/F", "/G", "/H", "/I", "/J", "/K", "/L", "-", ".", "/O", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "/Z", "%F", "%G", "%H", "%I", "%J", "%V", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "%K", "%L", "%M", "%N", "%O", "%W", "+A", "+B", "+C", "+D", "+E", "+F", "+G", "+H", "+I", "+J", "+K", "+L", "+M", "+N", "+O", "+P", "+Q", "+R", "+S", "+T", "+U", "+V", "+W", "+X", "+Y", "+Z", "%P", "%Q", "%R", "%S", "%T"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code39ext.$ctx[id] = $ctx[id]);
        bwipp_code39ext.__6893__ = 1;
      })();
    }
    $1.newcode = $s($1.barlen * 2);
    $1.newtext = $s($1.barlen * 2);
    $1.j = 0;
    for (var _K = 0, _J = $1.barlen - 1; _K <= _J; _K += 1) {
      $1.i = _K;
      $1.extchar = $get($1.extencs, $get($1.barcode, $1.i));
      $puti($1.newcode, $1.j, $1.extchar);
      var _X = $get($1.barcode, $1.i);
      $k[$j++] = $1.newtext;
      $k[$j++] = $1.j;
      $k[$j++] = _X;
      if (_X < 32 || _X == 127) {
        $j--;
        $k[$j++] = 32;
      }
      var _Y = $k[--$j];
      var _Z = $k[--$j];
      $put($k[--$j], _Z, _Y);
      if ($1.extchar.length != 1) {
        $put($1.newtext, $1.j + 1, 32);
      }
      $1.j = $1.j + $1.extchar.length;
    }
    $1.newcode = $geti($1.newcode, 0, $1.j);
    $1.newtext = $geti($1.newtext, 0, $1.j);
    $put($1.options, "dontdraw", true);
    $k[$j++] = "args";
    $k[$j++] = $1.newcode;
    $k[$j++] = $1.options;
    bwipp_code39();
    var _p = $k[--$j];
    $1[$k[--$j]] = _p;
    if ($1.includetext) {
      $1.txt = $get($1.args, "txt");
      for (var _w = 0, _v = $1.newtext.length - 1; _w <= _v; _w += 1) {
        $1.i = _w;
        $1.txtentry = $get($1.txt, $1.i + 1);
        $put($1.txtentry, 0, $geti($1.newtext, $1.i, 1));
        $put($1.txt, $1.i + 1, $1.txtentry);
      }
      $put($1.args, "txt", $1.txt);
    }
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_code32() {
    var $1 = Object.create(bwipp_code32.$ctx || (bwipp_code32.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.textxoffset = 0;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.barcode.length != 8 && $1.barcode.length != 9) {
      $k[$j++] = "bwipp.code32badLength#6976";
      $k[$j++] = "Italian Pharmacode must be 8 or 9 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _5 = $k[--$j];
      if (_5 < 48 || _5 > 57) {
        $k[$j++] = "bwipp.code32badCharacter#6980";
        $k[$j++] = "Italian Pharmacode must contain only digits";
        bwipp_raiseerror();
      }
    });
    $1.checksum = 0;
    for (var _6 = 0; _6 <= 7; _6 += 1) {
      $1.i = _6;
      $k[$j++] = $f($get($1.barcode, $1.i) - 48);
      if ($1.i % 2 != 0) {
        var _B = $k[--$j];
        $k[$j++] = _B * 2;
      }
      var _C = $k[--$j];
      $k[$j++] = _C;
      if (_C > 9) {
        var _D = $k[--$j];
        $k[$j++] = $f(_D - 9);
      }
      $1.checksum = $f($k[--$j] + $1.checksum);
    }
    $1.checksum = $1.checksum % 10;
    if ($1.barcode.length == 9) {
      if ($get($1.barcode, 8) != $f($1.checksum + 48)) {
        $k[$j++] = "bwipp.code32badCheckDigit#6994";
        $k[$j++] = "Incorrect Italian Pharmacode check digit provided";
        bwipp_raiseerror();
      }
    }
    var _L = $s(10);
    $puti(_L, 0, $1.barcode);
    $put(_L, 8, $f($1.checksum + 48));
    $1.text = _L;
    $1.val = $cvrs($s(6), $cvi($1.text), 32);
    $1.barcode = $s(6);
    for (var _S = 0; _S <= 5; _S += 1) {
      $put($1.barcode, _S, 48);
    }
    $puti($1.barcode, 6 - $1.val.length, $1.val);
    for (var _X = 0; _X <= 5; _X += 1) {
      var _Z = $get($1.barcode, _X);
      $k[$j++] = _X;
      $k[$j++] = _Z;
      $k[$j++] = _Z;
      for (var _a = 0, _b = "AEIO".length; _a < _b; _a++) {
        if ($k[--$j] >= $get("AEIO", _a)) {
          var _e = $k[--$j];
          $k[$j++] = $f(_e + 1);
        }
        var _f = $k[--$j];
        $k[$j++] = _f;
        $k[$j++] = _f;
      }
      $j--;
      var _h = $k[--$j];
      $put($1.barcode, $k[--$j], _h);
    }
    $puti($1.text, 1, $geti($1.text, 0, 9));
    $put($1.text, 0, 65);
    $put($1.options, "dontdraw", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code39();
    var _q = $k[--$j];
    var _r = $k[--$j];
    $1[_r] = _q;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_pzn() {
    var $1 = Object.create(bwipp_pzn.$ctx || (bwipp_pzn.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.textxoffset = 0;
    $1.height = 1;
    $1.pzn8 = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.pzn8) {
      if ($1.barcode.length != 7 && $1.barcode.length != 8) {
        $k[$j++] = "bwipp.pzn8badLength#7077";
        $k[$j++] = "PZN8 must be 7 or 8 digits";
        bwipp_raiseerror();
      }
    } else {
      if ($1.barcode.length != 6 && $1.barcode.length != 7) {
        $k[$j++] = "bwipp.pzn7badLength#7081";
        $k[$j++] = "PZN7 must be 6 or 7 digits";
        bwipp_raiseerror();
      }
    }
    $forall($1.barcode, function() {
      var _8 = $k[--$j];
      if (_8 < 48 || _8 > 57) {
        $k[$j++] = "bwipp.pznBadCharacter#7086";
        $k[$j++] = "PZN must contain only digits";
        bwipp_raiseerror();
      }
    });
    var _A = $1.pzn8 ? 9 : 8;
    $1.msglen = _A;
    $1.checksum = 0;
    for (var _D = 0, _C = $1.msglen - 3; _D <= _C; _D += 1) {
      $1.i = _D;
      var _J = $1.pzn8 ? 1 : 2;
      $1.checksum = $f($f($get($1.barcode, $1.i) - 48) * ($1.i + _J) + $1.checksum);
    }
    $1.checksum = $1.checksum % 11;
    if ($1.checksum == 10) {
      $k[$j++] = "bwipp.pznBadInputSequence#7100";
      $k[$j++] = "Incorrect PZN input sequence provided";
      bwipp_raiseerror();
    }
    if ($1.barcode.length == $1.msglen - 1) {
      if ($get($1.barcode, $1.msglen - 2) != $f($1.checksum + 48)) {
        $k[$j++] = "bwipp.pznBadCheckDigit#7104";
        $k[$j++] = "Incorrect PZN check digit provided";
        bwipp_raiseerror();
      }
    }
    var _U = $s($1.msglen);
    $put(_U, 0, 45);
    $puti(_U, 1, $1.barcode);
    $put(_U, $1.msglen - 1, $f($1.checksum + 48));
    $1.msg = _U;
    $put($1.options, "dontdraw", true);
    $k[$j++] = "args";
    $k[$j++] = $1.msg;
    $k[$j++] = $1.options;
    bwipp_code39();
    var _b = $k[--$j];
    $1[$k[--$j]] = _b;
    $1.text = $s($1.msglen + 5);
    $puti($1.text, 0, "PZN - ");
    $puti($1.text, 6, $geti($1.msg, 1, $1.msglen - 1));
    var _r = $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]);
    $put($1.args, "txt", _r);
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_code93() {
    var $1 = Object.create(bwipp_code93.$ctx || (bwipp_code93.$ctx = {}));
    $1.dontdraw = false;
    $1.includecheck = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_code93.__7204__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["131112", "111213", "111312", "111411", "121113", "121212", "121311", "111114", "131211", "141111", "211113", "211212", "211311", "221112", "221211", "231111", "112113", "112212", "112311", "122112", "132111", "111123", "111222", "111321", "121122", "131121", "212112", "212211", "211122", "211221", "221121", "222111", "112122", "112221", "122121", "123111", "121131", "311112", "311211", "321111", "112131", "113121", "211131", "121221", "312111", "311121", "122211", "111141", "1111411"]);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _3 = 0; _3 <= 42; _3 += 1) {
          $put($ctx.charvals, $get($ctx.barchars, _3), _3);
        }
        $ctx.sft1 = -1;
        $ctx.sft2 = -2;
        $ctx.sft3 = -3;
        $ctx.sft4 = -4;
        var _7 = $ctx.charvals;
        $put(_7, $ctx.sft1, 43);
        $put($ctx.charvals, $ctx.sft2, 44);
        $put($ctx.charvals, $ctx.sft3, 45);
        $put($ctx.charvals, $ctx.sft4, 46);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code93.$ctx[id] = $ctx[id]);
        bwipp_code93.__7204__ = 1;
      })();
    }
    var _M = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["SFT$", $1.sft1],
      ["SFT%", $1.sft2],
      ["SFT/", $1.sft3],
      ["SFT+", $1.sft4]
    ]);
    $1.fncvals = _M;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _P = $k[--$j];
    $1[$k[--$j]] = _P;
    $1.msglen = $1.msg.length;
    $forall($1.msg, function() {
      var _V = $get($1.charvals, $k[--$j]) !== void 0;
      if (!_V) {
        $k[$j++] = "bwipp.code93BadCharacter#7221";
        $k[$j++] = "Code 93 must only contain digits, capital letters, spaces, the symbols -.$/+ and shift non-data characters";
        bwipp_raiseerror();
      }
    });
    if ($1.includecheck) {
      $1.sbs = $s($1.msglen * 6 + 25);
    } else {
      $1.sbs = $s($1.msglen * 6 + 13);
    }
    $1.txt = $a($1.msglen);
    $puti($1.sbs, 0, $get($1.encs, 47));
    $1.checksum1 = 0;
    $1.checksum2 = 0;
    for (var _i = 0, _h = $1.msglen - 1; _i <= _h; _i += 1) {
      $1.i = _i;
      $1.indx = $get($1.charvals, $get($1.msg, $1.i));
      $puti($1.sbs, $1.i * 6 + 6, $get($1.encs, $1.indx));
      var _v = $get($1.msg, $1.i);
      $k[$j++] = "char";
      $k[$j++] = _v;
      if (_v < 0) {
        $j--;
        $k[$j++] = " ";
      } else {
        var _w = $s(1);
        $put(_w, 0, $k[--$j]);
        $k[$j++] = _w;
      }
      var _y = $k[--$j];
      $1[$k[--$j]] = _y;
      $put($1.txt, $1.i, $a([$1.char, $1.i * 9 + 9, $1.textyoffset, $1.textfont, $1.textsize]));
      $1.checksum1 = $f($1.checksum1 + (($1.msglen - $1.i - 1) % 20 + 1) * $1.indx);
      $1.checksum2 = $f($1.checksum2 + (($1.msglen - $1.i) % 15 + 1) * $1.indx);
    }
    if ($1.includecheck) {
      $1.checksum1 = $1.checksum1 % 47;
      $1.checksum2 = $f($1.checksum2 + $1.checksum1) % 47;
      $puti($1.sbs, $1.msglen * 6 + 6, $get($1.encs, $1.checksum1));
      $puti($1.sbs, $1.msglen * 6 + 12, $get($1.encs, $1.checksum2));
      $puti($1.sbs, $1.msglen * 6 + 18, $get($1.encs, 48));
    } else {
      $puti($1.sbs, $1.msglen * 6 + 6, $get($1.encs, 48));
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _1c = $1.sbs;
    for (var _1d = 0, _1e = _1c.length; _1d < _1e; _1d++) {
      $k[$j++] = $get(_1c, _1d) - 48;
    }
    var _1g = $a();
    $k[$j++] = Infinity;
    for (var _1i = 0, _1j = ~~(($1.sbs.length + 1) / 2); _1i < _1j; _1i++) {
      $k[$j++] = $1.height;
    }
    var _1l = $a();
    $k[$j++] = Infinity;
    for (var _1n = 0, _1o = ~~(($1.sbs.length + 1) / 2); _1n < _1o; _1n++) {
      $k[$j++] = 0;
    }
    var _1p = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _1g;
    $k[$j++] = "bhs";
    $k[$j++] = _1l;
    $k[$j++] = "bbs";
    $k[$j++] = _1p;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _1t = $d();
    $k[$j++] = _1t;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_code93ext() {
    var $1 = Object.create(bwipp_code93ext.$ctx || (bwipp_code93ext.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.parse = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _3 = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parseonly", true],
      ["parsefnc", false]
    ]);
    $1.fncvals = _3;
    $k[$j++] = "barcode";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _6 = $k[--$j];
    var _7 = $k[--$j];
    $1[_7] = _6;
    $1.barlen = $1.barcode.length;
    delete $1.options["parse"];
    if (!bwipp_code93ext.__7349__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.extencs = $a(["^SFT%U", "^SFT$A", "^SFT$B", "^SFT$C", "^SFT$D", "^SFT$E", "^SFT$F", "^SFT$G", "^SFT$H", "^SFT$I", "^SFT$J", "^SFT$K", "^SFT$L", "^SFT$M", "^SFT$N", "^SFT$O", "^SFT$P", "^SFT$Q", "^SFT$R", "^SFT$S", "^SFT$T", "^SFT$U", "^SFT$V", "^SFT$W", "^SFT$X", "^SFT$Y", "^SFT$Z", "^SFT%A", "^SFT%B", "^SFT%C", "^SFT%D", "^SFT%E", " ", "^SFT/A", "^SFT/B", "^SFT/C", "$", "%", "^SFT/F", "^SFT/G", "^SFT/H", "^SFT/I", "^SFT/J", "+", "^SFT/L", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "^SFT/Z", "^SFT%F", "^SFT%G", "^SFT%H", "^SFT%I", "^SFT%J", "^SFT%V", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "^SFT%K", "^SFT%L", "^SFT%M", "^SFT%N", "^SFT%O", "^SFT%W", "^SFT+A", "^SFT+B", "^SFT+C", "^SFT+D", "^SFT+E", "^SFT+F", "^SFT+G", "^SFT+H", "^SFT+I", "^SFT+J", "^SFT+K", "^SFT+L", "^SFT+M", "^SFT+N", "^SFT+O", "^SFT+P", "^SFT+Q", "^SFT+R", "^SFT+S", "^SFT+T", "^SFT+U", "^SFT+V", "^SFT+W", "^SFT+X", "^SFT+Y", "^SFT+Z", "^SFT%P", "^SFT%Q", "^SFT%R", "^SFT%S", "^SFT%T"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code93ext.$ctx[id] = $ctx[id]);
        bwipp_code93ext.__7349__ = 1;
      })();
    }
    $1.newcode = $s($1.barlen * 6);
    $1.newtext = $s($1.barlen * 6);
    $1.j = 0;
    $1.k = 0;
    for (var _I = 0, _H = $1.barlen - 1; _I <= _H; _I += 1) {
      $1.i = _I;
      var _L = $get($1.barcode, $1.i);
      $k[$j++] = _L;
      if (_L > 127) {
        $j--;
        $k[$j++] = "bwipp.code93extbadCharacter#7358";
        $k[$j++] = "Code 93 Extended only support ASCII characters with values 0 to 127";
        bwipp_raiseerror();
      }
      $1.extchar = $get($1.extencs, $k[--$j]);
      $1.extlen = $1.extchar.length;
      $puti($1.newcode, $1.j, $1.extchar);
      var _X = $get($1.barcode, $1.i);
      $k[$j++] = $1.newtext;
      $k[$j++] = $1.k;
      $k[$j++] = _X;
      if (_X < 32 || _X == 127) {
        $j--;
        $k[$j++] = 32;
      }
      var _Y = $k[--$j];
      var _Z = $k[--$j];
      $put($k[--$j], _Z, _Y);
      if ($1.extlen != 1) {
        $put($1.newtext, $1.k + 1, 32);
      }
      $1.j = $1.j + $1.extlen;
      var _i = $1.extlen == 1 ? 1 : 2;
      $1.k = $1.k + _i;
    }
    $1.newcode = $geti($1.newcode, 0, $1.j);
    $1.newtext = $geti($1.newtext, 0, $1.k);
    $put($1.options, "dontdraw", true);
    $put($1.options, "parsefnc", true);
    $k[$j++] = "args";
    $k[$j++] = $1.newcode;
    $k[$j++] = $1.options;
    bwipp_code93();
    var _t = $k[--$j];
    $1[$k[--$j]] = _t;
    if ($1.includetext) {
      $1.txt = $get($1.args, "txt");
      for (var _10 = 0, _z = $1.newtext.length - 1; _10 <= _z; _10 += 1) {
        $1.i = _10;
        $1.txtentry = $get($1.txt, $1.i);
        $put($1.txtentry, 0, $geti($1.newtext, $1.i, 1));
        $put($1.txt, $1.i, $1.txtentry);
      }
      $put($1.args, "txt", $1.txt);
    }
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_interleaved2of5() {
    var $1 = Object.create(bwipp_interleaved2of5.$ctx || (bwipp_interleaved2of5.$ctx = {}));
    $1.dontdraw = false;
    $1.includecheck = false;
    $1.includetext = false;
    $1.includecheckintext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $forall($1.barcode, function() {
      var _3 = $k[--$j];
      if (_3 < 48 || _3 > 57) {
        $k[$j++] = "bwipp.interleaved2of5badCharacter#7444";
        $k[$j++] = "Interleaved 2 of 5 must contain only digits";
        bwipp_raiseerror();
      }
    });
    $1.barlen = $1.barcode.length;
    if ($1.barlen % 2 == 0 && $1.includecheck || $1.barlen % 2 != 0 && !$1.includecheck) {
      $1.pad = $s($1.barlen + 1);
      $put($1.pad, 0, 48);
      $puti($1.pad, 1, $1.barcode);
      $1.barcode = $1.pad;
      $1.barlen = $1.barlen + 1;
    }
    if ($1.includecheck) {
      $1.checksum = 0;
      for (var _J = 0, _I = $1.barlen - 1; _J <= _I; _J += 1) {
        $1.i = _J;
        if ($1.i % 2 == 0) {
          $1.checksum = $1.checksum + ($get($1.barcode, $1.i) - 48) * 3;
        } else {
          $1.checksum = $1.checksum + ($get($1.barcode, $1.i) - 48);
        }
      }
      $1.checksum = (10 - $1.checksum % 10) % 10;
      $1.pad = $s($1.barlen + 1);
      $puti($1.pad, 0, $1.barcode);
      $put($1.pad, $1.barlen, $1.checksum + 48);
      $1.barcode = $1.pad;
      $1.barlen = $1.barlen + 1;
    }
    if (!bwipp_interleaved2of5.__7490__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["11221", "21112", "12112", "22111", "11212", "21211", "12211", "11122", "21121", "12121", "1111", "2111"]);
        $ctx.barchars = "0123456789";
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_interleaved2of5.$ctx[id] = $ctx[id]);
        bwipp_interleaved2of5.__7490__ = 1;
      })();
    }
    $1.sbs = $s($1.barlen * 5 + 8);
    $1.txt = $a($1.barlen);
    $puti($1.sbs, 0, $get($1.encs, 10));
    for (var _o = 0, _n = $1.barlen - 1; _o <= _n; _o += 2) {
      $1.i = _o;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enca = $get($1.encs, $1.indx);
      $search($1.barchars, $geti($1.barcode, $1.i + 1, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.encb = $get($1.encs, $1.indx);
      $1.intl = $s($1.enca.length * 2);
      for (var _19 = 0, _18 = $1.enca.length - 1; _19 <= _18; _19 += 1) {
        $1.j = _19;
        $1.achar = $get($1.enca, $1.j);
        $1.bchar = $get($1.encb, $1.j);
        $put($1.intl, $1.j * 2, $1.achar);
        $put($1.intl, $1.j * 2 + 1, $1.bchar);
      }
      $puti($1.sbs, $1.i * 5 + 4, $1.intl);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 9 + 4, $1.textyoffset, $1.textfont, $1.textsize]));
      if ($1.includecheck && !$1.includecheckintext && $1.barlen - 2 == $1.i) {
        $put($1.txt, $1.i + 1, $a([" ", ($1.i + 1) * 9 + 4, $1.textyoffset, $1.textfont, $1.textsize]));
      } else {
        $put($1.txt, $1.i + 1, $a([$geti($1.barcode, $1.i + 1, 1), ($1.i + 1) * 9 + 4, $1.textyoffset, $1.textfont, $1.textsize]));
      }
    }
    $puti($1.sbs, $1.barlen * 5 + 4, $get($1.encs, 11));
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _1y = $1.sbs;
    for (var _1z = 0, _20 = _1y.length; _1z < _20; _1z++) {
      $k[$j++] = $get(_1y, _1z) - 48;
    }
    var _22 = $a();
    $k[$j++] = Infinity;
    for (var _24 = 0, _25 = ~~(($1.sbs.length + 1) / 2); _24 < _25; _24++) {
      $k[$j++] = $1.height;
    }
    var _27 = $a();
    $k[$j++] = Infinity;
    for (var _29 = 0, _2A = ~~(($1.sbs.length + 1) / 2); _29 < _2A; _29++) {
      $k[$j++] = 0;
    }
    var _2B = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _22;
    $k[$j++] = "bhs";
    $k[$j++] = _27;
    $k[$j++] = "bbs";
    $k[$j++] = _2B;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "barratio";
    $k[$j++] = 2;
    $k[$j++] = "spaceratio";
    $k[$j++] = 2;
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2F = $d();
    $k[$j++] = _2F;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_itf14() {
    var $1 = Object.create(bwipp_itf14.$ctx || (bwipp_itf14.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.includecheckintext = true;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = 3;
    $1.height = 0.5;
    $1.showborder = true;
    $1.borderwidth = 4;
    $1.borderleft = 15;
    $1.borderright = 15;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $1.text = $1.barcode;
    var _3 = $1.barcode;
    $k[$j++] = $s(_3.length);
    $k[$j++] = 0;
    $forall(_3, function() {
      var _5 = $k[--$j];
      $k[$j++] = _5;
      if (_5 != 32) {
        var _6 = $k[--$j];
        var _7 = $k[--$j];
        var _8 = $k[--$j];
        $put(_8, _7, _6);
        $k[$j++] = _8;
        $k[$j++] = $f(_7 + 1);
      } else {
        $j--;
      }
    });
    var _9 = $k[--$j];
    $1.barcode = $geti($k[--$j], 0, _9);
    $1.hasspace = $1.text.length != $1.barcode.length;
    if ($1.barcode.length != 13 && $1.barcode.length != 14) {
      $k[$j++] = "bwipp.itf14badLength#7610";
      $k[$j++] = "ITF-14 must be 13 or 14 digits";
      bwipp_raiseerror();
    }
    var _G = $1.barcode;
    for (var _H = 0, _I = _G.length; _H < _I; _H++) {
      var _J = $get(_G, _H);
      if (_J < 48 || _J > 57) {
        $k[$j++] = "bwipp.itf14badCharacter#7614";
        $k[$j++] = "ITF-14 must contain only digits";
        bwipp_raiseerror();
      }
    }
    $1.checksum = 0;
    for (var _K = 0; _K <= 12; _K += 1) {
      $1.i = _K;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i) - 48);
      if ($1.i % 2 == 0) {
        var _Q = $k[--$j];
        $k[$j++] = _Q * 3;
      }
      var _R = $k[--$j];
      var _S = $k[--$j];
      $1[$k[--$j]] = $f(_S + _R);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 14) {
      if ($get($1.barcode, 13) != $1.checksum + 48) {
        $k[$j++] = "bwipp.itf14badCheckDigit#7627";
        $k[$j++] = "Incorrect ITF-14 check digit provided";
        bwipp_raiseerror();
      }
    } else {
      var _Z = $s(14);
      $puti(_Z, 0, $1.barcode);
      $put(_Z, 13, $1.checksum + 48);
      $1.barcode = _Z;
      var _e = $1.hasspace ? 2 : 1;
      var _f = $s($1.text.length + _e);
      $puti(_f, _f.length - 2, " ");
      $put(_f, _f.length - 1, $1.checksum + 48);
      $puti(_f, 0, $1.text);
      $1.text = _f;
    }
    var _i = $1.options;
    $put(_i, "dontdraw", true);
    $put($1.options, "showborder", $1.showborder);
    $put($1.options, "borderwidth", $1.borderwidth);
    $put($1.options, "borderleft", $1.borderleft);
    $put($1.options, "borderright", $1.borderright);
    var _r = $1.options;
    $put(_r, "height", $1.height);
    $put($1.options, "textyoffset", $1.textyoffset);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_interleaved2of5();
    var _x = $k[--$j];
    $1[$k[--$j]] = _x;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_identcode() {
    var $1 = Object.create(bwipp_identcode.$ctx || (bwipp_identcode.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.barcode.length != 11 && $1.barcode.length != 12) {
      $k[$j++] = "bwipp.identcodeBadLength#7703";
      $k[$j++] = "Deutsche Post Identcode must be 11 or 12 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _5 = $k[--$j];
      if (_5 < 48 || _5 > 57) {
        $k[$j++] = "bwipp.identcodeBadCharacter#7707";
        $k[$j++] = "Deutsche Post Identcode must contain only digits";
        bwipp_raiseerror();
      }
    });
    $1.checksum = 0;
    for (var _6 = 0; _6 <= 10; _6 += 1) {
      $1.i = _6;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i) - 48);
      if ($1.i % 2 == 0) {
        var _C = $k[--$j];
        $k[$j++] = _C * 4;
      } else {
        var _D = $k[--$j];
        $k[$j++] = _D * 9;
      }
      var _E = $k[--$j];
      var _F = $k[--$j];
      $1[$k[--$j]] = $f(_F + _E);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 12) {
      if ($get($1.barcode, 11) != $1.checksum + 48) {
        $k[$j++] = "bwipp.identcodeBadCheckDigit#7720";
        $k[$j++] = "Incorrect Deutsche Post Identcode check digit provided";
        bwipp_raiseerror();
      }
    }
    var _M = $s(12);
    $puti(_M, 0, $1.barcode);
    $put(_M, 11, $1.checksum + 48);
    $1.barcode = _M;
    $1.text = $strcpy($s(16), "  .       .     ");
    $puti($1.text, 0, $geti($1.barcode, 0, 2));
    $puti($1.text, 3, $geti($1.barcode, 2, 3));
    $puti($1.text, 7, $geti($1.barcode, 5, 3));
    $puti($1.text, 11, $geti($1.barcode, 8, 3));
    $puti($1.text, 15, $geti($1.barcode, 11, 1));
    $put($1.options, "dontdraw", true);
    $put($1.options, "includecheck", false);
    var _i = $1.barcode;
    $k[$j++] = "args";
    $k[$j++] = _i;
    $k[$j++] = $1.options;
    bwipp_interleaved2of5();
    var _k = $k[--$j];
    $1[$k[--$j]] = _k;
    var _r = $1.textsize;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, _r])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_leitcode() {
    var $1 = Object.create(bwipp_leitcode.$ctx || (bwipp_leitcode.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.barcode.length != 13 && $1.barcode.length != 14) {
      $k[$j++] = "bwipp.leitcodeBadLength#7793";
      $k[$j++] = "Deutsche Post Leitcode must be 13 or 14 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _5 = $k[--$j];
      if (_5 < 48 || _5 > 57) {
        $k[$j++] = "bwipp.leitcodeBadCharacter#7797";
        $k[$j++] = "Deutsche Post Leitcode must contain only digits";
        bwipp_raiseerror();
      }
    });
    $1.checksum = 0;
    for (var _6 = 0; _6 <= 12; _6 += 1) {
      $1.i = _6;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i) - 48);
      if ($1.i % 2 == 0) {
        var _C = $k[--$j];
        $k[$j++] = _C * 4;
      } else {
        var _D = $k[--$j];
        $k[$j++] = _D * 9;
      }
      var _E = $k[--$j];
      var _F = $k[--$j];
      $1[$k[--$j]] = $f(_F + _E);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 14) {
      if ($get($1.barcode, 13) != $1.checksum + 48) {
        $k[$j++] = "bwipp.leitcodeBadCheckDigit#7810";
        $k[$j++] = "Incorrect Deutsche Post Leitcode check digit provided";
        bwipp_raiseerror();
      }
    }
    var _M = $s(14);
    $puti(_M, 0, $1.barcode);
    $put(_M, 13, $1.checksum + 48);
    $1.barcode = _M;
    $1.text = $strcpy($s(18), "     .   .   .    ");
    $puti($1.text, 0, $geti($1.barcode, 0, 5));
    $puti($1.text, 6, $geti($1.barcode, 5, 3));
    $puti($1.text, 10, $geti($1.barcode, 8, 3));
    $puti($1.text, 14, $geti($1.barcode, 11, 2));
    $puti($1.text, 17, $geti($1.barcode, 13, 1));
    $put($1.options, "dontdraw", true);
    $put($1.options, "includecheck", false);
    var _i = $1.barcode;
    $k[$j++] = "args";
    $k[$j++] = _i;
    $k[$j++] = $1.options;
    bwipp_interleaved2of5();
    var _k = $k[--$j];
    $1[$k[--$j]] = _k;
    var _r = $1.textsize;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, _r])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_databaromni() {
    var $1 = Object.create(bwipp_databaromni.$ctx || (bwipp_databaromni.$ctx = {}));
    $1.dontdraw = false;
    $1.height = 33 / 72;
    $1.linkage = false;
    $1.format = "omni";
    $1.barxmult = 33;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($ne($geti($1.barcode, 0, 4), "(01)")) {
      $k[$j++] = "bwipp.databaromniBadAI#7882";
      $k[$j++] = "GS1 DataBar Omnidirectional must begin with (01) application identifier";
      bwipp_raiseerror();
    }
    if ($1.barcode.length != 17 && $1.barcode.length != 18) {
      $k[$j++] = "bwipp.databaromniBadLength#7885";
      $k[$j++] = "GS1 DataBar Omnidirectional must be 13 or 14 digits";
      bwipp_raiseerror();
    }
    var _8 = $geti($1.barcode, 4, $1.barcode.length - 4);
    for (var _9 = 0, _A = _8.length; _9 < _A; _9++) {
      var _B = $get(_8, _9);
      if (_B < 48 || _B > 57) {
        $k[$j++] = "bwipp.databaromniBadCharacter#7889";
        $k[$j++] = "GS1 DataBar Omnidirectional must contain only digits";
        bwipp_raiseerror();
      }
    }
    if ($1.barxmult < 33) {
      $k[$j++] = "bwipp.databarStackedOmniBarXmult#7894";
      $k[$j++] = "GS1 DataBar Stacked Omnidirectional must have a barxmult of at least 33";
      bwipp_raiseerror();
    }
    if ($ne($1.format, "omni") && $ne($1.format, "stacked") && $ne($1.format, "stackedomni") && $ne($1.format, "truncated")) {
      $k[$j++] = "bwipp.databaromniBadFormat#7898";
      $k[$j++] = "Valid formats are omni, stacked, stackedomni and truncated";
      bwipp_raiseerror();
    }
    if ($eq($1.format, "truncated")) {
      $1.height = 13 / 72;
    }
    $1.checksum = 0;
    for (var _I = 0; _I <= 12; _I += 1) {
      $1.i = _I;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i + 4) - 48);
      if ($1.i % 2 == 0) {
        var _O = $k[--$j];
        $k[$j++] = _O * 3;
      }
      var _P = $k[--$j];
      var _Q = $k[--$j];
      $1[$k[--$j]] = $f(_Q + _P);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 18) {
      if ($get($1.barcode, 17) != $1.checksum + 48) {
        $k[$j++] = "bwipp.databaromniBadCheckDigit#7914";
        $k[$j++] = "Incorrect GS1 DataBar Omnidirectional check digit provided";
        bwipp_raiseerror();
      }
    }
    var _X = $s(18);
    $puti(_X, 0, $1.barcode);
    $put(_X, 17, $1.checksum + 48);
    $1.barcode = _X;
    $1.txt = $a($1.barcode.length);
    for (var _e = 0, _d = $1.barcode.length - 1; _e <= _d; _e += 1) {
      $1.i = _e;
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), 0, 0, "", 0]));
    }
    $1.ncr = function() {
      var _l = $k[--$j];
      var _m = $k[--$j];
      var _n = $f(_m - _l);
      if (_l < $f(_m - _l)) {
        var _ = _n;
        _n = _l;
        _l = _;
      }
      $k[$j++] = _n;
      $k[$j++] = 1;
      $k[$j++] = 1;
      for (var _p = _m, _o = $f(_l + 1); _p >= _o; _p -= 1) {
        var _q = $k[--$j];
        var _r = $k[--$j];
        var _s = $k[--$j];
        $k[$j++] = _s;
        $k[$j++] = _r;
        $k[$j++] = _q * _p;
        if ($le(_r, _s)) {
          var _t = $k[--$j];
          var _u = $k[--$j];
          $k[$j++] = $f(_u + 1);
          $k[$j++] = ~~(_t / _u);
        }
      }
      for (; ; ) {
        var _v = $k[--$j];
        var _w = $k[--$j];
        var _x = $k[--$j];
        $k[$j++] = _x;
        $k[$j++] = _w;
        $k[$j++] = _v;
        if ($gt(_w, _x)) {
          break;
        }
        var _y = $k[--$j];
        var _z = $k[--$j];
        $k[$j++] = $f(_z + 1);
        $k[$j++] = ~~(_y / _z);
      }
      var _10 = $k[--$j];
      var _11 = $k[--$j];
      $k[$j++] = _10;
      $k[$j++] = _11;
      $j--;
      var _12 = $k[--$j];
      var _13 = $k[--$j];
      $k[$j++] = _12;
      $k[$j++] = _13;
      $j--;
    };
    $1.getRSSwidths = function() {
      $1.oe = $k[--$j];
      $1.el = $k[--$j];
      $1.mw = $k[--$j];
      $1.nm = $k[--$j];
      $1.val = $k[--$j];
      $1.out = $a($1.el);
      $1.mask = 0;
      for (var _1D = 0, _1C = $f($1.el - 2); _1D <= _1C; _1D += 1) {
        $1.bar = _1D;
        $1.ew = 1;
        var _1F = $1.bar;
        $1.mask = $1.mask | (_1F < 0 ? 1 >>> -_1F : 1 << _1F);
        for (; ; ) {
          $k[$j++] = "sval";
          $k[$j++] = $f($f($1.nm - $1.ew) - 1);
          $k[$j++] = $f($f($1.el - $1.bar) - 2);
          $1.ncr();
          var _1K = $k[--$j];
          $1[$k[--$j]] = _1K;
          if ($1.oe && $1.mask == 0 && $f($f($f($1.nm - $1.ew) - $1.el * 2) + $1.bar * 2) >= -2) {
            $k[$j++] = "sval";
            $k[$j++] = $1.sval;
            $k[$j++] = $f($f($f($1.nm - $1.ew) - $1.el) + $1.bar);
            $k[$j++] = $f($f($1.el - $1.bar) - 2);
            $1.ncr();
            var _1Z = $k[--$j];
            var _1a = $k[--$j];
            $1[$k[--$j]] = $f(_1a - _1Z);
          }
          if ($f($1.el - $1.bar) > 2) {
            $1.lval = 0;
            for (var _1k = $f($f($f($f($1.nm - $1.ew) - $1.el) + $1.bar) + 2), _1j = $f($1.mw + 1); _1k >= _1j; _1k -= 1) {
              $k[$j++] = $f($f($f($1.nm - _1k) - $1.ew) - 1);
              $k[$j++] = $f($f($1.el - $1.bar) - 3);
              $1.ncr();
              $1.lval = $f($k[--$j] + $1.lval);
            }
            $1.sval = $f($1.sval - $1.lval * $f($f($1.el - $1.bar) - 1));
          } else {
            if ($f($1.nm - $1.ew) > $1.mw) {
              $1.sval = $f($1.sval - 1);
            }
          }
          $1.val = $f($1.val - $1.sval);
          if ($1.val < 0) {
            break;
          }
          $1.ew = $1.ew + 1;
          var _24 = $1.bar;
          $1.mask = $1.mask & ~(_24 < 0 ? 1 >>> -_24 : 1 << _24);
        }
        $1.val = $f($1.val + $1.sval);
        $1.nm = $f($1.nm - $1.ew);
        $put($1.out, $1.bar, $1.ew);
      }
      $put($1.out, $f($1.el - 1), $1.nm);
      $k[$j++] = $1.out;
    };
    $k[$j++] = Infinity;
    var _2H = $1.linkage ? 1 : 0;
    var _2J = $geti($1.barcode, 4, 13);
    $k[$j++] = _2H;
    for (var _2K = 0, _2L = _2J.length; _2K < _2L; _2K++) {
      $k[$j++] = $f($get(_2J, _2K) - 48);
    }
    $1.binval = $a();
    for (var _2O = 0; _2O <= 12; _2O += 1) {
      $1.i = _2O;
      var _2P = $1.binval;
      var _2Q = $1.i;
      $put(_2P, _2Q + 1, $f($get(_2P, _2Q + 1) + $get($1.binval, $1.i) % 4537077 * 10));
      $put($1.binval, $1.i, ~~($get($1.binval, $1.i) / 4537077));
    }
    $1.right = $get($1.binval, 13) % 4537077;
    var _2c = $1.binval;
    $put(_2c, 13, ~~($get(_2c, 13) / 4537077));
    $1.left = 0;
    $1.i = true;
    for (var _2e = 0; _2e <= 13; _2e += 1) {
      $1.j = _2e;
      var _2h = $get($1.binval, $1.j);
      $k[$j++] = _2h;
      if (_2h == 0 && $1.i) {
        $j--;
      } else {
        $1.i = false;
        $1.left = $f($1.left + $k[--$j] * ~~Math.pow(10, 13 - $1.j));
      }
    }
    $1.d1 = ~~($1.left / 1597);
    $1.d2 = $1.left % 1597;
    $1.d3 = ~~($1.right / 1597);
    $1.d4 = $1.right % 1597;
    if (!bwipp_databaromni.__8030__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.tab164 = $a([160, 0, 12, 4, 8, 1, 161, 1, 960, 161, 10, 6, 6, 3, 80, 10, 2014, 961, 8, 8, 4, 5, 31, 34, 2714, 2015, 6, 10, 3, 6, 10, 70, 2840, 2715, 4, 12, 1, 8, 1, 126]);
        $ctx.tab154 = $a([335, 0, 5, 10, 2, 7, 4, 84, 1035, 336, 7, 8, 4, 5, 20, 35, 1515, 1036, 9, 6, 6, 3, 48, 10, 1596, 1516, 11, 4, 8, 1, 81, 1]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databaromni.$ctx[id] = $ctx[id]);
        bwipp_databaromni.__8030__ = 1;
      })();
    }
    $1.i = 0;
    for (; ; ) {
      if ($1.d1 <= $get($1.tab164, $1.i)) {
        var _2z = $geti($1.tab164, $1.i + 1, 7);
        for (var _30 = 0, _31 = _2z.length; _30 < _31; _30++) {
          $k[$j++] = $get(_2z, _30);
        }
        $1.d1te = $k[--$j];
        $1.d1to = $k[--$j];
        $1.d1mwe = $k[--$j];
        $1.d1mwo = $k[--$j];
        $1.d1ele = $k[--$j];
        $1.d1elo = $k[--$j];
        $1.d1gs = $k[--$j];
        break;
      }
      $1.i = $1.i + 8;
    }
    $1.i = 0;
    for (; ; ) {
      if ($1.d2 <= $get($1.tab154, $1.i)) {
        var _3H = $geti($1.tab154, $1.i + 1, 7);
        for (var _3I = 0, _3J = _3H.length; _3I < _3J; _3I++) {
          $k[$j++] = $get(_3H, _3I);
        }
        $1.d2te = $k[--$j];
        $1.d2to = $k[--$j];
        $1.d2mwe = $k[--$j];
        $1.d2mwo = $k[--$j];
        $1.d2ele = $k[--$j];
        $1.d2elo = $k[--$j];
        $1.d2gs = $k[--$j];
        break;
      }
      $1.i = $1.i + 8;
    }
    $1.i = 0;
    for (; ; ) {
      if ($1.d3 <= $get($1.tab164, $1.i)) {
        var _3Z = $geti($1.tab164, $1.i + 1, 7);
        for (var _3a = 0, _3b = _3Z.length; _3a < _3b; _3a++) {
          $k[$j++] = $get(_3Z, _3a);
        }
        $1.d3te = $k[--$j];
        $1.d3to = $k[--$j];
        $1.d3mwe = $k[--$j];
        $1.d3mwo = $k[--$j];
        $1.d3ele = $k[--$j];
        $1.d3elo = $k[--$j];
        $1.d3gs = $k[--$j];
        break;
      }
      $1.i = $1.i + 8;
    }
    $1.i = 0;
    for (; ; ) {
      if ($1.d4 <= $get($1.tab154, $1.i)) {
        var _3r = $geti($1.tab154, $1.i + 1, 7);
        for (var _3s = 0, _3t = _3r.length; _3s < _3t; _3s++) {
          $k[$j++] = $get(_3r, _3s);
        }
        $1.d4te = $k[--$j];
        $1.d4to = $k[--$j];
        $1.d4mwe = $k[--$j];
        $1.d4mwo = $k[--$j];
        $1.d4ele = $k[--$j];
        $1.d4elo = $k[--$j];
        $1.d4gs = $k[--$j];
        break;
      }
      $1.i = $1.i + 8;
    }
    $k[$j++] = "d1wo";
    $k[$j++] = ~~($f($1.d1 - $1.d1gs) / $1.d1te);
    $k[$j++] = $1.d1elo;
    $k[$j++] = $1.d1mwo;
    $k[$j++] = 4;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _48 = $k[--$j];
    $1[$k[--$j]] = _48;
    $k[$j++] = "d1we";
    $k[$j++] = $f($1.d1 - $1.d1gs) % $1.d1te;
    $k[$j++] = $1.d1ele;
    $k[$j++] = $1.d1mwe;
    $k[$j++] = 4;
    $k[$j++] = true;
    $1.getRSSwidths();
    var _4F = $k[--$j];
    $1[$k[--$j]] = _4F;
    $k[$j++] = "d2wo";
    $k[$j++] = $f($1.d2 - $1.d2gs) % $1.d2to;
    $k[$j++] = $1.d2elo;
    $k[$j++] = $1.d2mwo;
    $k[$j++] = 4;
    $k[$j++] = true;
    $1.getRSSwidths();
    var _4M = $k[--$j];
    $1[$k[--$j]] = _4M;
    $k[$j++] = "d2we";
    $k[$j++] = ~~($f($1.d2 - $1.d2gs) / $1.d2to);
    $k[$j++] = $1.d2ele;
    $k[$j++] = $1.d2mwe;
    $k[$j++] = 4;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _4T = $k[--$j];
    $1[$k[--$j]] = _4T;
    $k[$j++] = "d3wo";
    $k[$j++] = ~~($f($1.d3 - $1.d3gs) / $1.d3te);
    $k[$j++] = $1.d3elo;
    $k[$j++] = $1.d3mwo;
    $k[$j++] = 4;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _4a = $k[--$j];
    $1[$k[--$j]] = _4a;
    $k[$j++] = "d3we";
    $k[$j++] = $f($1.d3 - $1.d3gs) % $1.d3te;
    $k[$j++] = $1.d3ele;
    $k[$j++] = $1.d3mwe;
    $k[$j++] = 4;
    $k[$j++] = true;
    $1.getRSSwidths();
    var _4h = $k[--$j];
    $1[$k[--$j]] = _4h;
    $k[$j++] = "d4wo";
    $k[$j++] = $f($1.d4 - $1.d4gs) % $1.d4to;
    $k[$j++] = $1.d4elo;
    $k[$j++] = $1.d4mwo;
    $k[$j++] = 4;
    $k[$j++] = true;
    $1.getRSSwidths();
    var _4o = $k[--$j];
    $1[$k[--$j]] = _4o;
    $k[$j++] = "d4we";
    $k[$j++] = ~~($f($1.d4 - $1.d4gs) / $1.d4to);
    $k[$j++] = $1.d4ele;
    $k[$j++] = $1.d4mwe;
    $k[$j++] = 4;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _4v = $k[--$j];
    $1[$k[--$j]] = _4v;
    $1.d1w = $a(8);
    for (var _4y = 0; _4y <= 3; _4y += 1) {
      $1.i = _4y;
      $put($1.d1w, $1.i * 2, $get($1.d1wo, $1.i));
      $put($1.d1w, $1.i * 2 + 1, $get($1.d1we, $1.i));
    }
    $1.d2w = $a(8);
    for (var _5A = 0; _5A <= 3; _5A += 1) {
      $1.i = _5A;
      $put($1.d2w, 7 - $1.i * 2, $get($1.d2wo, $1.i));
      $put($1.d2w, 6 - $1.i * 2, $get($1.d2we, $1.i));
    }
    $1.d3w = $a(8);
    for (var _5M = 0; _5M <= 3; _5M += 1) {
      $1.i = _5M;
      $put($1.d3w, 7 - $1.i * 2, $get($1.d3wo, $1.i));
      $put($1.d3w, 6 - $1.i * 2, $get($1.d3we, $1.i));
    }
    $1.d4w = $a(8);
    for (var _5Y = 0; _5Y <= 3; _5Y += 1) {
      $1.i = _5Y;
      $put($1.d4w, $1.i * 2, $get($1.d4wo, $1.i));
      $put($1.d4w, $1.i * 2 + 1, $get($1.d4we, $1.i));
    }
    $k[$j++] = Infinity;
    var _5j = $1.d1w;
    for (var _5k = 0, _5l = _5j.length; _5k < _5l; _5k++) {
      $k[$j++] = $get(_5j, _5k);
    }
    var _5n = $1.d2w;
    for (var _5o = 0, _5p = _5n.length; _5o < _5p; _5o++) {
      $k[$j++] = $get(_5n, _5o);
    }
    var _5r = $1.d3w;
    for (var _5s = 0, _5t = _5r.length; _5s < _5t; _5s++) {
      $k[$j++] = $get(_5r, _5s);
    }
    var _5v = $1.d4w;
    for (var _5w = 0, _5x = _5v.length; _5w < _5x; _5w++) {
      $k[$j++] = $get(_5v, _5w);
    }
    $1.widths = $a();
    if (!bwipp_databaromni.__8137__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.checkweights = $a([1, 3, 9, 27, 2, 6, 18, 54, 58, 72, 24, 8, 29, 36, 12, 4, 74, 51, 17, 32, 37, 65, 48, 16, 64, 34, 23, 69, 49, 68, 46, 59]);
        $ctx.checkwidths = $a([3, 8, 2, 1, 1, 3, 5, 5, 1, 1, 3, 3, 7, 1, 1, 3, 1, 9, 1, 1, 2, 7, 4, 1, 1, 2, 5, 6, 1, 1, 2, 3, 8, 1, 1, 1, 5, 7, 1, 1, 1, 3, 9, 1, 1]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databaromni.$ctx[id] = $ctx[id]);
        bwipp_databaromni.__8137__ = 1;
      })();
    }
    $1.checksum = 0;
    for (var _63 = 0; _63 <= 31; _63 += 1) {
      $1.i = _63;
      $1.checksum = $f($1.checksum + $get($1.widths, $1.i) * $get($1.checkweights, $1.i));
    }
    $1.checksum = $1.checksum % 79;
    if ($1.checksum >= 8) {
      $1.checksum = $f($1.checksum + 1);
    }
    if ($1.checksum >= 72) {
      $1.checksum = $f($1.checksum + 1);
    }
    $1.checklt = $geti($1.checkwidths, ~~($1.checksum / 9) * 5, 5);
    $1.checkrtrev = $geti($1.checkwidths, $1.checksum % 9 * 5, 5);
    $1.checkrt = $a(5);
    for (var _6N = 0; _6N <= 4; _6N += 1) {
      $1.i = _6N;
      $put($1.checkrt, $1.i, $get($1.checkrtrev, 4 - $1.i));
    }
    if ($eq($1.format, "omni") || $eq($1.format, "truncated")) {
      $k[$j++] = Infinity;
      var _6V = $1.d1w;
      $k[$j++] = 1;
      for (var _6W = 0, _6X = _6V.length; _6W < _6X; _6W++) {
        $k[$j++] = $get(_6V, _6W);
      }
      var _6Z = $1.checklt;
      for (var _6a = 0, _6b = _6Z.length; _6a < _6b; _6a++) {
        $k[$j++] = $get(_6Z, _6a);
      }
      var _6d = $1.d2w;
      for (var _6e = 0, _6f = _6d.length; _6e < _6f; _6e++) {
        $k[$j++] = $get(_6d, _6e);
      }
      var _6h = $1.d4w;
      for (var _6i = 0, _6j = _6h.length; _6i < _6j; _6i++) {
        $k[$j++] = $get(_6h, _6i);
      }
      var _6l = $1.checkrt;
      for (var _6m = 0, _6n = _6l.length; _6m < _6n; _6m++) {
        $k[$j++] = $get(_6l, _6m);
      }
      var _6p = $1.d3w;
      for (var _6q = 0, _6r = _6p.length; _6q < _6r; _6q++) {
        $k[$j++] = $get(_6p, _6q);
      }
      $k[$j++] = 1;
      $k[$j++] = 1;
      $1.sbs = $a();
      $k[$j++] = Infinity;
      var _6u = $1.sbs;
      $k[$j++] = Infinity;
      for (var _6w = 0, _6x = ~~(($1.sbs.length + 1) / 2); _6w < _6x; _6w++) {
        $k[$j++] = $1.height;
      }
      var _6z = $a();
      $k[$j++] = Infinity;
      for (var _71 = 0, _72 = ~~(($1.sbs.length + 1) / 2); _71 < _72; _71++) {
        $k[$j++] = 0;
      }
      var _73 = $a();
      $k[$j++] = "ren";
      $k[$j++] = bwipp_renlinear;
      $k[$j++] = "sbs";
      $k[$j++] = _6u;
      $k[$j++] = "bhs";
      $k[$j++] = _6z;
      $k[$j++] = "bbs";
      $k[$j++] = _73;
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
      $k[$j++] = "textxalign";
      $k[$j++] = "center";
      $k[$j++] = "opt";
      $k[$j++] = $1.options;
      var _76 = $d();
      $k[$j++] = _76;
      if (!$1.dontdraw) {
        bwipp_renlinear();
      }
    } else {
      $k[$j++] = Infinity;
      var _78 = $1.d1w;
      $k[$j++] = 1;
      $k[$j++] = 1;
      for (var _79 = 0, _7A = _78.length; _79 < _7A; _79++) {
        $k[$j++] = $get(_78, _79);
      }
      var _7C = $1.checklt;
      for (var _7D = 0, _7E = _7C.length; _7D < _7E; _7D++) {
        $k[$j++] = $get(_7C, _7D);
      }
      var _7G = $1.d2w;
      for (var _7H = 0, _7I = _7G.length; _7H < _7I; _7H++) {
        $k[$j++] = $get(_7G, _7H);
      }
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $1.top = $a();
      $k[$j++] = Infinity;
      var _7L = $1.d4w;
      $k[$j++] = 1;
      $k[$j++] = 1;
      for (var _7M = 0, _7N = _7L.length; _7M < _7N; _7M++) {
        $k[$j++] = $get(_7L, _7M);
      }
      var _7P = $1.checkrt;
      for (var _7Q = 0, _7R = _7P.length; _7Q < _7R; _7Q++) {
        $k[$j++] = $get(_7P, _7Q);
      }
      var _7T = $1.d3w;
      for (var _7U = 0, _7V = _7T.length; _7U < _7V; _7U++) {
        $k[$j++] = $get(_7T, _7U);
      }
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $1.bot = $a();
      for (var _7Y = 0; _7Y <= 24; _7Y += 2) {
        $1.i = _7Y;
        for (var _7c = 0, _7d = $get($1.top, $1.i); _7c < _7d; _7c++) {
          $k[$j++] = 0;
        }
        for (var _7h = 0, _7i = $get($1.top, $1.i + 1); _7h < _7i; _7h++) {
          $k[$j++] = 1;
        }
      }
      $astore($a(50));
      $1.top = $k[--$j];
      for (var _7l = 0; _7l <= 24; _7l += 2) {
        $1.i = _7l;
        for (var _7p = 0, _7q = $get($1.bot, $1.i); _7p < _7q; _7p++) {
          $k[$j++] = 1;
        }
        for (var _7u = 0, _7v = $get($1.bot, $1.i + 1); _7u < _7v; _7u++) {
          $k[$j++] = 0;
        }
      }
      $astore($a(50));
      $1.bot = $k[--$j];
      if ($eq($1.format, "stacked")) {
        $1.sep = $a(50);
        $put($1.sep, 0, 0);
        for (var _81 = 1; _81 <= 49; _81 += 1) {
          $1.i = _81;
          if ($eq($get($1.top, $1.i), $get($1.bot, $1.i))) {
            $put($1.sep, $1.i, $f(1 - $get($1.top, $1.i)));
          } else {
            $put($1.sep, $1.i, $f(1 - $get($1.sep, $1.i - 1)));
          }
        }
        $puti($1.sep, 0, $a([0, 0, 0, 0]));
        $puti($1.sep, 46, $a([0, 0, 0, 0]));
        $k[$j++] = Infinity;
        for (var _8M = 0, _8N = 5; _8M < _8N; _8M++) {
          $aload($1.top);
        }
        $aload($1.sep);
        for (var _8Q = 0, _8R = 7; _8Q < _8R; _8Q++) {
          $aload($1.bot);
        }
        $1.pixs = $a();
        $1.pixy = ~~($1.pixs.length / 50);
      }
      if ($eq($1.format, "stackedomni")) {
        $k[$j++] = Infinity;
        $forall($1.top, function() {
          var _8X = $k[--$j];
          $k[$j++] = $f(1 - _8X);
        });
        $1.sep1 = $a();
        $puti($1.sep1, 0, $a([0, 0, 0, 0]));
        $puti($1.sep1, 46, $a([0, 0, 0, 0]));
        for (var _8d = 18; _8d <= 30; _8d += 1) {
          $1.i = _8d;
          if ($get($1.top, $1.i) == 0) {
            if ($get($1.top, $1.i - 1) == 1) {
              $k[$j++] = 1;
            } else {
              var _8n = $get($1.sep1, $1.i - 1) == 0 ? 1 : 0;
              $k[$j++] = _8n;
            }
          } else {
            $k[$j++] = 0;
          }
          $put($1.sep1, $1.i, $k[--$j]);
        }
        $k[$j++] = Infinity;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        for (var _8r = 0, _8s = 21; _8r < _8s; _8r++) {
          $k[$j++] = 0;
          $k[$j++] = 1;
        }
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $1.sep2 = $a();
        $k[$j++] = Infinity;
        $forall($1.bot, function() {
          var _8v = $k[--$j];
          $k[$j++] = $f(1 - _8v);
        });
        $1.sep3 = $a();
        $puti($1.sep3, 0, $a([0, 0, 0, 0]));
        $puti($1.sep3, 46, $a([0, 0, 0, 0]));
        for (var _91 = 19; _91 <= 31; _91 += 1) {
          $1.i = _91;
          if ($get($1.bot, $1.i) == 0) {
            if ($get($1.bot, $1.i - 1) == 1) {
              $k[$j++] = 1;
            } else {
              var _9B = $get($1.sep3, $1.i - 1) == 0 ? 1 : 0;
              $k[$j++] = _9B;
            }
          } else {
            $k[$j++] = 0;
          }
          $put($1.sep3, $1.i, $k[--$j]);
        }
        $1.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
        $k[$j++] = true;
        for (var _9G = 0; _9G <= 12; _9G += 1) {
          var _9L = $k[--$j];
          $k[$j++] = _9L && $eq($get($1.bot, _9G + 19), $get($1.f3, _9G));
        }
        if ($k[--$j]) {
          $puti($1.sep3, 19, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
        }
        $k[$j++] = Infinity;
        for (var _9Q = 0, _9R = $1.barxmult; _9Q < _9R; _9Q++) {
          $aload($1.top);
        }
        $aload($1.sep1);
        $aload($1.sep2);
        $aload($1.sep3);
        for (var _9X = 0, _9Y = $1.barxmult; _9X < _9Y; _9X++) {
          $aload($1.bot);
        }
        $1.pixs = $a();
        $1.pixy = ~~($1.pixs.length / 50);
      }
      var _9g = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", 50],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", 50 / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _9g;
      if (!$1.dontdraw) {
        bwipp_renmatrix();
      }
    }
  }
  function bwipp_databarstacked() {
    var $1 = Object.create(bwipp_databarstacked.$ctx || (bwipp_databarstacked.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($ne($geti($1.barcode, 0, 4), "(01)")) {
      $k[$j++] = "bwipp.databarstackedBadAI#8320";
      $k[$j++] = "GS1 DataBar Stacked must begin with (01) application identifier";
      bwipp_raiseerror();
    }
    if ($1.barcode.length != 17 && $1.barcode.length != 18) {
      $k[$j++] = "bwipp.databarstackedBadLength#8323";
      $k[$j++] = "GS1 DataBar Stacked must be 13 or 14 digits";
      bwipp_raiseerror();
    }
    var _8 = $geti($1.barcode, 4, $1.barcode.length - 4);
    for (var _9 = 0, _A = _8.length; _9 < _A; _9++) {
      var _B = $get(_8, _9);
      if (_B < 48 || _B > 57) {
        $k[$j++] = "bwipp.databarstackedBadCharacter#8327";
        $k[$j++] = "GS1 DataBar Stacked must contain only digits";
        bwipp_raiseerror();
      }
    }
    $1.checksum = 0;
    for (var _C = 0; _C <= 12; _C += 1) {
      $1.i = _C;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i + 4) - 48);
      if ($1.i % 2 == 0) {
        var _I = $k[--$j];
        $k[$j++] = _I * 3;
      }
      var _J = $k[--$j];
      var _K = $k[--$j];
      $1[$k[--$j]] = $f(_K + _J);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 18) {
      if ($get($1.barcode, 17) != $1.checksum + 48) {
        $k[$j++] = "bwipp.databarstackedBadCheckDigit#8340";
        $k[$j++] = "Incorrect GS1 DataBar Stacked check digit provided";
        bwipp_raiseerror();
      }
    }
    var _R = $s(18);
    $puti(_R, 0, $1.barcode);
    $put(_R, 17, $1.checksum + 48);
    $1.barcode = _R;
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "stacked");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_databaromni();
    var _Y = $k[--$j];
    $1[$k[--$j]] = _Y;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_databarstackedomni() {
    var $1 = Object.create(bwipp_databarstackedomni.$ctx || (bwipp_databarstackedomni.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($ne($geti($1.barcode, 0, 4), "(01)")) {
      $k[$j++] = "bwipp.databarstackedomniBadAI#8398";
      $k[$j++] = "GS1 DataBar Stacked Omnidirectional must begin with (01) application identifier";
      bwipp_raiseerror();
    }
    if ($1.barcode.length != 17 && $1.barcode.length != 18) {
      $k[$j++] = "bwipp.databarstackedomniBadLength#8401";
      $k[$j++] = "GS1 DataBar Stacked Omnidirectional must be 13 or 14 digits";
      bwipp_raiseerror();
    }
    var _8 = $geti($1.barcode, 4, $1.barcode.length - 4);
    for (var _9 = 0, _A = _8.length; _9 < _A; _9++) {
      var _B = $get(_8, _9);
      if (_B < 48 || _B > 57) {
        $k[$j++] = "bwipp.databarstackedomniBadCharacter#8405";
        $k[$j++] = "GS1 DataBar Stacked Omnidirectional must contain only digits";
        bwipp_raiseerror();
      }
    }
    $1.checksum = 0;
    for (var _C = 0; _C <= 12; _C += 1) {
      $1.i = _C;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i + 4) - 48);
      if ($1.i % 2 == 0) {
        var _I = $k[--$j];
        $k[$j++] = _I * 3;
      }
      var _J = $k[--$j];
      var _K = $k[--$j];
      $1[$k[--$j]] = $f(_K + _J);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 18) {
      if ($get($1.barcode, 17) != $1.checksum + 48) {
        $k[$j++] = "bwipp.databarstackedomniBadCheckDigit#8418";
        $k[$j++] = "Incorrect GS1 DataBar Stacked Omnidirectional check digit provided";
        bwipp_raiseerror();
      }
    }
    var _R = $s(18);
    $puti(_R, 0, $1.barcode);
    $put(_R, 17, $1.checksum + 48);
    $1.barcode = _R;
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "stackedomni");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_databaromni();
    var _Y = $k[--$j];
    $1[$k[--$j]] = _Y;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_databartruncated() {
    var $1 = Object.create(bwipp_databartruncated.$ctx || (bwipp_databartruncated.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($ne($geti($1.barcode, 0, 4), "(01)")) {
      $k[$j++] = "bwipp.databartruncatedBadAI#8476";
      $k[$j++] = "GS1 DataBar Truncated must begin with (01) application identifier";
      bwipp_raiseerror();
    }
    if ($1.barcode.length != 17 && $1.barcode.length != 18) {
      $k[$j++] = "bwipp.databartruncatedBadLength#8479";
      $k[$j++] = "GS1 DataBar Truncated must be 13 or 14 digits";
      bwipp_raiseerror();
    }
    var _8 = $geti($1.barcode, 4, $1.barcode.length - 4);
    for (var _9 = 0, _A = _8.length; _9 < _A; _9++) {
      var _B = $get(_8, _9);
      if (_B < 48 || _B > 57) {
        $k[$j++] = "bwipp.databartruncatedBadCharacter#8483";
        $k[$j++] = "GS1 DataBar Truncated must contain only digits";
        bwipp_raiseerror();
      }
    }
    $1.checksum = 0;
    for (var _C = 0; _C <= 12; _C += 1) {
      $1.i = _C;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i + 4) - 48);
      if ($1.i % 2 == 0) {
        var _I = $k[--$j];
        $k[$j++] = _I * 3;
      }
      var _J = $k[--$j];
      var _K = $k[--$j];
      $1[$k[--$j]] = $f(_K + _J);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 18) {
      if ($get($1.barcode, 17) != $1.checksum + 48) {
        $k[$j++] = "bwipp.databartruncatedBadCheckDigit#8496";
        $k[$j++] = "Incorrect GS1 DataBar Truncated check digit provided";
        bwipp_raiseerror();
      }
    }
    var _R = $s(18);
    $puti(_R, 0, $1.barcode);
    $put(_R, 17, $1.checksum + 48);
    $1.barcode = _R;
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "truncated");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_databaromni();
    var _Y = $k[--$j];
    $1[$k[--$j]] = _Y;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_databarlimited() {
    var $1 = Object.create(bwipp_databarlimited.$ctx || (bwipp_databarlimited.$ctx = {}));
    $1.dontdraw = false;
    $1.height = 10 / 72;
    $1.linkage = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($ne($geti($1.barcode, 0, 4), "(01)")) {
      $k[$j++] = "bwipp.databarlimitedBadAI#8559";
      $k[$j++] = "GS1 DataBar Limited must begin with (01) application identifier";
      bwipp_raiseerror();
    }
    if ($1.barcode.length != 17 && $1.barcode.length != 18) {
      $k[$j++] = "bwipp.databarlimitedBadLength#8562";
      $k[$j++] = "GS1 DataBar Limited must be 13 or 14 digits";
      bwipp_raiseerror();
    }
    var _7 = $get($1.barcode, 4);
    if (_7 < 48 || _7 > 49) {
      $k[$j++] = "bwipp.databarlimitedBadStartDigit#8565";
      $k[$j++] = "GS1 DataBar Limited must begin with 0 or 1";
      bwipp_raiseerror();
    }
    var _A = $geti($1.barcode, 5, $1.barcode.length - 5);
    for (var _B = 0, _C = _A.length; _B < _C; _B++) {
      var _D = $get(_A, _B);
      if (_D < 48 || _D > 57) {
        $k[$j++] = "bwipp.databarlimitedBadCharacter#8569";
        $k[$j++] = "GS1 DataBar Limited must contain only digits";
        bwipp_raiseerror();
      }
    }
    $1.checksum = 0;
    for (var _E = 0; _E <= 12; _E += 1) {
      $1.i = _E;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i + 4) - 48);
      if ($1.i % 2 == 0) {
        var _K = $k[--$j];
        $k[$j++] = _K * 3;
      }
      var _L = $k[--$j];
      var _M = $k[--$j];
      $1[$k[--$j]] = $f(_M + _L);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.barcode.length == 18) {
      if ($get($1.barcode, 17) != $1.checksum + 48) {
        $k[$j++] = "bwipp.databarlimitedBadCheckDigit#8582";
        $k[$j++] = "Incorrect GS1 DataBar Limited check digit provided";
        bwipp_raiseerror();
      }
    }
    var _T = $s(18);
    $puti(_T, 0, $1.barcode);
    $put(_T, 17, $1.checksum + 48);
    $1.barcode = _T;
    if (!bwipp_databarlimited.__8593__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.linkval = $a([2, 0, 1, 5, 1, 3, 3, 5, 3, 1, 0, 9, 6]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databarlimited.$ctx[id] = $ctx[id]);
        bwipp_databarlimited.__8593__ = 1;
      })();
    }
    $k[$j++] = Infinity;
    var _Z = $geti($1.barcode, 4, 13);
    for (var _a = 0, _b = _Z.length; _a < _b; _a++) {
      $k[$j++] = $f($get(_Z, _a) - 48);
    }
    $1.binval = $a();
    if ($1.linkage) {
      for (var _h = 0, _g = $1.binval.length - 1; _h <= _g; _h += 1) {
        $1.i = _h;
        $put($1.binval, $1.i, $f($get($1.binval, $1.i) + $get($1.linkval, $1.i)));
      }
    }
    $1.txt = $a($1.barcode.length);
    for (var _u = 0, _t = $1.barcode.length - 1; _u <= _t; _u += 1) {
      $1.i = _u;
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), 0, 0, "", 0]));
    }
    $1.ncr = function() {
      var _11 = $k[--$j];
      var _12 = $k[--$j];
      var _13 = $f(_12 - _11);
      if (_11 < $f(_12 - _11)) {
        var _ = _13;
        _13 = _11;
        _11 = _;
      }
      $k[$j++] = _13;
      $k[$j++] = 1;
      $k[$j++] = 1;
      for (var _15 = _12, _14 = $f(_11 + 1); _15 >= _14; _15 -= 1) {
        var _16 = $k[--$j];
        var _17 = $k[--$j];
        var _18 = $k[--$j];
        $k[$j++] = _18;
        $k[$j++] = _17;
        $k[$j++] = _16 * _15;
        if ($le(_17, _18)) {
          var _19 = $k[--$j];
          var _1A = $k[--$j];
          $k[$j++] = $f(_1A + 1);
          $k[$j++] = ~~(_19 / _1A);
        }
      }
      for (; ; ) {
        var _1B = $k[--$j];
        var _1C = $k[--$j];
        var _1D = $k[--$j];
        $k[$j++] = _1D;
        $k[$j++] = _1C;
        $k[$j++] = _1B;
        if ($gt(_1C, _1D)) {
          break;
        }
        var _1E = $k[--$j];
        var _1F = $k[--$j];
        $k[$j++] = $f(_1F + 1);
        $k[$j++] = ~~(_1E / _1F);
      }
      var _1G = $k[--$j];
      var _1H = $k[--$j];
      $k[$j++] = _1G;
      $k[$j++] = _1H;
      $j--;
      var _1I = $k[--$j];
      var _1J = $k[--$j];
      $k[$j++] = _1I;
      $k[$j++] = _1J;
      $j--;
    };
    $1.getRSSwidths = function() {
      $1.oe = $k[--$j];
      $1.el = $k[--$j];
      $1.mw = $k[--$j];
      $1.nm = $k[--$j];
      $1.val = $k[--$j];
      $1.out = $a($1.el);
      $1.mask = 0;
      for (var _1T = 0, _1S = $f($1.el - 2); _1T <= _1S; _1T += 1) {
        $1.bar = _1T;
        $1.ew = 1;
        var _1V = $1.bar;
        $1.mask = $1.mask | (_1V < 0 ? 1 >>> -_1V : 1 << _1V);
        for (; ; ) {
          $k[$j++] = "sval";
          $k[$j++] = $f($f($1.nm - $1.ew) - 1);
          $k[$j++] = $f($f($1.el - $1.bar) - 2);
          $1.ncr();
          var _1a = $k[--$j];
          $1[$k[--$j]] = _1a;
          if ($1.oe && $1.mask == 0 && $f($f($f($1.nm - $1.ew) - $1.el * 2) + $1.bar * 2) >= -2) {
            $k[$j++] = "sval";
            $k[$j++] = $1.sval;
            $k[$j++] = $f($f($f($1.nm - $1.ew) - $1.el) + $1.bar);
            $k[$j++] = $f($f($1.el - $1.bar) - 2);
            $1.ncr();
            var _1p = $k[--$j];
            var _1q = $k[--$j];
            $1[$k[--$j]] = $f(_1q - _1p);
          }
          if ($f($1.el - $1.bar) > 2) {
            $1.lval = 0;
            for (var _20 = $f($f($f($f($1.nm - $1.ew) - $1.el) + $1.bar) + 2), _1z = $f($1.mw + 1); _20 >= _1z; _20 -= 1) {
              $k[$j++] = $f($f($f($1.nm - _20) - $1.ew) - 1);
              $k[$j++] = $f($f($1.el - $1.bar) - 3);
              $1.ncr();
              $1.lval = $f($k[--$j] + $1.lval);
            }
            $1.sval = $f($1.sval - $1.lval * $f($f($1.el - $1.bar) - 1));
          } else {
            if ($f($1.nm - $1.ew) > $1.mw) {
              $1.sval = $f($1.sval - 1);
            }
          }
          $1.val = $f($1.val - $1.sval);
          if ($1.val < 0) {
            break;
          }
          $1.ew = $1.ew + 1;
          var _2K = $1.bar;
          $1.mask = $1.mask & ~(_2K < 0 ? 1 >>> -_2K : 1 << _2K);
        }
        $1.val = $f($1.val + $1.sval);
        $1.nm = $f($1.nm - $1.ew);
        $put($1.out, $1.bar, $1.ew);
      }
      $put($1.out, $f($1.el - 1), $1.nm);
      $k[$j++] = $1.out;
    };
    for (var _2W = 0; _2W <= 11; _2W += 1) {
      $1.i = _2W;
      var _2X = $1.binval;
      var _2Y = $1.i;
      $put(_2X, _2Y + 1, $f($get(_2X, _2Y + 1) + $get($1.binval, $1.i) % 2013571 * 10));
      $put($1.binval, $1.i, ~~($get($1.binval, $1.i) / 2013571));
    }
    $1.d2 = $get($1.binval, 12) % 2013571;
    var _2k = $1.binval;
    $put(_2k, 12, ~~($get(_2k, 12) / 2013571));
    $1.d1 = 0;
    $1.i = true;
    for (var _2m = 0; _2m <= 12; _2m += 1) {
      $1.j = _2m;
      var _2p = $get($1.binval, $1.j);
      $k[$j++] = _2p;
      if (_2p == 0 && $1.i) {
        $j--;
      } else {
        $1.i = false;
        $1.d1 = $f($1.d1 + $k[--$j] * ~~Math.pow(10, 12 - $1.j));
      }
    }
    if (!bwipp_databarlimited.__8697__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.tab267 = $a([183063, 0, 17, 9, 6, 3, 6538, 28, 820063, 183064, 13, 13, 5, 4, 875, 728, 1000775, 820064, 9, 17, 3, 6, 28, 6454, 1491020, 1000776, 15, 11, 5, 4, 2415, 203, 1979844, 1491021, 11, 15, 4, 5, 203, 2408, 1996938, 1979845, 19, 7, 8, 1, 17094, 1, 2013570, 1996939, 7, 19, 1, 8, 1, 16632]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databarlimited.$ctx[id] = $ctx[id]);
        bwipp_databarlimited.__8697__ = 1;
      })();
    }
    $1.i = 0;
    for (; ; ) {
      if ($1.d1 <= $get($1.tab267, $1.i)) {
        var _32 = $geti($1.tab267, $1.i + 1, 7);
        for (var _33 = 0, _34 = _32.length; _33 < _34; _33++) {
          $k[$j++] = $get(_32, _33);
        }
        $1.d1te = $k[--$j];
        $1.d1to = $k[--$j];
        $1.d1mwe = $k[--$j];
        $1.d1mwo = $k[--$j];
        $1.d1ele = $k[--$j];
        $1.d1elo = $k[--$j];
        $1.d1gs = $k[--$j];
        break;
      }
      $1.i = $1.i + 8;
    }
    $1.i = 0;
    for (; ; ) {
      if ($1.d2 <= $get($1.tab267, $1.i)) {
        var _3K = $geti($1.tab267, $1.i + 1, 7);
        for (var _3L = 0, _3M = _3K.length; _3L < _3M; _3L++) {
          $k[$j++] = $get(_3K, _3L);
        }
        $1.d2te = $k[--$j];
        $1.d2to = $k[--$j];
        $1.d2mwe = $k[--$j];
        $1.d2mwo = $k[--$j];
        $1.d2ele = $k[--$j];
        $1.d2elo = $k[--$j];
        $1.d2gs = $k[--$j];
        break;
      }
      $1.i = $1.i + 8;
    }
    $k[$j++] = "d1wo";
    $k[$j++] = ~~($f($1.d1 - $1.d1gs) / $1.d1te);
    $k[$j++] = $1.d1elo;
    $k[$j++] = $1.d1mwo;
    $k[$j++] = 7;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _3b = $k[--$j];
    $1[$k[--$j]] = _3b;
    $k[$j++] = "d1we";
    $k[$j++] = $f($1.d1 - $1.d1gs) % $1.d1te;
    $k[$j++] = $1.d1ele;
    $k[$j++] = $1.d1mwe;
    $k[$j++] = 7;
    $k[$j++] = true;
    $1.getRSSwidths();
    var _3i = $k[--$j];
    $1[$k[--$j]] = _3i;
    $k[$j++] = "d2wo";
    $k[$j++] = ~~($f($1.d2 - $1.d2gs) / $1.d2te);
    $k[$j++] = $1.d2elo;
    $k[$j++] = $1.d2mwo;
    $k[$j++] = 7;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _3p = $k[--$j];
    $1[$k[--$j]] = _3p;
    $k[$j++] = "d2we";
    $k[$j++] = $f($1.d2 - $1.d2gs) % $1.d2te;
    $k[$j++] = $1.d2ele;
    $k[$j++] = $1.d2mwe;
    $k[$j++] = 7;
    $k[$j++] = true;
    $1.getRSSwidths();
    var _3w = $k[--$j];
    $1[$k[--$j]] = _3w;
    $1.d1w = $a(14);
    for (var _3z = 0; _3z <= 6; _3z += 1) {
      $1.i = _3z;
      $put($1.d1w, $1.i * 2, $get($1.d1wo, $1.i));
      $put($1.d1w, $1.i * 2 + 1, $get($1.d1we, $1.i));
    }
    $1.d2w = $a(14);
    for (var _4B = 0; _4B <= 6; _4B += 1) {
      $1.i = _4B;
      $put($1.d2w, $1.i * 2, $get($1.d2wo, $1.i));
      $put($1.d2w, $1.i * 2 + 1, $get($1.d2we, $1.i));
    }
    $k[$j++] = Infinity;
    var _4M = $1.d1w;
    for (var _4N = 0, _4O = _4M.length; _4N < _4O; _4N++) {
      $k[$j++] = $get(_4M, _4N);
    }
    var _4Q = $1.d2w;
    for (var _4R = 0, _4S = _4Q.length; _4R < _4S; _4R++) {
      $k[$j++] = $get(_4Q, _4R);
    }
    $1.widths = $a();
    if (!bwipp_databarlimited.__8768__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.checkweights = $a([1, 3, 9, 27, 81, 65, 17, 51, 64, 14, 42, 37, 22, 66, 20, 60, 2, 6, 18, 54, 73, 41, 34, 13, 39, 28, 84, 74]);
        $k[$j++] = Infinity;
        for (var _4W = 0; _4W <= 43; _4W += 1) {
          $k[$j++] = _4W;
        }
        $k[$j++] = 45;
        $k[$j++] = 52;
        $k[$j++] = 57;
        for (var _4X = 63; _4X <= 66; _4X += 1) {
          $k[$j++] = _4X;
        }
        for (var _4Y = 73; _4Y <= 79; _4Y += 1) {
          $k[$j++] = _4Y;
        }
        $k[$j++] = 82;
        for (var _4Z = 126; _4Z <= 130; _4Z += 1) {
          $k[$j++] = _4Z;
        }
        $k[$j++] = 132;
        for (var _4a = 141; _4a <= 146; _4a += 1) {
          $k[$j++] = _4a;
        }
        for (var _4b = 210; _4b <= 217; _4b += 1) {
          $k[$j++] = _4b;
        }
        $k[$j++] = 220;
        for (var _4c = 316; _4c <= 320; _4c += 1) {
          $k[$j++] = _4c;
        }
        $k[$j++] = 322;
        $k[$j++] = 323;
        $k[$j++] = 326;
        $k[$j++] = 337;
        $ctx.checkseq = $a();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databarlimited.$ctx[id] = $ctx[id]);
        bwipp_databarlimited.__8768__ = 1;
      })();
    }
    $1.checksum = 0;
    for (var _4f = 0; _4f <= 27; _4f += 1) {
      $1.i = _4f;
      $1.checksum = $f($1.checksum + $get($1.widths, $1.i) * $get($1.checkweights, $1.i));
    }
    $1.checksum = $1.checksum % 89;
    $1.seq = $get($1.checkseq, $1.checksum);
    $k[$j++] = "swidths";
    $k[$j++] = ~~($1.seq / 21);
    $k[$j++] = 8;
    $k[$j++] = 3;
    $k[$j++] = 6;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _4s = $k[--$j];
    $1[$k[--$j]] = _4s;
    $k[$j++] = "bwidths";
    $k[$j++] = $1.seq % 21;
    $k[$j++] = 8;
    $k[$j++] = 3;
    $k[$j++] = 6;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _4v = $k[--$j];
    $1[$k[--$j]] = _4v;
    $1.checkwidths = $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]);
    for (var _4y = 0; _4y <= 5; _4y += 1) {
      $1.i = _4y;
      $put($1.checkwidths, $1.i * 2, $get($1.swidths, $1.i));
      $put($1.checkwidths, $1.i * 2 + 1, $get($1.bwidths, $1.i));
    }
    $k[$j++] = Infinity;
    var _59 = $1.d1w;
    $k[$j++] = 1;
    for (var _5A = 0, _5B = _59.length; _5A < _5B; _5A++) {
      $k[$j++] = $get(_59, _5A);
    }
    var _5D = $1.checkwidths;
    for (var _5E = 0, _5F = _5D.length; _5E < _5F; _5E++) {
      $k[$j++] = $get(_5D, _5E);
    }
    var _5H = $1.d2w;
    for (var _5I = 0, _5J = _5H.length; _5I < _5J; _5I++) {
      $k[$j++] = $get(_5H, _5I);
    }
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 5;
    $1.sbs = $a();
    $k[$j++] = Infinity;
    var _5M = $1.sbs;
    $k[$j++] = Infinity;
    for (var _5O = 0, _5P = ~~(($1.sbs.length + 1) / 2); _5O < _5P; _5O++) {
      $k[$j++] = $1.height;
    }
    var _5R = $a();
    $k[$j++] = Infinity;
    for (var _5T = 0, _5U = ~~(($1.sbs.length + 1) / 2); _5T < _5U; _5T++) {
      $k[$j++] = 0;
    }
    var _5V = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _5M;
    $k[$j++] = "bhs";
    $k[$j++] = _5R;
    $k[$j++] = "bbs";
    $k[$j++] = _5V;
    $k[$j++] = "txt";
    $k[$j++] = $1.txt;
    $k[$j++] = "textxalign";
    $k[$j++] = "center";
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _5Y = $d();
    $k[$j++] = _5Y;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_databarexpanded() {
    var $1 = Object.create(bwipp_databarexpanded.$ctx || (bwipp_databarexpanded.$ctx = {}));
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $1.dontdraw = false;
    $1.height = 34 / 72;
    $1.format = "expanded";
    $1.segments = -1;
    $1.linkage = false;
    $1.barxmult = 34;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.barxmult < 34) {
      $k[$j++] = "bwipp.databarStackedOmniBarXmult#8857";
      $k[$j++] = "GS1 DataBar Expanded Stacked must have a barxmult of at least 34";
      bwipp_raiseerror();
    }
    if ($ne($1.format, "expanded") && $ne($1.format, "expandedstacked")) {
      $k[$j++] = "bwipp.databarexpandedBadFormat#8861";
      $k[$j++] = "Valid formats are expanded and expandedstacked";
      bwipp_raiseerror();
    }
    if ($1.segments == -1) {
      var _7 = $eq($1.format, "expandedstacked") ? 4 : 22;
      $1.segments = _7;
    } else {
      if ($1.segments < 2 || $1.segments > 22 || $1.segments % 2 != 0) {
        $k[$j++] = "bwipp.gs1databarexpandedBadSegments#8868";
        $k[$j++] = "The number of segments must be even from 2 to 22";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = $1.barcode;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $1.fncs = $k[--$j];
    $1.vals = $k[--$j];
    $1.ais = $k[--$j];
    for (; ; ) {
      if ($1.ais.length == 2) {
        if ($eq($get($1.ais, 0), "01") && $eq($get($1.ais, 1), "3103")) {
          if ($eq($geti($get($1.vals, 0), 0, 1), "9") && $cvi($get($1.vals, 1)) <= 32767) {
            $k[$j++] = "0100";
            $k[$j++] = false;
            break;
          }
        }
      }
      if ($1.ais.length == 2) {
        if ($eq($get($1.ais, 0), "01") && $eq($get($1.ais, 1), "3202")) {
          if ($eq($geti($get($1.vals, 0), 0, 1), "9") && $cvi($get($1.vals, 1)) <= 9999) {
            $k[$j++] = "0101";
            $k[$j++] = false;
            break;
          }
        }
      }
      if ($1.ais.length == 2) {
        if ($eq($get($1.ais, 0), "01") && $eq($get($1.ais, 1), "3203")) {
          if ($eq($geti($get($1.vals, 0), 0, 1), "9") && $cvi($get($1.vals, 1)) <= 22767) {
            $k[$j++] = "0101";
            $k[$j++] = false;
            break;
          }
        }
      }
      var _k = $1.ais.length;
      if (_k == 2 || _k == 3) {
        $k[$j++] = "ai310x";
        $k[$j++] = false;
        for (var _l = 3100; _l <= 3109; _l += 1) {
          var _q = $k[--$j];
          $k[$j++] = _q || $eq($cvrs($s(4), _l, 10), $get($1.ais, 1));
        }
        var _r = $k[--$j];
        $1[$k[--$j]] = _r;
        $k[$j++] = "ai320x";
        $k[$j++] = false;
        for (var _t = 3200; _t <= 3209; _t += 1) {
          var _y = $k[--$j];
          $k[$j++] = _y || $eq($cvrs($s(4), _t, 10), $get($1.ais, 1));
        }
        var _z = $k[--$j];
        $1[$k[--$j]] = _z;
        if ($1.ais.length == 3) {
          var _12 = $a(["11", "13", "15", "17"]);
          $k[$j++] = "aibad";
          $k[$j++] = true;
          for (var _13 = 0, _14 = _12.length; _13 < _14; _13++) {
            var _18 = $k[--$j];
            $k[$j++] = _18 && $ne($get(_12, _13), $get($1.ais, 2));
          }
          var _19 = $k[--$j];
          $1[$k[--$j]] = _19;
        } else {
          $1.aibad = false;
        }
        if ($eq($get($1.ais, 0), "01") && ($1.ai310x || $1.ai320x) && !$1.aibad) {
          if ($1.ais.length == 3) {
            var _1P = $cvi($geti($get($1.vals, 2), 2, 2));
            var _1T = $cvi($geti($get($1.vals, 2), 4, 2));
            if ($eq($geti($get($1.vals, 0), 0, 1), "9") && $cvi($get($1.vals, 1)) <= 99999 && (_1P >= 1 && _1P <= 12) && (_1T >= 0 && _1T <= 31)) {
              if ($1.ai310x && $eq($get($1.ais, 2), "11")) {
                $k[$j++] = "0111000";
                $k[$j++] = false;
                break;
              }
              if ($1.ai320x && $eq($get($1.ais, 2), "11")) {
                $k[$j++] = "0111001";
                $k[$j++] = false;
                break;
              }
              if ($1.ai310x && $eq($get($1.ais, 2), "13")) {
                $k[$j++] = "0111010";
                $k[$j++] = false;
                break;
              }
              if ($1.ai320x && $eq($get($1.ais, 2), "13")) {
                $k[$j++] = "0111011";
                $k[$j++] = false;
                break;
              }
              if ($1.ai310x && $eq($get($1.ais, 2), "15")) {
                $k[$j++] = "0111100";
                $k[$j++] = false;
                break;
              }
              if ($1.ai320x && $eq($get($1.ais, 2), "15")) {
                $k[$j++] = "0111101";
                $k[$j++] = false;
                break;
              }
              if ($1.ai310x && $eq($get($1.ais, 2), "17")) {
                $k[$j++] = "0111110";
                $k[$j++] = false;
                break;
              }
              if ($1.ai320x && $eq($get($1.ais, 2), "17")) {
                $k[$j++] = "0111111";
                $k[$j++] = false;
                break;
              }
            }
          } else {
            if ($eq($geti($get($1.vals, 0), 0, 1), "9") && $cvi($get($1.vals, 1)) <= 99999) {
              if ($1.ai310x) {
                $k[$j++] = "0111000";
                $k[$j++] = false;
                break;
              }
              if ($1.ai320x) {
                $k[$j++] = "0111001";
                $k[$j++] = false;
                break;
              }
            }
          }
        }
      }
      if ($1.ais.length >= 2) {
        $k[$j++] = "ai392x";
        $k[$j++] = false;
        for (var _20 = 3920; _20 <= 3923; _20 += 1) {
          var _25 = $k[--$j];
          $k[$j++] = _25 || $eq($cvrs($s(4), _20, 10), $get($1.ais, 1));
        }
        var _26 = $k[--$j];
        $1[$k[--$j]] = _26;
        if ($eq($get($1.ais, 0), "01") && $1.ai392x) {
          if ($eq($geti($get($1.vals, 0), 0, 1), "9")) {
            $k[$j++] = "01100";
            $k[$j++] = true;
            break;
          }
        }
      }
      if ($1.ais.length >= 2) {
        $k[$j++] = "ai393x";
        $k[$j++] = false;
        for (var _2F = 3930; _2F <= 3933; _2F += 1) {
          var _2K = $k[--$j];
          $k[$j++] = _2K || $eq($cvrs($s(4), _2F, 10), $get($1.ais, 1));
        }
        var _2L = $k[--$j];
        $1[$k[--$j]] = _2L;
        if ($eq($get($1.ais, 0), "01") && $1.ai393x) {
          if ($eq($geti($get($1.vals, 0), 0, 1), "9")) {
            $k[$j++] = "01101";
            $k[$j++] = true;
            break;
          }
        }
      }
      if ($eq($get($1.ais, 0), "01")) {
        $k[$j++] = "1";
        $k[$j++] = true;
        break;
      }
      $k[$j++] = "00";
      $k[$j++] = true;
      break;
    }
    $1.gpfallow = $k[--$j];
    $1.method = $k[--$j];
    $1.conv12to40 = function() {
      var _2Y = $strcpy($s(40), "0000000000000000000000000000000000000000");
      var _2Z = $k[--$j];
      var _2d = $cvrs($s(10), $cvi($geti(_2Z, 0, 3)), 2);
      $puti($geti(_2Y, 0, 10), 10 - _2d.length, _2d);
      var _2h = $cvrs($s(10), $cvi($geti(_2Z, 3, 3)), 2);
      $puti($geti(_2Y, 10, 10), 10 - _2h.length, _2h);
      var _2l = $cvrs($s(10), $cvi($geti(_2Z, 6, 3)), 2);
      $puti($geti(_2Y, 20, 10), 10 - _2l.length, _2l);
      var _2p = $cvrs($s(10), $cvi($geti(_2Z, 9, 3)), 2);
      $puti($geti(_2Y, 30, 10), 10 - _2p.length, _2p);
      $k[$j++] = _2Y;
      $k[$j++] = _2Z;
      $j--;
    };
    $1.conv13to44 = function() {
      var _2r = $strcpy($s(44), "00000000000000000000000000000000000000000000");
      var _2s = $k[--$j];
      var _2w = $cvrs($s(4), $cvi($geti(_2s, 0, 1)), 2);
      $puti($geti(_2r, 0, 4), 4 - _2w.length, _2w);
      $k[$j++] = _2r;
      $k[$j++] = _2r;
      $k[$j++] = $geti(_2s, 1, 12);
      $1.conv12to40();
      var _2y = $k[--$j];
      $puti($k[--$j], 4, _2y);
    };
    $1.tobin = function() {
      var _31 = $s($k[--$j]);
      $k[$j++] = _31;
      for (var _33 = 0, _32 = _31.length - 1; _33 <= _32; _33 += 1) {
        var _34 = $k[--$j];
        $put(_34, _33, 48);
        $k[$j++] = _34;
      }
      var _35 = $k[--$j];
      var _38 = $cvrs($s(_35.length), $k[--$j], 2);
      $puti(_35, _35.length - _38.length, _38);
      $k[$j++] = _35;
    };
    $1.fnc1 = -1;
    $1.lnumeric = -2;
    $1.lalphanumeric = -3;
    $1.liso646 = -4;
    if ($eq($1.method, "00")) {
      $1.cdf = $a([]);
      $1.gpf = $a([]);
    }
    if ($eq($1.method, "1")) {
      $k[$j++] = "cdf";
      $k[$j++] = $geti($get($1.vals, 0), 0, 13);
      $1.conv13to44();
      var _3G = $k[--$j];
      $1[$k[--$j]] = _3G;
      $k[$j++] = Infinity;
      var _3I = $1.cdf;
      for (var _3J = 0, _3K = _3I.length; _3J < _3K; _3J++) {
        $k[$j++] = $f($get(_3I, _3J) - 48);
      }
      $1.cdf = $a();
      $1.gpf = $a([]);
      $1.ais = $geti($1.ais, 1, $1.ais.length - 1);
      $1.vals = $geti($1.vals, 1, $1.vals.length - 1);
      $1.fncs = $geti($1.fncs, 1, $1.fncs.length - 1);
    }
    if ($eq($1.method, "0100")) {
      $1.cdf = $s(55);
      $k[$j++] = $1.cdf;
      $k[$j++] = 0;
      $k[$j++] = $geti($get($1.vals, 0), 1, 12);
      $1.conv12to40();
      var _3d = $k[--$j];
      var _3e = $k[--$j];
      $puti($k[--$j], _3e, _3d);
      $k[$j++] = $1.cdf;
      $k[$j++] = 40;
      $k[$j++] = $cvi($get($1.vals, 1));
      $k[$j++] = 15;
      $1.tobin();
      var _3j = $k[--$j];
      var _3k = $k[--$j];
      $puti($k[--$j], _3k, _3j);
      $k[$j++] = Infinity;
      var _3m = $1.cdf;
      for (var _3n = 0, _3o = _3m.length; _3n < _3o; _3n++) {
        $k[$j++] = $get(_3m, _3n) - 48;
      }
      $1.cdf = $a();
      $1.gpf = $a([]);
      $1.ais = $a([]);
      $1.vals = $a([]);
      $1.fncs = $a([]);
    }
    if ($eq($1.method, "0101")) {
      $1.cdf = $s(55);
      $k[$j++] = $1.cdf;
      $k[$j++] = 0;
      $k[$j++] = $geti($get($1.vals, 0), 1, 12);
      $1.conv12to40();
      var _41 = $k[--$j];
      var _42 = $k[--$j];
      $puti($k[--$j], _42, _41);
      if ($eq($get($1.ais, 1), "3202")) {
        $k[$j++] = $cvi($get($1.vals, 1));
        $k[$j++] = 15;
        $1.tobin();
      } else {
        $k[$j++] = $cvi($get($1.vals, 1)) + 1e4;
        $k[$j++] = 15;
        $1.tobin();
      }
      $puti($1.cdf, 40, $k[--$j]);
      $k[$j++] = Infinity;
      var _4C = $1.cdf;
      for (var _4D = 0, _4E = _4C.length; _4D < _4E; _4D++) {
        $k[$j++] = $get(_4C, _4D) - 48;
      }
      $1.cdf = $a();
      $1.gpf = $a([]);
      $1.ais = $a([]);
      $1.vals = $a([]);
      $1.fncs = $a([]);
    }
    if ($1.method.length == 7) {
      $1.cdf = $s(76);
      $k[$j++] = $1.cdf;
      $k[$j++] = 0;
      $k[$j++] = $geti($get($1.vals, 0), 1, 12);
      $1.conv12to40();
      var _4R = $k[--$j];
      var _4S = $k[--$j];
      $puti($k[--$j], _4S, _4R);
      var _4U = $s(6);
      $puti(_4U, 0, $geti($get($1.ais, 1), 3, 1));
      $puti(_4U, 1, $geti($get($1.vals, 1), 1, 5));
      $k[$j++] = $cvi(_4U);
      $k[$j++] = 20;
      $1.tobin();
      $puti($1.cdf, 40, $k[--$j]);
      if ($1.ais.length == 3) {
        var _4f = $get($1.vals, 2);
        $k[$j++] = $cvi($geti(_4f, 0, 2)) * 384 + (($cvi($geti(_4f, 2, 2)) - 1) * 32 + $cvi($geti(_4f, 4, 2)));
      } else {
        $k[$j++] = 38400;
      }
      $k[$j++] = 16;
      $1.tobin();
      $puti($1.cdf, 60, $k[--$j]);
      $k[$j++] = Infinity;
      var _4l = $1.cdf;
      for (var _4m = 0, _4n = _4l.length; _4m < _4n; _4m++) {
        $k[$j++] = $get(_4l, _4m) - 48;
      }
      $1.cdf = $a();
      $1.gpf = $a([]);
      $1.ais = $a([]);
      $1.vals = $a([]);
      $1.fncs = $a([]);
    }
    if ($eq($1.method, "01100")) {
      $1.cdf = $s(42);
      $k[$j++] = $1.cdf;
      $k[$j++] = 0;
      $k[$j++] = $geti($get($1.vals, 0), 1, 12);
      $1.conv12to40();
      var _50 = $k[--$j];
      var _51 = $k[--$j];
      $puti($k[--$j], _51, _50);
      $k[$j++] = $1.cdf;
      $k[$j++] = 40;
      $k[$j++] = $cvi($geti($get($1.ais, 1), 3, 1));
      $k[$j++] = 2;
      $1.tobin();
      var _57 = $k[--$j];
      var _58 = $k[--$j];
      $puti($k[--$j], _58, _57);
      $k[$j++] = Infinity;
      var _5A = $1.cdf;
      for (var _5B = 0, _5C = _5A.length; _5B < _5C; _5B++) {
        $k[$j++] = $get(_5A, _5B) - 48;
      }
      $1.cdf = $a();
      $k[$j++] = Infinity;
      $forall($get($1.vals, 1));
      if ($1.ais.length > 2) {
        $k[$j++] = $1.fnc1;
      }
      $1.gpf = $a();
      $1.ais = $geti($1.ais, 2, $1.ais.length - 2);
      $1.vals = $geti($1.vals, 2, $1.vals.length - 2);
      $1.fncs = $geti($1.fncs, 2, $1.fncs.length - 2);
    }
    if ($eq($1.method, "01101")) {
      $1.cdf = $s(52);
      $k[$j++] = $1.cdf;
      $k[$j++] = 0;
      $k[$j++] = $geti($get($1.vals, 0), 1, 12);
      $1.conv12to40();
      var _5Z = $k[--$j];
      var _5a = $k[--$j];
      $puti($k[--$j], _5a, _5Z);
      $k[$j++] = $1.cdf;
      $k[$j++] = 40;
      $k[$j++] = $cvi($geti($get($1.ais, 1), 3, 1));
      $k[$j++] = 2;
      $1.tobin();
      var _5g = $k[--$j];
      var _5h = $k[--$j];
      $puti($k[--$j], _5h, _5g);
      $k[$j++] = $1.cdf;
      $k[$j++] = 42;
      $k[$j++] = $cvi($geti($get($1.vals, 1), 0, 3));
      $k[$j++] = 10;
      $1.tobin();
      var _5n = $k[--$j];
      var _5o = $k[--$j];
      $puti($k[--$j], _5o, _5n);
      $k[$j++] = Infinity;
      var _5q = $1.cdf;
      for (var _5r = 0, _5s = _5q.length; _5r < _5s; _5r++) {
        $k[$j++] = $get(_5q, _5r) - 48;
      }
      $1.cdf = $a();
      $k[$j++] = Infinity;
      var _5w = $get($1.vals, 1);
      var _5x = $geti(_5w, 3, _5w.length - 3);
      for (var _5y = 0, _5z = _5x.length; _5y < _5z; _5y++) {
        $k[$j++] = $get(_5x, _5y);
      }
      if ($1.ais.length > 2) {
        $k[$j++] = $1.fnc1;
      }
      $1.gpf = $a();
      $1.ais = $geti($1.ais, 2, $1.ais.length - 2);
      $1.vals = $geti($1.vals, 2, $1.vals.length - 2);
      $1.fncs = $geti($1.fncs, 2, $1.fncs.length - 2);
    }
    if ($1.gpfallow) {
      $1.vlf = $a(2);
    } else {
      $1.vlf = $a([]);
    }
    if (!bwipp_databarexpanded.__9120__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        for (var _6G = 0; _6G <= 119; _6G += 1) {
          var _6I = $strcpy($s(2), "00");
          var _6K = $cvrs($s(2), _6G, 11);
          $puti(_6I, 2 - _6K.length, _6K);
          $k[$j++] = _6G;
          $k[$j++] = _6I;
          if ($get(_6I, 0) == 65) {
            var _6M = $k[--$j];
            $put(_6M, 0, 94);
            $k[$j++] = _6M;
          }
          var _6N = $k[--$j];
          $k[$j++] = _6N;
          if ($get(_6N, 1) == 65) {
            var _6P = $k[--$j];
            $put(_6P, 1, 94);
            $k[$j++] = _6P;
          }
          var _6Q = $k[--$j];
          var _6T = $strcpy($s(7), "0000000");
          var _6V = $cvrs($s(7), $f($k[--$j] + 8), 2);
          $puti(_6T, 7 - _6V.length, _6V);
          $k[$j++] = _6Q;
          $k[$j++] = _6T;
        }
        $k[$j++] = $ctx.lalphanumeric;
        $k[$j++] = "0000";
        $ctx.numeric = $d();
        $k[$j++] = Infinity;
        for (var _6Y = 48; _6Y <= 57; _6Y += 1) {
          $k[$j++] = _6Y;
          $k[$j++] = _6Y - 43;
          $k[$j++] = 5;
          $ctx.tobin();
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = "01111";
        for (var _6a = 65; _6a <= 90; _6a += 1) {
          $k[$j++] = _6a;
          $k[$j++] = _6a - 33;
          $k[$j++] = 6;
          $ctx.tobin();
        }
        $k[$j++] = 42;
        $k[$j++] = "111010";
        for (var _6b = 44; _6b <= 47; _6b += 1) {
          $k[$j++] = _6b;
          $k[$j++] = _6b + 15;
          $k[$j++] = 6;
          $ctx.tobin();
        }
        $k[$j++] = $ctx.lnumeric;
        $k[$j++] = "000";
        $k[$j++] = $ctx.liso646;
        $k[$j++] = "00100";
        $ctx.alphanumeric = $d();
        $k[$j++] = Infinity;
        for (var _6f = 48; _6f <= 57; _6f += 1) {
          $k[$j++] = _6f;
          $k[$j++] = _6f - 43;
          $k[$j++] = 5;
          $ctx.tobin();
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = "01111";
        for (var _6h = 65; _6h <= 90; _6h += 1) {
          $k[$j++] = _6h;
          $k[$j++] = _6h - 1;
          $k[$j++] = 7;
          $ctx.tobin();
        }
        for (var _6i = 97; _6i <= 122; _6i += 1) {
          $k[$j++] = _6i;
          $k[$j++] = _6i - 7;
          $k[$j++] = 7;
          $ctx.tobin();
        }
        $k[$j++] = 33;
        $k[$j++] = "11101000";
        $k[$j++] = 34;
        $k[$j++] = "11101001";
        for (var _6j = 37; _6j <= 47; _6j += 1) {
          $k[$j++] = _6j;
          $k[$j++] = _6j + 197;
          $k[$j++] = 8;
          $ctx.tobin();
        }
        for (var _6k = 58; _6k <= 63; _6k += 1) {
          $k[$j++] = _6k;
          $k[$j++] = _6k + 187;
          $k[$j++] = 8;
          $ctx.tobin();
        }
        $k[$j++] = 95;
        $k[$j++] = "11111011";
        $k[$j++] = 32;
        $k[$j++] = "11111100";
        $k[$j++] = $ctx.lnumeric;
        $k[$j++] = "000";
        $k[$j++] = $ctx.lalphanumeric;
        $k[$j++] = "00100";
        $ctx.iso646 = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databarexpanded.$ctx[id] = $ctx[id]);
        bwipp_databarexpanded.__9120__ = 1;
      })();
    }
    for (var _6r = 0, _6q = $1.ais.length - 1; _6r <= _6q; _6r += 1) {
      $1.i = _6r;
      $1.ai = $get($1.ais, $1.i);
      $1.val = $get($1.vals, $1.i);
      var _71 = $a($1.gpf.length + $1.ai.length + $1.val.length);
      $puti(_71, 0, $1.gpf);
      $k[$j++] = _71;
      $k[$j++] = _71;
      $k[$j++] = $1.gpf.length;
      $k[$j++] = $1.ai;
      $k[$j++] = Infinity;
      var _75 = $k[--$j];
      var _76 = $k[--$j];
      $k[$j++] = _75;
      $forall(_76);
      var _77 = $a();
      var _78 = $k[--$j];
      $puti($k[--$j], _78, _77);
      var _7A = $k[--$j];
      $k[$j++] = _7A;
      $k[$j++] = _7A;
      $k[$j++] = $1.gpf.length + $1.ai.length;
      $k[$j++] = $1.val;
      $k[$j++] = Infinity;
      var _7E = $k[--$j];
      var _7F = $k[--$j];
      $k[$j++] = _7E;
      $forall(_7F);
      var _7G = $a();
      var _7H = $k[--$j];
      $puti($k[--$j], _7H, _7G);
      $1.gpf = $k[--$j];
      if ($1.i != $1.ais.length - 1 && $get($1.fncs, $1.i)) {
        var _7Q = $a($1.gpf.length + 1);
        $puti(_7Q, 0, $1.gpf);
        $put(_7Q, $1.gpf.length, $1.fnc1);
        $1.gpf = _7Q;
      }
    }
    $1.rembits = function() {
      var _7U = $k[--$j];
      var _7V = 48;
      var _7W = ~~Math.ceil(_7U / 12) * 12;
      if (~~Math.ceil(_7U / 12) * 12 < 48) {
        var _2 = _7V;
        _7V = _7W;
        _7W = _2;
      }
      var _7X = ~~(_7W / 12);
      $k[$j++] = _7U;
      $k[$j++] = _7W;
      $k[$j++] = _7X;
      if (_7X % $1.segments == 1) {
        var _7Z = $k[--$j];
        var _7a = $k[--$j];
        $k[$j++] = $f(_7Z + 1) * 12;
        $k[$j++] = _7a;
        $j--;
      } else {
        $j--;
      }
      var _7b = $k[--$j];
      var _7c = $k[--$j];
      $k[$j++] = $f(_7b - _7c);
    };
    $1.encode = function() {
      var _7d = $k[--$j];
      $k[$j++] = _7d;
      if ($ne(_7d, "raw")) {
        var _7e = $k[--$j];
        var _7g = $get(_7e, $k[--$j]);
        $k[$j++] = _7g;
      } else {
        $j--;
      }
      $k[$j++] = Infinity;
      var _7h = $k[--$j];
      var _7i = $k[--$j];
      $k[$j++] = _7h;
      $forall(_7i, function() {
        var _7j = $k[--$j];
        $k[$j++] = $f(_7j - 48);
      });
      var _7k = $a();
      $puti($1.gpfenc, $1.j, _7k);
      $1.j = _7k.length + $1.j;
    };
    $k[$j++] = Infinity;
    for (var _7p = 0, _7q = $1.gpf.length; _7p < _7q; _7p++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $k[$j++] = -1;
    $1.numericruns = $a();
    $k[$j++] = Infinity;
    for (var _7t = 0, _7u = $1.gpf.length; _7t < _7u; _7t++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.alphanumericruns = $a();
    $k[$j++] = Infinity;
    for (var _7x = 0, _7y = $1.gpf.length; _7x < _7y; _7x++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $1.nextiso646only = $a();
    for (var _81 = $1.gpf.length - 1; _81 >= 0; _81 -= 1) {
      $1.i = _81;
      var _86 = $strcpy($s(2), "00");
      var _89 = $get($1.gpf, $1.i);
      $k[$j++] = $get($1.gpf, $1.i);
      $k[$j++] = _86;
      $k[$j++] = _86;
      $k[$j++] = 0;
      $k[$j++] = _89;
      if (_89 == $1.fnc1) {
        $j--;
        $k[$j++] = 94;
      }
      var _8B = $k[--$j];
      var _8C = $k[--$j];
      $put($k[--$j], _8C, _8B);
      if ($1.i < $1.gpf.length - 1) {
        var _8G = $k[--$j];
        var _8J = $get($1.gpf, $1.i + 1);
        $k[$j++] = _8G;
        $k[$j++] = _8G;
        $k[$j++] = 1;
        $k[$j++] = _8J;
        if (_8J == $1.fnc1) {
          $j--;
          $k[$j++] = 94;
        }
        var _8L = $k[--$j];
        var _8M = $k[--$j];
        $put($k[--$j], _8M, _8L);
      }
      var _8Q = $get($1.numeric, $k[--$j]) !== void 0;
      if (_8Q) {
        $put($1.numericruns, $1.i, $f($get($1.numericruns, $1.i + 2) + 2));
      } else {
        $put($1.numericruns, $1.i, 0);
      }
      var _8Y = $k[--$j];
      var _8a = $get($1.alphanumeric, _8Y) !== void 0;
      $k[$j++] = _8Y;
      if (_8a) {
        $put($1.alphanumericruns, $1.i, $f($get($1.alphanumericruns, $1.i + 1) + 1));
      } else {
        $put($1.alphanumericruns, $1.i, 0);
      }
      var _8i = $k[--$j];
      var _8k = $get($1.iso646, _8i) !== void 0;
      var _8m = $get($1.alphanumeric, _8i) !== void 0;
      if (_8k && !_8m) {
        $put($1.nextiso646only, $1.i, 0);
      } else {
        $put($1.nextiso646only, $1.i, $f($get($1.nextiso646only, $1.i + 1) + 1));
      }
    }
    $1.gpfenc = $a(252);
    $1.i = 0;
    $1.j = 0;
    $1.mode = "numeric";
    for (; ; ) {
      if ($1.i == $1.gpf.length) {
        break;
      }
      for (; ; ) {
        if ($eq($1.mode, "numeric")) {
          if ($1.i <= $1.gpf.length - 2) {
            var _90 = $s(2);
            var _93 = $get($1.gpf, $1.i);
            $k[$j++] = _90;
            $k[$j++] = _90;
            $k[$j++] = 0;
            $k[$j++] = _93;
            if (_93 == $1.fnc1) {
              $j--;
              $k[$j++] = 94;
            }
            var _95 = $k[--$j];
            var _96 = $k[--$j];
            $put($k[--$j], _96, _95);
            var _98 = $k[--$j];
            var _9B = $get($1.gpf, $1.i + 1);
            $k[$j++] = _98;
            $k[$j++] = _98;
            $k[$j++] = 1;
            $k[$j++] = _9B;
            if (_9B == $1.fnc1) {
              $j--;
              $k[$j++] = 94;
            }
            var _9D = $k[--$j];
            var _9E = $k[--$j];
            $put($k[--$j], _9E, _9D);
            var _9G = $k[--$j];
            var _9I = $get($1.numeric, _9G) !== void 0;
            $k[$j++] = _9G;
            if (_9I) {
              $k[$j++] = $1.numeric;
              $1.encode();
              $1.i = $1.i + 2;
              break;
            }
            $j--;
            $k[$j++] = $1.lalphanumeric;
            $k[$j++] = $1.numeric;
            $1.encode();
            $1.mode = "alphanumeric";
            break;
          } else {
            var _9P = $get($1.gpf, $1.i);
            if (_9P < 48 || _9P > 57) {
              $k[$j++] = $1.lalphanumeric;
              $k[$j++] = $1.numeric;
              $1.encode();
              $1.mode = "alphanumeric";
              break;
            }
            $k[$j++] = "rem";
            $k[$j++] = 12 + 1 + $1.method.length + $1.vlf.length + $1.cdf.length + $1.j;
            $1.rembits();
            var _9W = $k[--$j];
            $1[$k[--$j]] = _9W;
            if ($1.rem >= 4 && $1.rem <= 6) {
              var _9d = $geti($strcpy($s(6), "000000"), 0, $1.rem);
              var _9i = $cvrs($s(4), $f($get($1.gpf, $1.i) - 47), 2);
              $puti(_9d, 4 - _9i.length, _9i);
              $k[$j++] = _9d;
              $k[$j++] = "raw";
              $1.encode();
              $1.i = $1.i + 1;
              break;
            } else {
              var _9k = $s(2);
              $put(_9k, 0, $get($1.gpf, $1.i));
              $put(_9k, 1, 94);
              $k[$j++] = _9k;
              $k[$j++] = $1.numeric;
              $1.encode();
              $1.i = $1.i + 1;
              break;
            }
          }
        }
        if ($eq($1.mode, "alphanumeric")) {
          if ($get($1.gpf, $1.i) == $1.fnc1) {
            $k[$j++] = $1.fnc1;
            $k[$j++] = $1.alphanumeric;
            $1.encode();
            $1.mode = "numeric";
            $1.i = $1.i + 1;
            break;
          }
          var _A0 = $get($1.gpf, $1.i);
          var _A2 = $get($1.iso646, _A0) !== void 0;
          var _A4 = $get($1.alphanumeric, _A0) !== void 0;
          if (_A2 && !_A4) {
            $k[$j++] = $1.liso646;
            $k[$j++] = $1.alphanumeric;
            $1.encode();
            $1.mode = "iso646";
            break;
          }
          if ($get($1.numericruns, $1.i) >= 6) {
            $k[$j++] = $1.lnumeric;
            $k[$j++] = $1.alphanumeric;
            $1.encode();
            $1.mode = "numeric";
            break;
          }
          var _AE = $get($1.numericruns, $1.i);
          if (_AE >= 4 && $f(_AE + $1.i) == $1.gpf.length) {
            $k[$j++] = $1.lnumeric;
            $k[$j++] = $1.alphanumeric;
            $1.encode();
            $1.mode = "numeric";
            break;
          }
          $k[$j++] = $get($1.gpf, $1.i);
          $k[$j++] = $1.alphanumeric;
          $1.encode();
          $1.i = $1.i + 1;
          break;
        }
        if ($eq($1.mode, "iso646")) {
          if ($get($1.gpf, $1.i) == $1.fnc1) {
            $k[$j++] = $1.fnc1;
            $k[$j++] = $1.iso646;
            $1.encode();
            $1.mode = "numeric";
            $1.i = $1.i + 1;
            break;
          }
          if ($get($1.numericruns, $1.i) >= 4 && $get($1.nextiso646only, $1.i) >= 10) {
            $k[$j++] = $1.lnumeric;
            $k[$j++] = $1.iso646;
            $1.encode();
            $1.mode = "numeric";
            break;
          }
          if ($get($1.alphanumericruns, $1.i) >= 5 && $get($1.nextiso646only, $1.i) >= 10) {
            $k[$j++] = $1.lalphanumeric;
            $k[$j++] = $1.iso646;
            $1.encode();
            $1.mode = "alphanumeric";
            break;
          }
          $k[$j++] = $get($1.gpf, $1.i);
          $k[$j++] = $1.iso646;
          $1.encode();
          $1.i = $1.i + 1;
          break;
        }
      }
    }
    $1.gpf = $geti($1.gpfenc, 0, $1.j);
    var _Ay = 1 + 12 + $1.method.length + $1.vlf.length + $1.cdf.length + $1.gpf.length;
    $k[$j++] = _Ay;
    $k[$j++] = _Ay;
    $1.rembits();
    var _Az = $k[--$j];
    $1.pad = $a(_Az);
    $k[$j++] = _Az;
    if ($1.vlf.length != 0) {
      var _B2 = $k[--$j];
      var _B4 = ~~($f($k[--$j] + _B2) / 12);
      $put($1.vlf, 0, _B4 % 2);
      var _B6 = _B4 <= 14 ? 0 : 1;
      $put($1.vlf, 1, _B6);
    } else {
      $j -= 2;
    }
    if ($1.pad.length > 0) {
      for (var _BB = 0, _BA = $1.pad.length - 1; _BB <= _BA; _BB += 5) {
        $1.i = _BB;
        var _BC = $1.pad;
        var _BD = $1.i;
        var _BE = $a([0, 0, 1, 0, 0]);
        var _BF = $1.pad;
        var _BG = $1.i;
        var _BH = 5;
        var _BI = _BF.length - _BG;
        if (_BF.length - _BG > 5) {
          var _ = _BH;
          _BH = _BI;
          _BI = _;
        }
        $puti(_BC, _BD, $geti(_BE, 0, _BI));
      }
      if ($eq($1.mode, "numeric")) {
        $k[$j++] = Infinity;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $aload($1.pad);
        $1.pad = $geti($a(), 0, $1.pad.length);
      }
    }
    $k[$j++] = Infinity;
    var _BQ = $1.linkage ? 1 : 0;
    $k[$j++] = _BQ;
    $forall($1.method, function() {
      var _BS = $k[--$j];
      $k[$j++] = $f(_BS - 48);
    });
    $aload($1.vlf);
    $aload($1.cdf);
    $aload($1.gpf);
    $aload($1.pad);
    $1.binval = $a();
    $1.datalen = ~~($1.binval.length / 12);
    $1.ncr = function() {
      var _BZ = $k[--$j];
      var _Ba = $k[--$j];
      var _Bb = $f(_Ba - _BZ);
      if (_BZ < $f(_Ba - _BZ)) {
        var _2 = _Bb;
        _Bb = _BZ;
        _BZ = _2;
      }
      $k[$j++] = _Bb;
      $k[$j++] = 1;
      $k[$j++] = 1;
      for (var _Bd = _Ba, _Bc = $f(_BZ + 1); _Bd >= _Bc; _Bd -= 1) {
        var _Be = $k[--$j];
        var _Bf = $k[--$j];
        var _Bg = $k[--$j];
        $k[$j++] = _Bg;
        $k[$j++] = _Bf;
        $k[$j++] = _Be * _Bd;
        if ($le(_Bf, _Bg)) {
          var _Bh = $k[--$j];
          var _Bi = $k[--$j];
          $k[$j++] = $f(_Bi + 1);
          $k[$j++] = ~~(_Bh / _Bi);
        }
      }
      for (; ; ) {
        var _Bj = $k[--$j];
        var _Bk = $k[--$j];
        var _Bl = $k[--$j];
        $k[$j++] = _Bl;
        $k[$j++] = _Bk;
        $k[$j++] = _Bj;
        if ($gt(_Bk, _Bl)) {
          break;
        }
        var _Bm = $k[--$j];
        var _Bn = $k[--$j];
        $k[$j++] = $f(_Bn + 1);
        $k[$j++] = ~~(_Bm / _Bn);
      }
      var _Bo = $k[--$j];
      var _Bp = $k[--$j];
      $k[$j++] = _Bo;
      $k[$j++] = _Bp;
      $j--;
      var _Bq = $k[--$j];
      var _Br = $k[--$j];
      $k[$j++] = _Bq;
      $k[$j++] = _Br;
      $j--;
    };
    $1.getRSSwidths = function() {
      $1.oe = $k[--$j];
      $1.el = $k[--$j];
      $1.mw = $k[--$j];
      $1.nm = $k[--$j];
      $1.val = $k[--$j];
      $1.out = $a($1.el);
      $1.mask = 0;
      for (var _C1 = 0, _C0 = $f($1.el - 2); _C1 <= _C0; _C1 += 1) {
        $1.bar = _C1;
        $1.ew = 1;
        var _C3 = $1.bar;
        $1.mask = $1.mask | (_C3 < 0 ? 1 >>> -_C3 : 1 << _C3);
        for (; ; ) {
          $k[$j++] = "sval";
          $k[$j++] = $f($f($1.nm - $1.ew) - 1);
          $k[$j++] = $f($f($1.el - $1.bar) - 2);
          $1.ncr();
          var _C8 = $k[--$j];
          $1[$k[--$j]] = _C8;
          if ($1.oe && $1.mask == 0 && $f($f($f($1.nm - $1.ew) - $1.el * 2) + $1.bar * 2) >= -2) {
            $k[$j++] = "sval";
            $k[$j++] = $1.sval;
            $k[$j++] = $f($f($f($1.nm - $1.ew) - $1.el) + $1.bar);
            $k[$j++] = $f($f($1.el - $1.bar) - 2);
            $1.ncr();
            var _CN = $k[--$j];
            var _CO = $k[--$j];
            $1[$k[--$j]] = $f(_CO - _CN);
          }
          if ($f($1.el - $1.bar) > 2) {
            $1.lval = 0;
            for (var _CY = $f($f($f($f($1.nm - $1.ew) - $1.el) + $1.bar) + 2), _CX = $f($1.mw + 1); _CY >= _CX; _CY -= 1) {
              $k[$j++] = $f($f($f($1.nm - _CY) - $1.ew) - 1);
              $k[$j++] = $f($f($1.el - $1.bar) - 3);
              $1.ncr();
              $1.lval = $f($k[--$j] + $1.lval);
            }
            $1.sval = $f($1.sval - $1.lval * $f($f($1.el - $1.bar) - 1));
          } else {
            if ($f($1.nm - $1.ew) > $1.mw) {
              $1.sval = $f($1.sval - 1);
            }
          }
          $1.val = $f($1.val - $1.sval);
          if ($1.val < 0) {
            break;
          }
          $1.ew = $1.ew + 1;
          var _Cs = $1.bar;
          $1.mask = $1.mask & ~(_Cs < 0 ? 1 >>> -_Cs : 1 << _Cs);
        }
        $1.val = $f($1.val + $1.sval);
        $1.nm = $f($1.nm - $1.ew);
        $put($1.out, $1.bar, $1.ew);
      }
      $put($1.out, $f($1.el - 1), $1.nm);
      $k[$j++] = $1.out;
    };
    if (!bwipp_databarexpanded.__9377__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.tab174 = $a([347, 0, 12, 5, 7, 2, 87, 4, 1387, 348, 10, 7, 5, 4, 52, 20, 2947, 1388, 8, 9, 4, 5, 30, 52, 3987, 2948, 6, 11, 3, 6, 10, 104, 4191, 3988, 4, 13, 1, 8, 1, 204]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databarexpanded.$ctx[id] = $ctx[id]);
        bwipp_databarexpanded.__9377__ = 1;
      })();
    }
    $1.dxw = $a($1.datalen);
    for (var _DA = 0, _D9 = $1.datalen - 1; _DA <= _D9; _DA += 1) {
      $1.x = _DA;
      $1.d = $geti($1.binval, $1.x * 12, 12);
      $k[$j++] = "d";
      $k[$j++] = 0;
      for (var _DE = 0; _DE <= 11; _DE += 1) {
        $1.j = _DE;
        var _DJ = $k[--$j];
        $k[$j++] = $f(_DJ + ~~Math.pow(2, 11 - $1.j) * $get($1.d, $1.j));
      }
      var _DK = $k[--$j];
      $1[$k[--$j]] = _DK;
      $1.j = 0;
      for (; ; ) {
        if ($le($1.d, $get($1.tab174, $1.j))) {
          var _DS = $geti($1.tab174, $1.j + 1, 7);
          for (var _DT = 0, _DU = _DS.length; _DT < _DU; _DT++) {
            $k[$j++] = $get(_DS, _DT);
          }
          $1.dte = $k[--$j];
          $1.dto = $k[--$j];
          $1.dmwe = $k[--$j];
          $1.dmwo = $k[--$j];
          $1.dele = $k[--$j];
          $1.delo = $k[--$j];
          $1.dgs = $k[--$j];
          break;
        }
        $1.j = $1.j + 8;
      }
      $k[$j++] = "dwo";
      $k[$j++] = ~~($f($1.d - $1.dgs) / $1.dte);
      $k[$j++] = $1.delo;
      $k[$j++] = $1.dmwo;
      $k[$j++] = 4;
      $k[$j++] = true;
      $1.getRSSwidths();
      var _Dj = $k[--$j];
      $1[$k[--$j]] = _Dj;
      $k[$j++] = "dwe";
      $k[$j++] = $f($1.d - $1.dgs) % $1.dte;
      $k[$j++] = $1.dele;
      $k[$j++] = $1.dmwe;
      $k[$j++] = 4;
      $k[$j++] = false;
      $1.getRSSwidths();
      var _Dq = $k[--$j];
      $1[$k[--$j]] = _Dq;
      $1.dw = $a(8);
      if ($1.x % 2 == 0) {
        for (var _Du = 0; _Du <= 3; _Du += 1) {
          $1.j = _Du;
          $put($1.dw, 7 - $1.j * 2, $get($1.dwo, $1.j));
          $put($1.dw, 6 - $1.j * 2, $get($1.dwe, $1.j));
        }
      } else {
        for (var _E5 = 0; _E5 <= 3; _E5 += 1) {
          $1.j = _E5;
          $put($1.dw, $1.j * 2, $get($1.dwo, $1.j));
          $put($1.dw, $1.j * 2 + 1, $get($1.dwe, $1.j));
        }
      }
      $put($1.dxw, $1.x, $1.dw);
    }
    if (!bwipp_databarexpanded.__9444__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.finderwidths = $a([1, 8, 4, 1, 1, 1, 1, 4, 8, 1, 3, 6, 4, 1, 1, 1, 1, 4, 6, 3, 3, 4, 6, 1, 1, 1, 1, 6, 4, 3, 3, 2, 8, 1, 1, 1, 1, 8, 2, 3, 2, 6, 5, 1, 1, 1, 1, 5, 6, 2, 2, 2, 9, 1, 1, 1, 1, 9, 2, 2]);
        $ctx.finderseq = $a([$a([0, 1]), $a([0, 3, 2]), $a([0, 5, 2, 7]), $a([0, 9, 2, 7, 4]), $a([0, 9, 2, 7, 6, 11]), $a([0, 9, 2, 7, 8, 11, 10]), $a([0, 1, 2, 3, 4, 5, 6, 7]), $a([0, 1, 2, 3, 4, 5, 6, 9, 8]), $a([0, 1, 2, 3, 4, 5, 6, 9, 10, 11]), $a([0, 1, 2, 3, 4, 7, 6, 9, 8, 11, 10])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databarexpanded.$ctx[id] = $ctx[id]);
        bwipp_databarexpanded.__9444__ = 1;
      })();
    }
    $1.seq = $get($1.finderseq, ~~(($1.datalen - 2) / 2));
    $1.fxw = $a($1.seq.length);
    for (var _Ed = 0, _Ec = $1.seq.length - 1; _Ed <= _Ec; _Ed += 1) {
      $1.x = _Ed;
      $put($1.fxw, $1.x, $geti($1.finderwidths, $get($1.seq, $1.x) * 5, 5));
    }
    if (!bwipp_databarexpanded.__9480__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.checkweights = $a([-1, -1, -1, -1, -1, -1, -1, -1, 77, 96, 32, 81, 27, 9, 3, 1, 20, 60, 180, 118, 143, 7, 21, 63, 205, 209, 140, 117, 39, 13, 145, 189, 193, 157, 49, 147, 19, 57, 171, 91, 132, 44, 85, 169, 197, 136, 186, 62, 185, 133, 188, 142, 4, 12, 36, 108, 50, 87, 29, 80, 97, 173, 128, 113, 150, 28, 84, 41, 123, 158, 52, 156, 166, 196, 206, 139, 187, 203, 138, 46, 76, 17, 51, 153, 37, 111, 122, 155, 146, 119, 110, 107, 106, 176, 129, 43, 16, 48, 144, 10, 30, 90, 59, 177, 164, 125, 112, 178, 200, 137, 116, 109, 70, 210, 208, 202, 184, 130, 179, 115, 190, 204, 68, 93, 31, 151, 191, 134, 148, 22, 66, 198, 172, 94, 71, 2, 40, 154, 192, 64, 162, 54, 18, 6, 120, 149, 25, 75, 14, 42, 126, 167, 175, 199, 207, 69, 23, 78, 26, 79, 103, 98, 83, 38, 114, 131, 182, 124, 159, 53, 88, 170, 127, 183, 61, 161, 55, 165, 73, 8, 24, 72, 5, 15, 89, 100, 174, 58, 160, 194, 135, 45]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_databarexpanded.$ctx[id] = $ctx[id]);
        bwipp_databarexpanded.__9480__ = 1;
      })();
    }
    $k[$j++] = Infinity;
    $forall($1.seq, function() {
      $aload($geti($1.checkweights, $k[--$j] * 16, 16));
    });
    var _Er = $a();
    $1.checkweightseq = $geti(_Er, 8, _Er.length - 8);
    $k[$j++] = Infinity;
    var _Et = $1.dxw;
    for (var _Eu = 0, _Ev = _Et.length; _Eu < _Ev; _Eu++) {
      $forall($get(_Et, _Eu));
    }
    $1.widths = $a();
    $1.checksum = 0;
    for (var _F0 = 0, _Ez = $1.widths.length - 1; _F0 <= _Ez; _F0 += 1) {
      $1.i = _F0;
      $1.checksum = $f($1.checksum + $get($1.widths, $1.i) * $get($1.checkweightseq, $1.i));
    }
    $1.checksum = $f($1.checksum % 211 + ($1.datalen - 3) * 211);
    $1.i = 0;
    for (; ; ) {
      if ($1.checksum <= $get($1.tab174, $1.i)) {
        var _FG = $geti($1.tab174, $1.i + 1, 7);
        for (var _FH = 0, _FI = _FG.length; _FH < _FI; _FH++) {
          $k[$j++] = $get(_FG, _FH);
        }
        $1.cte = $k[--$j];
        $1.cto = $k[--$j];
        $1.cmwe = $k[--$j];
        $1.cmwo = $k[--$j];
        $1.cele = $k[--$j];
        $1.celo = $k[--$j];
        $1.cgs = $k[--$j];
        break;
      }
      $1.i = $1.i + 8;
    }
    $k[$j++] = "cwo";
    $k[$j++] = ~~($f($1.checksum - $1.cgs) / $1.cte);
    $k[$j++] = $1.celo;
    $k[$j++] = $1.cmwo;
    $k[$j++] = 4;
    $k[$j++] = true;
    $1.getRSSwidths();
    var _FX = $k[--$j];
    $1[$k[--$j]] = _FX;
    $k[$j++] = "cwe";
    $k[$j++] = $f($1.checksum - $1.cgs) % $1.cte;
    $k[$j++] = $1.cele;
    $k[$j++] = $1.cmwe;
    $k[$j++] = 4;
    $k[$j++] = false;
    $1.getRSSwidths();
    var _Fe = $k[--$j];
    $1[$k[--$j]] = _Fe;
    $1.cw = $a(8);
    for (var _Fh = 0; _Fh <= 3; _Fh += 1) {
      $1.i = _Fh;
      $put($1.cw, $1.i * 2, $get($1.cwo, $1.i));
      $put($1.cw, $1.i * 2 + 1, $get($1.cwe, $1.i));
    }
    var _Fs = $a(22);
    $put(_Fs, 0, $1.cw);
    $puti(_Fs, 1, $1.dxw);
    $1.dxw = $geti(_Fs, 0, $1.datalen + 1);
    $1.datalen = $1.dxw.length;
    $1.rows = $a(~~Math.ceil($1.datalen / $1.segments));
    $1.numrows = $1.rows.length;
    for (var _G4 = 0, _G3 = $1.numrows - 1; _G4 <= _G3; _G4 += 1) {
      $1.r = _G4;
      $k[$j++] = Infinity;
      if ($1.segments % 4 != 0 && $1.r % 2 == 1) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 1;
      for (var _G9 = 0, _G8 = $1.segments - 1; _G9 <= _G8; _G9 += 1) {
        $1.pos = _G9 + $1.r * $1.segments;
        if ($1.pos < $1.datalen) {
          $forall($get($1.dxw, $1.pos));
          if ($1.pos % 2 == 0) {
            $forall($get($1.fxw, ~~($1.pos / 2)));
          }
        }
      }
      var _GL = $counttomark() + 2;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $astore($a(_GL));
      $put($1.rows, $1.r, $k[--$j]);
      $j--;
    }
    if ($ne($1.format, "expandedstacked")) {
      var _GS = $get($1.rows, 0);
      $1.sbs = $geti(_GS, 1, _GS.length - 1);
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      for (var _GW = 0, _GV = $1.datalen - 1; _GW <= _GV; _GW += 1) {
        $1.i = _GW;
        $forall($get($1.dxw, $1.i));
        if ($1.i % 2 == 0) {
          $forall($get($1.fxw, ~~($1.i / 2)));
        }
      }
      $k[$j++] = 1;
      $k[$j++] = 1;
      $1.sbs = $a();
      delete $1.options["parse"];
      $k[$j++] = Infinity;
      var _Gg = $1.sbs;
      $k[$j++] = Infinity;
      for (var _Gi = 0, _Gj = ~~(($1.sbs.length + 1) / 2); _Gi < _Gj; _Gi++) {
        $k[$j++] = $1.height;
      }
      var _Gl = $a();
      $k[$j++] = Infinity;
      for (var _Gn = 0, _Go = ~~(($1.sbs.length + 1) / 2); _Gn < _Go; _Gn++) {
        $k[$j++] = 0;
      }
      var _Gp = $a();
      $k[$j++] = "ren";
      $k[$j++] = bwipp_renlinear;
      $k[$j++] = "sbs";
      $k[$j++] = _Gg;
      $k[$j++] = "bhs";
      $k[$j++] = _Gl;
      $k[$j++] = "bbs";
      $k[$j++] = _Gp;
      $k[$j++] = "opt";
      $k[$j++] = $1.options;
      var _Gr = $d();
      $k[$j++] = _Gr;
      if (!$1.dontdraw) {
        bwipp_renlinear();
      }
    } else {
      $1.seps = $a($1.numrows);
      for (var _Gx = 0, _Gw = $1.numrows - 1; _Gx <= _Gw; _Gx += 1) {
        $1.r = _Gx;
        $1.row = $get($1.rows, $1.r);
        $k[$j++] = Infinity;
        for (var _H3 = 0, _H2 = $1.row.length - 1; _H3 <= _H2; _H3 += 2) {
          $1.i = _H3;
          for (var _H7 = 0, _H8 = $get($1.row, $1.i); _H7 < _H8; _H7++) {
            $k[$j++] = 0;
          }
          if ($1.i < $1.row.length - 1) {
            for (var _HE = 0, _HF = $get($1.row, $1.i + 1); _HE < _HF; _HE++) {
              $k[$j++] = 1;
            }
          }
        }
        $astore($a($counttomark()));
        $1.row = $k[--$j];
        $j--;
        $k[$j++] = Infinity;
        $forall($1.row, function() {
          var _HK = $k[--$j];
          $k[$j++] = $f(1 - _HK);
        });
        $1.sep = $a();
        $k[$j++] = Infinity;
        for (var _HO = 19, _HN = $1.row.length - 13; _HO <= _HN; _HO += 98) {
          $k[$j++] = _HO;
        }
        for (var _HR = 68, _HQ = $1.row.length - 13; _HR <= _HQ; _HR += 98) {
          $k[$j++] = _HR;
        }
        $1.finderpos = $a();
        var _HT = $1.finderpos;
        for (var _HU = 0, _HV = _HT.length; _HU < _HV; _HU++) {
          var _HW = $get(_HT, _HU);
          for (var _HY = _HW, _HX = $f(_HW + 14); _HY <= _HX; _HY += 1) {
            $1.i = _HY;
            if ($get($1.row, $1.i) == 0) {
              if ($get($1.row, $1.i - 1) == 1) {
                $k[$j++] = 1;
              } else {
                var _Hi = $get($1.sep, $1.i - 1) == 0 ? 1 : 0;
                $k[$j++] = _Hi;
              }
            } else {
              $k[$j++] = 0;
            }
            $put($1.sep, $1.i, $k[--$j]);
          }
        }
        $puti($1.sep, 0, $a([0, 0, 0, 0]));
        $puti($1.sep, $1.row.length - 4, $a([0, 0, 0, 0]));
        if ($1.segments % 4 == 0 && $1.r % 2 == 1) {
          if ($get($1.rows, $1.r).length != $get($1.rows, 0).length && $1.finderpos.length % 2 == 1) {
            $k[$j++] = Infinity;
            $k[$j++] = 0;
            $aload($1.row);
            $1.row = $a();
            $k[$j++] = Infinity;
            $k[$j++] = 0;
            $aload($1.sep);
            $1.sep = $a();
          } else {
            for (var _I4 = $1.row.length - 1; _I4 >= 0; _I4 -= 1) {
              $k[$j++] = $get($1.row, _I4);
            }
            $astore($1.row);
            $j--;
            for (var _I9 = $1.sep.length - 1; _I9 >= 0; _I9 -= 1) {
              $k[$j++] = $get($1.sep, _I9);
            }
            $astore($1.sep);
            $j--;
          }
        }
        $put($1.rows, $1.r, $1.row);
        $put($1.seps, $1.r, $1.sep);
      }
      $1.pixx = $get($1.rows, 0).length;
      $k[$j++] = Infinity;
      for (var _IM = 0, _IN = $1.pixx; _IM < _IN; _IM++) {
        $k[$j++] = 0;
      }
      var _IO = $a();
      $puti(_IO, 0, $get($1.rows, $1.numrows - 1));
      $put($1.rows, $1.numrows - 1, _IO);
      $k[$j++] = Infinity;
      for (var _IV = 0, _IW = $1.pixx; _IV < _IW; _IV++) {
        $k[$j++] = 0;
      }
      var _IX = $a();
      $puti(_IX, 0, $get($1.seps, $1.numrows - 1));
      $put($1.seps, $1.numrows - 1, _IX);
      $k[$j++] = Infinity;
      for (var _Ie = 0, _If = ~~($1.pixx / 2) + 1; _Ie < _If; _Ie++) {
        $k[$j++] = 0;
        $k[$j++] = 1;
      }
      $1.sep = $geti($a(), 0, $1.pixx);
      $puti($1.sep, 0, $a([0, 0, 0, 0]));
      $puti($1.sep, $1.pixx - 4, $a([0, 0, 0, 0]));
      $k[$j++] = Infinity;
      for (var _Iq = 0, _Ip = $1.numrows - 1; _Iq <= _Ip; _Iq += 1) {
        $1.r = _Iq;
        if ($1.r != 0) {
          $aload($get($1.seps, $1.r));
        }
        for (var _Iw = 0, _Ix = $1.barxmult; _Iw < _Ix; _Iw++) {
          $aload($get($1.rows, $1.r));
        }
        if ($1.r != $1.numrows - 1) {
          $aload($get($1.seps, $1.r));
          $aload($1.sep);
        }
      }
      $1.pixs = $a();
      delete $1.options["parse"];
      var _JH = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", ~~($1.pixs.length / $1.pixx)],
        ["height", ~~($1.pixs.length / $1.pixx) / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _JH;
      if (!$1.dontdraw) {
        bwipp_renmatrix();
      }
    }
  }
  function bwipp_databarexpandedstacked() {
    var $1 = Object.create(bwipp_databarexpandedstacked.$ctx || (bwipp_databarexpandedstacked.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "expandedstacked");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_databarexpanded();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_gs1northamericancoupon() {
    var $1 = Object.create(bwipp_gs1northamericancoupon.$ctx || (bwipp_gs1northamericancoupon.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.coupontextfont = "OCR-B";
    $1.coupontextsize = 9;
    $1.coupontextxoffset = null;
    $1.coupontextyoffset = null;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $k[$j++] = $1.barcode;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j--;
    $1.vals = $k[--$j];
    $1.ais = $k[--$j];
    if ($1.ais.length != 1) {
      $k[$j++] = "bwipp.gs1northamericancouponBadAIStructure#9776";
      $k[$j++] = "A GS1 North American Coupon should consist of a single AI (8110)";
      bwipp_raiseerror();
    }
    if ($ne($get($1.ais, 0), "8110")) {
      $k[$j++] = "bwipp.gs1northamericancouponBadAIStructure#9779";
      $k[$j++] = "A GS1 North American Coupon should consist of a single AI (8110)";
      bwipp_raiseerror();
    }
    $1.val = $get($1.vals, 0);
    $1.vli = $f($get($1.val, 0) - 48);
    if ($1.vli < 0 || $1.vli > 6) {
      $k[$j++] = "bwipp.gs1northamericancouponBadVLI#9786";
      $k[$j++] = "The AI (8110) data should start with a Company Prefix length indicator in the range 0 to 6";
      bwipp_raiseerror();
    }
    $1.gcp = $geti($1.val, 1, $f($1.vli + 6));
    $1.cod = $geti($1.val, $f($1.vli + 7), 6);
    $1.coupontext = $s($1.gcp.length + 7);
    $puti($1.coupontext, 0, $1.gcp);
    $puti($1.coupontext, $1.gcp.length, "-");
    $puti($1.coupontext, $1.gcp.length + 1, $1.cod);
    delete $1.options["parse"];
    $put($1.options, "dontdraw", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_databarexpandedstacked();
    var _X = $k[--$j];
    $1[$k[--$j]] = _X;
    if ($1.includetext) {
      if ($eq($1.coupontextxoffset, null)) {
        $1.coupontextxoffset = 0;
      }
      if ($eq($1.coupontextyoffset, null)) {
        $1.coupontextyoffset = $f($get($1.args, "height") * 72 + 3);
      }
      var _f = $get($1.args, "txt") !== void 0;
      if (_f) {
        $1.txt = $get($1.args, "txt");
        $1.newtxt = $a($1.txt.length + 1);
        $puti($1.newtxt, 0, $1.txt);
        $put($1.newtxt, $1.newtxt.length - 1, $a([$1.coupontext, $1.coupontextxoffset, $1.coupontextyoffset, $1.coupontextfont, $1.coupontextsize]));
        $put($1.args, "txt", $1.newtxt);
      } else {
        $put($1.args, "txt", $a([$a([$1.coupontext, $1.coupontextxoffset, $1.coupontextyoffset, $1.coupontextfont, $1.coupontextsize])]));
      }
    }
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_pharmacode() {
    var $1 = Object.create(bwipp_pharmacode.$ctx || (bwipp_pharmacode.$ctx = {}));
    $1.dontdraw = false;
    $1.height = 8 * 2.835 / 72;
    $1.nwidth = 0.5 * 2.835;
    $1.wwidth = 1.5 * 2.835;
    $1.swidth = 1 * 2.835;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.barcode.length < 1 || $1.barcode.length > 6) {
      $k[$j++] = "bwipp.pharmacodeBadLength#9867";
      $k[$j++] = "Pharmacode must be 1 to 6 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _5 = $k[--$j];
      if (_5 < 48 || _5 > 57) {
        $k[$j++] = "bwipp.pharmacodeBadCharacter#9871";
        $k[$j++] = "Pharmacode must contain only digits";
        bwipp_raiseerror();
      }
    });
    var _7 = $cvi($1.barcode);
    if (_7 < 3 || _7 > 131070) {
      $k[$j++] = "bwipp.pharmacodeBadValue#9875";
      $k[$j++] = "Pharmacode value must be between 3 and 131070";
      bwipp_raiseerror();
    }
    $1.txt = $a($1.barcode.length);
    for (var _C = 0, _B = $1.barcode.length - 1; _C <= _B; _C += 1) {
      $1.i = _C;
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), 0, 0, "", 0]));
    }
    $1.barcode = $cvrs($s(17), $cvi($1.barcode) + 1, 2);
    $1.barcode = $geti($1.barcode, 1, $1.barcode.length - 1);
    $1.barlen = $1.barcode.length;
    $1.sbs = $a($1.barlen * 2);
    for (var _U = 0, _T = $1.barlen - 1; _U <= _T; _U += 1) {
      $1.i = _U;
      $1.enc = $geti($1.barcode, $1.i, 1);
      if ($eq($1.enc, "0")) {
        $put($1.sbs, $1.i * 2, $1.nwidth);
      } else {
        $put($1.sbs, $1.i * 2, $1.wwidth);
      }
      $put($1.sbs, $1.i * 2 + 1, $1.swidth);
    }
    $k[$j++] = Infinity;
    var _i = $1.sbs;
    $k[$j++] = Infinity;
    for (var _k = 0, _l = ~~(($1.sbs.length + 1) / 2); _k < _l; _k++) {
      $k[$j++] = $1.height;
    }
    var _n = $a();
    $k[$j++] = Infinity;
    for (var _p = 0, _q = ~~(($1.sbs.length + 1) / 2); _p < _q; _p++) {
      $k[$j++] = 0;
    }
    var _r = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _i;
    $k[$j++] = "bhs";
    $k[$j++] = _n;
    $k[$j++] = "bbs";
    $k[$j++] = _r;
    $k[$j++] = "txt";
    $k[$j++] = $1.txt;
    $k[$j++] = "textxalign";
    $k[$j++] = "center";
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _u = $d();
    $k[$j++] = _u;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_pharmacode2() {
    var $1 = Object.create(bwipp_pharmacode2.$ctx || (bwipp_pharmacode2.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.height = 4;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.barcode.length < 1 || $1.barcode.length > 8) {
      $k[$j++] = "bwipp.pharmacode2BadLength#9956";
      $k[$j++] = "Two-track Pharmacode must be 1 to 6 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _5 = $k[--$j];
      if (_5 < 48 || _5 > 57) {
        $k[$j++] = "bwipp.pharmacode2badCharacter#9960";
        $k[$j++] = "Two-track Pharmacode must contain only digits";
        bwipp_raiseerror();
      }
    });
    var _7 = $cvi($1.barcode);
    if (_7 < 4 || _7 > 64570080) {
      $k[$j++] = "bwipp.pharmacode2badValue#9964";
      $k[$j++] = "Two-track Pharmacode value must be between 4 and 64570080";
      bwipp_raiseerror();
    }
    $1.txt = $a($1.barcode.length);
    for (var _C = 0, _B = $1.barcode.length - 1; _C <= _B; _C += 1) {
      $1.i = _C;
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), 0, 0, "", 0]));
    }
    $1.encstr = $s(16);
    $1.sbs = $a(32);
    $1.bar = 1 / 25.4 * $1.height;
    $1.spc = 1 / 25.4 * 72;
    $1.i = 15;
    $1.val = $cvi($1.barcode);
    for (; ; ) {
      if ($1.val == 0) {
        break;
      }
      var _P = $1.val % 3;
      $1.val = ~~($f($1.val - $get($a([3, 1, 2]), _P)) / 3);
      $put($1.encstr, $1.i, $get($a([2, 0, 1]), _P));
      $1.i = $1.i - 1;
    }
    $1.encstr = $geti($1.encstr, $1.i + 1, 15 - $1.i);
    $1.bhs = $a($1.encstr.length);
    $1.bbs = $a($1.encstr.length);
    for (var _i = 0, _h = $1.encstr.length - 1; _i <= _h; _i += 1) {
      $1.i = _i;
      var _l = $get($1.encstr, $1.i);
      $put($1.bhs, $1.i, $1.bar * $get($a([1, 1, 2]), _l));
      $put($1.bbs, $1.i, $get($a([0, $1.bar, 0]), _l));
    }
    $k[$j++] = Infinity;
    var _w = $1.bhs;
    var _x = $1.bbs;
    $k[$j++] = Infinity;
    for (var _z = 0, _10 = $1.encstr.length * 2; _z < _10; _z++) {
      $k[$j++] = $1.spc;
    }
    var _12 = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bhs";
    $k[$j++] = _w;
    $k[$j++] = "bbs";
    $k[$j++] = _x;
    $k[$j++] = "sbs";
    $k[$j++] = _12;
    $k[$j++] = "txt";
    $k[$j++] = $1.txt;
    $k[$j++] = "textxalign";
    $k[$j++] = "center";
    $k[$j++] = "textyoffset";
    $k[$j++] = 4;
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _15 = $d();
    $k[$j++] = _15;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_code2of5() {
    var $1 = Object.create(bwipp_code2of5.$ctx || (bwipp_code2of5.$ctx = {}));
    $1.dontdraw = false;
    $1.includecheck = false;
    $1.validatecheck = false;
    $1.includetext = false;
    $1.includecheckintext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $1.version = "industrial";
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $forall($1.barcode, function() {
      var _3 = $k[--$j];
      if (_3 < 48 || _3 > 57) {
        $k[$j++] = "bwipp.code2of5badCharacter#10067";
        $k[$j++] = "Code 25 must contain only digits";
        bwipp_raiseerror();
      }
    });
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _6 = $k[--$j];
      $k[$j++] = $f(_6 - 1);
    }
    var _7 = $k[--$j];
    $1[$k[--$j]] = _7;
    $1.checksum = 0;
    for (var _B = 0, _A = $f($1.barlen - 1); _B <= _A; _B += 1) {
      $1.i = _B;
      $k[$j++] = "checksum";
      $k[$j++] = $1.checksum;
      $k[$j++] = $f($get($1.barcode, $1.i) - 48);
      if ($f($1.barlen - $1.i) % 2 != 0) {
        var _I = $k[--$j];
        $k[$j++] = _I * 3;
      }
      var _J = $k[--$j];
      var _K = $k[--$j];
      $1[$k[--$j]] = $f(_K + _J);
    }
    $1.checksum = (10 - $1.checksum % 10) % 10;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $1.checksum + 48) {
        $k[$j++] = "bwipp.code2of5badCheckDigit#10081";
        $k[$j++] = "Incorrect Code 25 check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
      $1.includecheck = true;
    }
    if (!bwipp_code2of5.__10113__) {
      (function() {
        var $ctx = Object.create($1);
        var _a = /* @__PURE__ */ new Map([
          ["industrial", $a(["1111313111", "3111111131", "1131111131", "3131111111", "1111311131", "3111311111", "1131311111", "1111113131", "3111113111", "1131113111", "313111", "31113"])],
          ["iata", $a(["1111313111", "3111111131", "1131111131", "3131111111", "1111311131", "3111311111", "1131311111", "1111113131", "3111113111", "1131113111", "1111", "311"])],
          ["matrix", $a(["113311", "311131", "131131", "331111", "113131", "313111", "133111", "111331", "311311", "131311", "311111", "31111"])],
          ["coop", $a(["331111", "111331", "113131", "113311", "131131", "131311", "133111", "311131", "311311", "313111", "3131", "133"])],
          ["datalogic", $a(["113311", "311131", "131131", "331111", "113131", "313111", "133111", "111331", "311311", "131311", "1111", "311"])]
        ]);
        $ctx.versions = _a;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code2of5.$ctx[id] = $ctx[id]);
        bwipp_code2of5.__10113__ = 1;
      })();
    }
    var _e = $get($1.versions, $1.version) !== void 0;
    if (!_e) {
      $k[$j++] = "bwipp.code2of5badVersion#10116";
      $k[$j++] = "Unrecognised Code 25 version";
      bwipp_raiseerror();
    }
    $1.encs = $get($1.versions, $1.version);
    $1.cs = $get($1.encs, 0).length;
    $k[$j++] = "cw";
    $k[$j++] = 0;
    $forall($get($1.encs, 0), function() {
      var _m = $k[--$j];
      var _n = $k[--$j];
      $k[$j++] = $f(_n + $f(_m - 48));
    });
    var _o = $k[--$j];
    $1[$k[--$j]] = _o;
    $1.ss = $get($1.encs, 10).length;
    $k[$j++] = "sw";
    $k[$j++] = 0;
    $forall($get($1.encs, 10), function() {
      var _u = $k[--$j];
      var _v = $k[--$j];
      $k[$j++] = $f(_v + $f(_u - 48));
    });
    var _w = $k[--$j];
    $1[$k[--$j]] = _w;
    $1.es = $get($1.encs, 11).length;
    if (!bwipp_code2of5.__10129__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789";
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code2of5.$ctx[id] = $ctx[id]);
        bwipp_code2of5.__10129__ = 1;
      })();
    }
    $k[$j++] = "sbs";
    $k[$j++] = $1.barlen;
    if ($1.includecheck) {
      var _13 = $k[--$j];
      $k[$j++] = $f(_13 + 1);
    }
    var _18 = $s($f($f($k[--$j] * $1.cs + $1.ss) + $1.es));
    $1[$k[--$j]] = _18;
    $k[$j++] = "txt";
    $k[$j++] = $1.barlen;
    if ($1.includecheck) {
      var _1C = $k[--$j];
      $k[$j++] = $f(_1C + 1);
    }
    var _1E = $a($k[--$j]);
    $1[$k[--$j]] = _1E;
    $puti($1.sbs, 0, $get($1.encs, 10));
    for (var _1L = 0, _1K = $f($1.barlen - 1); _1L <= _1K; _1L += 1) {
      $1.i = _1L;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * $1.cs + $1.ss, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $f($1.i * $1.cw + $1.sw), $1.textyoffset, $1.textfont, $1.textsize]));
    }
    if ($1.includecheck) {
      $puti($1.sbs, $f($1.barlen * $1.cs + $1.ss), $get($1.encs, $1.checksum));
      $puti($1.sbs, $f($f($1.barlen * $1.cs + $1.cs) + $1.ss), $get($1.encs, 11));
      if ($1.includecheckintext) {
        $put($1.txt, $1.barlen, $a([$geti($1.barchars, $1.checksum, 1), $f($1.barlen * $1.cw + $1.sw), $1.textyoffset, $1.textfont, $1.textsize]));
      } else {
        $put($1.txt, $1.barlen, $a([" ", $f($1.barlen * $1.cw + $1.sw), $1.textyoffset, $1.textfont, $1.textsize]));
      }
    } else {
      $puti($1.sbs, $f($1.barlen * $1.cs + $1.ss), $get($1.encs, 11));
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    $forall($1.sbs, function() {
      var _2T = $k[--$j];
      $k[$j++] = $f(_2T - 48);
    });
    var _2U = $a();
    $k[$j++] = Infinity;
    for (var _2W = 0, _2X = ~~(($1.sbs.length + 1) / 2); _2W < _2X; _2W++) {
      $k[$j++] = $1.height;
    }
    var _2Z = $a();
    $k[$j++] = Infinity;
    for (var _2b = 0, _2c = ~~(($1.sbs.length + 1) / 2); _2b < _2c; _2b++) {
      $k[$j++] = 0;
    }
    var _2d = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _2U;
    $k[$j++] = "bhs";
    $k[$j++] = _2Z;
    $k[$j++] = "bbs";
    $k[$j++] = _2d;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2h = $d();
    $k[$j++] = _2h;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_industrial2of5() {
    var $1 = Object.create(bwipp_industrial2of5.$ctx || (bwipp_industrial2of5.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "version", "industrial");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code2of5();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_iata2of5() {
    var $1 = Object.create(bwipp_iata2of5.$ctx || (bwipp_iata2of5.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "version", "iata");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code2of5();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_matrix2of5() {
    var $1 = Object.create(bwipp_matrix2of5.$ctx || (bwipp_matrix2of5.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "version", "matrix");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code2of5();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_coop2of5() {
    var $1 = Object.create(bwipp_coop2of5.$ctx || (bwipp_coop2of5.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "version", "coop");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code2of5();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_datalogic2of5() {
    var $1 = Object.create(bwipp_datalogic2of5.$ctx || (bwipp_datalogic2of5.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "version", "datalogic");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code2of5();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_code11() {
    var $1 = Object.create(bwipp_code11.$ctx || (bwipp_code11.$ctx = {}));
    $1.dontdraw = false;
    $1.includecheck = false;
    $1.validatecheck = false;
    $1.includetext = false;
    $1.includecheckintext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    var _1 = $k[--$j];
    $1.barcode = _1;
    if (!bwipp_code11.__10477__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["111131", "311131", "131131", "331111", "113131", "313111", "133111", "111331", "311311", "311111", "113111", "113311"]);
        $ctx.barchars = "0123456789-";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _3 = 0; _3 <= 10; _3 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _3, 1), _3);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code11.$ctx[id] = $ctx[id]);
        bwipp_code11.__10477__ = 1;
      })();
    }
    for (var _A = 0, _9 = $1.barcode.length - 1; _A <= _9; _A += 1) {
      var _E = $get($1.charvals, $geti($1.barcode, _A, 1)) !== void 0;
      if (!_E) {
        $k[$j++] = "bwipp.code11badCharacter#10482";
        $k[$j++] = "Code 11 must contain only digits and dashes";
        bwipp_raiseerror();
      }
    }
    $1.barlen = $1.barcode.length;
    if ($1.validatecheck) {
      if ($1.barlen == 11) {
        $k[$j++] = "bwipp.code11badLength#10489";
        $k[$j++] = "Code 11 cannot be 11 characters using check digits";
        bwipp_raiseerror();
      }
      var _K = $1.barlen <= 10 ? 1 : 2;
      $1.barlen = $1.barlen - _K;
    }
    $k[$j++] = "numchecks";
    if ($1.includecheck || $1.validatecheck) {
      var _O = $1.barlen >= 10 ? 2 : 1;
      $k[$j++] = _O;
    } else {
      $k[$j++] = 0;
    }
    var _P = $k[--$j];
    $1[$k[--$j]] = _P;
    $1.checksum1 = 0;
    $1.checksum2 = 0;
    for (var _T = 0, _S = $1.barlen - 1; _T <= _S; _T += 1) {
      $1.i = _T;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $1.checksum1 = $f($1.checksum1 + (($1.barlen - $1.i - 1) % 10 + 1) * $1.indx);
      $1.checksum2 = $f($1.checksum2 + (($1.barlen - $1.i) % 9 + 1) * $1.indx);
    }
    $1.checksum1 = $1.checksum1 % 11;
    $1.checksum2 = $f($1.checksum2 + $1.checksum1) % 11;
    if ($1.validatecheck) {
      if ($1.numchecks == 1) {
        var _r = $get($1.barchars, $1.checksum1);
        if ($get($1.barcode, $1.barlen) != _r) {
          $k[$j++] = "bwipp.code11badCheckDigit#10507";
          $k[$j++] = "Incorrect Code 11 check digit provided";
          bwipp_raiseerror();
        }
      } else {
        if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum1) || $get($1.barcode, $1.barlen + 1) != $get($1.barchars, $1.checksum2)) {
          $k[$j++] = "bwipp.code11badCheckDigits#10512";
          $k[$j++] = "Incorrect Code 11 check digits provided";
          bwipp_raiseerror();
        }
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
      $1.includecheck = true;
    }
    $1.sbs = $s($f($f($1.barlen + $1.numchecks) * 6 + 12));
    $1.txt = $a($f($1.barlen + $1.numchecks));
    $puti($1.sbs, 0, $get($1.encs, 11));
    $1.xpos = 8;
    for (var _1I = 0, _1H = $1.barlen - 1; _1I <= _1H; _1I += 1) {
      $1.i = _1I;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * 6 + 6, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
      for (var _1e = 0; _1e <= 5; _1e += 1) {
        $1.xpos = $f($f($get($1.enc, _1e) - 48) + $1.xpos);
      }
    }
    if ($1.includecheck) {
      if ($1.barlen >= 10) {
        $puti($1.sbs, $1.barlen * 6 + 6, $get($1.encs, $1.checksum1));
        $puti($1.sbs, $1.barlen * 6 + 12, $get($1.encs, $1.checksum2));
        if ($1.includecheckintext) {
          $put($1.txt, $1.barlen, $a([$geti($1.barchars, $1.checksum1, 1), $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
          $1.enc = $get($1.encs, $1.checksum1);
          for (var _28 = 0; _28 <= 5; _28 += 1) {
            $1.xpos = $f($f($get($1.enc, _28) - 48) + $1.xpos);
          }
          $put($1.txt, $1.barlen + 1, $a([$geti($1.barchars, $1.checksum2, 1), $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
        } else {
          $put($1.txt, $1.barlen, $a(["", $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
          $put($1.txt, $1.barlen + 1, $a(["", $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
        }
        $puti($1.sbs, $1.barlen * 6 + 18, $get($1.encs, 11));
      } else {
        $puti($1.sbs, $1.barlen * 6 + 6, $get($1.encs, $1.checksum1));
        if ($1.includecheckintext) {
          $put($1.txt, $1.barlen, $a([$geti($1.barchars, $1.checksum1, 1), $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
        } else {
          $put($1.txt, $1.barlen, $a(["", $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
        }
        $puti($1.sbs, $1.barlen * 6 + 12, $get($1.encs, 11));
      }
    } else {
      $puti($1.sbs, $1.barlen * 6 + 6, $get($1.encs, 11));
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _39 = $1.sbs;
    for (var _3A = 0, _3B = _39.length; _3A < _3B; _3A++) {
      $k[$j++] = $get(_39, _3A) - 48;
    }
    var _3D = $a();
    $k[$j++] = Infinity;
    for (var _3F = 0, _3G = ~~(($1.sbs.length + 1) / 2); _3F < _3G; _3F++) {
      $k[$j++] = $1.height;
    }
    var _3I = $a();
    $k[$j++] = Infinity;
    for (var _3K = 0, _3L = ~~(($1.sbs.length + 1) / 2); _3K < _3L; _3K++) {
      $k[$j++] = 0;
    }
    var _3M = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _3D;
    $k[$j++] = "bhs";
    $k[$j++] = _3I;
    $k[$j++] = "bbs";
    $k[$j++] = _3M;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _3Q = $d();
    $k[$j++] = _3Q;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_bc412() {
    var $1 = Object.create(bwipp_bc412.$ctx || (bwipp_bc412.$ctx = {}));
    $1.dontdraw = false;
    $1.includecheck = false;
    $1.validatecheck = false;
    $1.includetext = false;
    $1.includecheckintext = false;
    $1.includestartstop = false;
    $1.semi = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.semi) {
      $1.includestartstop = true;
    }
    if (!bwipp_bc412.__10643__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0R9GLVHA8EZ4NTS1J2Q6C7DYKBUIX3FWP5M";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _3 = 0; _3 <= 34; _3 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _3, 1), _3);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_bc412.$ctx[id] = $ctx[id]);
        bwipp_bc412.__10643__ = 1;
      })();
    }
    for (var _A = 0, _9 = $1.barcode.length - 1; _A <= _9; _A += 1) {
      var _E = $get($1.charvals, $geti($1.barcode, _A, 1)) !== void 0;
      if (!_E) {
        $k[$j++] = "bwipp.bc412badCharacter#10648";
        $k[$j++] = "BC412 must contain only digits and capital letters except O";
        bwipp_raiseerror();
      }
    }
    if ($1.semi) {
      if ($1.validatecheck) {
        if ($1.barcode.length < 8 || $1.barcode.length > 19) {
          $k[$j++] = "bwipp.bc412semivalidateBadLength#10656";
          $k[$j++] = "BC412 semi with check digit must be 8 to 19 characters long";
          bwipp_raiseerror();
        }
      } else {
        if ($1.barcode.length < 7 || $1.barcode.length > 18) {
          $k[$j++] = "bwipp.bc412semiBadLength#10660";
          $k[$j++] = "BC412 semi must be 7 to 18 characters long";
          bwipp_raiseerror();
        }
      }
      $1.barlen = $1.barcode.length;
      if (!$1.validatecheck) {
        $1.barlen = $1.barlen + 1;
        $1.sbarcode = $s($1.barlen);
        $put($1.sbarcode, 0, $get($1.barcode, 0));
        $put($1.sbarcode, 1, 48);
        $puti($1.sbarcode, 2, $geti($1.barcode, 1, $1.barlen - 2));
        $1.barcode = $1.sbarcode;
      }
      $1.sumodd = 0;
      $1.sumeven = 0;
      for (var _b = 0, _a = $1.barlen - 1; _b <= _a; _b += 1) {
        $1.i = _b;
        $k[$j++] = $get($1.charvals, $geti($1.barcode, $1.i, 1));
        if ($1.i % 2 == 0) {
          $1.sumodd = $f($k[--$j] + $1.sumodd);
        } else {
          $1.sumeven = $f($k[--$j] + $1.sumeven);
        }
      }
      $1.checksum = $f($1.sumodd % 35 + $1.sumeven % 35 * 2) % 35;
      if ($1.validatecheck) {
        if ($1.checksum != 0) {
          $k[$j++] = "bwipp.bc412semiBadCheckDigit#10686";
          $k[$j++] = "Incorrect BC412 semi check digit provided";
          bwipp_raiseerror();
        }
      } else {
        $1.checksum = $1.checksum * 17 % 35;
        $put($1.barcode, 1, $get($1.barchars, $1.checksum));
      }
    } else {
      $k[$j++] = "barlen";
      $k[$j++] = $1.barcode.length;
      if ($1.validatecheck) {
        var _x = $k[--$j];
        $k[$j++] = $f(_x - 1);
      }
      var _y = $k[--$j];
      $1[$k[--$j]] = _y;
      $1.checksum = 0;
      for (var _12 = 0, _11 = $1.barlen - 1; _12 <= _11; _12 += 1) {
        $1.checksum = $f($get($1.charvals, $geti($1.barcode, _12, 1)) + $1.checksum);
      }
      $1.checksum = $1.checksum % 35;
      if ($1.validatecheck) {
        if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
          $k[$j++] = "bwipp.bc412badCheckDigit#10703";
          $k[$j++] = "Incorrect BC412 check digit provided";
          bwipp_raiseerror();
        }
        $1.barcode = $geti($1.barcode, 0, $1.barlen);
        $1.includecheck = true;
      }
    }
    if (!bwipp_bc412.__10722__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["11111115", "13111212", "11131113", "12111213", "12121311", "13131111", "12111312", "11131212", "11121411", "11151111", "15111111", "11111511", "12131211", "13121112", "13111311", "11111214", "12121113", "11111313", "13111113", "11121213", "11141112", "11121312", "11141211", "14121111", "12121212", "11131311", "13121211", "12111411", "14111211", "11111412", "12111114", "14111112", "12141111", "11121114", "12131112", "12", "111"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_bc412.$ctx[id] = $ctx[id]);
        bwipp_bc412.__10722__ = 1;
      })();
    }
    $1.sbs = $s(($1.barlen + 1) * 8 + 5);
    if ($1.includecheck) {
      $1.txt = $a($1.barlen + 1);
    } else {
      $1.txt = $a($1.barlen);
    }
    if ($1.includestartstop) {
      $puti($1.sbs, 0, $get($1.encs, 35));
      $1.pos = 2;
      $1.txtpos = 3;
    } else {
      $1.pos = 0;
      $1.txtpos = 0;
    }
    for (var _1Y = 0, _1X = $1.barlen - 1; _1Y <= _1X; _1Y += 1) {
      $1.i = _1Y;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $puti($1.sbs, $1.pos, $get($1.encs, $1.indx));
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 12 + $1.txtpos, $1.textyoffset, $1.textfont, $1.textsize]));
      $1.pos = $1.pos + 8;
    }
    if ($1.includecheck) {
      $puti($1.sbs, $1.pos, $get($1.encs, $1.checksum));
      if ($1.includecheckintext) {
        $put($1.txt, $1.barlen, $a([$geti($1.barchars, $1.checksum, 1), $1.barlen * 12 + $1.txtpos, $1.textyoffset, $1.textfont, $1.textsize]));
      } else {
        $put($1.txt, $1.barlen, $a(["", $1.barlen * 12 + $1.txtpos, $1.textyoffset, $1.textfont, $1.textsize]));
      }
      $1.pos = $1.pos + 8;
    }
    if ($1.includestartstop) {
      $puti($1.sbs, $1.pos, $get($1.encs, 36));
      $1.pos = $1.pos + 3;
    }
    $1.sbs = $geti($1.sbs, 0, $1.pos);
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _2V = $1.sbs;
    for (var _2W = 0, _2X = _2V.length; _2W < _2X; _2W++) {
      $k[$j++] = $f($get(_2V, _2W) - 48);
    }
    var _2Z = $a();
    $k[$j++] = Infinity;
    for (var _2b = 0, _2c = ~~(($1.sbs.length + 1) / 2); _2b < _2c; _2b++) {
      $k[$j++] = $1.height;
    }
    var _2e = $a();
    $k[$j++] = Infinity;
    for (var _2g = 0, _2h = ~~(($1.sbs.length + 1) / 2); _2g < _2h; _2g++) {
      $k[$j++] = 0;
    }
    var _2i = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _2Z;
    $k[$j++] = "bhs";
    $k[$j++] = _2e;
    $k[$j++] = "bbs";
    $k[$j++] = _2i;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2m = $d();
    $k[$j++] = _2m;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_rationalizedCodabar() {
    var $1 = Object.create(bwipp_rationalizedCodabar.$ctx || (bwipp_rationalizedCodabar.$ctx = {}));
    $1.dontdraw = false;
    $1.altstartstop = false;
    $1.includecheck = false;
    $1.validatecheck = false;
    $1.includetext = false;
    $1.includecheckintext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    var _1 = $k[--$j];
    $1.barcode = _1;
    if (!bwipp_rationalizedCodabar.__10844__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["11111331", "11113311", "11131131", "33111111", "11311311", "31111311", "13111131", "13113111", "13311111", "31131111", "11133111", "11331111", "31113131", "31311131", "31313111", "11313131", "11331311", "13131131", "11131331", "11133311"]);
        $ctx.barcharsnormal = "0123456789-$:/.+ABCD";
        $ctx.barcharsalt = "0123456789-$:/.+TN*E";
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_rationalizedCodabar.$ctx[id] = $ctx[id]);
        bwipp_rationalizedCodabar.__10844__ = 1;
      })();
    }
    var _5 = $1.altstartstop ? $1.barcharsalt : $1.barcharsnormal;
    $1.barchars = _5;
    $1.charvals = /* @__PURE__ */ new Map();
    for (var _6 = 0; _6 <= 19; _6 += 1) {
      $put($1.charvals, $geti($1.barchars, _6, 1), _6);
    }
    $1.bodyvals = /* @__PURE__ */ new Map();
    for (var _A = 0; _A <= 15; _A += 1) {
      $put($1.bodyvals, $geti($1.barchars, _A, 1), _A);
    }
    $1.ssvals = /* @__PURE__ */ new Map();
    for (var _E = 16; _E <= 19; _E += 1) {
      $put($1.ssvals, $geti($1.barchars, _E, 1), _E);
    }
    var _L = $get($1.ssvals, $geti($1.barcode, 0, 1)) !== void 0;
    var _Q = $get($1.ssvals, $geti($1.barcode, $1.barcode.length - 1, 1)) !== void 0;
    if (!_L || !_Q) {
      if ($1.altstartstop) {
        $k[$j++] = "bwipp.rationalizedCodabarBadAltStartStop#10859";
        $k[$j++] = "Codabar start and stop characters must be one of E N T or *";
        bwipp_raiseerror();
      } else {
        $k[$j++] = "bwipp.rationalizedCodabarBadStartStop#10861";
        $k[$j++] = "Codabar start and stop characters must be one of A B C or D";
        bwipp_raiseerror();
      }
    }
    for (var _U = 1, _T = $1.barcode.length - 2; _U <= _T; _U += 1) {
      var _Y = $get($1.bodyvals, $geti($1.barcode, _U, 1)) !== void 0;
      if (!_Y) {
        $k[$j++] = "bwipp.rationalizedCodabarBadCharacter#10866";
        $k[$j++] = "Codabar body must contain only digits and symbols - $ : / . +";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _b = $k[--$j];
      $k[$j++] = $f(_b - 1);
    }
    var _c = $k[--$j];
    $1[$k[--$j]] = _c;
    $1.checksum = 0;
    for (var _g = 0, _f = $f($1.barlen - 2); _g <= _f; _g += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _g, 1)) + $1.checksum);
    }
    $1.checksum = $f($get($1.charvals, $geti($1.barcode, $1.barcode.length - 1, 1)) + $1.checksum);
    $1.checksum = $f(16 - $1.checksum % 16) % 16;
    if ($1.validatecheck) {
      if ($get($1.barcode, $f($1.barlen - 1)) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.rationalizedCodabarBadCheckDigit#10882";
        $k[$j++] = "Incorrect Codabar check digit provided";
        bwipp_raiseerror();
      }
      var _11 = $s($1.barlen);
      $puti(_11, 0, $geti($1.barcode, 0, $f($1.barlen - 1)));
      $puti(_11, $f($1.barlen - 1), $geti($1.barcode, $1.barlen, 1));
      $1.barcode = _11;
      $1.includecheck = true;
    }
    $k[$j++] = "sbs";
    $k[$j++] = $1.barlen;
    if ($1.includecheck) {
      var _1B = $k[--$j];
      $k[$j++] = $f(_1B + 1);
    }
    var _1D = $s($k[--$j] * 8);
    $1[$k[--$j]] = _1D;
    $k[$j++] = "txt";
    $k[$j++] = $1.barlen;
    if ($1.includecheck) {
      var _1H = $k[--$j];
      $k[$j++] = $f(_1H + 1);
    }
    var _1J = $a($k[--$j]);
    $1[$k[--$j]] = _1J;
    $1.xpos = 0;
    for (var _1N = 0, _1M = $f($1.barlen - 2); _1N <= _1M; _1N += 1) {
      $1.i = _1N;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * 8, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
      for (var _1j = 0; _1j <= 7; _1j += 1) {
        $1.xpos = $f($f($get($1.enc, _1j) - 48) + $1.xpos);
      }
    }
    if ($1.includecheck) {
      $puti($1.sbs, $f($1.barlen * 8 - 8), $get($1.encs, $1.checksum));
      if ($1.includecheckintext) {
        $put($1.txt, $f($1.barlen - 1), $a([$geti($1.barchars, $1.checksum, 1), $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
      } else {
        $put($1.txt, $f($1.barlen - 1), $a([" ", $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
      }
      for (var _2B = 0; _2B <= 7; _2B += 1) {
        $1.xpos = $f($f($get($get($1.encs, $1.checksum), _2B) - 48) + $1.xpos);
      }
      $1.indx = $get($1.charvals, $geti($1.barcode, $f($1.barlen - 1), 1));
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.barlen * 8, $1.enc);
      $put($1.txt, $1.barlen, $a([$geti($1.barcode, $f($1.barlen - 1), 1), $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
    } else {
      $1.indx = $get($1.charvals, $geti($1.barcode, $f($1.barlen - 1), 1));
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $f($1.barlen * 8 - 8), $1.enc);
      $put($1.txt, $f($1.barlen - 1), $a([$geti($1.barcode, $f($1.barlen - 1), 1), $1.xpos, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    $forall($1.sbs, function() {
      var _2y = $k[--$j];
      $k[$j++] = $f(_2y - 48);
    });
    var _2z = $a();
    $k[$j++] = Infinity;
    for (var _31 = 0, _32 = ~~(($1.sbs.length + 1) / 2); _31 < _32; _31++) {
      $k[$j++] = $1.height;
    }
    var _34 = $a();
    $k[$j++] = Infinity;
    for (var _36 = 0, _37 = ~~(($1.sbs.length + 1) / 2); _36 < _37; _36++) {
      $k[$j++] = 0;
    }
    var _38 = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _2z;
    $k[$j++] = "bhs";
    $k[$j++] = _34;
    $k[$j++] = "bbs";
    $k[$j++] = _38;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _3C = $d();
    $k[$j++] = _3C;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_onecode() {
    var $1 = Object.create(bwipp_onecode.$ctx || (bwipp_onecode.$ctx = {}));
    $1.dontdraw = false;
    $1.height = 0.15;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $1.barlen = $1.barcode.length;
    $forall($1.barcode, function() {
      var _4 = $k[--$j];
      if (_4 < 48 || _4 > 57) {
        $k[$j++] = "bwipp.onecodeBadCharacter#10992";
        $k[$j++] = "The data must contain only digits";
        bwipp_raiseerror();
      }
    });
    if ($1.barlen != 20 && $1.barlen != 25 && $1.barlen != 29 && $1.barlen != 31) {
      $k[$j++] = "bwipp.onecodeInvalidLength#10997";
      $k[$j++] = "The data must be 20, 25, 29 or 31 digits";
      bwipp_raiseerror();
    }
    $k[$j++] = Infinity;
    var _B = $eq($geti($1.barcode, 5, 1), "9") ? 14 : 11;
    $k[$j++] = 2;
    $k[$j++] = 2;
    $k[$j++] = 5;
    $k[$j++] = 5;
    $k[$j++] = _B;
    $k[$j++] = _B;
    $k[$j++] = 20;
    $k[$j++] = 20;
    $k[$j++] = 25;
    $k[$j++] = 25;
    $k[$j++] = 29;
    $k[$j++] = 29;
    $1.txtdict = $d();
    $1.txt = $a($1.barlen + 6);
    $1.spacecnt = 0;
    for (var _H = 0, _G = $1.barlen - 1; _H <= _G; _H += 1) {
      $1.i = _H;
      var _K = $get($1.txtdict, $1.i) !== void 0;
      if (_K) {
        $put($1.txt, $1.i + $1.spacecnt, $a([" ", 0, 0, "", 0]));
        $1.spacecnt = $1.spacecnt + 1;
      }
      $put($1.txt, $1.i + $1.spacecnt, $a([$geti($1.barcode, $1.i, 1), 0, 0, "", 0]));
    }
    $1.txt = $geti($1.txt, 0, $1.barcode.length + $1.spacecnt);
    $1.normalize = function() {
      $1.base = $k[--$j];
      $1.num = $k[--$j];
      for (var _e = $1.num.length - 1; _e >= 1; _e -= 1) {
        $1.i = _e;
        var _f = $1.num;
        var _g = $1.i;
        $put(_f, _g - 1, $f($get(_f, _g - 1) + ~~($get($1.num, $1.i) / $1.base)));
        $put($1.num, $1.i, $get($1.num, $1.i) % $1.base);
      }
      for (; ; ) {
        if ($lt($get($1.num, 0), $1.base)) {
          break;
        }
        $k[$j++] = Infinity;
        $k[$j++] = 0;
        $aload($1.num);
        $1.num = $a();
        $put($1.num, 0, $f($get($1.num, 0) + ~~($get($1.num, 1) / $1.base)));
        $put($1.num, 1, $get($1.num, 1) % $1.base);
      }
      $k[$j++] = Infinity;
      $1.i = true;
      var _17 = $1.num;
      for (var _18 = 0, _19 = _17.length; _18 < _19; _18++) {
        var _1A = $get(_17, _18);
        $k[$j++] = _1A;
        if (_1A == 0 && $1.i) {
          $j--;
        } else {
          $1.i = false;
        }
      }
      $1.num = $a();
      if ($1.num.length == 0) {
        $1.num = $a([0]);
      }
      $k[$j++] = $1.num;
    };
    $1.bigadd = function() {
      var _1G = $k[--$j];
      var _1H = $k[--$j];
      $1.offset = Math.abs(_1G.length - _1H.length);
      if (_1G.length < _1H.length) {
        var _ = _1G;
        _1G = _1H;
        _1H = _;
      }
      $1.a = _1G;
      $1.b = _1H;
      for (var _1K = 0, _1J = $1.b.length - 1; _1K <= _1J; _1K += 1) {
        var _1L = $1.a;
        var _1M = $1.offset;
        $put(_1L, _1K + _1M, $f($get(_1L, _1K + _1M) + $get($1.b, _1K)));
      }
      $k[$j++] = $1.a;
    };
    if (!bwipp_onecode.__11060__) {
      (function() {
        var $ctx = Object.create($1);
        var _1V = /* @__PURE__ */ new Map([
          [20, $a([0])],
          [25, $a([1])],
          [29, $a([1, 0, 0, 0, 0, 1])],
          [31, $a([1, 0, 0, 0, 1, 0, 0, 0, 0, 1])]
        ]);
        $ctx.startvals = _1V;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_onecode.$ctx[id] = $ctx[id]);
        bwipp_onecode.__11060__ = 1;
      })();
    }
    $k[$j++] = "binval";
    $k[$j++] = $get($1.startvals, $1.barlen);
    $k[$j++] = Infinity;
    var _1c = $geti($1.barcode, 20, $1.barlen - 20);
    for (var _1d = 0, _1e = _1c.length; _1d < _1e; _1d++) {
      $k[$j++] = $f($get(_1c, _1d) - 48);
    }
    var _1g = $a();
    $k[$j++] = _1g;
    $1.bigadd();
    var _1h = $k[--$j];
    $1[$k[--$j]] = _1h;
    $k[$j++] = Infinity;
    $aload($1.binval);
    $k[$j++] = $f($get($1.barcode, 0) - 48);
    $1.binval = $a();
    $k[$j++] = Infinity;
    var _1n = $1.binval;
    for (var _1o = 0, _1p = _1n.length; _1o < _1p; _1o++) {
      $k[$j++] = $get(_1n, _1o) * 5;
    }
    var _1r = $a();
    $k[$j++] = "binval";
    $k[$j++] = _1r;
    $k[$j++] = $a([$f($get($1.barcode, 1) - 48)]);
    $1.bigadd();
    $k[$j++] = 10;
    $1.normalize();
    var _1v = $k[--$j];
    $1[$k[--$j]] = _1v;
    $k[$j++] = Infinity;
    $aload($1.binval);
    var _1z = $geti($1.barcode, 2, 18);
    for (var _20 = 0, _21 = _1z.length; _20 < _21; _20++) {
      $k[$j++] = $f($get(_1z, _20) - 48);
    }
    $1.binval = $a();
    $1.bytes = $a(13);
    var _25 = $1.binval;
    $1.bintmp = $arrcpy($a(_25.length), _25);
    for (var _28 = 12; _28 >= 0; _28 -= 1) {
      $1.i = _28;
      for (var _2B = 0, _2A = $1.bintmp.length - 2; _2B <= _2A; _2B += 1) {
        $1.j = _2B;
        var _2C = $1.bintmp;
        var _2D = $1.j;
        $put(_2C, _2D + 1, $f($get(_2C, _2D + 1) + $get($1.bintmp, $1.j) % 256 * 10));
        $put($1.bintmp, $1.j, ~~($get($1.bintmp, $1.j) / 256));
      }
      $put($1.bytes, $1.i, $get($1.bintmp, $1.bintmp.length - 1) % 256);
      var _2S = $1.bintmp;
      var _2T = $1.bintmp;
      $put(_2S, _2T.length - 1, ~~($get(_2S, _2T.length - 1) / 256));
    }
    $1.fcs = 2047;
    $1.dat = $get($1.bytes, 0) << 5;
    for (var _2X = 0, _2Y = 6; _2X < _2Y; _2X++) {
      if ((($1.fcs ^ $1.dat) & 1024) != 0) {
        $1.fcs = $1.fcs << 1 ^ 3893;
      } else {
        $1.fcs = $1.fcs << 1;
      }
      $1.fcs = $1.fcs & 2047;
      $1.dat = $1.dat << 1;
    }
    for (var _2f = 1; _2f <= 12; _2f += 1) {
      $1.dat = $get($1.bytes, _2f) << 3;
      for (var _2i = 0, _2j = 8; _2i < _2j; _2i++) {
        if ((($1.fcs ^ $1.dat) & 1024) != 0) {
          $1.fcs = $1.fcs << 1 ^ 3893;
        } else {
          $1.fcs = $1.fcs << 1;
        }
        $1.fcs = $1.fcs & 2047;
        $1.dat = $1.dat << 1;
      }
    }
    $1.codewords = $a(10);
    for (var _2r = 9; _2r >= 0; _2r -= 1) {
      $1.i = _2r;
      var _2t = $1.i == 9 ? 636 : 1365;
      $1.b = _2t;
      for (var _2w = 0, _2v = $1.binval.length - 2; _2w <= _2v; _2w += 1) {
        $1.j = _2w;
        var _2x = $1.binval;
        var _2y = $1.j;
        $put(_2x, _2y + 1, $f($get(_2x, _2y + 1) + $get($1.binval, $1.j) % $1.b * 10));
        $put($1.binval, $1.j, ~~($get($1.binval, $1.j) / $1.b));
      }
      $put($1.codewords, $1.i, $get($1.binval, $1.binval.length - 1) % $1.b);
      var _3G = $1.binval;
      var _3H = $1.binval;
      $put(_3G, _3H.length - 1, ~~($get(_3G, _3H.length - 1) / $1.b));
    }
    $put($1.codewords, 9, $get($1.codewords, 9) * 2);
    if (($1.fcs & 1024) != 0) {
      $put($1.codewords, 0, $f($get($1.codewords, 0) + 659));
    }
    if (!bwipp_onecode.__11225__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.tab513 = $a([31, 7936, 47, 7808, 55, 7552, 59, 7040, 61, 6016, 62, 3968, 79, 7744, 87, 7488, 91, 6976, 93, 5952, 94, 3904, 103, 7360, 107, 6848, 109, 5824, 110, 3776, 115, 6592, 117, 5568, 118, 3520, 121, 5056, 122, 3008, 124, 1984, 143, 7712, 151, 7456, 155, 6944, 157, 5920, 158, 3872, 167, 7328, 171, 6816, 173, 5792, 174, 3744, 179, 6560, 181, 5536, 182, 3488, 185, 5024, 186, 2976, 188, 1952, 199, 7264, 203, 6752, 205, 5728, 206, 3680, 211, 6496, 213, 5472, 214, 3424, 217, 4960, 218, 2912, 220, 1888, 227, 6368, 229, 5344, 230, 3296, 233, 4832, 234, 2784, 236, 1760, 241, 4576, 242, 2528, 244, 1504, 248, 992, 271, 7696, 279, 7440, 283, 6928, 285, 5904, 286, 3856, 295, 7312, 299, 6800, 301, 5776, 302, 3728, 307, 6544, 309, 5520, 310, 3472, 313, 5008, 314, 2960, 316, 1936, 327, 7248, 331, 6736, 333, 5712, 334, 3664, 339, 6480, 341, 5456, 342, 3408, 345, 4944, 346, 2896, 348, 1872, 355, 6352, 357, 5328, 358, 3280, 361, 4816, 362, 2768, 364, 1744, 369, 4560, 370, 2512, 372, 1488, 376, 976, 391, 7216, 395, 6704, 397, 5680, 398, 3632, 403, 6448, 405, 5424, 406, 3376, 409, 4912, 410, 2864, 412, 1840, 419, 6320, 421, 5296, 422, 3248, 425, 4784, 426, 2736, 428, 1712, 433, 4528, 434, 2480, 436, 1456, 440, 944, 451, 6256, 453, 5232, 454, 3184, 457, 4720, 458, 2672, 460, 1648, 465, 4464, 466, 2416, 468, 1392, 472, 880, 481, 4336, 482, 2288, 484, 1264, 488, 752, 527, 7688, 535, 7432, 539, 6920, 541, 5896, 542, 3848, 551, 7304, 555, 6792, 557, 5768, 558, 3720, 563, 6536, 565, 5512, 566, 3464, 569, 5e3, 570, 2952, 572, 1928, 583, 7240, 587, 6728, 589, 5704, 590, 3656, 595, 6472, 597, 5448, 598, 3400, 601, 4936, 602, 2888, 604, 1864, 611, 6344, 613, 5320, 614, 3272, 617, 4808, 618, 2760, 620, 1736, 625, 4552, 626, 2504, 628, 1480, 632, 968, 647, 7208, 651, 6696, 653, 5672, 654, 3624, 659, 6440, 661, 5416, 662, 3368, 665, 4904, 666, 2856, 668, 1832, 675, 6312, 677, 5288, 678, 3240, 681, 4776, 682, 2728, 684, 1704, 689, 4520, 690, 2472, 692, 1448, 696, 936, 707, 6248, 709, 5224, 710, 3176, 713, 4712, 714, 2664, 716, 1640, 721, 4456, 722, 2408, 724, 1384, 728, 872, 737, 4328, 738, 2280, 740, 1256, 775, 7192, 779, 6680, 781, 5656, 782, 3608, 787, 6424, 789, 5400, 790, 3352, 793, 4888, 794, 2840, 796, 1816, 803, 6296, 805, 5272, 806, 3224, 809, 4760, 810, 2712, 812, 1688, 817, 4504, 818, 2456, 820, 1432, 824, 920, 835, 6232, 837, 5208, 838, 3160, 841, 4696, 842, 2648, 844, 1624, 849, 4440, 850, 2392, 852, 1368, 865, 4312, 866, 2264, 868, 1240, 899, 6200, 901, 5176, 902, 3128, 905, 4664, 906, 2616, 908, 1592, 913, 4408, 914, 2360, 916, 1336, 929, 4280, 930, 2232, 932, 1208, 961, 4216, 962, 2168, 964, 1144, 1039, 7684, 1047, 7428, 1051, 6916, 1053, 5892, 1054, 3844, 1063, 7300, 1067, 6788, 1069, 5764, 1070, 3716, 1075, 6532, 1077, 5508, 1078, 3460, 1081, 4996, 1082, 2948, 1084, 1924, 1095, 7236, 1099, 6724, 1101, 5700, 1102, 3652, 1107, 6468, 1109, 5444, 1110, 3396, 1113, 4932, 1114, 2884, 1116, 1860, 1123, 6340, 1125, 5316, 1126, 3268, 1129, 4804, 1130, 2756, 1132, 1732, 1137, 4548, 1138, 2500, 1140, 1476, 1159, 7204, 1163, 6692, 1165, 5668, 1166, 3620, 1171, 6436, 1173, 5412, 1174, 3364, 1177, 4900, 1178, 2852, 1180, 1828, 1187, 6308, 1189, 5284, 1190, 3236, 1193, 4772, 1194, 2724, 1196, 1700, 1201, 4516, 1202, 2468, 1204, 1444, 1219, 6244, 1221, 5220, 1222, 3172, 1225, 4708, 1226, 2660, 1228, 1636, 1233, 4452, 1234, 2404, 1236, 1380, 1249, 4324, 1250, 2276, 1287, 7188, 1291, 6676, 1293, 5652, 1294, 3604, 1299, 6420, 1301, 5396, 1302, 3348, 1305, 4884, 1306, 2836, 1308, 1812, 1315, 6292, 1317, 5268, 1318, 3220, 1321, 4756, 1322, 2708, 1324, 1684, 1329, 4500, 1330, 2452, 1332, 1428, 1347, 6228, 1349, 5204, 1350, 3156, 1353, 4692, 1354, 2644, 1356, 1620, 1361, 4436, 1362, 2388, 1377, 4308, 1378, 2260, 1411, 6196, 1413, 5172, 1414, 3124, 1417, 4660, 1418, 2612, 1420, 1588, 1425, 4404, 1426, 2356, 1441, 4276, 1442, 2228, 1473, 4212, 1474, 2164, 1543, 7180, 1547, 6668, 1549, 5644, 1550, 3596, 1555, 6412, 1557, 5388, 1558, 3340, 1561, 4876, 1562, 2828, 1564, 1804, 1571, 6284, 1573, 5260, 1574, 3212, 1577, 4748, 1578, 2700, 1580, 1676, 1585, 4492, 1586, 2444, 1603, 6220, 1605, 5196, 1606, 3148, 1609, 4684, 1610, 2636, 1617, 4428, 1618, 2380, 1633, 4300, 1634, 2252, 1667, 6188, 1669, 5164, 1670, 3116, 1673, 4652, 1674, 2604, 1681, 4396, 1682, 2348, 1697, 4268, 1698, 2220, 1729, 4204, 1730, 2156, 1795, 6172, 1797, 5148, 1798, 3100, 1801, 4636, 1802, 2588, 1809, 4380, 1810, 2332, 1825, 4252, 1826, 2204, 1857, 4188, 1858, 2140, 1921, 4156, 1922, 2108, 2063, 7682, 2071, 7426, 2075, 6914, 2077, 5890, 2078, 3842, 2087, 7298, 2091, 6786, 2093, 5762, 2094, 3714, 2099, 6530, 2101, 5506, 2102, 3458, 2105, 4994, 2106, 2946, 2119, 7234, 2123, 6722, 2125, 5698, 2126, 3650, 2131, 6466, 2133, 5442, 2134, 3394, 2137, 4930, 2138, 2882, 2147, 6338, 2149, 5314, 2150, 3266, 2153, 4802, 2154, 2754, 2161, 4546, 2162, 2498, 2183, 7202, 2187, 6690, 2189, 5666, 2190, 3618, 2195, 6434, 2197, 5410, 2198, 3362, 2201, 4898, 2202, 2850, 2211, 6306, 2213, 5282, 2214, 3234, 2217, 4770, 2218, 2722, 2225, 4514, 2226, 2466, 2243, 6242, 2245, 5218, 2246, 3170, 2249, 4706, 2250, 2658, 2257, 4450, 2258, 2402, 2273, 4322, 2311, 7186, 2315, 6674, 2317, 5650, 2318, 3602, 2323, 6418, 2325, 5394, 2326, 3346, 2329, 4882, 2330, 2834, 2339, 6290, 2341, 5266, 2342, 3218, 2345, 4754, 2346, 2706, 2353, 4498, 2354, 2450, 2371, 6226, 2373, 5202, 2374, 3154, 2377, 4690, 2378, 2642, 2385, 4434, 2401, 4306, 2435, 6194, 2437, 5170, 2438, 3122, 2441, 4658, 2442, 2610, 2449, 4402, 2465, 4274, 2497, 4210, 2567, 7178, 2571, 6666, 2573, 5642, 2574, 3594, 2579, 6410, 2581, 5386, 2582, 3338, 2585, 4874, 2586, 2826, 2595, 6282, 2597, 5258, 2598, 3210, 2601, 4746, 2602, 2698, 2609, 4490, 2627, 6218, 2629, 5194, 2630, 3146, 2633, 4682, 2641, 4426, 2657, 4298, 2691, 6186, 2693, 5162, 2694, 3114, 2697, 4650, 2705, 4394, 2721, 4266, 2753, 4202, 2819, 6170, 2821, 5146, 2822, 3098, 2825, 4634, 2833, 4378, 2849, 4250, 2881, 4186, 2945, 4154, 3079, 7174, 3083, 6662, 3085, 5638, 3086, 3590, 3091, 6406, 3093, 5382, 3094, 3334, 3097, 4870, 3107, 6278, 3109, 5254, 3110, 3206, 3113, 4742, 3121, 4486, 3139, 6214, 3141, 5190, 3145, 4678, 3153, 4422, 3169, 4294, 3203, 6182, 3205, 5158, 3209, 4646, 3217, 4390, 3233, 4262, 3265, 4198, 3331, 6166, 3333, 5142, 3337, 4630, 3345, 4374, 3361, 4246, 3393, 4182, 3457, 4150, 3587, 6158, 3589, 5134, 3593, 4622, 3601, 4366, 3617, 4238, 3649, 4174, 3713, 4142, 3841, 4126, 4111, 7681, 4119, 7425, 4123, 6913, 4125, 5889, 4135, 7297, 4139, 6785, 4141, 5761, 4147, 6529, 4149, 5505, 4153, 4993, 4167, 7233, 4171, 6721, 4173, 5697, 4179, 6465, 4181, 5441, 4185, 4929, 4195, 6337, 4197, 5313, 4201, 4801, 4209, 4545, 4231, 7201, 4235, 6689, 4237, 5665, 4243, 6433, 4245, 5409, 4249, 4897, 4259, 6305, 4261, 5281, 4265, 4769, 4273, 4513, 4291, 6241, 4293, 5217, 4297, 4705, 4305, 4449, 4359, 7185, 4363, 6673, 4365, 5649, 4371, 6417, 4373, 5393, 4377, 4881, 4387, 6289, 4389, 5265, 4393, 4753, 4401, 4497, 4419, 6225, 4421, 5201, 4425, 4689, 4483, 6193, 4485, 5169, 4489, 4657, 4615, 7177, 4619, 6665, 4621, 5641, 4627, 6409, 4629, 5385, 4633, 4873, 4643, 6281, 4645, 5257, 4649, 4745, 4675, 6217, 4677, 5193, 4739, 6185, 4741, 5161, 4867, 6169, 4869, 5145, 5127, 7173, 5131, 6661, 5133, 5637, 5139, 6405, 5141, 5381, 5155, 6277, 5157, 5253, 5187, 6213, 5251, 6181, 5379, 6165, 5635, 6157, 6151, 7171, 6155, 6659, 6163, 6403, 6179, 6275, 6211, 5189, 4681, 4433, 4321, 3142, 2634, 2386, 2274, 1612, 1364, 1252, 856, 744, 496]);
        $ctx.tab213 = $a([3, 6144, 5, 5120, 6, 3072, 9, 4608, 10, 2560, 12, 1536, 17, 4352, 18, 2304, 20, 1280, 24, 768, 33, 4224, 34, 2176, 36, 1152, 40, 640, 48, 384, 65, 4160, 66, 2112, 68, 1088, 72, 576, 80, 320, 96, 192, 129, 4128, 130, 2080, 132, 1056, 136, 544, 144, 288, 257, 4112, 258, 2064, 260, 1040, 264, 528, 513, 4104, 514, 2056, 516, 1032, 1025, 4100, 1026, 2052, 2049, 4098, 4097, 2050, 1028, 520, 272, 160]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_onecode.$ctx[id] = $ctx[id]);
        bwipp_onecode.__11225__ = 1;
      })();
    }
    $1.chars = $a(10);
    for (var _3V = 0; _3V <= 9; _3V += 1) {
      $1.i = _3V;
      var _3Y = $get($1.codewords, $1.i);
      $k[$j++] = _3Y;
      if (_3Y <= 1286) {
        var _3b = $get($1.tab513, $k[--$j]);
        $k[$j++] = _3b;
      } else {
        var _3e = $get($1.tab213, $f($k[--$j] - 1287));
        $k[$j++] = _3e;
      }
      $put($1.chars, $1.i, $k[--$j]);
    }
    for (var _3i = 9; _3i >= 0; _3i -= 1) {
      $1.i = _3i;
      if ((~~Math.pow(2, $1.i) & $1.fcs) != 0) {
        $put($1.chars, $1.i, $get($1.chars, $1.i) ^ 8191);
      }
    }
    if (!bwipp_onecode.__11262__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barmap = $a([7, 2, 4, 3, 1, 10, 0, 0, 9, 12, 2, 8, 5, 5, 6, 11, 8, 9, 3, 1, 0, 1, 5, 12, 2, 5, 1, 8, 4, 4, 9, 11, 6, 3, 8, 10, 3, 9, 7, 6, 5, 11, 1, 4, 8, 5, 2, 12, 9, 10, 0, 2, 7, 1, 6, 7, 3, 6, 4, 9, 0, 3, 8, 6, 6, 4, 2, 7, 1, 1, 9, 9, 7, 10, 5, 2, 4, 0, 3, 8, 6, 2, 0, 4, 8, 11, 1, 0, 9, 8, 3, 12, 2, 6, 7, 7, 5, 1, 4, 10, 1, 12, 6, 9, 7, 3, 8, 0, 5, 8, 9, 7, 4, 6, 2, 10, 3, 4, 0, 5, 8, 4, 5, 7, 7, 11, 1, 9, 6, 0, 9, 6, 0, 6, 4, 8, 2, 1, 3, 2, 5, 9, 8, 12, 4, 11, 6, 1, 9, 5, 7, 4, 3, 3, 1, 2, 0, 7, 2, 0, 1, 3, 4, 1, 6, 10, 3, 5, 8, 7, 9, 4, 2, 11, 5, 6, 0, 8, 7, 12, 4, 2, 8, 1, 5, 10, 3, 0, 9, 3, 0, 9, 6, 5, 2, 4, 7, 8, 1, 7, 5, 0, 4, 5, 2, 3, 0, 10, 6, 12, 9, 2, 3, 11, 1, 6, 8, 8, 7, 9, 5, 4, 0, 11, 1, 5, 2, 2, 9, 1, 4, 12, 8, 3, 6, 6, 7, 0, 3, 7, 4, 7, 7, 5, 0, 12, 1, 11, 2, 9, 9, 0, 6, 8, 5, 3, 3, 10, 8, 2]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_onecode.$ctx[id] = $ctx[id]);
        bwipp_onecode.__11262__ = 1;
      })();
    }
    $1.bbs = $a(65);
    $1.bhs = $a(65);
    for (var _3u = 0; _3u <= 64; _3u += 1) {
      $1.i = _3u;
      $1.dec = ($get($1.chars, $get($1.barmap, $1.i * 4)) & ~~Math.pow(2, $get($1.barmap, $1.i * 4 + 1))) != 0;
      $1.asc = ($get($1.chars, $get($1.barmap, $1.i * 4 + 2)) & ~~Math.pow(2, $get($1.barmap, $1.i * 4 + 3))) != 0;
      if (!$1.dec && !$1.asc) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 2 * $1.height / 8);
      }
      if (!$1.dec && $1.asc) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($1.dec && !$1.asc) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($1.dec && $1.asc) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 8 * $1.height / 8);
      }
    }
    $k[$j++] = Infinity;
    var _4h = $1.bbs;
    var _4i = $1.bhs;
    $k[$j++] = Infinity;
    for (var _4k = 0, _4l = $1.bhs.length - 1; _4k < _4l; _4k++) {
      $k[$j++] = 1.44;
      $k[$j++] = 1.872;
    }
    $k[$j++] = 1.44;
    var _4m = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bbs";
    $k[$j++] = _4h;
    $k[$j++] = "bhs";
    $k[$j++] = _4i;
    $k[$j++] = "sbs";
    $k[$j++] = _4m;
    $k[$j++] = "txt";
    $k[$j++] = $1.txt;
    $k[$j++] = "textxalign";
    $k[$j++] = "left";
    $k[$j++] = "textfont";
    $k[$j++] = "OCR-B";
    $k[$j++] = "textyoffset";
    $k[$j++] = 1;
    $k[$j++] = "textxoffset";
    $k[$j++] = -0.3;
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _4p = $d();
    $k[$j++] = _4p;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_postnet() {
    var $1 = Object.create(bwipp_postnet.$ctx || (bwipp_postnet.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.validatecheck = false;
    $1.includecheckintext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 0.125;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _4 = $k[--$j];
      $k[$j++] = $f(_4 - 1);
    }
    var _5 = $k[--$j];
    $1[$k[--$j]] = _5;
    if ($1.barlen != 5 && $1.barlen != 9 && $1.barlen != 11) {
      $k[$j++] = "bwipp.postnetBadLength#11357";
      $k[$j++] = "USPS POSTNET must be 5, 9 or 11 digits excluding check digit";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _B = $k[--$j];
      if (_B < 48 || _B > 57) {
        $k[$j++] = "bwipp.postnetBadCharacter#11361";
        $k[$j++] = "USPS POSTNET must contain only digits";
        bwipp_raiseerror();
      }
    });
    if (!bwipp_postnet.__11375__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789";
        $ctx.encs = $a(["55222", "22255", "22525", "22552", "25225", "25252", "25522", "52225", "52252", "52522", "5", "5"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_postnet.$ctx[id] = $ctx[id]);
        bwipp_postnet.__11375__ = 1;
      })();
    }
    $1.checksum = 0;
    for (var _G = 0, _F = $f($1.barlen - 1); _G <= _F; _G += 1) {
      $1.i = _G;
      $1.checksum = $f($1.checksum + $f($get($1.barcode, $1.i) - 48));
    }
    $1.checksum = $f(10 - $1.checksum % 10) % 10;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.postnetBadCheckDigit#11385";
        $k[$j++] = "Incorrect USPS POSTNET check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    $1.bhs = $a($f($1.barlen * 5 + 7));
    $1.txt = $a($f($1.barlen + 1));
    $1.enc = $get($1.encs, 10);
    $1.heights = $a($1.enc.length);
    for (var _g = 0, _f = $1.enc.length - 1; _g <= _f; _g += 1) {
      $1.j = _g;
      $put($1.heights, $1.j, $cvi($geti($1.enc, $1.j, 1)) * $1.height / 5);
    }
    $puti($1.bhs, 0, $1.heights);
    for (var _r = 0, _q = $f($1.barlen - 1); _r <= _q; _r += 1) {
      $1.i = _r;
      $1.enc = $get($1.encs, $f($get($1.barcode, $1.i) - 48));
      $1.heights = $a($1.enc.length);
      for (var _11 = 0, _10 = $1.enc.length - 1; _11 <= _10; _11 += 1) {
        $1.j = _11;
        $put($1.heights, $1.j, $cvi($geti($1.enc, $1.j, 1)) * $1.height / 5);
      }
      $puti($1.bhs, $1.i * 5 + 1, $1.heights);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.i * 5 + 1) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $1.enc = $get($1.encs, $1.checksum);
    $1.heights = $a($1.enc.length);
    for (var _1S = 0, _1R = $1.enc.length - 1; _1S <= _1R; _1S += 1) {
      $1.j = _1S;
      $put($1.heights, $1.j, $cvi($geti($1.enc, $1.j, 1)) * $1.height / 5);
    }
    $puti($1.bhs, $f($1.barlen * 5 + 1), $1.heights);
    if ($1.includecheckintext) {
      $put($1.txt, $1.barlen, $a([$geti($1.barchars, $1.checksum, 1), $f($1.barlen * 5 + 1) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    } else {
      $put($1.txt, $1.barlen, $a([" ", $f($1.barlen * 5 + 1) * 72 / 25, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $1.enc = $get($1.encs, 11);
    $1.heights = $a($1.enc.length);
    for (var _20 = 0, _1z = $1.enc.length - 1; _20 <= _1z; _20 += 1) {
      $1.j = _20;
      $put($1.heights, $1.j, $cvi($geti($1.enc, $1.j, 1)) * $1.height / 5);
    }
    $puti($1.bhs, $f($1.barlen * 5 + 6), $1.heights);
    $k[$j++] = Infinity;
    var _2A = $1.bhs;
    $k[$j++] = Infinity;
    for (var _2C = 0, _2D = $1.bhs.length; _2C < _2D; _2C++) {
      $k[$j++] = 0;
    }
    var _2E = $a();
    $k[$j++] = Infinity;
    for (var _2G = 0, _2H = $1.bhs.length - 1; _2G < _2H; _2G++) {
      $k[$j++] = 1.44;
      $k[$j++] = 1.872;
    }
    $k[$j++] = 1.44;
    var _2I = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bhs";
    $k[$j++] = _2A;
    $k[$j++] = "bbs";
    $k[$j++] = _2E;
    $k[$j++] = "sbs";
    $k[$j++] = _2I;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2M = $d();
    $k[$j++] = _2M;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_planet() {
    var $1 = Object.create(bwipp_planet.$ctx || (bwipp_planet.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.validatecheck = false;
    $1.includecheckintext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 0.125;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _4 = $k[--$j];
      $k[$j++] = $f(_4 - 1);
    }
    var _5 = $k[--$j];
    $1[$k[--$j]] = _5;
    if ($1.barlen != 11 && $1.barlen != 13) {
      $k[$j++] = "bwipp.planetBadLength#11505";
      $k[$j++] = "USPS PLANET must be 11 or 13 digits excluding check digit";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _A = $k[--$j];
      if (_A < 48 || _A > 57) {
        $k[$j++] = "bwipp.planetBadCharacter#11509";
        $k[$j++] = "USPS PLANET must contain only digits";
        bwipp_raiseerror();
      }
    });
    if (!bwipp_planet.__11523__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789";
        $ctx.encs = $a(["22555", "55522", "55252", "55225", "52552", "52525", "52255", "25552", "25525", "25255", "5", "5"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_planet.$ctx[id] = $ctx[id]);
        bwipp_planet.__11523__ = 1;
      })();
    }
    $1.checksum = 0;
    for (var _F = 0, _E = $f($1.barlen - 1); _F <= _E; _F += 1) {
      $1.i = _F;
      $1.checksum = $f($1.checksum + $f($get($1.barcode, $1.i) - 48));
    }
    $1.checksum = $f(10 - $1.checksum % 10) % 10;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.planetBadCheckDigit#11534";
        $k[$j++] = "Incorrect USPS PLANET check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    $1.bhs = $a($f($1.barlen * 5 + 7));
    $1.txt = $a($f($1.barlen + 1));
    $1.enc = $get($1.encs, 10);
    $1.heights = $a($1.enc.length);
    for (var _f = 0, _e = $1.enc.length - 1; _f <= _e; _f += 1) {
      $1.j = _f;
      $put($1.heights, $1.j, $cvi($geti($1.enc, $1.j, 1)) * $1.height / 5);
    }
    $puti($1.bhs, 0, $1.heights);
    for (var _q = 0, _p = $f($1.barlen - 1); _q <= _p; _q += 1) {
      $1.i = _q;
      $1.enc = $get($1.encs, $f($get($1.barcode, $1.i) - 48));
      $1.heights = $a($1.enc.length);
      for (var _10 = 0, _z = $1.enc.length - 1; _10 <= _z; _10 += 1) {
        $1.j = _10;
        $put($1.heights, $1.j, $cvi($geti($1.enc, $1.j, 1)) * $1.height / 5);
      }
      $puti($1.bhs, $1.i * 5 + 1, $1.heights);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.i * 5 + 1) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $1.enc = $get($1.encs, $1.checksum);
    $1.heights = $a($1.enc.length);
    for (var _1R = 0, _1Q = $1.enc.length - 1; _1R <= _1Q; _1R += 1) {
      $1.j = _1R;
      $put($1.heights, $1.j, $cvi($geti($1.enc, $1.j, 1)) * $1.height / 5);
    }
    $puti($1.bhs, $f($1.barlen * 5 + 1), $1.heights);
    if ($1.includecheckintext) {
      $put($1.txt, $1.barlen, $a([$geti($1.barchars, $1.checksum, 1), $f($1.barlen * 5 + 1) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    } else {
      $put($1.txt, $1.barlen, $a([" ", $f($1.barlen * 5 + 1) * 72 / 25, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $1.enc = $get($1.encs, 11);
    $1.heights = $a($1.enc.length);
    for (var _1z = 0, _1y = $1.enc.length - 1; _1z <= _1y; _1z += 1) {
      $1.j = _1z;
      $put($1.heights, $1.j, $cvi($geti($1.enc, $1.j, 1)) * $1.height / 5);
    }
    $puti($1.bhs, $f($1.barlen * 5 + 6), $1.heights);
    $k[$j++] = Infinity;
    var _29 = $1.bhs;
    $k[$j++] = Infinity;
    for (var _2B = 0, _2C = $1.bhs.length; _2B < _2C; _2B++) {
      $k[$j++] = 0;
    }
    var _2D = $a();
    $k[$j++] = Infinity;
    for (var _2F = 0, _2G = $1.bhs.length - 1; _2F < _2G; _2F++) {
      $k[$j++] = 1.44;
      $k[$j++] = 1.872;
    }
    $k[$j++] = 1.44;
    var _2H = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bhs";
    $k[$j++] = _29;
    $k[$j++] = "bbs";
    $k[$j++] = _2D;
    $k[$j++] = "sbs";
    $k[$j++] = _2H;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2L = $d();
    $k[$j++] = _2L;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_royalmail() {
    var $1 = Object.create(bwipp_royalmail.$ctx || (bwipp_royalmail.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.validatecheck = false;
    $1.includecheckintext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 0.175;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    var _1 = $k[--$j];
    $1.barcode = _1;
    if (!bwipp_royalmail.__11666__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 35; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        $ctx.encs = $a(["3300", "2211", "2301", "2310", "3201", "3210", "1122", "0033", "0123", "0132", "1023", "1032", "1302", "0213", "0303", "0312", "1203", "1212", "1320", "0231", "0321", "0330", "1221", "1230", "3102", "2013", "2103", "2112", "3003", "3012", "3120", "2031", "2121", "2130", "3021", "3030", "2", "3"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_royalmail.$ctx[id] = $ctx[id]);
        bwipp_royalmail.__11666__ = 1;
      })();
    }
    for (var _A = 0, _9 = $1.barcode.length - 1; _A <= _9; _A += 1) {
      var _E = $get($1.charvals, $geti($1.barcode, _A, 1)) !== void 0;
      if (!_E) {
        $k[$j++] = "bwipp.royalmailBadCharacter#11671";
        $k[$j++] = "RM4SCC must contain only capital letters and digits";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _H = $k[--$j];
      $k[$j++] = $f(_H - 1);
    }
    var _I = $k[--$j];
    $1[$k[--$j]] = _I;
    $1.checksumrow = 0;
    $1.checksumcol = 0;
    for (var _M = 0, _L = $f($1.barlen - 1); _M <= _L; _M += 1) {
      $1.i = _M;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $1.checksumrow = $1.checksumrow + ~~($1.indx / 6);
      $1.checksumcol = $f($1.checksumcol + $1.indx % 6);
    }
    $1.checksum = $f($1.checksumrow % 6 * 6 + $1.checksumcol % 6);
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.royalmailBadCheckDigit#11688";
        $k[$j++] = "Incorrect RM4SCC check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    $1.encstr = $s($f($1.barlen * 4 + 6));
    $1.txt = $a($f($1.barlen + 1));
    $puti($1.encstr, 0, $get($1.encs, 36));
    for (var _r = 0, _q = $f($1.barlen - 1); _r <= _q; _r += 1) {
      $1.i = _r;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $puti($1.encstr, $1.i * 4 + 1, $get($1.encs, $1.indx));
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.i * 4 + 1) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $puti($1.encstr, $f($1.barlen * 4 + 1), $get($1.encs, $1.checksum));
    if ($1.includecheckintext) {
      $put($1.txt, $1.barlen, $a([$geti($1.barchars, $1.checksum, 1), $f($1.barlen * 4 + 1) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    } else {
      $put($1.txt, $1.barlen, $a([" ", $f($1.barlen * 4 + 1) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $puti($1.encstr, $f($1.barlen * 4 + 5), $get($1.encs, 37));
    $1.bbs = $a($1.encstr.length);
    $1.bhs = $a($1.encstr.length);
    for (var _1j = 0, _1i = $1.encstr.length - 1; _1j <= _1i; _1j += 1) {
      $1.i = _1j;
      $1.enc = $geti($1.encstr, $1.i, 1);
      if ($eq($1.enc, "0")) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 2 * $1.height / 8);
      }
      if ($eq($1.enc, "1")) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($eq($1.enc, "2")) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($eq($1.enc, "3")) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 8 * $1.height / 8);
      }
    }
    $k[$j++] = Infinity;
    var _2F = $1.bbs;
    var _2G = $1.bhs;
    $k[$j++] = Infinity;
    for (var _2I = 0, _2J = $1.bhs.length - 1; _2I < _2J; _2I++) {
      $k[$j++] = 1.44;
      $k[$j++] = 1.872;
    }
    $k[$j++] = 1.44;
    var _2K = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bbs";
    $k[$j++] = _2F;
    $k[$j++] = "bhs";
    $k[$j++] = _2G;
    $k[$j++] = "sbs";
    $k[$j++] = _2K;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2O = $d();
    $k[$j++] = _2O;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_auspost() {
    var $1 = Object.create(bwipp_auspost.$ctx || (bwipp_auspost.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 0.175;
    $1.custinfoenc = "character";
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($ne($1.custinfoenc, "character") && $ne($1.custinfoenc, "numeric")) {
      $k[$j++] = "bwipp.auspostBadCustinfoEncoding#11801";
      $k[$j++] = "Customer information encoding must be either character or numeric";
      bwipp_raiseerror();
    }
    if (!bwipp_auspost.__11827__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["000", "001", "002", "010", "011", "012", "020", "021", "022", "100", "101", "102", "110", "111", "112", "120", "121", "122", "200", "201", "202", "210", "211", "212", "220", "221", "222", "300", "301", "302", "310", "311", "312", "320", "321", "322", "023", "030", "031", "032", "033", "103", "113", "123", "130", "131", "132", "133", "203", "213", "223", "230", "231", "232", "233", "303", "313", "323", "330", "331", "332", "333", "003", "013", "00", "01", "02", "10", "11", "12", "20", "21", "22", "30", "13", "3"]);
        $ctx.barchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #";
        var _5 = /* @__PURE__ */ new Map([
          ["11", 37],
          ["45", 37],
          ["59", 52],
          ["62", 67]
        ]);
        $ctx.fcclen = _5;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_auspost.$ctx[id] = $ctx[id]);
        bwipp_auspost.__11827__ = 1;
      })();
    }
    $1.barlen = $1.barcode.length;
    $1.txt = $a($1.barlen - 2);
    $k[$j++] = $1.fcclen;
    if ($1.barlen >= 2) {
      $k[$j++] = $geti($1.barcode, 0, 2);
    } else {
      $k[$j++] = "";
    }
    var _E = $k[--$j];
    var _F = $k[--$j];
    var _G = $get(_F, _E) !== void 0;
    $k[$j++] = _F;
    $k[$j++] = _E;
    if (!_G) {
      $j -= 2;
      $k[$j++] = "bwipp.auspostBadFCC#11834";
      $k[$j++] = "Must begin with an FCC, either 11, 45, 59 or 62";
      bwipp_raiseerror();
    }
    var _H = $k[--$j];
    $1.encstr = $s($get($k[--$j], _H));
    $k[$j++] = true;
    for (var _L = 0, _M = 1; _L < _M; _L++) {
      if ($1.barlen < 10) {
        $j--;
        $k[$j++] = false;
        break;
      }
      var _P = $geti($1.barcode, 2, 8);
      for (var _Q = 0, _R = _P.length; _Q < _R; _Q++) {
        var _S = $get(_P, _Q);
        if (_S < 48 || _S > 57) {
          $j--;
          $k[$j++] = false;
          break;
        }
      }
    }
    if ($nt($k[--$j])) {
      $k[$j++] = "bwipp.auspostIncompleteDPID#11845";
      $k[$j++] = "The DPID must be 8 digits";
      bwipp_raiseerror();
    }
    var _W = $eq($1.custinfoenc, "numeric") ? 2 : 3;
    if (($1.barlen - 10) * _W > $1.encstr.length - 22 - 14) {
      $k[$j++] = "bwipp.auspostTooLong#11851";
      $k[$j++] = "The message is too long";
      bwipp_raiseerror();
    }
    $puti($1.encstr, 0, $get($1.encs, 74));
    for (var _b = 0; _b <= 1; _b += 1) {
      $1.i = _b;
      $puti($1.encstr, $1.i * 2 + 2, $get($1.encs, $cvi($geti($1.barcode, $1.i, 1)) + 64));
    }
    for (var _j = 2; _j <= 9; _j += 1) {
      $1.i = _j;
      $puti($1.encstr, $1.i * 2 + 2, $get($1.encs, $cvi($geti($1.barcode, $1.i, 1)) + 64));
      $put($1.txt, $1.i - 2, $a([$geti($1.barcode, $1.i, 1), (($1.i - 2) * 2 + 6) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    if ($eq($1.custinfoenc, "numeric")) {
      for (var _14 = 0, _13 = $1.barlen - 11; _14 <= _13; _14 += 1) {
        $1.i = _14;
        var _18 = $get($1.barcode, $1.i + 10);
        $k[$j++] = $1.encs;
        $k[$j++] = _18;
        if (_18 < 48 || _18 > 57) {
          $k[$j++] = "bwipp.auspostInvalidCustinfoDigit#11878";
          $k[$j++] = "The customer information data contains a non-digit character";
          bwipp_raiseerror();
        }
        var _19 = $k[--$j];
        $puti($1.encstr, $1.i * 2 + 22, $get($k[--$j], $f($f(_19 - 48) + 64)));
        $put($1.txt, $1.i + 8, $a([$geti($1.barcode, $1.i + 10, 1), ($1.i * 2 + 22) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
      }
      $1.ciflen = ($1.barlen - 10) * 2;
    } else {
      for (var _1R = 0, _1Q = $1.barlen - 11; _1R <= _1Q; _1R += 1) {
        $1.i = _1R;
        $search($1.barchars, $geti($1.barcode, $1.i + 10, 1));
        if ($nt($k[--$j])) {
          $j--;
          $k[$j++] = "bwipp.auspostInvalidCustinfoCharacter#11890";
          $k[$j++] = "The customer information contains an invalid character";
          bwipp_raiseerror();
        }
        $1.indx = $k[--$j].length;
        $j -= 2;
        $1.enc = $get($1.encs, $1.indx);
        $puti($1.encstr, $1.i * 3 + 22, $1.enc);
        $put($1.txt, $1.i + 8, $a([$geti($1.barcode, $1.i + 10, 1), ($1.i * 3 + 22) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
      }
      $1.ciflen = ($1.barlen - 10) * 3;
    }
    for (var _1s = 22 + $1.ciflen, _1r = $1.encstr.length - 14; _1s <= _1r; _1s += 1) {
      $puti($1.encstr, _1s, $get($1.encs, 75));
    }
    if (!bwipp_auspost.__11927__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.rstable = $a(64 * 64);
        $k[$j++] = $ctx.rstable;
        $k[$j++] = 0;
        $k[$j++] = Infinity;
        for (var _1y = 0, _1z = 64; _1y < _1z; _1y++) {
          $k[$j++] = 0;
        }
        var _20 = $a();
        var _21 = $k[--$j];
        $puti($k[--$j], _21, _20);
        $k[$j++] = $ctx.rstable;
        $k[$j++] = 64;
        $k[$j++] = Infinity;
        for (var _24 = 0; _24 <= 63; _24 += 1) {
          $k[$j++] = _24;
        }
        var _25 = $a();
        var _26 = $k[--$j];
        $puti($k[--$j], _26, _25);
        $ctx.prev = 1;
        for (var _28 = 0, _29 = 64; _28 < _29; _28++) {
          $ctx.next = $ctx.prev << 1;
          if (($ctx.next & 64) != 0) {
            $ctx.next = $ctx.next ^ 67;
          }
          for (var _2D = 0; _2D <= 63; _2D += 1) {
            $ctx.j = _2D;
            $ctx.nextcell = function() {
              $k[$j++] = $ctx.rstable;
              $k[$j++] = 64 * $ctx.next + $ctx.j;
            };
            $ctx.nextcell();
            var _2L = $k[--$j];
            $put($k[--$j], _2L, $get($ctx.rstable, 64 * $ctx.prev + $ctx.j) << 1);
            $ctx.nextcell();
            var _2N = $k[--$j];
            if (($get($k[--$j], _2N) & 64) != 0) {
              $ctx.nextcell();
              $ctx.nextcell();
              var _2Q = $k[--$j];
              var _2S = $get($k[--$j], _2Q);
              var _2T = $k[--$j];
              $put($k[--$j], _2T, _2S ^ 67);
            }
          }
          $ctx.prev = $ctx.next;
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_auspost.$ctx[id] = $ctx[id]);
        bwipp_auspost.__11927__ = 1;
      })();
    }
    $1.rscodes = $a(~~(($1.encstr.length - 16) / 3) + 4);
    $k[$j++] = $1.rscodes;
    $k[$j++] = 0;
    $k[$j++] = Infinity;
    for (var _2a = 0, _2b = 4; _2a < _2b; _2a++) {
      $k[$j++] = 0;
    }
    var _2c = $a();
    var _2d = $k[--$j];
    $puti($k[--$j], _2d, _2c);
    for (var _2h = 2, _2g = $1.encstr.length - 16; _2h <= _2g; _2h += 3) {
      $1.i = _2h;
      $put($1.rscodes, $1.rscodes.length - ~~(($1.i - 2) / 3) - 1, $cvi($geti($1.encstr, $1.i, 1)) * 16 + $cvi($geti($1.encstr, $1.i + 1, 1)) * 4 + $cvi($geti($1.encstr, $1.i + 2, 1)));
    }
    for (var _2v = $1.rscodes.length - 5; _2v >= 0; _2v -= 1) {
      $1.i = _2v;
      for (var _2w = 0; _2w <= 4; _2w += 1) {
        $1.j = _2w;
        $put($1.rscodes, $1.i + $1.j, $xo($get($1.rscodes, $1.i + $1.j), $get($1.rstable, $f(64 * $get($a([48, 17, 29, 30, 1]), $1.j) + $get($1.rscodes, $1.i + 4)))));
      }
    }
    $1.checkcode = $strcpy($s(12), "000000000000");
    for (var _3E = 0; _3E <= 3; _3E += 1) {
      $1.i = _3E;
      $1.enc = $cvrs($s(3), $get($1.rscodes, 3 - $1.i), 4);
      $puti($1.checkcode, $1.i * 3 + (3 - $1.enc.length), $1.enc);
    }
    $puti($1.encstr, $1.encstr.length - 14, $1.checkcode);
    $puti($1.encstr, $1.encstr.length - 2, $get($1.encs, 74));
    $1.bbs = $a($1.encstr.length);
    $1.bhs = $a($1.encstr.length);
    for (var _3b = 0, _3a = $1.encstr.length - 1; _3b <= _3a; _3b += 1) {
      $1.i = _3b;
      $1.enc = $geti($1.encstr, $1.i, 1);
      if ($eq($1.enc, "0")) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 8 * $1.height / 8);
      }
      if ($eq($1.enc, "1")) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($eq($1.enc, "2")) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($eq($1.enc, "3")) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 2 * $1.height / 8);
      }
    }
    $k[$j++] = Infinity;
    var _47 = $1.bbs;
    var _48 = $1.bhs;
    $k[$j++] = Infinity;
    for (var _4A = 0, _4B = $1.bhs.length - 1; _4A < _4B; _4A++) {
      $k[$j++] = 1.44;
      $k[$j++] = 1.872;
    }
    $k[$j++] = 1.44;
    var _4C = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bbs";
    $k[$j++] = _47;
    $k[$j++] = "bhs";
    $k[$j++] = _48;
    $k[$j++] = "sbs";
    $k[$j++] = _4C;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _4G = $d();
    $k[$j++] = _4G;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_kix() {
    var $1 = Object.create(bwipp_kix.$ctx || (bwipp_kix.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 0.175;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    var _1 = $k[--$j];
    $1.barcode = _1;
    if (!bwipp_kix.__12059__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["0033", "0123", "0132", "1023", "1032", "1122", "0213", "0303", "0312", "1203", "1212", "1302", "0231", "0321", "0330", "1221", "1230", "1320", "2013", "2103", "2112", "3003", "3012", "3102", "2031", "2121", "2130", "3021", "3030", "3120", "2211", "2301", "2310", "3201", "3210", "3300"]);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _3 = 0; _3 <= 35; _3 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _3, 1), _3);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_kix.$ctx[id] = $ctx[id]);
        bwipp_kix.__12059__ = 1;
      })();
    }
    for (var _A = 0, _9 = $1.barcode.length - 1; _A <= _9; _A += 1) {
      var _E = $get($1.charvals, $geti($1.barcode, _A, 1)) !== void 0;
      if (!_E) {
        $k[$j++] = "bwipp.kixBadCharacter#12064";
        $k[$j++] = "KIX must contain only capital letters and digits";
        bwipp_raiseerror();
      }
    }
    $1.barlen = $1.barcode.length;
    $1.encstr = $s($1.barlen * 4);
    $1.txt = $a($1.barlen);
    for (var _M = 0, _L = $1.barlen - 1; _M <= _L; _M += 1) {
      $1.i = _M;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $puti($1.encstr, $1.i * 4, $get($1.encs, $1.indx));
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 4 * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $1.bbs = $a($1.encstr.length);
    $1.bhs = $a($1.encstr.length);
    for (var _n = 0, _m = $1.encstr.length - 1; _n <= _m; _n += 1) {
      $1.i = _n;
      $1.enc = $geti($1.encstr, $1.i, 1);
      if ($eq($1.enc, "0")) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 2 * $1.height / 8);
      }
      if ($eq($1.enc, "1")) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($eq($1.enc, "2")) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($eq($1.enc, "3")) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 8 * $1.height / 8);
      }
    }
    $k[$j++] = Infinity;
    var _1J = $1.bbs;
    var _1K = $1.bhs;
    $k[$j++] = Infinity;
    for (var _1M = 0, _1N = $1.bhs.length - 1; _1M < _1N; _1M++) {
      $k[$j++] = 1.44;
      $k[$j++] = 1.872;
    }
    $k[$j++] = 1.44;
    var _1O = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bbs";
    $k[$j++] = _1J;
    $k[$j++] = "bhs";
    $k[$j++] = _1K;
    $k[$j++] = "sbs";
    $k[$j++] = _1O;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _1S = $d();
    $k[$j++] = _1S;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_japanpost() {
    var $1 = Object.create(bwipp_japanpost.$ctx || (bwipp_japanpost.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.includecheckintext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 0.175;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $forall($1.barcode, function() {
      var _3 = $k[--$j];
      if (!(_3 >= 48 && _3 <= 57 || (_3 >= 65 && _3 <= 90 || _3 == 45))) {
        $k[$j++] = "bwipp.japanPostBadCharacter#12169";
        $k[$j++] = "Japan Post must contain only digits, capital letters and the dash symbol";
        if ("raiseerror"() === true) {
          return true;
        }
      }
    });
    if (!bwipp_japanpost.__12183__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["300", "330", "312", "132", "321", "303", "123", "231", "213", "033", "030", "120", "102", "210", "012", "201", "021", "003", "333", "31", "13"]);
        $ctx.barchars = "0123456789-ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_japanpost.$ctx[id] = $ctx[id]);
        bwipp_japanpost.__12183__ = 1;
      })();
    }
    $1.barlen = $1.barcode.length;
    $1.encstr = $s((20 + 1) * 3 + 4);
    $1.digits = $a(20);
    $1.txt = $a($1.barlen + 1);
    $puti($1.encstr, 0, $get($1.encs, 19));
    $1.checksum = 0;
    $1.j = 0;
    $1.i = 0;
    $k[$j++] = true;
    for (var _G = 0, _F = $1.barlen - 1; _G <= _F; _G += 1) {
      $1.i = _G;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      if ($1.indx >= 11 && $1.indx < 37) {
        if ($1.j > 18) {
          $j--;
          $k[$j++] = false;
          break;
        }
        $1.digit = ~~(($1.indx - 1) / 10) + 10;
        $puti($1.encstr, $1.j * 3 + 2, $get($1.encs, $1.digit));
        $1.checksum = $1.checksum + $1.digit;
        $put($1.digits, $1.j, $1.digit);
        $1.j = $1.j + 1;
      }
      if ($1.j > 19) {
        $j--;
        $k[$j++] = false;
        break;
      }
      $1.digit = 0;
      if ($1.indx == 37) {
        $1.digit = 14;
      }
      if ($1.indx >= 11 && $1.indx < 37) {
        $1.digit = ($1.indx - 1) % 10;
      }
      if ($1.indx < 11) {
        $1.digit = $1.indx;
      }
      $puti($1.encstr, $1.j * 3 + 2, $get($1.encs, $1.digit));
      $1.checksum = $1.checksum + $1.digit;
      $put($1.digits, $1.j, $1.digit);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), ($1.j * 3 + 2) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
      $1.j = $1.j + 1;
    }
    if ($nt($k[--$j])) {
      $k[$j++] = "bwipp.japanpostTooLong#12233";
      $k[$j++] = "The input is too long";
      bwipp_raiseerror();
    }
    for (var _16 = $1.j, _15 = 20 - 1; _16 <= _15; _16 += 1) {
      $1.k = _16;
      $puti($1.encstr, $1.k * 3 + 2, $get($1.encs, 14));
      $1.checksum = $1.checksum + 14;
      $put($1.digits, $1.k, 14);
    }
    $1.checksum = 19 - $1.checksum % 19;
    $puti($1.encstr, 2 + 20 * 3, $get($1.encs, $1.checksum));
    $puti($1.encstr, 2 + 21 * 3, $get($1.encs, 20));
    $1.checkdigit = " ";
    if ($1.includecheckintext) {
      $1.checkdigit = $geti($1.barchars, $1.checksum, 1);
    }
    $put($1.txt, $1.i + 1, $a([$1.checkdigit, (20 * 3 + 2) * 3.312, $1.textyoffset, $1.textfont, $1.textsize]));
    $puti($1.encstr, (20 + 1) * 3 + 2, $get($1.encs, 20));
    $1.bbs = $a(21 * 3 + 4);
    $1.bhs = $a($1.bbs.length);
    for (var _1f = 0, _1e = $1.bbs.length - 1; _1f <= _1e; _1f += 1) {
      $1.i = _1f;
      $1.enc = $geti($1.encstr, $1.i, 1);
      $1.bunit = 0;
      $1.hunit = 0;
      if ($eq($1.enc, "0")) {
        $1.bunit = 3;
        $1.hunit = 2;
      }
      if ($eq($1.enc, "1")) {
        $1.bunit = 0;
        $1.hunit = 5;
      }
      if ($eq($1.enc, "2")) {
        $1.bunit = 3;
        $1.hunit = 5;
      }
      if ($eq($1.enc, "3")) {
        $1.bunit = 0;
        $1.hunit = 8;
      }
      $put($1.bbs, $1.i, $1.bunit * $1.height / 8);
      $put($1.bhs, $1.i, $1.hunit * $1.height / 8);
    }
    $k[$j++] = Infinity;
    var _1v = $1.bbs;
    var _1w = $1.bhs;
    $k[$j++] = Infinity;
    for (var _1y = 0, _1z = $1.bhs.length - 1; _1y < _1z; _1y++) {
      $k[$j++] = 1.44;
      $k[$j++] = 1.872;
    }
    $k[$j++] = 1.44;
    var _20 = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bbs";
    $k[$j++] = _1v;
    $k[$j++] = "bhs";
    $k[$j++] = _1w;
    $k[$j++] = "sbs";
    $k[$j++] = _20;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _24 = $d();
    $k[$j++] = _24;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_msi() {
    var $1 = Object.create(bwipp_msi.$ctx || (bwipp_msi.$ctx = {}));
    $1.dontdraw = false;
    $1.includecheck = false;
    $1.includetext = false;
    $1.includecheckintext = false;
    $1.checktype = "unset";
    $1.badmod11 = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($ne($1.checktype, "unset") && !$1.includecheck) {
      $k[$j++] = "bwipp.msiCheckTypeWithoutCheck#12350";
      $k[$j++] = "checktype requires includecheck";
      bwipp_raiseerror();
    }
    if ($1.badmod11 && ($ne($1.checktype, "mod11") && $ne($1.checktype, "ncrmod11") && $ne($1.checktype, "mod1110") && $ne($1.checktype, "ncrmod1110"))) {
      $k[$j++] = "bwipp.msiBadMod11Mismatch#12354";
      $k[$j++] = "badmod11 requires checktype with mod11";
      bwipp_raiseerror();
    }
    if ($eq($1.checktype, "unset")) {
      $1.checktype = "mod10";
    }
    $forall($1.barcode, function() {
      var _B = $k[--$j];
      if (_B < 48 || _B > 57) {
        $k[$j++] = "bwipp.msiBadCharacter#12364";
        $k[$j++] = "MSI must contain only digits";
        bwipp_raiseerror();
      }
    });
    if (!bwipp_msi.__12378__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["12121212", "12121221", "12122112", "12122121", "12211212", "12211221", "12212112", "12212121", "21121212", "21121221", "21", "121"]);
        $ctx.barchars = "0123456789";
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_msi.$ctx[id] = $ctx[id]);
        bwipp_msi.__12378__ = 1;
      })();
    }
    $1.barlen = $1.barcode.length;
    $1.txtlen = $1.barlen;
    $1.mod10 = function() {
      $1.code = $k[--$j];
      $k[$j++] = 0;
      $k[$j++] = 0;
      $forall($1.code, function() {
        var _I = $k[--$j];
        var _J = $k[--$j];
        var _K = $k[--$j];
        $k[$j++] = $f($f(_I - 48) + _J * 10);
        $k[$j++] = _K;
      });
      $j--;
      var _L = $k[--$j];
      $k[$j++] = _L * 2;
      $k[$j++] = 0;
      for (; ; ) {
        var _M = $k[--$j];
        var _N = $k[--$j];
        var _O = ~~(_N / 10);
        $k[$j++] = $f(_M + _N % 10);
        $k[$j++] = _O;
        if (_O == 0) {
          $j--;
          break;
        }
        var _P = $k[--$j];
        var _Q = $k[--$j];
        $k[$j++] = _P;
        $k[$j++] = _Q;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $forall($1.code, function() {
        var _S = $k[--$j];
        var _T = $k[--$j];
        var _U = $k[--$j];
        $k[$j++] = $f(_T + $f(_S - 48));
        $k[$j++] = _U;
      });
      var _V = $k[--$j];
      var _W = $k[--$j];
      $k[$j++] = _V;
      $k[$j++] = _W;
      $j--;
      var _X = $k[--$j];
      var _a = $s($1.code.length + 1);
      $puti(_a, 0, $1.code);
      $put(_a, $1.code.length, $f($f(10 - $f($k[--$j] + _X) % 10) % 10 + 48));
      $k[$j++] = _a;
    };
    $1.mod11 = function() {
      $1.code = $k[--$j];
      $k[$j++] = $1.code.length - 1;
      $forall($1.code, function() {
        var _g = $k[--$j];
        var _h = $k[--$j];
        $k[$j++] = $f(_g - 48);
        $k[$j++] = $f(_h % 6 + 2);
        $k[$j++] = $f(_h - 1);
      });
      $j--;
      $k[$j++] = 0;
      for (var _j = 0, _k = $1.code.length; _j < _k; _j++) {
        var _l = $k[--$j];
        var _m = $k[--$j];
        var _n = $k[--$j];
        $k[$j++] = $f(_l + _n * _m);
      }
      var _p = $f(11 - $k[--$j] % 11) % 11;
      $k[$j++] = _p;
      if (_p == 10) {
        if ($1.badmod11) {
          $j--;
          var _s = $s($1.code.length + 2);
          $puti(_s, 0, $1.code);
          $puti(_s, $1.code.length, "10");
          $k[$j++] = _s;
        } else {
          $j--;
          $k[$j++] = "bwipp.msiBadMod11NotSpecified#12401";
          $k[$j++] = "mod11 check digit is 10 but badmod11 not specified";
          bwipp_raiseerror();
        }
      } else {
        var _w = $s($1.code.length + 1);
        $puti(_w, 0, $1.code);
        $put(_w, $1.code.length, $f($k[--$j] + 48));
        $k[$j++] = _w;
      }
    };
    $1.ncrmod11 = function() {
      $1.code = $k[--$j];
      $k[$j++] = $1.code.length - 1;
      $forall($1.code, function() {
        var _13 = $k[--$j];
        var _14 = $k[--$j];
        $k[$j++] = $f(_13 - 48);
        $k[$j++] = $f(_14 % 8 + 2);
        $k[$j++] = $f(_14 - 1);
      });
      $j--;
      $k[$j++] = 0;
      for (var _16 = 0, _17 = $1.code.length; _16 < _17; _16++) {
        var _18 = $k[--$j];
        var _19 = $k[--$j];
        var _1A = $k[--$j];
        $k[$j++] = $f(_18 + _1A * _19);
      }
      var _1C = $f(11 - $k[--$j] % 11) % 11;
      $k[$j++] = _1C;
      if (_1C == 10) {
        if ($1.badmod11) {
          $j--;
          var _1F = $s($1.code.length + 2);
          $puti(_1F, 0, $1.code);
          $puti(_1F, $1.code.length, "10");
          $k[$j++] = _1F;
        } else {
          $j--;
          $k[$j++] = "bwipp.msiBadMod11NotSpecified#12417";
          $k[$j++] = "mod11 check digit is 10 but badmod11 not specified";
          bwipp_raiseerror();
        }
      } else {
        var _1J = $s($1.code.length + 1);
        $puti(_1J, 0, $1.code);
        $put(_1J, $1.code.length, $f($k[--$j] + 48));
        $k[$j++] = _1J;
      }
    };
    if (!bwipp_msi.__12433__) {
      (function() {
        var $ctx = Object.create($1);
        var _1N = /* @__PURE__ */ new Map([
          ["mod10", function() {
            $ctx.mod10();
          }],
          ["mod1010", function() {
            $ctx.mod10();
            $ctx.mod10();
          }],
          ["mod11", function() {
            $ctx.mod11();
          }],
          ["ncrmod11", function() {
            $ctx.ncrmod11();
          }],
          ["mod1110", function() {
            $ctx.mod11();
            $ctx.mod10();
          }],
          ["ncrmod1110", function() {
            $ctx.ncrmod11();
            $ctx.mod10();
          }]
        ]);
        $ctx.checkfunc = _1N;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_msi.$ctx[id] = $ctx[id]);
        bwipp_msi.__12433__ = 1;
      })();
    }
    if ($1.includecheck) {
      var _1Q = $1.checkfunc;
      var _1R = $1.checktype;
      var _1S = $get(_1Q, _1R) !== void 0;
      $k[$j++] = _1Q;
      $k[$j++] = _1R;
      if (!_1S) {
        $j -= 2;
        $k[$j++] = "bwipp.msiBadCharacter#12438";
        $k[$j++] = "MSI checktype must be mod10, mod1010, mod11, ncrmod11, mod1110 or ncrmod1110";
        bwipp_raiseerror();
      }
      var _1T = $k[--$j];
      var _1V = $get($k[--$j], _1T);
      $k[$j++] = $1.barcode;
      if (_1V() === true) {
        return true;
      }
      $1.barcode = $k[--$j];
      $1.barlen = $1.barcode.length;
      if ($1.includecheckintext) {
        $1.txtlen = $1.barlen;
      }
    }
    $1.sbs = $s($1.barlen * 8 + 5);
    $1.txt = $a($1.barlen);
    $puti($1.sbs, 0, $get($1.encs, 10));
    for (var _1k = 0, _1j = $1.barlen - 1; _1k <= _1j; _1k += 1) {
      $1.i = _1k;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * 8 + 2, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 12 + 3, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $puti($1.sbs, $1.barlen * 8 + 2, $get($1.encs, 11));
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _2A = $1.sbs;
    for (var _2B = 0, _2C = _2A.length; _2B < _2C; _2B++) {
      $k[$j++] = $get(_2A, _2B) - 48;
    }
    var _2E = $a();
    $k[$j++] = Infinity;
    for (var _2G = 0, _2H = ~~(($1.sbs.length + 1) / 2); _2G < _2H; _2G++) {
      $k[$j++] = $1.height;
    }
    var _2J = $a();
    $k[$j++] = Infinity;
    for (var _2L = 0, _2M = ~~(($1.sbs.length + 1) / 2); _2L < _2M; _2L++) {
      $k[$j++] = 0;
    }
    var _2N = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _2E;
    $k[$j++] = "bhs";
    $k[$j++] = _2J;
    $k[$j++] = "bbs";
    $k[$j++] = _2N;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $geti($1.txt, 0, $1.txtlen);
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2T = $d();
    $k[$j++] = _2T;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_plessey() {
    var $1 = Object.create(bwipp_plessey.$ctx || (bwipp_plessey.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.validatecheck = false;
    $1.includecheckintext = false;
    $1.unidirectional = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    var _1 = $k[--$j];
    $1.barcode = _1;
    if (!bwipp_plessey.__12544__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEF";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 15; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        $ctx.encs = $a(["14141414", "32141414", "14321414", "32321414", "14143214", "32143214", "14323214", "32323214", "14141432", "32141432", "14321432", "32321432", "14143232", "32143232", "14323232", "32323232", "32321432", "541412323", "323"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_plessey.$ctx[id] = $ctx[id]);
        bwipp_plessey.__12544__ = 1;
      })();
    }
    for (var _A = 0, _9 = $1.barcode.length - 1; _A <= _9; _A += 1) {
      var _E = $get($1.charvals, $geti($1.barcode, _A, 1)) !== void 0;
      if (!_E) {
        $k[$j++] = "bwipp.plesseyBadCharacter#12549";
        $k[$j++] = "Plessey must contain only digits and letters A B C D E F";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _H = $k[--$j];
      $k[$j++] = $f(_H - 2);
    }
    var _I = $k[--$j];
    $1[$k[--$j]] = _I;
    $1.checkbits = $a($f($1.barlen * 4 + 8));
    $puti($1.checkbits, $1.barlen * 4, $a([0, 0, 0, 0, 0, 0, 0, 0]));
    for (var _R = 0, _Q = $f($1.barlen - 1); _R <= _Q; _R += 1) {
      $1.i = _R;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $puti($1.checkbits, $1.i * 4, $a([$1.indx & 1, $1.indx >>> 1 & 1, $1.indx >>> 2 & 1, $1.indx >>> 3]));
    }
    $1.checksalt = $a([1, 1, 1, 1, 0, 1, 0, 0, 1]);
    for (var _h = 0, _g = $f($1.barlen * 4 - 1); _h <= _g; _h += 1) {
      $1.i = _h;
      if ($get($1.checkbits, $1.i) == 1) {
        for (var _l = 0; _l <= 8; _l += 1) {
          $1.j = _l;
          $put($1.checkbits, $1.i + $1.j, $xo($get($1.checkbits, $1.i + $1.j), $get($1.checksalt, $1.j)));
        }
      }
    }
    $1.checkval = 0;
    for (var _w = 0; _w <= 7; _w += 1) {
      $1.i = _w;
      $1.checkval = $f($1.checkval + ~~Math.pow(2, $1.i) * $get($1.checkbits, $f($1.barlen * 4 + $1.i)));
    }
    $1.checksum1 = $1.checkval & 15;
    $1.checksum2 = $1.checkval >>> 4;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum1) || $get($1.barcode, $f($1.barlen + 1)) != $get($1.barchars, $1.checksum2)) {
        $k[$j++] = "bwipp.plesseyBadCheckDigits#12588";
        $k[$j++] = "Incorrect Plessey check digits provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _1N = $1.unidirectional ? 27 : 33;
    $1.sbs = $s($f($1.barlen * 8 + _1N));
    $1.txt = $a($f($1.barlen + 2));
    $puti($1.sbs, 0, $get($1.encs, 16));
    for (var _1W = 0, _1V = $f($1.barlen - 1); _1W <= _1V; _1W += 1) {
      $1.i = _1W;
      $1.indx = $get($1.charvals, $geti($1.barcode, $1.i, 1));
      $puti($1.sbs, $1.i * 8 + 8, $get($1.encs, $1.indx));
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 20 + 20, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $puti($1.sbs, $f($1.barlen * 8 + 8), $get($1.encs, $1.checksum1));
    $puti($1.sbs, $f($1.barlen * 8 + 16), $get($1.encs, $1.checksum2));
    if ($1.includecheckintext) {
      $put($1.txt, $1.barlen, $a([$geti($1.barchars, $1.checksum1, 1), $f($1.barlen * 20 + 20), $1.textyoffset, $1.textfont, $1.textsize]));
      $put($1.txt, $f($1.barlen + 1), $a([$geti($1.barchars, $1.checksum2, 1), $f($f($1.barlen + 1) * 20 + 20), $1.textyoffset, $1.textfont, $1.textsize]));
    } else {
      $put($1.txt, $1.barlen, $a([" ", $f($1.barlen * 20 + 20), $1.textyoffset, $1.textfont, $1.textsize]));
      $put($1.txt, $f($1.barlen + 1), $a([" ", $f($f($1.barlen + 1) * 20 + 20), $1.textyoffset, $1.textfont, $1.textsize]));
    }
    var _2e = $1.unidirectional ? 18 : 17;
    $puti($1.sbs, $f($1.barlen * 8 + 24), $get($1.encs, _2e));
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _2g = $1.sbs;
    for (var _2h = 0, _2i = _2g.length; _2h < _2i; _2h++) {
      $k[$j++] = $get(_2g, _2h) - 48;
    }
    var _2k = $a();
    $k[$j++] = Infinity;
    for (var _2m = 0, _2n = ~~(($1.sbs.length + 1) / 2); _2m < _2n; _2m++) {
      $k[$j++] = $1.height;
    }
    var _2p = $a();
    $k[$j++] = Infinity;
    for (var _2r = 0, _2s = ~~(($1.sbs.length + 1) / 2); _2r < _2s; _2r++) {
      $k[$j++] = 0;
    }
    var _2t = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _2k;
    $k[$j++] = "bhs";
    $k[$j++] = _2p;
    $k[$j++] = "bbs";
    $k[$j++] = _2t;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2x = $d();
    $k[$j++] = _2x;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_telepen() {
    var $1 = Object.create(bwipp_telepen.$ctx || (bwipp_telepen.$ctx = {}));
    $1.numeric = false;
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 1;
    $1.parse = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _3 = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parseonly", true],
      ["parsefnc", false]
    ]);
    $1.fncvals = _3;
    $k[$j++] = "barcode";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $1.barlen = $1.barcode.length;
    delete $1.options["parse"];
    if ($1.numeric && $1.barlen % 2 != 0) {
      $k[$j++] = "bwipp.telepenNumericOddLength#12695";
      $k[$j++] = "Telepen Numeric must have an even length";
      bwipp_raiseerror();
    }
    if (!bwipp_telepen.__12734__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["31313131", "1131313111", "33313111", "1111313131", "3111313111", "11333131", "13133131", "111111313111", "31333111", "1131113131", "33113131", "1111333111", "3111113131", "1113133111", "1311133111", "111111113131", "3131113111", "11313331", "333331", "111131113111", "31113331", "1133113111", "1313113111", "1111113331", "31131331", "113111113111", "3311113111", "1111131331", "311111113111", "1113111331", "1311111331", "11111111113111", "31313311", "1131311131", "33311131", "1111313311", "3111311131", "11333311", "13133311", "111111311131", "31331131", "1131113311", "33113311", "1111331131", "3111113311", "1113131131", "1311131131", "111111113311", "3131111131", "1131131311", "33131311", "111131111131", "3111131311", "1133111131", "1313111131", "111111131311", "3113111311", "113111111131", "3311111131", "111113111311", "311111111131", "111311111311", "131111111311", "11111111111131", "3131311111", "11313133", "333133", "111131311111", "31113133", "1133311111", "1313311111", "1111113133", "313333", "113111311111", "3311311111", "11113333", "311111311111", "11131333", "13111333", "11111111311111", "31311133", "1131331111", "33331111", "1111311133", "3111331111", "11331133", "13131133", "111111331111", "3113131111", "1131111133", "33111133", "111113131111", "3111111133", "111311131111", "131111131111", "111111111133", "31311313", "113131111111", "3331111111", "1111311313", "311131111111", "11331313", "13131313", "11111131111111", "3133111111", "1131111313", "33111313", "111133111111", "3111111313", "111313111111", "131113111111", "111111111313", "313111111111", "1131131113", "33131113", "11113111111111", "3111131113", "113311111111", "131311111111", "111111131113", "3113111113", "11311111111111", "331111111111", "111113111113", "31111111111111", "111311111113", "131111111113", "1111111111111111"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_telepen.$ctx[id] = $ctx[id]);
        bwipp_telepen.__12734__ = 1;
      })();
    }
    $1.sbs = $s($1.barlen * 16 + 48);
    $1.txt = $a($1.barlen);
    $1.enc = $get($1.encs, 95);
    $puti($1.sbs, 0, $1.enc);
    $1.l = $1.enc.length;
    $1.checksum = 0;
    $1.i = 0;
    $1.j = 0;
    for (; ; ) {
      if ($1.i == $1.barlen) {
        break;
      }
      if ($1.numeric) {
        if ($get($1.barcode, $1.i) > 16) {
          $1.np = $geti($1.barcode, $1.i, 2);
          var _X = $get($1.np, 0);
          var _Z = $get($1.np, 1);
          if (_X < 48 || _X > 57 || (_Z < 48 || _Z > 57) && !(_Z == 88)) {
            $k[$j++] = -1;
          } else {
            var _e = $f($get($1.np, 1) - 48);
            $k[$j++] = $f($get($1.np, 0) - 48);
            $k[$j++] = _e;
            if (_e != 40) {
              var _f = $k[--$j];
              var _g = $k[--$j];
              $k[$j++] = $f($f(_f + _g * 10) + 10);
            } else {
              $j--;
            }
            var _h = $k[--$j];
            $k[$j++] = $f(_h + 17);
          }
          var _i = $k[--$j];
          $k[$j++] = _i;
          if (_i == -1) {
            $k[$j++] = "bwipp.telepenInvalidNumericCharacter#12761";
            $k[$j++] = "Telepen Numeric may contain only digits, or X in even positions";
            bwipp_raiseerror();
          }
          $1.indx = $k[--$j];
          $put($1.txt, $1.j, $a([$1.np, $1.j * 16 + 16, $1.textyoffset, $1.textfont, $1.textsize]));
          $1.i = $1.i + 2;
        } else {
          $1.indx = $get($1.barcode, $1.i);
          $put($1.txt, $1.j, $a([" ", $1.j * 16 + 16, $1.textyoffset, $1.textfont, $1.textsize]));
          $1.i = $1.i + 1;
        }
      } else {
        $1.indx = $get($1.barcode, $1.i);
        if ($1.indx > 127) {
          $k[$j++] = "bwipp.telepenInvalidAlphaCharacter#12774";
          $k[$j++] = "Telepen Alpha characters must have ordinal values 0 to 127";
          bwipp_raiseerror();
        }
        if ($1.indx >= 32 && $1.indx <= 126) {
          $put($1.txt, $1.j, $a([$geti($1.barcode, $1.i, 1), $1.j * 16 + 16, $1.textyoffset, $1.textfont, $1.textsize]));
        } else {
          $put($1.txt, $1.j, $a([" ", $1.j * 16 + 16, $1.textyoffset, $1.textfont, $1.textsize]));
        }
        $1.i = $1.i + 1;
      }
      $1.checksum = $f($1.checksum + $1.indx);
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.l, $1.enc);
      $1.l = $1.l + $1.enc.length;
      $1.j = $1.j + 1;
    }
    $1.checksum = $f(127 - $1.checksum % 127) % 127;
    $1.enc = $get($1.encs, $1.checksum);
    $puti($1.sbs, $1.l, $1.enc);
    $1.l = $1.l + $1.enc.length;
    $1.enc = $get($1.encs, 122);
    $puti($1.sbs, $1.l, $1.enc);
    $1.l = $1.l + $1.enc.length;
    $1.sbs = $geti($1.sbs, 0, $1.l);
    $1.txt = $geti($1.txt, 0, $1.j);
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _1z = $1.sbs;
    for (var _20 = 0, _21 = _1z.length; _20 < _21; _20++) {
      $k[$j++] = $f($get(_1z, _20) - 48);
    }
    var _23 = $a();
    $k[$j++] = Infinity;
    for (var _25 = 0, _26 = ~~(($1.sbs.length + 1) / 2); _25 < _26; _25++) {
      $k[$j++] = $1.height;
    }
    var _28 = $a();
    $k[$j++] = Infinity;
    for (var _2A = 0, _2B = ~~(($1.sbs.length + 1) / 2); _2A < _2B; _2A++) {
      $k[$j++] = 0;
    }
    var _2C = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _23;
    $k[$j++] = "bhs";
    $k[$j++] = _28;
    $k[$j++] = "bbs";
    $k[$j++] = _2C;
    if ($1.includetext) {
      $k[$j++] = "txt";
      $k[$j++] = $1.txt;
    }
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _2G = $d();
    $k[$j++] = _2G;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_telepennumeric() {
    var $1 = Object.create(bwipp_telepennumeric.$ctx || (bwipp_telepennumeric.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "numeric", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_telepen();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_posicode() {
    var $1 = Object.create(bwipp_posicode.$ctx || (bwipp_posicode.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = -8;
    $1.height = 1;
    $1.encoding = "auto";
    $1.version = "a";
    $1.checkoffset = 0;
    $1.raw = false;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    var _1 = $k[--$j];
    $1.barcode = _1;
    if (!bwipp_posicode.__12963__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.la0 = -1;
        $ctx.la1 = -2;
        $ctx.la2 = -3;
        $ctx.sf0 = -4;
        $ctx.sf1 = -5;
        $ctx.sf2 = -6;
        $ctx.fn1 = -7;
        $ctx.fn2 = -8;
        $ctx.fn3 = -9;
        $ctx.fn4 = -10;
        $ctx.charmapsnormal = $a([$a(["0", "^", "'"]), $a(["1", ";", 27]), $a(["2", "<", 28]), $a(["3", "=", 29]), $a(["4", ">", 30]), $a(["5", "?", 31]), $a(["6", "@", "!"]), $a(["7", "[", '"']), $a(["8", 92, "#"]), $a(["9", "]", "&"]), $a(["A", "a", 1]), $a(["B", "b", 2]), $a(["C", "c", 3]), $a(["D", "d", 4]), $a(["E", "e", 5]), $a(["F", "f", 6]), $a(["G", "g", 7]), $a(["H", "h", 8]), $a(["I", "i", 9]), $a(["J", "j", 10]), $a(["K", "k", 11]), $a(["L", "l", 12]), $a(["M", "m", 13]), $a(["N", "n", 14]), $a(["O", "o", 15]), $a(["P", "p", 16]), $a(["Q", "q", 17]), $a(["R", "r", 18]), $a(["S", "s", 19]), $a(["T", "t", 20]), $a(["U", "u", 21]), $a(["V", "v", 22]), $a(["W", "w", 23]), $a(["X", "x", 24]), $a(["Y", "y", 25]), $a(["Z", "z", 26]), $a(["-", "_", 40]), $a([".", "`", 41]), $a([" ", 127, 0]), $a(["$", "{", "*"]), $a(["/", "|", ","]), $a(["+", "}", ":"]), $a(["%", "~", $ctx.fn1]), $a([$ctx.la1, $ctx.la0, $ctx.fn2]), $a([$ctx.sf1, $ctx.sf0, $ctx.fn3]), $a([$ctx.sf2, $ctx.sf2, $ctx.fn4])]);
        var _12 = $a(["5", -98, -98]);
        $ctx.chapmapslimited = $a([$a(["0", -98, -98]), $a(["1", -98, -98]), $a(["2", -98, -98]), $a(["3", -98, -98]), $a(["4", -98, -98]), _12, $a(["6", -98, -98]), $a(["7", -98, -98]), $a(["8", -98, -98]), $a(["9", -98, -98]), $a(["A", -98, -98]), $a(["B", -98, -98]), $a(["C", -98, -98]), $a(["D", -98, -98]), $a(["E", -98, -98]), $a(["F", -98, -98]), $a(["G", -98, -98]), $a(["H", -98, -98]), $a(["I", -98, -98]), $a(["J", -98, -98]), $a(["K", -98, -98]), $a(["L", -98, -98]), $a(["M", -98, -98]), $a(["N", -98, -98]), $a(["O", -98, -98]), $a(["P", -98, -98]), $a(["Q", -98, -98]), $a(["R", -98, -98]), $a(["S", -98, -98]), $a(["T", -98, -98]), $a(["U", -98, -98]), $a(["V", -98, -98]), $a(["W", -98, -98]), $a(["X", -98, -98]), $a(["Y", -98, -98]), $a(["Z", -98, -98]), $a(["-", -98, -98]), $a([".", -98, -98])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_posicode.$ctx[id] = $ctx[id]);
        bwipp_posicode.__12963__ = 1;
      })();
    }
    $k[$j++] = "charmaps";
    if ($eq($1.version, "a") || $eq($1.version, "b")) {
      $k[$j++] = $1.charmapsnormal;
    } else {
      $k[$j++] = $1.chapmapslimited;
    }
    var _1f = $k[--$j];
    $1[$k[--$j]] = _1f;
    var _1h = $1.charmaps;
    var _1i = $1.charmaps;
    var _1j = $1.charmaps;
    $1.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
    for (var _1n = 0, _1m = $1.charmaps.length - 1; _1n <= _1m; _1n += 1) {
      $1.i = _1n;
      $1.encs = $get($1.charmaps, $1.i);
      for (var _1r = 0; _1r <= 2; _1r += 1) {
        $1.j = _1r;
        var _1u = $get($1.encs, $1.j);
        $k[$j++] = _1u;
        if ($eq($type(_1u), "stringtype")) {
          var _1x = $get($k[--$j], 0);
          $k[$j++] = _1x;
        }
        $put($get($1.charvals, $1.j), $k[--$j], $1.i);
      }
    }
    $1.set0 = $get($1.charvals, 0);
    $1.set1 = $get($1.charvals, 1);
    $1.set2 = $get($1.charvals, 2);
    if ($1.raw) {
      $1.encoding = "raw";
    }
    if ($eq($1.encoding, "raw")) {
      $1.cws = $a($1.barcode.length);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i == $1.barcode.length) {
          break;
        }
        $1.cw = $cvi($geti($1.barcode, $1.i + 1, 3));
        $put($1.cws, $1.j, $1.cw);
        $1.i = $1.i + 4;
        $1.j = $1.j + 1;
      }
      $1.cws = $geti($1.cws, 0, $1.j);
      $1.text = "";
    }
    if ($eq($1.encoding, "auto")) {
      var _2W = /* @__PURE__ */ new Map([
        ["parse", $1.parse],
        ["parsefnc", $1.parsefnc],
        ["FNC1", $1.fn1],
        ["FNC2", $1.fn2],
        ["FNC3", $1.fn3]
      ]);
      $1.fncvals = _2W;
      $k[$j++] = "msg";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.fncvals;
      bwipp_parseinput();
      var _2Z = $k[--$j];
      $1[$k[--$j]] = _2Z;
      $1.msglen = $1.msg.length;
      $1.text = $s($1.msglen);
      for (var _2g = 0, _2f = $1.msglen - 1; _2g <= _2f; _2g += 1) {
        $1.i = _2g;
        var _2l = $get($1.msg, $1.i);
        $k[$j++] = $1.text;
        $k[$j++] = $1.i;
        $k[$j++] = _2l;
        if (_2l < 0) {
          $j--;
          $k[$j++] = 32;
        }
        var _2m = $k[--$j];
        var _2n = $k[--$j];
        $put($k[--$j], _2n, _2m);
      }
      $k[$j++] = Infinity;
      for (var _2q = 0, _2r = $1.msglen; _2q < _2r; _2q++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numSA = $a();
      $k[$j++] = Infinity;
      for (var _2u = 0, _2v = $1.msglen; _2u < _2v; _2u++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numEA = $a();
      for (var _2y = $1.msglen - 1; _2y >= 0; _2y -= 1) {
        $1.i = _2y;
        if ($get($1.msg, $1.i) >= 0) {
          if ($get($1.msg, $1.i) >= 128) {
            $put($1.numEA, $1.i, $f($get($1.numEA, $1.i + 1) + 1));
          } else {
            $put($1.numSA, $1.i, $f($get($1.numSA, $1.i + 1) + 1));
          }
        }
      }
      $1.ea = false;
      $1.msgtmp = $a([]);
      for (var _3I = 0, _3H = $1.msglen - 1; _3I <= _3H; _3I += 1) {
        $1.i = _3I;
        $1.c = $get($1.msg, $1.i);
        if (!$xo($1.ea, $1.c < 128) && $1.c >= 0) {
          if ($1.ea) {
            $k[$j++] = $1.numSA;
          } else {
            $k[$j++] = $1.numEA;
          }
          var _3U = $get($k[--$j], $1.i);
          var _3X = $f(_3U + $1.i) == $1.msglen ? 3 : 5;
          if (_3U < _3X) {
            $k[$j++] = Infinity;
            $aload($1.msgtmp);
            $k[$j++] = $1.fn4;
            $1.msgtmp = $a();
          } else {
            $k[$j++] = Infinity;
            $aload($1.msgtmp);
            $k[$j++] = $1.fn4;
            $k[$j++] = $1.fn4;
            $1.msgtmp = $a();
            $1.ea = !$1.ea;
          }
        }
        $k[$j++] = Infinity;
        $aload($1.msgtmp);
        if ($1.c >= 0) {
          $k[$j++] = $1.c & 127;
        } else {
          $k[$j++] = $1.c;
        }
        $1.msgtmp = $a();
      }
      $1.msg = $1.msgtmp;
      $1.msglen = $1.msg.length;
      $1.enc = function() {
        var _3n = $k[--$j];
        $put($1.cws, $1.j, $get(_3n, $k[--$j]));
        $1.j = $1.j + 1;
      };
      $1.cws = $a($1.msglen * 2);
      $1.i = 0;
      $1.j = 0;
      $1.cset = "set0";
      for (; ; ) {
        if ($1.i == $1.msglen) {
          break;
        }
        for (; ; ) {
          $1.char1 = $get($1.msg, $1.i);
          $k[$j++] = "char2";
          if ($1.i + 1 < $1.msglen) {
            $k[$j++] = $get($1.msg, $1.i + 1);
          } else {
            $k[$j++] = -99;
          }
          var _45 = $k[--$j];
          $1[$k[--$j]] = _45;
          var _4A = $get($1[$1.cset], $1.char1) !== void 0;
          if (_4A) {
            $k[$j++] = $1.char1;
            $k[$j++] = $1[$1.cset];
            $1.enc();
            $1.i = $1.i + 1;
            break;
          }
          var _4H = $get($1.set2, $1.char1) !== void 0;
          if (_4H) {
            $k[$j++] = $1.sf2;
            $k[$j++] = $1[$1.cset];
            $1.enc();
            $k[$j++] = $1.char1;
            $k[$j++] = $1.set2;
            $1.enc();
            $1.i = $1.i + 1;
            break;
          }
          var _4R = $get($1[$1.cset], $1.char2) !== void 0;
          if (!_4R) {
            if ($eq($1.cset, "set0")) {
              $k[$j++] = $1.la1;
              $k[$j++] = $1[$1.cset];
              $1.enc();
              $1.cset = "set1";
            } else {
              $k[$j++] = $1.la0;
              $k[$j++] = $1[$1.cset];
              $1.enc();
              $1.cset = "set0";
            }
            break;
          } else {
            if ($eq($1.cset, "set0")) {
              $k[$j++] = $1.sf1;
              $k[$j++] = $1[$1.cset];
              $1.enc();
              $k[$j++] = $1.char1;
              $k[$j++] = $1.set1;
              $1.enc();
            } else {
              $k[$j++] = $1.sf0;
              $k[$j++] = $1[$1.cset];
              $1.enc();
              $k[$j++] = $1.char1;
              $k[$j++] = $1.set0;
              $1.enc();
            }
            $1.i = $1.i + 1;
            break;
          }
          break;
        }
      }
      $1.cws = $geti($1.cws, 0, $1.j);
    }
    if (!bwipp_posicode.__13163__) {
      (function() {
        var $ctx = Object.create($1);
        var _4s = /* @__PURE__ */ new Map([
          ["a", $a(["141112", "131212", "121312", "111412", "131113", "121213", "111313", "121114", "111214", "111115", "181111", "171211", "161311", "151411", "141511", "131611", "121711", "111811", "171112", "161212", "151312", "141412", "131512", "121612", "111712", "161113", "151213", "141313", "131413", "121513", "111613", "151114", "141214", "131314", "121414", "111514", "141115", "131215", "121315", "111415", "131116", "121216", "111316", "121117", "111217", "111118", "1<111112", "111111111;1"])],
          ["b", $a(["151213", "141313", "131413", "121513", "141214", "131314", "121414", "131215", "121315", "121216", "191212", "181312", "171412", "161512", "151612", "141712", "131812", "121912", "181213", "171313", "161413", "151513", "141613", "131713", "121813", "171214", "161314", "151414", "141514", "131614", "121714", "161215", "151315", "141415", "131515", "121615", "151216", "141316", "131416", "121516", "141217", "131317", "121417", "131218", "121318", "121219", "1<121312", "121212121<1"])],
          ["limiteda", $a(["111411", "111312", "111213", "111114", "121311", "121212", "121113", "141111", "131211", "131112", "171111", "161211", "151311", "141411", "131511", "121611", "111711", "161112", "151212", "141312", "131412", "121512", "111612", "151113", "141213", "131313", "121413", "111513", "141114", "131214", "121314", "111414", "131115", "121215", "111315", "121116", "111216", "111117", "151111", "1"])],
          ["limitedb", $a(["121512", "121413", "121314", "121215", "131412", "131313", "131214", "151212", "141312", "141213", "181212", "171312", "161412", "151512", "141612", "131712", "121812", "171213", "161313", "151413", "141513", "131613", "121713", "161214", "151314", "141414", "131514", "121614", "151215", "141315", "131415", "121515", "141216", "131316", "121416", "131217", "121317", "121218", "141212", "1"])]
        ]);
        $ctx.encmaps = _4s;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_posicode.$ctx[id] = $ctx[id]);
        bwipp_posicode.__13163__ = 1;
      })();
    }
    $1.encs = $get($1.encmaps, $1.version);
    if (!bwipp_posicode.__13174__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.c2w = $a([$a([495, 330, 210, 126, 70, 35, 15, 5]), $a([165, 120, 84, 56, 35, 20, 10, 4]), $a([45, 36, 28, 21, 15, 10, 6, 3]), $a([9, 8, 7, 6, 5, 4, 3, 2]), $a([1, 1, 1, 1, 1, 1, 1, 1])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_posicode.$ctx[id] = $ctx[id]);
        bwipp_posicode.__13174__ = 1;
      })();
    }
    $1.v = 0;
    var _54 = $1.cws;
    for (var _55 = 0, _56 = _54.length; _55 < _56; _55++) {
      $1.cw = $get(_54, _55);
      for (var _58 = 0, _59 = 6; _58 < _59; _58++) {
        if ((($1.cw ^ $1.v) & 1) != 0) {
          $1.v = $1.v ^ 7682;
        }
        $1.v = $1.v >>> 1;
        $1.cw = $1.cw >>> 1;
      }
    }
    $1.v = $1.v + $1.checkoffset;
    if ($eq($1.version, "limiteda") || $eq($1.version, "limitedb")) {
      $1.v = $1.v & 1023;
      if ($1.v > 824 && $1.v < 853) {
        $1.v = $1.v + 292;
      }
    } else {
      $1.v = ($1.v & 1023) + 45;
    }
    $1.d = $a([2, 2, 2, 2, 2, 2]);
    $1.r = 0;
    $1.c = 0;
    $1.w = 0;
    $1.sum = 0;
    for (; ; ) {
      if ($1.sum == $1.v) {
        break;
      }
      $1.t = $f($1.sum + $get($get($1.c2w, $1.r), $1.c));
      if ($1.t == $1.v) {
        $1.w = $1.w + 1;
        $put($1.d, $1.r, $1.w + 2);
        $1.sum = $1.t;
      }
      if ($1.t > $1.v) {
        $put($1.d, $1.r, $1.w + 2);
        $1.r = $1.r + 1;
        $1.w = 0;
      }
      if ($1.t < $1.v) {
        $1.c = $1.c + 1;
        $1.w = $1.w + 1;
        $1.sum = $1.t;
      }
    }
    $k[$j++] = 20;
    for (var _5p = 0; _5p <= 4; _5p += 1) {
      var _5s = $k[--$j];
      $k[$j++] = $f(_5s - $get($1.d, _5p));
    }
    $put($1.d, 5, $k[--$j]);
    if ($eq($1.version, "b") || $eq($1.version, "limitedb")) {
      $k[$j++] = Infinity;
      var _5x = $1.d;
      for (var _5y = 0, _5z = _5x.length; _5y < _5z; _5y++) {
        $k[$j++] = $f($get(_5x, _5y) + 1);
      }
      $1.d = $a();
    }
    $1.cbs = $strcpy($s(12), "111111111111");
    for (var _64 = 5; _64 >= 0; _64 -= 1) {
      $1.i = _64;
      $put($1.cbs, (5 - $1.i) * 2 + 1, $f($get($1.d, $1.i) + 47));
    }
    $1.sbs = $s($1.cws.length * 6 + 31);
    var _6E = $get($1.encs, $1.encs.length - 2);
    $puti($1.sbs, 0, _6E);
    $1.j = _6E.length;
    for (var _6I = 0, _6H = $1.cws.length - 1; _6I <= _6H; _6I += 1) {
      $1.i = _6I;
      $puti($1.sbs, $1.j, $get($1.encs, $get($1.cws, $1.i)));
      $1.j = $1.j + 6;
    }
    $puti($1.sbs, $1.j, $1.cbs);
    $1.j = $1.j + 12;
    var _6X = $get($1.encs, $1.encs.length - 1);
    $puti($1.sbs, $1.j, _6X);
    $1.j = _6X.length + $1.j;
    $1.sbs = $geti($1.sbs, 0, $1.j);
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _6e = $1.sbs;
    for (var _6f = 0, _6g = _6e.length; _6f < _6g; _6f++) {
      $k[$j++] = $f($get(_6e, _6f) - 48);
    }
    var _6i = $a();
    $k[$j++] = Infinity;
    for (var _6k = 0, _6l = ~~(($1.sbs.length + 1) / 2); _6k < _6l; _6k++) {
      $k[$j++] = $1.height;
    }
    var _6n = $a();
    $k[$j++] = Infinity;
    for (var _6p = 0, _6q = ~~(($1.sbs.length + 1) / 2); _6p < _6q; _6p++) {
      $k[$j++] = 0;
    }
    var _6r = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _6i;
    $k[$j++] = "bhs";
    $k[$j++] = _6n;
    $k[$j++] = "bbs";
    $k[$j++] = _6r;
    $k[$j++] = "txt";
    $k[$j++] = $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]);
    $k[$j++] = "textxalign";
    $k[$j++] = "center";
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _70 = $d();
    $k[$j++] = _70;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_codablockf() {
    var $1 = Object.create(bwipp_codablockf.$ctx || (bwipp_codablockf.$ctx = {}));
    $1.dontdraw = false;
    $1.rows = -1;
    $1.columns = 8;
    $1.rowheight = 10;
    $1.sepheight = 1;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.columns < 4 || $1.columns > 62) {
      $k[$j++] = "bwipp.codablockfBadColumns#13307";
      $k[$j++] = "Codablock F must have 4 to 62 columns";
      bwipp_raiseerror();
    }
    if ($1.rows != -1 && ($1.rows < 2 || $1.rows > 44)) {
      $k[$j++] = "bwipp.codablockfBadRows#13311";
      $k[$j++] = "Codablock F must have 2 to 44 rows";
      bwipp_raiseerror();
    }
    if ($1.rowheight < 8) {
      $k[$j++] = "bwipp.codablockfBadRowHeight#13315";
      $k[$j++] = "Codablock F must have rowheight of at least 8";
      bwipp_raiseerror();
    }
    if ($1.sepheight < 1) {
      $k[$j++] = "bwipp.codablockfBadSepHeight#13319";
      $k[$j++] = "Codablock F must have sepheight of at least 1";
      bwipp_raiseerror();
    }
    $k[$j++] = "c";
    if ($1.columns >= 4 && $1.columns <= 62) {
      $k[$j++] = $1.columns;
    } else {
      $k[$j++] = 8;
    }
    var _C = $k[--$j];
    $1[$k[--$j]] = _C;
    $k[$j++] = "rows";
    if ($1.rows >= 2 && $1.rows <= 44) {
      $k[$j++] = $1.rows;
    } else {
      $k[$j++] = -1;
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.swa = -1;
    $1.swb = -2;
    $1.swc = -3;
    $1.sft = -4;
    $1.fn1 = -5;
    $1.fn2 = -6;
    $1.fn3 = -7;
    $1.fn4 = -8;
    $1.sta = -9;
    $1.stp = -10;
    var _N = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["FNC1", $1.fn1],
      ["FNC3", $1.fn3]
    ]);
    $1.fncvals = _N;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _Q = $k[--$j];
    $1[$k[--$j]] = _Q;
    $1.msglen = $1.msg.length;
    $1.msgtmp = $a([]);
    var _U = $1.msg;
    for (var _V = 0, _W = _U.length; _V < _W; _V++) {
      $1.char = $get(_U, _V);
      $k[$j++] = Infinity;
      $aload($1.msgtmp);
      if ($1.char < 128) {
        $k[$j++] = $1.char;
      } else {
        $k[$j++] = $1.fn4;
        $k[$j++] = $1.char & 127;
      }
      $1.msgtmp = $a();
    }
    $1.kmsg = $1.msg;
    $1.msg = $1.msgtmp;
    $1.msglen = $1.msg.length;
    if (!bwipp_codablockf.__13409__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.charmaps = $a([$a([32, 32, "00"]), $a(["!", "!", "01"]), $a(['"', '"', "02"]), $a(["#", "#", "03"]), $a(["$", "$", "04"]), $a(["%", "%", "05"]), $a(["&", "&", "06"]), $a(["'", "'", "07"]), $a([40, 40, "08"]), $a([41, 41, "09"]), $a(["*", "*", "10"]), $a(["+", "+", "11"]), $a([",", ",", "12"]), $a(["-", "-", "13"]), $a([".", ".", "14"]), $a(["/", "/", "15"]), $a(["0", "0", "16"]), $a(["1", "1", "17"]), $a(["2", "2", "18"]), $a(["3", "3", "19"]), $a(["4", "4", "20"]), $a(["5", "5", "21"]), $a(["6", "6", "22"]), $a(["7", "7", "23"]), $a(["8", "8", "24"]), $a(["9", "9", "25"]), $a([":", ":", "26"]), $a([";", ";", "27"]), $a(["<", "<", "28"]), $a(["=", "=", "29"]), $a([">", ">", "30"]), $a(["?", "?", "31"]), $a(["@", "@", "32"]), $a(["A", "A", "33"]), $a(["B", "B", "34"]), $a(["C", "C", "35"]), $a(["D", "D", "36"]), $a(["E", "E", "37"]), $a(["F", "F", "38"]), $a(["G", "G", "39"]), $a(["H", "H", "40"]), $a(["I", "I", "41"]), $a(["J", "J", "42"]), $a(["K", "K", "43"]), $a(["L", "L", "44"]), $a(["M", "M", "45"]), $a(["N", "N", "46"]), $a(["O", "O", "47"]), $a(["P", "P", "48"]), $a(["Q", "Q", "49"]), $a(["R", "R", "50"]), $a(["S", "S", "51"]), $a(["T", "T", "52"]), $a(["U", "U", "53"]), $a(["V", "V", "54"]), $a(["W", "W", "55"]), $a(["X", "X", "56"]), $a(["Y", "Y", "57"]), $a(["Z", "Z", "58"]), $a(["[", "[", "59"]), $a([92, 92, "60"]), $a(["]", "]", "61"]), $a(["^", "^", "62"]), $a(["_", "_", "63"]), $a([0, "`", "64"]), $a([1, "a", "65"]), $a([2, "b", "66"]), $a([3, "c", "67"]), $a([4, "d", "68"]), $a([5, "e", "69"]), $a([6, "f", "70"]), $a([7, "g", "71"]), $a([8, "h", "72"]), $a([9, "i", "73"]), $a([10, "j", "74"]), $a([11, "k", "75"]), $a([12, "l", "76"]), $a([13, "m", "77"]), $a([14, "n", "78"]), $a([15, "o", "79"]), $a([16, "p", "80"]), $a([17, "q", "81"]), $a([18, "r", "82"]), $a([19, "s", "83"]), $a([20, "t", "84"]), $a([21, "u", "85"]), $a([22, "v", "86"]), $a([23, "w", "87"]), $a([24, "x", "88"]), $a([25, "y", "89"]), $a([26, "z", "90"]), $a([27, "{", "91"]), $a([28, "|", "92"]), $a([29, "}", "93"]), $a([30, "~", "94"]), $a([31, 127, "95"]), $a([$ctx.fn3, $ctx.fn3, "96"]), $a([$ctx.fn2, $ctx.fn2, "97"]), $a([$ctx.sft, $ctx.sft, "98"]), $a([$ctx.swc, $ctx.swc, "99"]), $a([$ctx.swb, $ctx.fn4, $ctx.swb]), $a([$ctx.fn4, $ctx.swa, $ctx.swa]), $a([$ctx.fn1, $ctx.fn1, $ctx.fn1]), $a([$ctx.sta, $ctx.sta, $ctx.sta]), $a([$ctx.stp, $ctx.stp, $ctx.stp])]);
        $ctx.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
        for (var _2p = 0, _2o = $ctx.charmaps.length - 1; _2p <= _2o; _2p += 1) {
          $ctx.i = _2p;
          $ctx.encs = $get($ctx.charmaps, $ctx.i);
          for (var _2t = 0; _2t <= 2; _2t += 1) {
            $ctx.j = _2t;
            var _2w = $get($ctx.encs, $ctx.j);
            $k[$j++] = _2w;
            if ($eq($type(_2w), "stringtype")) {
              var _2z = $get($k[--$j], 0);
              $k[$j++] = _2z;
            }
            $put($get($ctx.charvals, $ctx.j), $k[--$j], $ctx.i);
          }
        }
        $ctx.seta = $get($ctx.charvals, 0);
        $ctx.setb = $get($ctx.charvals, 1);
        $ctx.setc = $get($ctx.charvals, 2);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_codablockf.$ctx[id] = $ctx[id]);
        bwipp_codablockf.__13409__ = 1;
      })();
    }
    $1.numsscr = function() {
      $1.n = 0;
      $1.s = 0;
      $1.p = $k[--$j];
      for (; ; ) {
        if ($1.p >= $1.msglen) {
          break;
        }
        var _3H = $get($1.msg, $1.p);
        var _3J = $get($1.setc, _3H) !== void 0;
        $k[$j++] = _3H;
        if (!_3J) {
          $j--;
          break;
        }
        if ($k[--$j] == $1.fn1) {
          if ($1.s % 2 == 0) {
            $1.s = $1.s + 1;
          } else {
            break;
          }
        }
        $1.n = $1.n + 1;
        $1.s = $1.s + 1;
        $1.p = $f($1.p + 1);
      }
      $k[$j++] = $1.n;
      $k[$j++] = $1.s;
    };
    $1.enca = function() {
      $put($1.cws, $1.j, $get($1.seta, $k[--$j]));
      $1.j = $1.j + 1;
    };
    $1.encb = function() {
      $put($1.cws, $1.j, $get($1.setb, $k[--$j]));
      $1.j = $1.j + 1;
    };
    $1.encc = function() {
      var _3f = $k[--$j];
      $k[$j++] = _3f;
      if ($ne($type(_3f), "arraytype")) {
        var _3j = $get($1.setc, $k[--$j]);
        $k[$j++] = _3j;
      } else {
        $aload($k[--$j]);
        var _3l = $k[--$j];
        var _3m = $k[--$j];
        $k[$j++] = $f($f(_3l - 48) + $f(_3m - 48) * 10);
      }
      $put($1.cws, $1.j, $k[--$j]);
      $1.j = $1.j + 1;
    };
    $1.anotb = function() {
      var _3r = $k[--$j];
      var _3t = $get($1.seta, _3r) !== void 0;
      var _3v = $get($1.setb, _3r) !== void 0;
      $k[$j++] = _3t && !_3v;
    };
    $1.bnota = function() {
      var _3w = $k[--$j];
      var _3y = $get($1.setb, _3w) !== void 0;
      var _40 = $get($1.seta, _3w) !== void 0;
      $k[$j++] = _3y && !_40;
    };
    $k[$j++] = Infinity;
    for (var _42 = 0, _43 = $1.msg.length; _42 < _43; _42++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $1.nextanotb = $a();
    $k[$j++] = Infinity;
    for (var _46 = 0, _47 = $1.msg.length; _46 < _47; _46++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $1.nextbnota = $a();
    for (var _4A = $1.msg.length - 1; _4A >= 0; _4A -= 1) {
      $1.i = _4A;
      $k[$j++] = $get($1.msg, $1.i);
      $1.anotb();
      if ($k[--$j]) {
        $put($1.nextanotb, $1.i, 0);
      } else {
        $put($1.nextanotb, $1.i, $f($get($1.nextanotb, $1.i + 1) + 1));
      }
      $k[$j++] = $get($1.msg, $1.i);
      $1.bnota();
      if ($k[--$j]) {
        $put($1.nextbnota, $1.i, 0);
      } else {
        $put($1.nextbnota, $1.i, $f($get($1.nextbnota, $1.i + 1) + 1));
      }
    }
    $1.abeforeb = function() {
      var _4X = $k[--$j];
      $k[$j++] = $lt($get($1.nextanotb, _4X), $get($1.nextbnota, _4X));
    };
    $1.bbeforea = function() {
      var _4c = $k[--$j];
      $k[$j++] = $lt($get($1.nextbnota, _4c), $get($1.nextanotb, _4c));
    };
    $1.padrow = function() {
      for (var _4i = 0, _4j = $k[--$j]; _4i < _4j; _4i++) {
        for (; ; ) {
          if ($eq($1.cset, "seta")) {
            $k[$j++] = $1.swc;
            $1.enca();
            $1.cset = "setc";
            break;
          }
          if ($eq($1.cset, "setb")) {
            $k[$j++] = $1.swc;
            $1.encb();
            $1.cset = "setc";
            break;
          }
          if ($eq($1.cset, "setc")) {
            $k[$j++] = $1.swb;
            $1.encc();
            $1.cset = "setb";
            break;
          }
        }
      }
    };
    $1.encafitsrow = function() {
      if ($1.rem <= 2 && $get($1.msg, $1.i) == $1.fn4) {
        var _4z = $1.rem == 2 && $get($1.msg, $1.i + 1) <= 95;
        $k[$j++] = _4z;
        if (_4z) {
          $k[$j++] = $1.fn4;
          $1.enca();
          $k[$j++] = $get($1.msg, $1.i + 1);
          $1.enca();
          $1.i = $1.i + 2;
        }
      } else {
        $k[$j++] = $get($1.msg, $1.i);
        $1.enca();
        $1.i = $1.i + 1;
        $k[$j++] = true;
      }
    };
    $1.encbfitsrow = function() {
      if ($1.rem <= 2 && $get($1.msg, $1.i) == $1.fn4) {
        var _5I = $1.rem == 2 && $get($1.msg, $1.i + 1) >= 32;
        $k[$j++] = _5I;
        if (_5I) {
          $k[$j++] = $1.fn4;
          $1.encb();
          $k[$j++] = $get($1.msg, $1.i + 1);
          $1.encb();
          $1.i = $1.i + 2;
        }
      } else {
        $k[$j++] = $get($1.msg, $1.i);
        $1.encb();
        $1.i = $1.i + 1;
        $k[$j++] = true;
      }
    };
    $1.cws = $a($f($1.c + 5) * 44);
    $1.i = 0;
    $1.j = 0;
    $1.r = 1;
    $1.lastrow = false;
    for (; ; ) {
      if ($1.lastrow) {
        break;
      }
      if ($1.r > 44) {
        $k[$j++] = "bwipp.codablockfTooBig#13525";
        $k[$j++] = "Maximum length exceeded";
        bwipp_raiseerror();
      }
      $k[$j++] = $1.sta;
      $1.enca();
      if ($1.i < $1.msglen) {
        $k[$j++] = $1.i;
        $1.numsscr();
      } else {
        $k[$j++] = -1;
        $k[$j++] = -1;
      }
      $1.nums = $k[--$j];
      $1.nchars = $k[--$j];
      for (; ; ) {
        if ($1.msglen == 0) {
          $k[$j++] = $1.swb;
          $1.enca();
          $1.cset = "setb";
          break;
        }
        if ($1.nums >= 2) {
          $k[$j++] = $1.swc;
          $1.enca();
          $1.cset = "setc";
          break;
        }
        $k[$j++] = $1.i;
        $1.abeforeb();
        if ($k[--$j]) {
          $k[$j++] = $1.sft;
          $1.enca();
          $1.cset = "seta";
          break;
        }
        $k[$j++] = $1.swb;
        $1.enca();
        $1.cset = "setb";
        break;
      }
      $1.j = $1.j + 1;
      $1.endofrow = false;
      for (; ; ) {
        $1.rem = $f($f($1.c + 3) - $1.j % $f($1.c + 5));
        if ($1.i == $1.msglen || $1.endofrow) {
          break;
        }
        $k[$j++] = $1.i;
        $1.numsscr();
        $1.nums = $k[--$j];
        $1.nchars = $k[--$j];
        $k[$j++] = "remnums";
        if ($1.nums > $1.rem * 2) {
          $k[$j++] = $1.rem * 2;
        } else {
          $k[$j++] = $1.nums;
        }
        var _5y = $k[--$j];
        $1[$k[--$j]] = _5y;
        for (; ; ) {
          if (($eq($1.cset, "seta") || $eq($1.cset, "setb")) && $1.remnums >= 4 && $get($1.msg, $1.i) != $1.fn1) {
            if ($1.remnums % 2 == 0 && $1.rem >= 3) {
              $k[$j++] = $1.swc;
              if ($eq($1.cset, "seta")) {
                $1.enca();
              } else {
                $1.encb();
              }
              $1.cset = "setc";
              for (var _6B = 0, _6C = 2; _6B < _6C; _6B++) {
                if ($get($1.msg, $1.i) == $1.fn1) {
                  $k[$j++] = $1.fn1;
                  $1.encc();
                  $1.i = $1.i + 1;
                } else {
                  $k[$j++] = $geti($1.msg, $1.i, 2);
                  $1.encc();
                  $1.i = $1.i + 2;
                }
              }
              break;
            }
            if ($1.remnums % 2 != 0 && $1.rem >= 4) {
              $k[$j++] = $get($1.msg, $1.i);
              if ($eq($1.cset, "seta")) {
                $1.enca();
              } else {
                $1.encb();
              }
              $1.i = $1.i + 1;
              $k[$j++] = $1.swc;
              if ($eq($1.cset, "seta")) {
                $1.enca();
              } else {
                $1.encb();
              }
              $1.cset = "setc";
              for (var _6W = 0, _6X = 2; _6W < _6X; _6W++) {
                if ($get($1.msg, $1.i) == $1.fn1) {
                  $k[$j++] = $1.fn1;
                  $1.encc();
                  $1.i = $1.i + 1;
                } else {
                  $k[$j++] = $geti($1.msg, $1.i, 2);
                  $1.encc();
                  $1.i = $1.i + 2;
                }
              }
              break;
            }
          }
          $k[$j++] = $eq($1.cset, "setb");
          $k[$j++] = $get($1.msg, $1.i);
          $1.anotb();
          var _6m = $k[--$j];
          var _6n = $k[--$j];
          if (_6n && _6m && $1.rem >= 2) {
            if ($1.i < $1.msglen - 1) {
              $k[$j++] = $1.i + 1;
              $1.bbeforea();
              if ($k[--$j]) {
                $k[$j++] = $1.sft;
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i);
                $1.enca();
                $1.i = $1.i + 1;
                break;
              }
            }
            $k[$j++] = $1.swa;
            $1.encb();
            $1.cset = "seta";
            $k[$j++] = $get($1.msg, $1.i);
            $1.enca();
            $1.i = $1.i + 1;
            break;
          }
          $k[$j++] = $eq($1.cset, "seta");
          $k[$j++] = $get($1.msg, $1.i);
          $1.bnota();
          var _77 = $k[--$j];
          var _78 = $k[--$j];
          if (_78 && _77 && $1.rem >= 2) {
            if ($1.i < $1.msglen - 1) {
              $k[$j++] = $1.i + 1;
              $1.abeforeb();
              if ($k[--$j]) {
                $k[$j++] = $1.sft;
                $1.enca();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $1.i = $1.i + 1;
                break;
              }
            }
            $k[$j++] = $1.swb;
            $1.enca();
            $1.cset = "setb";
            $k[$j++] = $get($1.msg, $1.i);
            $1.encb();
            $1.i = $1.i + 1;
            break;
          }
          if ($eq($1.cset, "setc") && $1.remnums < 2 && $1.rem >= 2) {
            $1.rem = $f($1.rem - 1);
            $k[$j++] = $1.i;
            $1.abeforeb();
            if ($k[--$j]) {
              $k[$j++] = $1.swa;
              $1.encc();
              $1.cset = "seta";
              $1.encafitsrow();
              if ($k[--$j]) {
                break;
              }
            } else {
              $k[$j++] = $1.swb;
              $1.encc();
              $1.cset = "setb";
              $1.encbfitsrow();
              if ($k[--$j]) {
                break;
              }
            }
          }
          var _7d = $get($1.seta, $get($1.msg, $1.i)) !== void 0;
          if ($eq($1.cset, "seta") && _7d && $1.rem >= 1) {
            $1.encafitsrow();
            if ($k[--$j]) {
              break;
            }
          }
          var _7l = $get($1.setb, $get($1.msg, $1.i)) !== void 0;
          if ($eq($1.cset, "setb") && _7l && $1.rem >= 1) {
            $1.encbfitsrow();
            if ($k[--$j]) {
              break;
            }
          }
          if ($eq($1.cset, "setc") && $1.remnums >= 2 && $1.rem >= 1) {
            if ($get($1.msg, $1.i) == $1.fn1) {
              $k[$j++] = $1.fn1;
              $1.encc();
              $1.i = $1.i + 1;
            } else {
              $k[$j++] = $geti($1.msg, $1.i, 2);
              $1.encc();
              $1.i = $1.i + 2;
            }
            break;
          }
          $1.endofrow = true;
          break;
        }
      }
      if (($1.r >= $1.rows || $1.rows == -1) && $1.r > 1 && $1.i == $1.msglen && $1.rem >= 2) {
        $k[$j++] = $f($1.rem - 2);
        $1.padrow();
        $1.j = $1.j + 3;
        $k[$j++] = $1.stp;
        $1.enca();
        $1.lastrow = true;
      } else {
        $k[$j++] = $1.rem;
        $1.padrow();
        $1.j = $1.j + 1;
        $k[$j++] = $1.stp;
        $1.enca();
        $1.r = $1.r + 1;
      }
    }
    $1.cws = $geti($1.cws, 0, $1.j);
    if (!bwipp_codablockf.__13698__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        for (var _8I = 64; _8I <= 95; _8I += 1) {
          $k[$j++] = _8I;
        }
        for (var _8J = 0; _8J <= 15; _8J += 1) {
          $k[$j++] = _8J;
        }
        for (var _8K = 26; _8K <= 63; _8K += 1) {
          $k[$j++] = _8K;
        }
        $ctx.abmap = $a();
        $k[$j++] = Infinity;
        for (var _8M = 0; _8M <= 85; _8M += 1) {
          $k[$j++] = _8M;
        }
        $ctx.cmap = $a();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_codablockf.$ctx[id] = $ctx[id]);
        bwipp_codablockf.__13698__ = 1;
      })();
    }
    $1.chkmsg = $a($1.kmsg.length);
    $1.j = 0;
    for (var _8T = 0, _8S = $1.kmsg.length - 1; _8T <= _8S; _8T += 1) {
      $1.i = _8T;
      $1.char = $get($1.kmsg, $1.i);
      if ($1.char >= 0) {
        $put($1.chkmsg, $1.j, $1.char);
        $1.j = $1.j + 1;
      }
      if ($1.char == $1.fn1 && $1.i != 0) {
        $put($1.chkmsg, $1.j, 29);
        $1.j = $1.j + 1;
      }
    }
    $1.t1 = 0;
    $1.t2 = 0;
    $1.k1 = 0;
    $1.k2 = 0;
    for (var _8k = 0, _8j = $1.j - 1; _8k <= _8j; _8k += 1) {
      $1.i = _8k;
      $1.t1 = $get($1.chkmsg, $1.i) * $1.i % 86;
      $1.t2 = $f($1.t1 + $get($1.chkmsg, $1.i)) % 86;
      $1.k1 = $f($1.k1 + $1.t2) % 86;
      $1.k2 = $f($1.k2 + $1.t1) % 86;
    }
    $k[$j++] = $1.cws;
    $k[$j++] = $1.cws.length - 4;
    if ($ne($1.cset, "setc")) {
      $k[$j++] = $1.abmap;
    } else {
      $k[$j++] = $1.cmap;
    }
    var _94 = $get($k[--$j], $1.k1);
    var _95 = $k[--$j];
    $put($k[--$j], _95, _94);
    $k[$j++] = $1.cws;
    $k[$j++] = $1.cws.length - 3;
    if ($ne($1.cset, "setc")) {
      $k[$j++] = $1.abmap;
    } else {
      $k[$j++] = $1.cmap;
    }
    var _9E = $get($k[--$j], $1.k2);
    var _9F = $k[--$j];
    $put($k[--$j], _9F, _9E);
    var _9H = $1.cws;
    $k[$j++] = _9H;
    $k[$j++] = 2;
    if ($get(_9H, 2 - 1) != 99) {
      $k[$j++] = $1.abmap;
    } else {
      $k[$j++] = $1.cmap;
    }
    var _9N = $get($k[--$j], $1.r - 2);
    var _9O = $k[--$j];
    $put($k[--$j], _9O, _9N);
    for (var _9S = 1, _9R = $1.r - 1; _9S <= _9R; _9S += 1) {
      $1.i = _9S;
      var _9T = $1.cws;
      var _9U = $1.i;
      var _9V = $1.c;
      $k[$j++] = _9T;
      $k[$j++] = $f(_9U * $f(_9V + 5) + 2);
      if ($get(_9T, $f($f(_9U * $f(_9V + 5) + 2) - 1)) != 99) {
        $k[$j++] = $1.abmap;
      } else {
        $k[$j++] = $1.cmap;
      }
      var _9b = $get($k[--$j], $1.i + 42);
      var _9c = $k[--$j];
      $put($k[--$j], _9c, _9b);
    }
    for (var _9g = 0, _9f = $1.r - 1; _9g <= _9f; _9g += 1) {
      $1.rcws = $geti($1.cws, _9g * $f($1.c + 5), $f($1.c + 4));
      $1.csum = $get($1.rcws, 0);
      for (var _9p = 1, _9o = $1.rcws.length - 2; _9p <= _9o; _9p += 1) {
        $1.i = _9p;
        $1.csum = $f($1.csum + $get($1.rcws, $1.i) * $1.i);
      }
      $put($1.rcws, $1.rcws.length - 1, $1.csum % 103);
    }
    var _9z = $get($1.options, "debugcws") !== void 0;
    if (_9z) {
      $k[$j++] = "bwipp.debugcws#13738";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    if (!bwipp_codablockf.__13759__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["212222", "222122", "222221", "121223", "121322", "131222", "122213", "122312", "132212", "221213", "221312", "231212", "112232", "122132", "122231", "113222", "123122", "123221", "223211", "221132", "221231", "213212", "223112", "312131", "311222", "321122", "321221", "312212", "322112", "322211", "212123", "212321", "232121", "111323", "131123", "131321", "112313", "132113", "132311", "211313", "231113", "231311", "112133", "112331", "132131", "113123", "113321", "133121", "313121", "211331", "231131", "213113", "213311", "213131", "311123", "311321", "331121", "312113", "312311", "332111", "314111", "221411", "431111", "111224", "111422", "121124", "121421", "141122", "141221", "112214", "112412", "122114", "122411", "142112", "142211", "241211", "221114", "413111", "241112", "134111", "111242", "121142", "121241", "114212", "124112", "124211", "411212", "421112", "421211", "212141", "214121", "412121", "111143", "111341", "131141", "114113", "114311", "411113", "411311", "113141", "114131", "311141", "411131", "211412", "2331112"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_codablockf.$ctx[id] = $ctx[id]);
        bwipp_codablockf.__13759__ = 1;
      })();
    }
    $1.rowbits = $a($1.r);
    for (var _A7 = 0, _A6 = $1.r - 1; _A7 <= _A6; _A7 += 1) {
      $1.i = _A7;
      $k[$j++] = Infinity;
      var _AC = $geti($1.cws, $1.i * $f($1.c + 5), $f($1.c + 5));
      for (var _AD = 0, _AE = _AC.length; _AD < _AE; _AD++) {
        $forall($get($1.encs, $get(_AC, _AD)), function() {
          var _AI = $k[--$j];
          $k[$j++] = $f(_AI - 48);
        });
      }
      $1.sbs = $a();
      $k[$j++] = Infinity;
      var _AK = $1.sbs;
      $k[$j++] = 0;
      for (var _AL = 0, _AM = _AK.length; _AL < _AM; _AL++) {
        var _AO = $k[--$j];
        var _AP = _AO == 1 ? 0 : 1;
        $k[$j++] = _AO;
        for (var _AQ = 0, _AR = $get(_AK, _AL); _AQ < _AR; _AQ++) {
          $k[$j++] = _AP;
        }
      }
      $astore($a($counttomark() - 1));
      var _AU = $k[--$j];
      var _AV = $k[--$j];
      $k[$j++] = _AU;
      $k[$j++] = _AV;
      $j--;
      var _AW = $k[--$j];
      var _AX = $k[--$j];
      $k[$j++] = _AW;
      $k[$j++] = _AX;
      $j--;
      $put($1.rowbits, $1.i, $k[--$j]);
    }
    $1.symwid = $f($1.c * 11 + 57);
    $k[$j++] = Infinity;
    for (var _Ae = 0, _Af = $1.symwid * $1.sepheight; _Ae < _Af; _Ae++) {
      $k[$j++] = 1;
    }
    for (var _Ai = 0, _Ah = $1.r - 2; _Ai <= _Ah; _Ai += 1) {
      $1.i = _Ai;
      for (var _Ak = 0, _Al = $1.rowheight; _Ak < _Al; _Ak++) {
        $aload($get($1.rowbits, $1.i));
      }
      for (var _Aq = 0, _Ar = $1.sepheight; _Aq < _Ar; _Aq++) {
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 0;
        for (var _At = 0, _Au = $f($1.symwid - 24); _At < _Au; _At++) {
          $k[$j++] = 1;
        }
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 1;
      }
    }
    for (var _Aw = 0, _Ax = $1.rowheight; _Aw < _Ax; _Aw++) {
      $aload($get($1.rowbits, $1.r - 1));
    }
    for (var _B3 = 0, _B4 = $1.symwid * $1.sepheight; _B3 < _B4; _B3++) {
      $k[$j++] = 1;
    }
    $1.pixs = $a();
    var _BE = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.symwid],
      ["pixy", ~~($1.pixs.length / $1.symwid)],
      ["height", ~~($1.pixs.length / $1.symwid) / 72],
      ["width", $1.symwid / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _BE;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_code16k() {
    var $1 = Object.create(bwipp_code16k.$ctx || (bwipp_code16k.$ctx = {}));
    $1.dontdraw = false;
    $1.sam = -1;
    $1.rows = 0;
    $1.rowheight = 8;
    $1.sepheight = 1;
    $1.raw = false;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.rows != 0 && ($1.rows < 2 || $1.rows > 16)) {
      $k[$j++] = "bwipp.code16kBadRows#13855";
      $k[$j++] = "Code 16K must have 2 to 16 rows";
      bwipp_raiseerror();
    }
    if ($1.rowheight < 8) {
      $k[$j++] = "bwipp.code16kBadRowHeight#13859";
      $k[$j++] = "Code 16K must have rowheight of at least 8";
      bwipp_raiseerror();
    }
    if ($1.sepheight < 1) {
      $k[$j++] = "bwipp.code16kBadSepHeight#13863";
      $k[$j++] = "Code 16K must have sepheight of at least 1";
      bwipp_raiseerror();
    }
    if ($1.sam != -1) {
      $k[$j++] = true;
      for (var _8 = 0, _9 = 1; _8 < _9; _8++) {
        var _A = $1.sam;
        if (_A < 12 || _A > 99) {
          $j--;
          $k[$j++] = false;
          break;
        }
        if ($1.sam % 10 < 2) {
          $j--;
          $k[$j++] = false;
          break;
        }
        if (~~($1.sam / 10) > $1.sam % 10) {
          $j--;
          $k[$j++] = false;
          break;
        }
      }
      if ($nt($k[--$j])) {
        $k[$j++] = "bwipp.code16kBadSAM#13874";
        $k[$j++] = 'SAM must be formatted as "NM" for Nth of M symbols, from 2 to 9 symbols';
        bwipp_raiseerror();
      }
    }
    if ($1.sam != -1) {
      $1.rows = 16;
    }
    if (!bwipp_code16k.__13945__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.swa = -1;
        $ctx.swb = -2;
        $ctx.swc = -3;
        $ctx.sa1 = -4;
        $ctx.sb1 = -5;
        $ctx.sc1 = -6;
        $ctx.sa2 = -7;
        $ctx.sb2 = -8;
        $ctx.sc2 = -9;
        $ctx.pad = -10;
        $ctx.sb3 = -11;
        $ctx.sc3 = -12;
        $ctx.fn1 = -13;
        $ctx.fn2 = -14;
        $ctx.fn3 = -15;
        $ctx.fn4 = -16;
        $ctx.charmaps = $a([$a([32, 32, "00"]), $a(["!", "!", "01"]), $a(['"', '"', "02"]), $a(["#", "#", "03"]), $a(["$", "$", "04"]), $a(["%", "%", "05"]), $a(["&", "&", "06"]), $a(["'", "'", "07"]), $a([40, 40, "08"]), $a([41, 41, "09"]), $a(["*", "*", "10"]), $a(["+", "+", "11"]), $a([",", ",", "12"]), $a(["-", "-", "13"]), $a([".", ".", "14"]), $a(["/", "/", "15"]), $a(["0", "0", "16"]), $a(["1", "1", "17"]), $a(["2", "2", "18"]), $a(["3", "3", "19"]), $a(["4", "4", "20"]), $a(["5", "5", "21"]), $a(["6", "6", "22"]), $a(["7", "7", "23"]), $a(["8", "8", "24"]), $a(["9", "9", "25"]), $a([":", ":", "26"]), $a([";", ";", "27"]), $a(["<", "<", "28"]), $a(["=", "=", "29"]), $a([">", ">", "30"]), $a(["?", "?", "31"]), $a(["@", "@", "32"]), $a(["A", "A", "33"]), $a(["B", "B", "34"]), $a(["C", "C", "35"]), $a(["D", "D", "36"]), $a(["E", "E", "37"]), $a(["F", "F", "38"]), $a(["G", "G", "39"]), $a(["H", "H", "40"]), $a(["I", "I", "41"]), $a(["J", "J", "42"]), $a(["K", "K", "43"]), $a(["L", "L", "44"]), $a(["M", "M", "45"]), $a(["N", "N", "46"]), $a(["O", "O", "47"]), $a(["P", "P", "48"]), $a(["Q", "Q", "49"]), $a(["R", "R", "50"]), $a(["S", "S", "51"]), $a(["T", "T", "52"]), $a(["U", "U", "53"]), $a(["V", "V", "54"]), $a(["W", "W", "55"]), $a(["X", "X", "56"]), $a(["Y", "Y", "57"]), $a(["Z", "Z", "58"]), $a(["[", "[", "59"]), $a([92, 92, "60"]), $a(["]", "]", "61"]), $a(["^", "^", "62"]), $a(["_", "_", "63"]), $a([0, "`", "64"]), $a([1, "a", "65"]), $a([2, "b", "66"]), $a([3, "c", "67"]), $a([4, "d", "68"]), $a([5, "e", "69"]), $a([6, "f", "70"]), $a([7, "g", "71"]), $a([8, "h", "72"]), $a([9, "i", "73"]), $a([10, "j", "74"]), $a([11, "k", "75"]), $a([12, "l", "76"]), $a([13, "m", "77"]), $a([14, "n", "78"]), $a([15, "o", "79"]), $a([16, "p", "80"]), $a([17, "q", "81"]), $a([18, "r", "82"]), $a([19, "s", "83"]), $a([20, "t", "84"]), $a([21, "u", "85"]), $a([22, "v", "86"]), $a([23, "w", "87"]), $a([24, "x", "88"]), $a([25, "y", "89"]), $a([26, "z", "90"]), $a([27, "{", "91"]), $a([28, "|", "92"]), $a([29, "}", "93"]), $a([30, "~", "94"]), $a([31, 127, "95"]), $a([$ctx.fn3, $ctx.fn3, "96"]), $a([$ctx.fn2, $ctx.fn2, "97"]), $a([$ctx.sb1, $ctx.sa1, "98"]), $a([$ctx.swc, $ctx.swc, "99"]), $a([$ctx.swb, $ctx.fn4, $ctx.swb]), $a([$ctx.fn4, $ctx.swa, $ctx.swa]), $a([$ctx.fn1, $ctx.fn1, $ctx.fn1]), $a([$ctx.pad, $ctx.pad, $ctx.pad]), $a([$ctx.sb2, $ctx.sa2, $ctx.sb1]), $a([$ctx.sc2, $ctx.sc2, $ctx.sb2]), $a([$ctx.sc3, $ctx.sc3, $ctx.sb3])]);
        $ctx.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
        for (var _2W = 0, _2V = $ctx.charmaps.length - 1; _2W <= _2V; _2W += 1) {
          $ctx.i = _2W;
          $ctx.encs = $get($ctx.charmaps, $ctx.i);
          for (var _2a = 0; _2a <= 2; _2a += 1) {
            $ctx.j = _2a;
            var _2d = $get($ctx.encs, $ctx.j);
            $k[$j++] = _2d;
            if ($eq($type(_2d), "stringtype")) {
              var _2g = $get($k[--$j], 0);
              $k[$j++] = _2g;
            }
            $put($get($ctx.charvals, $ctx.j), $k[--$j], $ctx.i);
          }
        }
        $ctx.seta = $get($ctx.charvals, 0);
        $ctx.setb = $get($ctx.charvals, 1);
        $ctx.setc = $get($ctx.charvals, 2);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code16k.$ctx[id] = $ctx[id]);
        bwipp_code16k.__13945__ = 1;
      })();
    }
    if ($1.raw) {
      $1.cws = $a($1.barcode.length);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i >= $1.barcode.length - 3) {
          break;
        }
        if ($get($1.barcode, $1.i) != 94) {
          break;
        }
        var _33 = $geti($1.barcode, $1.i + 1, 3);
        $k[$j++] = _33;
        $k[$j++] = false;
        for (var _34 = 0, _35 = _33.length; _34 < _35; _34++) {
          var _36 = $get(_33, _34);
          if (_36 < 48 || _36 > 57) {
            $j--;
            $k[$j++] = true;
          }
        }
        if ($k[--$j]) {
          $j--;
          break;
        }
        $1.cw = $cvi($k[--$j]);
        $put($1.cws, $1.j, $1.cw);
        $1.i = $1.i + 4;
        $1.j = $1.j + 1;
      }
      if ($1.i != $1.barcode.length) {
        $k[$j++] = "bwipp.code16kBadRawFormat#13963";
        $k[$j++] = "raw data must be formatted as ^NNN";
        bwipp_raiseerror();
      }
      $1.cws = $geti($1.cws, 0, $1.j);
    } else {
      var _3O = /* @__PURE__ */ new Map([
        ["parse", $1.parse],
        ["parsefnc", $1.parsefnc],
        ["eci", true],
        ["FNC1", $1.fn1],
        ["FNC2", $1.fn2],
        ["FNC3", $1.fn3]
      ]);
      $1.fncvals = _3O;
      $k[$j++] = "msg";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.fncvals;
      bwipp_parseinput();
      var _3R = $k[--$j];
      $1[$k[--$j]] = _3R;
      $1.msglen = $1.msg.length;
      $k[$j++] = Infinity;
      for (var _3V = 0, _3W = $1.msglen; _3V < _3W; _3V++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numSA = $a();
      $k[$j++] = Infinity;
      for (var _3Z = 0, _3a = $1.msglen; _3Z < _3a; _3Z++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numEA = $a();
      for (var _3d = $1.msglen - 1; _3d >= 0; _3d -= 1) {
        $1.i = _3d;
        if ($get($1.msg, $1.i) >= 0) {
          if ($get($1.msg, $1.i) >= 128) {
            $put($1.numEA, $1.i, $f($get($1.numEA, $1.i + 1) + 1));
          } else {
            $put($1.numSA, $1.i, $f($get($1.numSA, $1.i + 1) + 1));
          }
        }
      }
      $1.ea = false;
      $1.msgtmp = $a([]);
      for (var _3x = 0, _3w = $1.msglen - 1; _3x <= _3w; _3x += 1) {
        $1.i = _3x;
        $1.c = $get($1.msg, $1.i);
        if (!$xo($1.ea, $1.c < 128) && $1.c >= 0) {
          if ($1.ea) {
            $k[$j++] = $1.numSA;
          } else {
            $k[$j++] = $1.numEA;
          }
          var _49 = $get($k[--$j], $1.i);
          var _4C = $f(_49 + $1.i) == $1.msglen ? 3 : 5;
          if (_49 < _4C) {
            $k[$j++] = Infinity;
            $aload($1.msgtmp);
            $k[$j++] = $1.fn4;
            $1.msgtmp = $a();
          } else {
            $k[$j++] = Infinity;
            $aload($1.msgtmp);
            $k[$j++] = $1.fn4;
            $k[$j++] = $1.fn4;
            $1.msgtmp = $a();
            $1.ea = !$1.ea;
          }
        }
        $k[$j++] = Infinity;
        $aload($1.msgtmp);
        if ($1.c >= 0) {
          $k[$j++] = $1.c & 127;
        } else {
          $k[$j++] = $1.c;
        }
        $1.msgtmp = $a();
      }
      $1.msg = $1.msgtmp;
      $1.msglen = $1.msg.length;
      $1.numsscr = function() {
        $1.n = 0;
        $1.s = 0;
        $1.p = $k[--$j];
        for (; ; ) {
          if ($1.p >= $1.msglen) {
            break;
          }
          var _4X = $get($1.msg, $1.p);
          var _4Z = $get($1.setc, _4X) !== void 0;
          $k[$j++] = _4X;
          if (!_4Z) {
            $j--;
            break;
          }
          if ($k[--$j] == $1.fn1) {
            if ($1.s % 2 == 0) {
              $1.s = $1.s + 1;
            } else {
              break;
            }
          }
          $1.n = $1.n + 1;
          $1.s = $1.s + 1;
          $1.p = $f($1.p + 1);
        }
        $k[$j++] = $1.n;
        $k[$j++] = $1.s;
      };
      $1.enca = function() {
        $put($1.cws, $1.j, $get($1.seta, $k[--$j]));
        $1.j = $1.j + 1;
      };
      $1.encb = function() {
        $put($1.cws, $1.j, $get($1.setb, $k[--$j]));
        $1.j = $1.j + 1;
      };
      $1.encc = function() {
        var _4v = $k[--$j];
        $k[$j++] = _4v;
        if ($ne($type(_4v), "arraytype")) {
          var _4z = $get($1.setc, $k[--$j]);
          $k[$j++] = _4z;
        } else {
          $aload($k[--$j]);
          var _51 = $k[--$j];
          var _52 = $k[--$j];
          $k[$j++] = $f($f(_51 - 48) + $f(_52 - 48) * 10);
        }
        $put($1.cws, $1.j, $k[--$j]);
        $1.j = $1.j + 1;
      };
      $1.anotb = function() {
        var _57 = $k[--$j];
        var _59 = $get($1.seta, _57) !== void 0;
        var _5B = $get($1.setb, _57) !== void 0;
        $k[$j++] = _59 && !_5B;
      };
      $1.bnota = function() {
        var _5C = $k[--$j];
        var _5E = $get($1.setb, _5C) !== void 0;
        var _5G = $get($1.seta, _5C) !== void 0;
        $k[$j++] = _5E && !_5G;
      };
      $k[$j++] = Infinity;
      for (var _5I = 0, _5J = $1.msg.length; _5I < _5J; _5I++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 9999;
      $1.nextanotb = $a();
      $k[$j++] = Infinity;
      for (var _5M = 0, _5N = $1.msg.length; _5M < _5N; _5M++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 9999;
      $1.nextbnota = $a();
      for (var _5Q = $1.msg.length - 1; _5Q >= 0; _5Q -= 1) {
        $1.i = _5Q;
        $k[$j++] = $get($1.msg, $1.i);
        $1.anotb();
        if ($k[--$j]) {
          $put($1.nextanotb, $1.i, 0);
        } else {
          $put($1.nextanotb, $1.i, $f($get($1.nextanotb, $1.i + 1) + 1));
        }
        $k[$j++] = $get($1.msg, $1.i);
        $1.bnota();
        if ($k[--$j]) {
          $put($1.nextbnota, $1.i, 0);
        } else {
          $put($1.nextbnota, $1.i, $f($get($1.nextbnota, $1.i + 1) + 1));
        }
      }
      $1.abeforeb = function() {
        var _5n = $k[--$j];
        $k[$j++] = $lt($get($1.nextanotb, _5n), $get($1.nextbnota, _5n));
      };
      $1.bbeforea = function() {
        var _5s = $k[--$j];
        $k[$j++] = $lt($get($1.nextbnota, _5s), $get($1.nextanotb, _5s));
      };
      $1.cws = $a($1.barcode.length * 2 + 3);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.sam != -1) {
          $put($1.cws, 0, ~~($1.sam / 10) - 1);
          $put($1.cws, 1, $1.sam % 10 - 1);
          $1.j = 2;
          $1.cset = "setb";
          $1.mode = 7;
          break;
        }
        if ($1.msglen == 0) {
          $1.cset = "setb";
          $1.mode = 1;
          break;
        }
        if ($1.msglen >= 2) {
          $k[$j++] = $get($1.msg, 0) == $1.fn1;
          $k[$j++] = 1;
          $1.numsscr();
          var _69 = $k[--$j];
          var _6A = $k[--$j];
          $k[$j++] = _69;
          $k[$j++] = _6A;
          $j--;
          var _6B = $k[--$j];
          var _6C = $k[--$j];
          if (_6C && _6B >= 2) {
            $1.cset = "setc";
            $1.mode = 4;
            $1.i = 1;
            break;
          }
        }
        if ($get($1.msg, 0) == $1.fn1) {
          $1.cset = "setb";
          $1.mode = 3;
          $1.i = 1;
          break;
        }
        if ($1.msglen >= 2) {
          $k[$j++] = 0;
          $1.numsscr();
          var _6H = $k[--$j];
          var _6I = $k[--$j];
          $k[$j++] = _6H;
          $k[$j++] = _6I;
          $j--;
          var _6J = $k[--$j];
          if (_6J >= 2 && _6J % 2 == 0) {
            $1.cset = "setc";
            $1.mode = 2;
            break;
          }
          $k[$j++] = 0;
          $1.numsscr();
          var _6K = $k[--$j];
          var _6L = $k[--$j];
          $k[$j++] = _6K;
          $k[$j++] = _6L;
          $j--;
          var _6M = $k[--$j];
          if (_6M >= 3 && _6M % 2 == 1) {
            $k[$j++] = $get($1.msg, 0);
            $1.encb();
            $1.cset = "setc";
            $1.mode = 5;
            $1.i = 1;
            break;
          }
          var _6S = $get($1.setb, $get($1.msg, 0)) !== void 0;
          $k[$j++] = _6S;
          $k[$j++] = 1;
          $1.numsscr();
          var _6T = $k[--$j];
          var _6U = $k[--$j];
          $k[$j++] = _6T;
          $k[$j++] = _6U;
          $j--;
          var _6V = $k[--$j];
          var _6W = $k[--$j];
          if (_6W && (_6V >= 2 && _6V % 2 == 0)) {
            $k[$j++] = $get($1.msg, 0);
            $1.encb();
            $1.cset = "setc";
            $1.mode = 5;
            $1.i = 1;
            break;
          }
          var _6c = $get($1.setb, $get($1.msg, 0)) !== void 0;
          $k[$j++] = _6c;
          $k[$j++] = 1;
          $1.numsscr();
          var _6d = $k[--$j];
          var _6e = $k[--$j];
          $k[$j++] = _6d;
          $k[$j++] = _6e;
          $j--;
          var _6f = $k[--$j];
          var _6g = $k[--$j];
          if (_6g && (_6f >= 3 && _6f % 2 == 1)) {
            $k[$j++] = $get($1.msg, 0);
            $1.encb();
            $k[$j++] = $get($1.msg, 1);
            $1.encb();
            $1.cset = "setc";
            $1.mode = 6;
            $1.i = 2;
            break;
          }
          var _6o = $get($1.setb, $get($1.msg, 0)) !== void 0;
          var _6s = $get($1.setb, $get($1.msg, 1)) !== void 0;
          $k[$j++] = _6o && _6s;
          $k[$j++] = 2;
          $1.numsscr();
          var _6t = $k[--$j];
          var _6u = $k[--$j];
          $k[$j++] = _6t;
          $k[$j++] = _6u;
          $j--;
          var _6v = $k[--$j];
          var _6w = $k[--$j];
          if (_6w && (_6v >= 2 && _6v % 2 == 0)) {
            $k[$j++] = $get($1.msg, 0);
            $1.encb();
            $k[$j++] = $get($1.msg, 1);
            $1.encb();
            $1.cset = "setc";
            $1.mode = 6;
            $1.i = 2;
            break;
          }
        }
        $k[$j++] = 0;
        $1.abeforeb();
        if ($k[--$j]) {
          $1.cset = "seta";
          $1.mode = 0;
          break;
        }
        $1.cset = "setb";
        $1.mode = 1;
        break;
      }
      for (; ; ) {
        if ($1.i == $1.msglen) {
          break;
        }
        $k[$j++] = $1.i;
        $1.numsscr();
        $1.nums = $k[--$j];
        $1.nchars = $k[--$j];
        for (; ; ) {
          if ($eq($1.cset, "seta")) {
            if ($1.i < $1.msglen - 1) {
              $k[$j++] = $get($1.msg, $1.i);
              $1.bnota();
              $k[$j++] = $1.i + 1;
              $1.abeforeb();
              var _7E = $k[--$j];
              var _7F = $k[--$j];
              if (_7F && _7E) {
                $k[$j++] = $1.sb1;
                $1.enca();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $1.i = $1.i + 1;
                break;
              }
            }
            if ($1.i < $1.msglen - 2) {
              $k[$j++] = $get($1.msg, $1.i);
              $1.bnota();
              $k[$j++] = $get($1.msg, $1.i + 1);
              $1.bnota();
              var _7T = $k[--$j];
              var _7U = $k[--$j];
              $k[$j++] = $an(_7U, _7T);
              $k[$j++] = $1.i + 2;
              $1.abeforeb();
              var _7W = $k[--$j];
              var _7X = $k[--$j];
              if (_7X && _7W) {
                $k[$j++] = $1.sb2;
                $1.enca();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i + 1);
                $1.encb();
                $1.i = $1.i + 2;
                break;
              }
            }
            $k[$j++] = $get($1.msg, $1.i);
            $1.bnota();
            if ($k[--$j]) {
              $k[$j++] = $1.swb;
              $1.enca();
              $1.cset = "setb";
              break;
            }
            if ($1.i < $1.msglen - 4) {
              var _7s = $get($1.seta, $get($1.msg, $1.i + 4)) !== void 0;
              if ($1.nums == 4 && _7s) {
                $k[$j++] = $1.sc2;
                $1.enca();
                for (var _7u = 0, _7v = 2; _7u < _7v; _7u++) {
                  if ($get($1.msg, $1.i) == $1.fn1) {
                    $k[$j++] = $1.fn1;
                    $1.encc();
                    $1.i = $1.i + 1;
                  } else {
                    $k[$j++] = $geti($1.msg, $1.i, 2);
                    $1.encc();
                    $1.i = $1.i + 2;
                  }
                }
                break;
              }
            }
            if ($1.i < $1.msglen - 6) {
              var _8D = $get($1.seta, $get($1.msg, $1.i + 6)) !== void 0;
              if ($1.nums == 6 && _8D) {
                $k[$j++] = $1.sc3;
                $1.enca();
                for (var _8F = 0, _8G = 3; _8F < _8G; _8F++) {
                  if ($get($1.msg, $1.i) == $1.fn1) {
                    $k[$j++] = $1.fn1;
                    $1.encc();
                    $1.i = $1.i + 1;
                  } else {
                    $k[$j++] = $geti($1.msg, $1.i, 2);
                    $1.encc();
                    $1.i = $1.i + 2;
                  }
                }
                break;
              }
            }
            if ($1.nums >= 4 && $1.nums % 2 == 0) {
              $k[$j++] = $1.swc;
              $1.enca();
              $1.cset = "setc";
              break;
            }
            $k[$j++] = $get($1.msg, $1.i);
            $1.enca();
            $1.i = $1.i + 1;
            break;
          }
          if ($eq($1.cset, "setb")) {
            if ($1.i < $1.msglen - 1) {
              $k[$j++] = $get($1.msg, $1.i);
              $1.anotb();
              $k[$j++] = $1.i + 1;
              $1.bbeforea();
              var _8f = $k[--$j];
              var _8g = $k[--$j];
              if (_8g && _8f) {
                $k[$j++] = $1.sa1;
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i);
                $1.enca();
                $1.i = $1.i + 1;
                break;
              }
            }
            if ($1.i < $1.msglen - 2) {
              $k[$j++] = $get($1.msg, $1.i);
              $1.anotb();
              $k[$j++] = $get($1.msg, $1.i + 1);
              $1.anotb();
              var _8u = $k[--$j];
              var _8v = $k[--$j];
              $k[$j++] = $an(_8v, _8u);
              $k[$j++] = $1.i + 2;
              $1.bbeforea();
              var _8x = $k[--$j];
              var _8y = $k[--$j];
              if (_8y && _8x) {
                $k[$j++] = $1.sa2;
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i);
                $1.enca();
                $k[$j++] = $get($1.msg, $1.i + 1);
                $1.enca();
                $1.i = $1.i + 2;
                break;
              }
            }
            $k[$j++] = $get($1.msg, $1.i);
            $1.anotb();
            if ($k[--$j]) {
              $k[$j++] = $1.swa;
              $1.encb();
              $1.cset = "seta";
              break;
            }
            if ($1.i < $1.msglen - 4) {
              var _9J = $get($1.setb, $get($1.msg, $1.i + 4)) !== void 0;
              if ($1.nums == 4 && _9J) {
                $k[$j++] = $1.sc2;
                $1.encb();
                for (var _9L = 0, _9M = 2; _9L < _9M; _9L++) {
                  if ($get($1.msg, $1.i) == $1.fn1) {
                    $k[$j++] = $1.fn1;
                    $1.encc();
                    $1.i = $1.i + 1;
                  } else {
                    $k[$j++] = $geti($1.msg, $1.i, 2);
                    $1.encc();
                    $1.i = $1.i + 2;
                  }
                }
                break;
              }
            }
            if ($1.i < $1.msglen - 6) {
              var _9e = $get($1.setb, $get($1.msg, $1.i + 6)) !== void 0;
              if ($1.nums == 6 && _9e) {
                $k[$j++] = $1.sc3;
                $1.encb();
                for (var _9g = 0, _9h = 3; _9g < _9h; _9g++) {
                  if ($get($1.msg, $1.i) == $1.fn1) {
                    $k[$j++] = $1.fn1;
                    $1.encc();
                    $1.i = $1.i + 1;
                  } else {
                    $k[$j++] = $geti($1.msg, $1.i, 2);
                    $1.encc();
                    $1.i = $1.i + 2;
                  }
                }
                break;
              }
            }
            if ($1.nums >= 4 && $1.nums % 2 == 0) {
              $k[$j++] = $1.swc;
              $1.encb();
              $1.cset = "setc";
              break;
            }
            $k[$j++] = $get($1.msg, $1.i);
            $1.encb();
            $1.i = $1.i + 1;
            break;
          }
          if ($eq($1.cset, "setc")) {
            if ($1.nums >= 2) {
              if ($get($1.msg, $1.i) == $1.fn1) {
                $k[$j++] = $1.fn1;
                $1.encc();
                $1.i = $1.i + 1;
              } else {
                $k[$j++] = $geti($1.msg, $1.i, 2);
                $1.encc();
                $1.i = $1.i + 2;
              }
              break;
            }
            if ($1.i < $1.msglen - 1) {
              var _AH = $get($1.setb, $get($1.msg, $1.i)) !== void 0;
              $k[$j++] = _AH;
              $k[$j++] = $1.i + 1;
              $1.numsscr();
              var _AJ = $k[--$j];
              var _AK = $k[--$j];
              $k[$j++] = _AJ;
              $k[$j++] = _AK;
              $j--;
              var _AL = $k[--$j];
              var _AM = $k[--$j];
              if (_AM && (_AL >= 2 && _AL % 2 == 0)) {
                $k[$j++] = $1.sb1;
                $1.encc();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $1.i = $1.i + 1;
                break;
              }
            }
            if ($1.i < $1.msglen - 1) {
              var _AY = $get($1.setb, $get($1.msg, $1.i)) !== void 0;
              $k[$j++] = _AY;
              $k[$j++] = $1.i + 1;
              $1.numsscr();
              var _Aa = $k[--$j];
              var _Ab = $k[--$j];
              $k[$j++] = _Aa;
              $k[$j++] = _Ab;
              $j--;
              var _Ac = $k[--$j];
              var _Ad = $k[--$j];
              if (_Ad && (_Ac >= 3 && _Ac % 2 == 1)) {
                $k[$j++] = $1.sb2;
                $1.encc();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i + 1);
                $1.encb();
                $1.i = $1.i + 2;
                break;
              }
            }
            if ($1.i < $1.msglen - 2) {
              var _As = $get($1.setb, $get($1.msg, $1.i)) !== void 0;
              var _Ax = $get($1.setb, $get($1.msg, $1.i + 1)) !== void 0;
              $k[$j++] = _As && _Ax;
              $k[$j++] = $1.i + 2;
              $1.numsscr();
              var _Az = $k[--$j];
              var _B0 = $k[--$j];
              $k[$j++] = _Az;
              $k[$j++] = _B0;
              $j--;
              var _B1 = $k[--$j];
              var _B2 = $k[--$j];
              if (_B2 && (_B1 >= 2 && _B1 % 2 == 0)) {
                $k[$j++] = $1.sb2;
                $1.encc();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i + 1);
                $1.encb();
                $1.i = $1.i + 2;
                break;
              }
            }
            if ($1.i < $1.msglen - 3) {
              var _BH = $get($1.setb, $get($1.msg, $1.i)) !== void 0;
              var _BM = $get($1.setb, $get($1.msg, $1.i + 1)) !== void 0;
              $k[$j++] = _BH && _BM;
              $k[$j++] = $1.i + 2;
              $1.numsscr();
              var _BO = $k[--$j];
              var _BP = $k[--$j];
              $k[$j++] = _BO;
              $k[$j++] = _BP;
              $j--;
              var _BQ = $k[--$j];
              var _BR = $k[--$j];
              if (_BR && (_BQ >= 3 && _BQ % 2 == 1)) {
                $k[$j++] = $1.sb3;
                $1.encc();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i + 1);
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i + 2);
                $1.encb();
                $1.i = $1.i + 3;
                break;
              }
            }
            if ($1.i < $1.msglen - 3) {
              var _Bj = $get($1.setb, $get($1.msg, $1.i)) !== void 0;
              var _Bo = $get($1.setb, $get($1.msg, $1.i + 1)) !== void 0;
              var _Bt = $get($1.setb, $get($1.msg, $1.i + 2)) !== void 0;
              $k[$j++] = _Bj && _Bo && _Bt;
              $k[$j++] = $1.i + 3;
              $1.numsscr();
              var _Bv = $k[--$j];
              var _Bw = $k[--$j];
              $k[$j++] = _Bv;
              $k[$j++] = _Bw;
              $j--;
              var _Bx = $k[--$j];
              var _By = $k[--$j];
              if (_By && (_Bx >= 2 && _Bx % 2 == 0)) {
                $k[$j++] = $1.sb3;
                $1.encc();
                $k[$j++] = $get($1.msg, $1.i);
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i + 1);
                $1.encb();
                $k[$j++] = $get($1.msg, $1.i + 2);
                $1.encb();
                $1.i = $1.i + 3;
                break;
              }
            }
            $k[$j++] = $1.i;
            $1.abeforeb();
            if ($k[--$j]) {
              $k[$j++] = $1.swa;
              $1.encc();
              $1.cset = "seta";
              break;
            }
            $k[$j++] = $1.swb;
            $1.encc();
            $1.cset = "setb";
            break;
          }
          break;
        }
      }
      $1.cws = $geti($1.cws, 0, $1.j);
    }
    if (!bwipp_code16k.__14438__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.metrics = $a([$a([2, 7]), $a([3, 12]), $a([4, 17]), $a([5, 22]), $a([6, 27]), $a([7, 32]), $a([8, 37]), $a([9, 42]), $a([10, 47]), $a([11, 52]), $a([12, 57]), $a([13, 62]), $a([14, 67]), $a([15, 72]), $a([16, 77])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code16k.$ctx[id] = $ctx[id]);
        bwipp_code16k.__14438__ = 1;
      })();
    }
    $1.urows = $1.rows;
    var _CZ = $1.metrics;
    for (var _Ca = 0, _Cb = _CZ.length; _Ca < _Cb; _Ca++) {
      $1.m = $get(_CZ, _Ca);
      $1.r = $get($1.m, 0);
      $1.dcws = $get($1.m, 1);
      $1.okay = true;
      if ($1.urows != 0 && $1.urows != $1.r) {
        $1.okay = false;
      }
      if ($1.cws.length > $1.dcws) {
        $1.okay = false;
      }
      if ($1.okay) {
        break;
      }
    }
    if (!$1.okay) {
      $k[$j++] = "bwipp.code16kNoValidSymbol#14453";
      $k[$j++] = "Maximum length exceeded or data too large for given options";
      bwipp_raiseerror();
    }
    $k[$j++] = Infinity;
    $aload($1.cws);
    for (var _Cr = 0, _Cs = $f($1.dcws - $1.cws.length); _Cr < _Cs; _Cr++) {
      $k[$j++] = 103;
    }
    $1.cws = $a();
    $k[$j++] = Infinity;
    $k[$j++] = $f($f($1.r - 2) * 7 + $1.mode);
    $aload($1.cws);
    $1.cws = $a();
    $k[$j++] = 0;
    for (var _D0 = 0, _Cz = $1.dcws; _D0 <= _Cz; _D0 += 1) {
      var _D3 = $k[--$j];
      $k[$j++] = $f(_D3 + (_D0 + 2) * $get($1.cws, _D0));
    }
    $1.c1 = $k[--$j] % 107;
    $k[$j++] = 0;
    for (var _D7 = 0, _D6 = $1.dcws; _D7 <= _D6; _D7 += 1) {
      var _DA = $k[--$j];
      $k[$j++] = $f(_DA + (_D7 + 1) * $get($1.cws, _D7));
    }
    $1.c2 = $f($k[--$j] + $1.c1 * $f($1.dcws + 2)) % 107;
    $k[$j++] = Infinity;
    $aload($1.cws);
    $k[$j++] = $1.c1;
    $k[$j++] = $1.c2;
    $1.cws = $a();
    var _DJ = $get($1.options, "debugcws") !== void 0;
    if (_DJ) {
      $k[$j++] = "bwipp.debugcws#14469";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    if (!bwipp_code16k.__14505__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["212222", "222122", "222221", "121223", "121322", "131222", "122213", "122312", "132212", "221213", "221312", "231212", "112232", "122132", "122231", "113222", "123122", "123221", "223211", "221132", "221231", "213212", "223112", "312131", "311222", "321122", "321221", "312212", "322112", "322211", "212123", "212321", "232121", "111323", "131123", "131321", "112313", "132113", "132311", "211313", "231113", "231311", "112133", "112331", "132131", "113123", "113321", "133121", "313121", "211331", "231131", "213113", "213311", "213131", "311123", "311321", "331121", "312113", "312311", "332111", "314111", "221411", "431111", "111224", "111422", "121124", "121421", "141122", "141221", "112214", "112412", "122114", "122411", "142112", "142211", "241211", "221114", "413111", "241112", "134111", "111242", "121142", "121241", "114212", "124112", "124211", "411212", "421112", "421211", "212141", "214121", "412121", "111143", "111341", "131141", "114113", "114311", "411113", "411311", "113141", "114131", "311141", "411131", "211412", "211214", "211232", "211133"]);
        $ctx.startencs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "3112", "3211", "2221", "2122", "1411", "1132", "1231", "1114", "3112"]);
        $ctx.stopencsodd = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "3112", "1132", "1231", "1114", "3112", "3211", "2221", "2122", "1411"]);
        $ctx.stopencseven = $a(["2122", "1411", "1132", "1231", "1114", "3112", "1132", "1231", "1114", "3112", "3211", "2221", "2122", "1411", "3211", "2221"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code16k.$ctx[id] = $ctx[id]);
        bwipp_code16k.__14505__ = 1;
      })();
    }
    if ($1.sam == -1 || ~~($1.sam / 10) % 2 == 1) {
      $1.stopencs = $1.stopencsodd;
    } else {
      $1.stopencs = $1.stopencseven;
    }
    $1.rowbits = $a($1.r);
    for (var _DY = 0, _DX = $f($1.r - 1); _DY <= _DX; _DY += 1) {
      $1.i = _DY;
      $k[$j++] = Infinity;
      $k[$j++] = 10;
      $forall($get($1.startencs, $1.i), function() {
        var _Dc = $k[--$j];
        $k[$j++] = $f(_Dc - 48);
      });
      var _Df = $geti($1.cws, $1.i * 5, 5);
      $k[$j++] = 1;
      for (var _Dg = 0, _Dh = _Df.length; _Dg < _Dh; _Dg++) {
        $forall($get($1.encs, $get(_Df, _Dg)), function() {
          var _Dl = $k[--$j];
          $k[$j++] = $f(_Dl - 48);
        });
      }
      $forall($get($1.stopencs, $1.i), function() {
        var _Dp = $k[--$j];
        $k[$j++] = $f(_Dp - 48);
      });
      $k[$j++] = 1;
      $1.sbs = $a();
      $k[$j++] = Infinity;
      var _Dr = $1.sbs;
      $k[$j++] = 1;
      for (var _Ds = 0, _Dt = _Dr.length; _Ds < _Dt; _Ds++) {
        var _Dv = $k[--$j];
        var _Dw = _Dv == 0 ? 1 : 0;
        $k[$j++] = _Dv;
        for (var _Dx = 0, _Dy = $get(_Dr, _Ds); _Dx < _Dy; _Dx++) {
          $k[$j++] = _Dw;
        }
      }
      $astore($a($counttomark() - 1));
      var _E1 = $k[--$j];
      var _E2 = $k[--$j];
      $k[$j++] = _E1;
      $k[$j++] = _E2;
      $j--;
      var _E3 = $k[--$j];
      var _E4 = $k[--$j];
      $k[$j++] = _E3;
      $k[$j++] = _E4;
      $j--;
      $put($1.rowbits, $1.i, $k[--$j]);
    }
    $k[$j++] = Infinity;
    for (var _E9 = 0, _EA = 81 * $1.sepheight; _E9 < _EA; _E9++) {
      $k[$j++] = 1;
    }
    for (var _ED = 0, _EC = $f($1.r - 2); _ED <= _EC; _ED += 1) {
      $1.i = _ED;
      for (var _EF = 0, _EG = $1.rowheight; _EF < _EG; _EF++) {
        $aload($get($1.rowbits, $1.i));
      }
      for (var _EL = 0, _EM = $1.sepheight; _EL < _EM; _EL++) {
        for (var _EN = 0, _EO = 10; _EN < _EO; _EN++) {
          $k[$j++] = 0;
        }
        for (var _EP = 0, _EQ = 70; _EP < _EQ; _EP++) {
          $k[$j++] = 1;
        }
        $k[$j++] = 0;
      }
    }
    for (var _ES = 0, _ET = $1.rowheight; _ES < _ET; _ES++) {
      $aload($get($1.rowbits, $f($1.r - 1)));
    }
    for (var _EY = 0, _EZ = 81 * $1.sepheight; _EY < _EZ; _EY++) {
      $k[$j++] = 1;
    }
    $1.pixs = $a();
    var _Ef = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", 81],
      ["pixy", ~~($1.pixs.length / 81)],
      ["height", ~~($1.pixs.length / 81) / 72],
      ["width", 81 / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _Ef;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_code49() {
    var $1 = Object.create(bwipp_code49.$ctx || (bwipp_code49.$ctx = {}));
    $1.dontdraw = false;
    $1.sam = -1;
    $1.append = false;
    $1.rows = 0;
    $1.rowheight = 8;
    $1.sepheight = 1;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.rows != 0 && ($1.rows < 2 || $1.rows > 8)) {
      $k[$j++] = "bwipp.code49badRows#14607";
      $k[$j++] = "Code 49 must have 2 to 8 rows";
      bwipp_raiseerror();
    }
    if ($1.rowheight < 8) {
      $k[$j++] = "bwipp.code49badRowHeight#14611";
      $k[$j++] = "Code 49 must have rowheight of at least 8";
      bwipp_raiseerror();
    }
    if ($1.sepheight < 1) {
      $k[$j++] = "bwipp.code49badSepHeight#14615";
      $k[$j++] = "Code 49 must have sepheight of at least 1";
      bwipp_raiseerror();
    }
    if ($1.append && $1.sam != -1) {
      $k[$j++] = "bwipp.code49samAndAppend#14619";
      $k[$j++] = "sam and append cannot be specified together";
      bwipp_raiseerror();
    }
    if ($1.sam != -1) {
      $k[$j++] = true;
      for (var _A = 0, _B = 1; _A < _B; _A++) {
        var _C = $1.sam;
        if (_C < 12 || _C > 99) {
          $j--;
          $k[$j++] = false;
          break;
        }
        if ($1.sam % 10 < 2) {
          $j--;
          $k[$j++] = false;
          break;
        }
        if (~~($1.sam / 10) > $1.sam % 10) {
          $j--;
          $k[$j++] = false;
          break;
        }
      }
      if ($nt($k[--$j])) {
        $k[$j++] = "bwipp.code49badSAM#14630";
        $k[$j++] = 'SAM must be formatted as "NM" for Nth of M symbols, from 2 to 9 symbols';
        bwipp_raiseerror();
      }
    }
    if (!bwipp_code49.__14638__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.s1 = -1;
        $ctx.s2 = -2;
        $ctx.fn1 = -3;
        $ctx.fn2 = -4;
        $ctx.fn3 = -5;
        $ctx.ns = -6;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code49.$ctx[id] = $ctx[id]);
        bwipp_code49.__14638__ = 1;
      })();
    }
    var _N = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["FNC1", $1.fn1],
      ["FNC2", $1.fn2],
      ["FNC3", $1.fn3]
    ]);
    $1.fncvals = _N;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _Q = $k[--$j];
    $1[$k[--$j]] = _Q;
    $1.msglen = $1.msg.length;
    $forall($1.msg, function() {
      if ($k[--$j] > 127) {
        $k[$j++] = "bwipp.code49badCharacter#14653";
        $k[$j++] = "Code 49 can only support ASCII characters with values 0 to 127";
        bwipp_raiseerror();
      }
    });
    if (!bwipp_code49.__14697__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.charmap = $a(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "-", ".", " ", "$", "/", "+", "%", $ctx.s1, $ctx.s2, $ctx.fn1, $ctx.fn2, $ctx.fn3, $ctx.ns]);
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _c = 0; _c <= 48; _c += 1) {
          $ctx.i = _c;
          var _f = $get($ctx.charmap, $ctx.i);
          $k[$j++] = _f;
          if ($eq($type(_f), "stringtype")) {
            var _i = $get($k[--$j], 0);
            $k[$j++] = _i;
          }
          $put($ctx.charvals, $k[--$j], $ctx.i);
        }
        $ctx.combos = $a(["1 ", "1A", "1B", "1C", "1D", "1E", "1F", "1G", "1H", "1I", "1J", "1K", "1L", "1M", "1N", "1O", "1P", "1Q", "1R", "1S", "1T", "1U", "1V", "1W", "1X", "1Y", "1Z", "11", "12", "13", "14", "15", "  ", "16", "17", "18", " $", " %", "19", "10", "1-", "1.", "1$", " +", "1/", " -", " .", " /", " 0", " 1", " 2", " 3", " 4", " 5", " 6", " 7", " 8", " 9", "1+", "21", "22", "23", "24", "25", "26", " A", " B", " C", " D", " E", " F", " G", " H", " I", " J", " K", " L", " M", " N", " O", " P", " Q", " R", " S", " T", " U", " V", " W", " X", " Y", " Z", "27", "28", "29", "20", "2-", "2.", "2A", "2B", "2C", "2D", "2E", "2F", "2G", "2H", "2I", "2J", "2K", "2L", "2M", "2N", "2O", "2P", "2Q", "2R", "2S", "2T", "2U", "2V", "2W", "2X", "2Y", "2Z", "2$", "2/", "2+", "2%", "2 "]);
        for (var _n = 0; _n <= 127; _n += 1) {
          $ctx.i = _n;
          var _q = $get($ctx.combos, $ctx.i);
          $ctx.c1 = $get(_q, 0);
          $ctx.c2 = $get(_q, 1);
          if ($ctx.c1 == 49) {
            $put($ctx.charvals, $ctx.i, $a([$get($ctx.charvals, $ctx.s1), $get($ctx.charvals, $ctx.c2)]));
          }
          if ($ctx.c1 == 50) {
            $put($ctx.charvals, $ctx.i, $a([$get($ctx.charvals, $ctx.s2), $get($ctx.charvals, $ctx.c2)]));
          }
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code49.$ctx[id] = $ctx[id]);
        bwipp_code49.__14697__ = 1;
      })();
    }
    $1.encodealpha = function() {
      var _1G = $get($1.charvals, $k[--$j]);
      $k[$j++] = _1G;
      if ($ne($type(_1G), "arraytype")) {
        $astore($a(1));
      }
      var _1J = $k[--$j];
      $puti($1.cws, $1.j, _1J);
      $1.j = _1J.length + $1.j;
    };
    $1.base48 = function() {
      var _1N = $k[--$j];
      $k[$j++] = 0;
      $forall(_1N, function() {
        var _1O = $k[--$j];
        var _1P = $k[--$j];
        $k[$j++] = $f($f(_1O - 48) + _1P * 10);
      });
      $k[$j++] = Infinity;
      var _1Q = $k[--$j];
      var _1R = $k[--$j];
      var _1S = $k[--$j];
      $k[$j++] = _1Q;
      $k[$j++] = _1R;
      for (var _1T = 0, _1U = $f(_1S - 1); _1T < _1U; _1T++) {
        var _1V = $k[--$j];
        $k[$j++] = _1V % 48;
        $k[$j++] = ~~(_1V / 48);
      }
      var _1W = $a();
      $k[$j++] = _1W;
      $k[$j++] = Infinity;
      var _1X = $k[--$j];
      var _1Y = $k[--$j];
      $k[$j++] = _1X;
      $k[$j++] = _1Y;
      for (var _1Z = _1Y.length - 1; _1Z >= 0; _1Z -= 1) {
        var _1a = $k[--$j];
        $k[$j++] = $get(_1a, _1Z);
        $k[$j++] = _1a;
      }
      $j--;
      var _1c = $a();
      $puti($1.cws, $1.j, _1c);
      $1.j = _1c.length + $1.j;
    };
    $1.encodenumeric = function() {
      $1.nums = $k[--$j];
      var _1i = $1.nums.length;
      var _1j = _1i % 5;
      $k[$j++] = "pre";
      $k[$j++] = _1i;
      $k[$j++] = _1j;
      if (_1j != 2) {
        var _1k = $k[--$j];
        var _1l = $k[--$j];
        $k[$j++] = $f(_1l - _1k);
      } else {
        var _1m = $k[--$j];
        var _1n = $k[--$j];
        $k[$j++] = $f($f(_1n - _1m) - 5);
      }
      var _1o = $k[--$j];
      $1[$k[--$j]] = _1o;
      for (var _1s = 0, _1r = $f($1.pre - 1); _1s <= _1r; _1s += 5) {
        $k[$j++] = 3;
        $k[$j++] = $geti($1.nums, _1s, 5);
        $1.base48();
      }
      $1.nums = $geti($1.nums, $1.pre, $f($1.nums.length - $1.pre));
      var _21 = $1.nums.length;
      $k[$j++] = _21;
      if (_21 == 1) {
        $k[$j++] = $get($1.nums, $1.i);
        $1.encodealpha();
      }
      var _25 = $k[--$j];
      $k[$j++] = _25;
      if (_25 == 3) {
        $k[$j++] = 2;
        $k[$j++] = $1.nums;
        $1.base48();
      }
      var _27 = $k[--$j];
      $k[$j++] = _27;
      if (_27 == 4) {
        $k[$j++] = 3;
        $k[$j++] = Infinity;
        $k[$j++] = 49;
        $k[$j++] = 48;
        $aload($1.nums);
        var _29 = $a();
        $k[$j++] = _29;
        $1.base48();
      }
      if ($k[--$j] == 7) {
        $k[$j++] = 3;
        $k[$j++] = Infinity;
        $k[$j++] = 49;
        $k[$j++] = 48;
        $aload($geti($1.nums, 0, 4));
        var _2D = $a();
        $k[$j++] = _2D;
        $1.base48();
        $k[$j++] = 2;
        $k[$j++] = $geti($1.nums, 4, 3);
        $1.base48();
      }
    };
    $k[$j++] = Infinity;
    for (var _2H = 0, _2I = $1.msglen; _2H < _2I; _2H++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.numericruns = $a();
    for (var _2L = $1.msglen - 1; _2L >= 0; _2L -= 1) {
      $1.i = _2L;
      var _2O = $get($1.msg, $1.i);
      if (_2O >= 48 && _2O <= 57) {
        $put($1.numericruns, $1.i, $f($get($1.numericruns, $1.i + 1) + 1));
      } else {
        $put($1.numericruns, $1.i, 0);
      }
    }
    $1.cws = $a($1.msglen * 2 + 1);
    if (!bwipp_code49.__14754__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.samval = $a([12, 22, 13, 23, 33, 14, 24, 34, 44, 15, 25, 35, 45, 55, 16, 26, 36, 46, 56, 66, 17, 27, 37, 47, 57, 67, 77, 18, 28, 38, 48, 58, 68, 78, 88, 19, 29, 39, 49, 59, 69, 79, 89, 99]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code49.$ctx[id] = $ctx[id]);
        bwipp_code49.__14754__ = 1;
      })();
    }
    for (; ; ) {
      if ($1.append) {
        $1.mode = 1;
        $1.method = "alpha";
        $1.i = 0;
        $1.j = 0;
        break;
      }
      if ($1.sam != -1) {
        $1.mode = 3;
        $k[$j++] = $1.cws;
        $k[$j++] = 0;
        for (var _2d = 0; _2d <= 43; _2d += 1) {
          $k[$j++] = _2d;
          if ($get($1.samval, _2d) != $1.sam) {
            $j--;
          }
        }
        var _2h = $k[--$j];
        var _2i = $k[--$j];
        $put($k[--$j], _2i, $f(_2h + 1));
        $1.method = "alpha";
        $1.i = 0;
        $1.j = 1;
        break;
      }
      if ($get($1.numericruns, 0) >= 5) {
        $1.mode = 2;
        $1.method = "numeric";
        $1.i = 0;
        $1.j = 0;
        break;
      }
      var _2p = $get($1.charvals, $get($1.msg, 0));
      $k[$j++] = _2p;
      if ($ne($type(_2p), "arraytype")) {
        $j--;
        $1.mode = 0;
        $1.method = "alpha";
        $1.i = 0;
        $1.j = 0;
        break;
      }
      var _2t = $get($k[--$j], 0) == 43 ? 4 : 5;
      $1.mode = _2t;
      $put($1.cws, 0, $get($get($1.charvals, $get($1.msg, 0)), 1));
      $1.method = "alpha";
      $1.i = 1;
      $1.j = 1;
      break;
    }
    for (; ; ) {
      if ($1.i == $1.msglen) {
        break;
      }
      for (; ; ) {
        if ($eq($1.method, "alpha")) {
          if ($get($1.numericruns, $1.i) >= 5) {
            $k[$j++] = $1.ns;
            $1.encodealpha();
            $1.method = "numeric";
            break;
          }
          $k[$j++] = $get($1.msg, $1.i);
          $1.encodealpha();
          $1.i = $1.i + 1;
          break;
        }
        if ($eq($1.method, "numeric")) {
          if ($get($1.numericruns, $1.i) < 5) {
            $k[$j++] = $1.ns;
            $1.encodealpha();
            $1.method = "alpha";
            break;
          }
          $k[$j++] = $geti($1.msg, $1.i, $get($1.numericruns, $1.i));
          $1.encodenumeric();
          $1.i = $f($1.i + $get($1.numericruns, $1.i));
          break;
        }
      }
    }
    $1.cws = $geti($1.cws, 0, $1.j);
    if (!bwipp_code49.__14832__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.metrics = $a([$a([2, 9]), $a([3, 16]), $a([4, 23]), $a([5, 30]), $a([6, 37]), $a([7, 42]), $a([8, 49])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code49.$ctx[id] = $ctx[id]);
        bwipp_code49.__14832__ = 1;
      })();
    }
    $1.urows = $1.rows;
    var _3d = $1.metrics;
    for (var _3e = 0, _3f = _3d.length; _3e < _3f; _3e++) {
      $1.m = $get(_3d, _3e);
      $1.r = $get($1.m, 0);
      $1.dcws = $get($1.m, 1);
      $1.okay = true;
      if ($1.urows != 0 && $1.urows != $1.r) {
        $1.okay = false;
      }
      if ($1.cws.length > $1.dcws) {
        $1.okay = false;
      }
      if ($1.okay) {
        break;
      }
    }
    if (!$1.okay) {
      $k[$j++] = "bwipp.code49noValidSymbol#14847";
      $k[$j++] = "Maximum length exceeded";
      bwipp_raiseerror();
    }
    $k[$j++] = Infinity;
    $aload($1.cws);
    for (var _3v = 0, _3w = $f($1.dcws - $1.cws.length); _3v < _3w; _3v++) {
      $k[$j++] = 48;
    }
    $1.cws = $a();
    $1.ccs = $a($1.r * 8);
    $1.j = 0;
    for (var _42 = 0, _41 = $f($1.r - 2); _42 <= _41; _42 += 1) {
      $1.i = _42;
      $1.cc = $geti($1.cws, $1.j, 7);
      $puti($1.ccs, $1.i * 8, $1.cc);
      var _4B = $1.cc;
      $k[$j++] = $1.ccs;
      $k[$j++] = $1.i * 8 + 7;
      $k[$j++] = 0;
      for (var _4C = 0, _4D = _4B.length; _4C < _4D; _4C++) {
        var _4F = $k[--$j];
        $k[$j++] = $f(_4F + $get(_4B, _4C));
      }
      var _4G = $k[--$j];
      var _4H = $k[--$j];
      $put($k[--$j], _4H, _4G % 49);
      $1.j = $1.j + 7;
    }
    if ($1.j < $1.dcws) {
      $puti($1.ccs, $1.ccs.length - 8, $geti($1.cws, $1.j, $f($1.dcws - $1.j)));
    }
    $1.cr7 = $f($f($1.r - 2) * 7 + $1.mode);
    $put($1.ccs, $1.ccs.length - 2, $1.cr7);
    if (!bwipp_code49.__14878__) {
      (function() {
        var $ctx = Object.create($1);
        var _4Y = $a([1, 9, 31, 26, 2, 12, 17, 23, 37, 18, 22, 6, 27, 44, 15, 43, 39, 11, 13, 5, 41, 33, 36, 8, 4, 32, 3, 19, 40, 25, 29, 10, 24, 30]);
        $k[$j++] = _4Y;
        $k[$j++] = _4Y;
        $k[$j++] = Infinity;
        var _4Z = $k[--$j];
        var _4b = $geti($k[--$j], 0, 32);
        $k[$j++] = _4Z;
        $k[$j++] = 20;
        $aload(_4b);
        $ctx.weightx = $a();
        var _4d = $k[--$j];
        $k[$j++] = _4d;
        $k[$j++] = _4d;
        $k[$j++] = Infinity;
        var _4e = $k[--$j];
        var _4g = $geti($k[--$j], 1, 32);
        $k[$j++] = _4e;
        $k[$j++] = 16;
        $aload(_4g);
        $ctx.weighty = $a();
        $k[$j++] = Infinity;
        var _4i = $k[--$j];
        var _4k = $geti($k[--$j], 2, 32);
        $k[$j++] = _4i;
        $k[$j++] = 38;
        $aload(_4k);
        $ctx.weightz = $a();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code49.$ctx[id] = $ctx[id]);
        bwipp_code49.__14878__ = 1;
      })();
    }
    $1.calccheck = function() {
      $1.weights = $k[--$j];
      $1.score = 0;
      for (var _4q = 0, _4p = ~~($f($1.r - 1) * 8 / 2) - 1; _4q <= _4p; _4q += 1) {
        $1.i = _4q;
        $1.score = $f($f($get($1.ccs, $1.i * 2) * 49 + $get($1.ccs, $1.i * 2 + 1)) * $get($1.weights, $1.i + 1) + $1.score);
      }
      $k[$j++] = $1.score;
    };
    $1.lastrow = $geti($1.ccs, $1.ccs.length - 8, 8);
    if ($1.r >= 7) {
      $k[$j++] = $1.cr7 * $get($1.weightz, 0);
      $k[$j++] = $1.weightz;
      $1.calccheck();
      var _5A = $k[--$j];
      var _5C = $f($k[--$j] + _5A) % 2401;
      $k[$j++] = ~~(_5C / 49);
      $k[$j++] = _5C % 49;
      $astore($a(2));
      $puti($1.lastrow, 0, $k[--$j]);
    }
    $1.wr1 = $f($get($1.lastrow, 0) * 49 + $get($1.lastrow, 1));
    $k[$j++] = $1.cr7 * $get($1.weighty, 0);
    $k[$j++] = $1.weighty;
    $1.calccheck();
    var _5O = $k[--$j];
    var _5U = $f($f($k[--$j] + _5O) + $1.wr1 * $get($1.weighty, $f($1.r * 4 - 3))) % 2401;
    $1.wr2 = _5U;
    $k[$j++] = ~~(_5U / 49);
    $k[$j++] = _5U % 49;
    $astore($a(2));
    $puti($1.lastrow, 2, $k[--$j]);
    $k[$j++] = $1.cr7 * $get($1.weightx, 0);
    $k[$j++] = $1.weightx;
    $1.calccheck();
    var _5c = $k[--$j];
    var _5m = $f($f($f($k[--$j] + _5c) + $1.wr1 * $get($1.weightx, $f($1.r * 4 - 3))) + $1.wr2 * $get($1.weightx, $f($1.r * 4 - 2))) % 2401;
    $k[$j++] = ~~(_5m / 49);
    $k[$j++] = _5m % 49;
    $astore($a(2));
    $puti($1.lastrow, 4, $k[--$j]);
    var _5s = $geti($1.ccs, $1.ccs.length - 8, 7);
    $k[$j++] = 0;
    for (var _5t = 0, _5u = _5s.length; _5t < _5u; _5t++) {
      var _5w = $k[--$j];
      $k[$j++] = $f(_5w + $get(_5s, _5t));
    }
    $put($1.ccs, $1.ccs.length - 1, $k[--$j] % 49);
    var _61 = $get($1.options, "debugcws") !== void 0;
    if (_61) {
      $k[$j++] = "bwipp.debugcws#14918";
      $k[$j++] = $1.ccs;
      bwipp_raiseerror();
    }
    if (!bwipp_code49.__15616__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.patterns = $a([$a(["11521132", "25112131", "14212132", "25121221", "14221222", "12412132", "23321221", "12421222", "21521221", "15112222", "15121312", "13312222", "24221311", "13321312", "11512222", "22421311", "11521312", "25112311", "14212312", "23312311", "12412312", "21512311", "16121131", "14321131", "12521131", "15212131", "15221221", "13412131", "13421221", "11612131", "16112221", "16121311", "14312221", "14321311", "12512221", "12521311", "15212311", "13412311", "11612311", "11131135", "31131133", "51131131", "21122134", "41122132", "21131224", "41131222", "11113135", "31113133", "51113131", "11122225", "31122223", "51122221", "11131315", "31131313", "51131311", "21113224", "41113222", "21122314", "41122312", "11113315", "31113313", "51113311", "12131134", "32131132", "21231133", "41231131", "22122133", "42122131", "11222134", "22131223", "42131221", "11231224", "31231222", "12113134", "32113132", "12122224", "32122222", "12131314", "32131312", "21231313", "41231311", "22113223", "42113221", "11213224", "22122313", "42122311", "11222314", "31222312", "12113314", "32113312", "21213313", "41213311", "13131133", "33131131", "22231132", "11331133", "31331131", "23122132", "12222133", "23131222", "12231223", "32231221", "21331222", "13113133", "33113131", "13122223", "33122221", "11313133", "13131313", "33131311", "11322223", "22231312", "11331313", "31331311", "23113222", "12213223", "23122312", "12222313", "32222311", "21322312", "13113313", "33113311", "22213312", "11313313", "31313311", "14131132", "23231131", "12331132", "21431131", "24122131", "13222132", "24131221", "13231222", "11422132", "22331221", "11431222", "14113132", "14122222", "12313132", "14131312", "12322222", "23231311", "12331312", "21431311", "24113221", "13213222", "24122311", "13222312", "11413222", "22322311", "11422312", "14113312", "23213311", "12313312", "21413311", "15131131", "13331131", "14222131", "14231221", "12422131", "12431221", "15113131", "15122221", "13313131", "15131311", "13322221", "11513131", "13331311", "11522221", "14213221", "14222311", "12413221", "12422311", "15113311", "13313311", "11513311", "11141134", "31141132", "21132133", "41132131", "21141223", "41141221", "11123134", "31123132", "11132224", "31132222", "11141314", "31141312", "21114133", "41114131", "21123223", "41123221", "21132313", "41132311", "11114224", "31114222", "11123314", "31123312", "21114313", "41114311", "12141133", "32141131", "21241132", "22132132", "11232133", "22141222", "11241223", "31241221", "12123133", "32123131", "12132223", "32132221", "12141313", "32141311", "21241312", "22114132", "11214133", "22123222", "11223223", "22132312", "11232313", "31232311", "12114223", "32114221", "12123313", "32123311", "21223312", "22114312", "11214313", "31214311", "13141132", "22241131", "11341132", "23132131", "12232132", "23141221", "12241222", "21341221", "13123132", "13132222", "11323132", "13141312", "11332222", "22241311", "11341312", "23114131", "12214132", "23123221", "12223222", "23132311", "12232312", "21332311", "13114222", "13123312", "11314222", "22223311", "11323312", "23114311", "12214312", "21314311", "14141131", "12341131", "13232131", "13241221", "11432131", "14123131", "14132221", "12323131", "14141311", "12332221", "12341311", "13214131", "13223221", "11414131", "13232311", "11423221", "11432311", "14114221", "14123311", "12314221", "12323311", "13214311", "11414311", "11151133", "31151131", "21142132", "21151222", "11133133", "31133131", "11142223", "31142221", "11151313", "31151311", "21124132", "21133222", "21142312", "11115133", "31115131", "11124223", "31124221", "11133313", "31133311", "21115222", "21124312", "12151132", "21251131", "22142131", "11242132", "22151221", "11251222", "12133132", "12142222", "12151312", "21251311", "22124131", "11224132", "22133221", "11233222", "22142311", "11242312", "12115132", "12124222", "12133312", "21233311", "22115221", "11215222", "22124311", "11224312", "13151131", "12242131", "12251221", "13133131", "13142221", "11333131", "13151311", "11342221", "12224131", "12233221", "12242311", "13115131", "13124221", "11315131", "13133311", "11324221", "11333311", "12215221", "12224311", "11161132", "21152131", "21161221", "11143132", "11152222", "11161312", "21134131", "21143221", "21152311", "11125132", "11134222", "11143312", "21116131", "21125221", "21134311", "12161131", "11252131", "12143131", "12152221", "12161311", "11234131", "11243221", "11252311", "12125131", "12134221", "12143311", "11216131", "11225221", "11234311", "11111236", "31111234", "51111232", "21111325", "41111323", "61111321", "11111416", "31111414", "51111412", "31211143", "51211141", "12111235", "32111233", "52111231", "21211234", "41211232", "22111324", "42111322", "11211325", "31211323", "51211321", "12111415", "32111413", "52111411", "21211414", "41211412", "12211144", "32211142", "21311143", "41311141", "13111234", "33111232", "22211233", "42211231", "11311234", "31311232", "23111323", "43111321", "12211324", "32211322", "21311323", "41311321", "13111414", "33111412", "22211413", "42211411", "11311414", "31311412", "13211143", "33211141", "22311142", "11411143", "31411141", "14111233", "34111231", "23211232", "12311233", "32311231", "21411232", "24111322", "13211323", "33211321", "22311322", "11411323", "31411321", "14111413", "34111411", "23211412", "12311413", "32311411", "21411412", "14211142", "23311141", "12411142", "21511141", "15111232", "24211231", "13311232", "22411231", "11511232", "25111321", "14211322", "23311321", "12411322", "21511321", "15111412", "24211411", "13311412", "22411411", "11511412", "15211141", "13411141", "11611141", "16111231", "14311231", "12511231", "15211321", "13411321", "11611321", "16111411", "14311411", "12511411", "21121144", "41121142", "11112145", "31112143", "51112141", "11121235", "31121233", "51121231", "21112234", "41112232", "21121324", "41121322", "11112325", "31112323", "51112321", "11121415", "31121413", "51121411", "21112414", "41112412", "22121143", "42121141", "11221144", "31221142", "12112144", "32112142", "12121234", "32121232", "21221233", "41221231", "22112233", "42112231", "11212234", "22121323", "42121321", "11221324", "31221322", "12112324", "32112322", "12121414", "32121412", "21221413", "41221411", "22112413", "42112411", "11212414", "31212412", "23121142", "12221143", "32221141", "21321142", "13112143", "33112141", "13121233", "33121231", "11312143", "22221232", "11321233", "31321231", "23112232", "12212233", "23121322", "12221323", "32221321", "21321322", "13112323", "33112321", "13121413", "33121411", "11312323", "22221412", "11321413", "31321411", "23112412", "12212413", "32212411", "21312412", "24121141", "13221142", "22321141", "11421142", "14112142", "14121232", "12312142", "23221231", "12321232", "21421231", "24112231", "13212232", "24121321", "13221322", "11412232", "22321321", "11421322", "14112322", "14121412", "12312322", "23221411", "12321412", "21421411", "24112411", "13212412", "22312411", "11412412", "14221141", "12421141", "15112141", "15121231", "13312141", "13321231", "11512141", "11521231", "14212231", "14221321", "12412231", "12421321", "15112321", "15121411", "13312321", "13321411", "11512321", "11521411", "14212411", "12412411", "21131143", "41131141", "11122144", "31122142", "11131234", "31131232", "21113143", "41113141", "21122233", "41122231", "21131323", "41131321", "11113234", "31113232", "11122324", "31122322", "11131414", "31131412", "21113323", "41113321", "21122413", "41122411", "11113414", "31113412", "22131142", "11231143", "31231141", "12122143", "32122141", "12131233", "32131231", "21231232", "22113142", "11213143", "22122232", "11222233", "22131322", "11231323", "31231321", "12113233", "32113231", "12122323", "32122321", "12131413", "32131411", "21231412", "22113322", "11213323", "22122412", "11222413", "31222411", "12113413", "32113411", "21213412", "23131141", "12231142", "21331141", "13122142", "13131232", "11322142", "22231231", "11331232", "23113141", "12213142", "23122231", "12222232", "23131321", "12231322", "21331321", "13113232", "13122322", "11313232", "13131412", "11322322", "22231411", "11331412", "23113321", "12213322", "23122411", "12222412", "21322411", "13113412", "22213411", "11313412", "13231141", "11431141", "14122141", "14131231", "12322141", "12331231", "13213141", "13222231", "11413141", "13231321", "11422231", "11431321", "14113231", "14122321", "12313231", "14131411", "12322321", "12331411", "13213321", "13222411", "11413321", "11422411", "14113411", "12313411", "21141142", "11132143", "31132141", "11141233", "31141231", "21123142", "21132232", "21141322", "11114143", "31114141", "11123233", "31123231", "11132323", "31132321", "11141413", "31141411", "21114232", "21123322", "21132412", "11114323", "31114321", "11123413", "31123411", "22141141", "11241142", "12132142", "12141232", "21241231", "22123141", "11223142", "22132231", "11232232", "22141321", "11241322", "12114142", "12123232", "12132322", "12141412", "21241411", "22114231", "11214232", "22123321", "11223322", "22132411", "11232412", "12114322", "12123412", "21223411", "12241141", "13132141", "13141231", "11332141", "11341231", "12223141", "12232231", "12241321", "13114141", "13123231", "11314141", "13132321", "11323231", "13141411", "11332321", "11341411", "12214231", "12223321", "12232411", "13114321", "13123411", "11314321", "11323411", "21151141", "11142142", "11151232", "21133141", "21142231", "21151321", "11124142", "11133232", "11142322", "11151412", "21115141", "21124231", "21133321", "21142411", "11115232", "11124322", "11133412", "11251141", "12142141", "12151231", "11233141", "11242231", "11251321", "12124141", "12133231", "12142321", "12151411", "11215141", "11224231", "11233321", "11242411", "12115231", "12124321", "12133411", "11152141", "11161231", "11134141", "11143231", "11152321", "11161411", "11116141", "11125231", "11134321", "11143411", "21111244", "41111242", "11111335", "31111333", "51111331", "21111424", "41111422", "11111515", "31111513", "51111511", "21211153", "41211151", "22111243", "42111241", "11211244", "31211242", "12111334", "32111332", "21211333", "41211331", "22111423", "42111421", "11211424", "31211422", "12111514", "32111512", "21211513", "41211511", "22211152", "11311153", "31311151", "23111242", "12211243", "32211241", "21311242", "13111333", "33111331", "22211332", "11311333", "31311331", "23111422", "12211423", "32211421", "21311422", "13111513", "33111511", "22211512", "11311513", "31311511", "23211151", "12311152", "21411151", "24111241", "13211242", "22311241", "11411242", "14111332", "23211331", "12311332", "21411331", "24111421", "13211422", "22311421", "11411422", "14111512", "23211511", "12311512", "21411511", "13311151", "11511151", "14211241", "12411241", "15111331", "13311331", "11511331", "14211421", "12411421", "15111511", "13311511", "11511511", "31121152", "21112153", "41112151", "21121243", "41121241", "11112244", "31112242", "11121334", "31121332", "21112333", "41112331", "21121423", "41121421", "11112424", "31112422", "11121514", "31121512", "21112513", "41112511", "12121153", "32121151", "21221152", "22112152", "11212153", "22121242", "11221243", "31221241", "12112243", "32112241", "12121333", "32121331", "21221332", "22112332", "11212333", "22121422", "11221423", "31221421", "12112423", "32112421", "12121513", "32121511", "21221512", "22112512", "11212513", "31212511", "13121152", "22221151", "11321152", "23112151", "12212152", "23121241", "12221242", "21321241", "13112242", "13121332", "11312242", "22221331", "11321332", "23112331", "12212332", "23121421", "12221422", "21321421", "13112422", "13121512", "11312422", "22221511", "11321512", "23112511", "12212512", "21312511", "14121151", "12321151", "13212151", "13221241", "11412151", "11421241", "14112241", "14121331", "12312241", "12321331", "13212331", "13221421", "11412331", "11421421", "14112421", "14121511", "12312421", "12321511", "13212511", "11412511", "11131153", "31131151", "21122152", "21131242", "11113153", "31113151", "11122243", "31122241", "11131333", "31131331", "21113242", "21122332", "21131422", "11113333", "31113331", "11122423", "31122421", "11131513", "31131511", "21113422", "21122512", "12131152", "21231151", "22122151", "11222152", "22131241", "11231242", "12113152", "12122242", "12131332", "21231331", "22113241", "11213242", "22122331", "11222332", "22131421", "11231422", "12113332", "12122422", "12131512", "21231511", "22113421", "11213422", "22122511", "11222512", "13131151", "11331151", "12222151", "12231241", "13113151", "13122241", "11313151", "13131331", "11322241", "11331331", "12213241", "12222331", "12231421", "13113331", "13122421", "11313331", "13131511", "11322421", "11331511", "12213421", "12222511", "11141152", "21132151", "21141241", "11123152", "11132242", "11141332", "21114151", "21123241", "21132331", "21141421", "11114242", "11123332", "11132422", "11141512", "21114331", "21123421", "21132511", "12141151", "11232151", "11241241", "12123151", "12132241", "12141331", "11214151", "11223241", "11232331", "11241421", "12114241", "12123331", "12132421", "12141511", "11214331", "11223421", "11232511", "11151151", "11133151", "11142241", "11151331", "11115151", "11124241", "11133331", "11142421", "11151511", "11111254", "31111252", "21111343", "41111341", "11111434", "31111432", "21111523", "41111521", "11111614", "31111612", "31211161", "12111253", "32111251", "21211252", "22111342", "11211343", "31211341", "12111433", "32111431", "21211432", "22111522", "11211523", "31211521", "12111613", "32111611", "21211612", "12211162", "21311161", "13111252", "22211251", "11311252", "23111341", "12211342", "21311341", "13111432", "22211431", "11311432", "23111521", "12211522", "21311521", "13111612", "22211611", "11311612", "13211161", "11411161", "14111251", "12311251", "13211341", "11411341", "14111431", "12311431", "13211521", "11411521", "14111611", "12311611", "21121162", "11112163", "31112161", "11121253", "31121251", "21112252", "21121342", "11112343", "31112341", "11121433", "31121431", "21112432", "21121522", "11112523", "31112521", "11121613", "31121611", "22121161", "11221162", "12112162", "12121252", "21221251", "22112251", "11212252", "22121341", "11221342", "12112342", "12121432", "21221431", "22112431", "11212432", "22121521", "11221522", "12112522", "12121612", "21221611", "12221161", "13112161", "13121251", "11312161", "11321251", "32121115", "52121113", "21221116", "41221114", "61221112", "22112116", "42112114", "31212115", "51212113", "13121116", "33121114", "22221115", "42221113", "11321116", "31321114", "51321112", "23112115", "43112113", "12212116", "32212114", "52212112", "21312115", "41312113", "61312111", "14121115", "34121113", "23221114", "43221112", "12321115", "32321113", "52321111", "21421114", "41421112", "24112114", "13212115", "33212113", "22312114", "42312112", "11412115", "31412113", "51412111", "15121114", "24221113", "13321114", "33321112", "22421113", "42421111", "11521114", "31521112", "25112113", "14212114", "34212112", "23312113", "43312111", "12412114", "32412112", "21512113", "41512111", "16121113", "25221112", "14321113", "34321111", "23421112", "12521113", "32521111", "15212113", "24312112", "13412113", "33412111", "22512112", "11612113", "31612111", "31131115", "51131113", "21122116", "41122114", "61122112", "31113115", "51113113", "12131116", "32131114", "52131112", "21231115", "41231113", "61231111", "22122115", "42122113", "11222116", "31222114", "51222112", "12113116", "32113114", "52113112", "21213115", "41213113", "61213111", "13131115", "33131113", "22231114", "42231112", "11331115", "31331113", "51331111", "23122114", "43122112", "12222115", "32222113", "52222111", "21322114", "41322112", "13113115", "33113113", "22213114", "42213112", "11313115", "31313113", "51313111", "14131114", "34131112", "23231113", "43231111", "12331114", "32331112", "21431113", "41431111", "24122113", "13222114", "33222112", "22322113", "42322111", "11422114", "31422112", "14113114", "34113112", "23213113", "43213111", "12313114", "32313112", "21413113", "41413111", "15131113", "24231112", "13331113", "33331111", "22431112", "25122112", "14222113", "34222111", "23322112", "12422113", "32422111", "21522112", "15113113", "24213112", "13313113", "33313111", "22413112", "11513113", "31513111", "16131112", "25231111", "14331112", "23431111", "15222112", "24322111", "13422112", "22522111", "16113112", "25213111", "14313112", "23413111", "12513112", "21613111", "11141116", "31141114", "51141112", "21132115", "41132113", "61132111", "11123116", "31123114", "51123112", "21114115", "41114113", "61114111", "12141115", "32141113", "52141111", "21241114", "41241112", "22132114", "42132112", "11232115", "31232113", "51232111", "12123115", "32123113", "52123111", "21223114", "41223112", "22114114", "42114112", "11214115", "31214113", "51214111", "13141114", "33141112", "22241113", "42241111", "11341114", "31341112", "23132113", "43132111", "12232114", "32232112", "21332113", "41332111", "13123114", "33123112", "22223113", "42223111", "11323114", "31323112", "23114113", "43114111", "12214114", "32214112", "21314113", "41314111", "14141113", "34141111", "23241112", "12341113", "32341111", "24132112", "13232113", "33232111", "22332112", "11432113", "31432111", "14123113", "34123111", "23223112", "12323113", "32323111", "21423112", "24114112", "13214113", "33214111", "22314112", "11414113", "31414111", "15141112", "24241111", "13341112", "25132111", "14232112", "23332111", "12432112", "15123112", "24223111", "13323112", "22423111", "11523112", "25114111", "14214112", "23314111", "12414112", "21514111", "16141111", "14341111", "15232111", "13432111", "16123111", "14323111", "12523111", "15214111", "13414111", "11614111", "11151115", "31151113", "51151111", "21142114", "41142112", "11133115", "31133113", "51133111", "21124114", "41124112", "11115115", "31115113", "51115111", "12151114", "32151112", "21251113", "41251111", "22142113", "42142111", "11242114", "31242112", "12133114", "32133112", "21233113", "41233111", "22124113", "42124111", "11224114", "31224112", "12115114", "32115112", "21215113", "41215111", "13151113", "33151111", "22251112", "23142112", "12242113", "32242111", "21342112", "13133113", "33133111", "22233112", "11333113", "31333111", "23124112", "12224113", "32224111", "21324112", "13115113", "33115111", "22215112", "11315113", "31315111", "14151112", "23251111", "24142111", "13242112", "22342111", "14133112", "23233111", "12333112", "21433111", "24124111", "13224112", "22324111", "11424112", "14115112", "23215111", "12315112", "21415111", "15151111", "14242111", "15133111", "13333111", "14224111", "12424111", "15115111", "13315111", "11515111", "11161114", "31161112", "21152113", "41152111", "11143114", "31143112", "21134113", "41134111", "11125114", "31125112", "21116113", "41116111", "12161113", "32161111", "22152112", "11252113", "31252111", "12143113", "32143111", "21243112", "22134112", "11234113", "31234111", "12125113", "32125111", "21225112", "22116112", "11216113", "31216111", "13161112", "23152111", "12252112", "13143112", "22243111", "11343112", "23134111", "12234112", "21334111", "13125112", "22225111", "11325112", "23116111", "12216112", "21316111", "14161111", "13252111", "14143111", "12343111", "13234111", "11434111", "14125111", "12325111", "13216111", "11416111", "31111216", "51111214", "31211125", "51211123", "32111215", "52111213", "21211216", "41211214", "61211212", "12211126", "32211124", "52211122", "21311125", "41311123", "61311121", "13111216", "33111214", "22211215", "42211213", "11311216", "31311214", "51311212", "13211125", "33211123", "22311124", "42311122", "11411125", "31411123", "51411121", "14111215", "34111213", "23211214", "43211212", "12311215", "32311213", "52311211", "21411214", "41411212", "14211124", "34211122", "23311123", "43311121", "12411124", "32411122", "21511123", "41511121", "15111214", "24211213", "13311214", "33311212", "22411213", "42411211", "11511214", "31511212", "15211123", "24311122", "13411123", "33411121", "22511122", "11611123", "31611121", "16111213", "25211212", "14311213", "34311211", "23411212", "12511213", "32511211", "21611212", "21121126", "41121124", "61121122", "31112125", "51112123", "31121215", "51121213", "21112216", "41112214", "61112212", "22121125", "42121123", "11221126", "31221124", "51221122", "12112126", "32112124", "52112122", "12121216", "32121214", "52121212", "21221215", "41221213", "61221211", "22112215", "42112213", "11212216", "31212214", "51212212", "23121124", "43121122", "12221125", "32221123", "52221121", "21321124", "41321122", "13112125", "33112123", "13121215", "33121213", "11312125", "22221214", "42221212", "11321215", "31321213", "51321211", "23112214", "43112212", "12212215", "32212213", "52212211", "21312214", "41312212", "24121123", "13221124", "33221122", "22321123", "42321121", "11421124", "31421122", "14112124", "34112122", "14121214", "34121212", "12312124", "23221213", "43221211", "12321214", "32321212", "21421213", "41421211", "24112213", "13212214", "33212212", "22312213", "42312211", "11412214", "31412212", "25121122", "14221123", "34221121", "23321122", "12421123", "32421121", "21521122", "15112123", "15121213", "13312123", "24221212", "13321213", "33321211", "11512123", "22421212", "11521213", "31521211", "25112212", "14212213", "34212211", "23312212", "12412213", "32412211", "21512212", "15221122", "24321121", "13421122", "22521121", "16112122", "16121212", "14312122", "25221211", "14321212", "12512122", "23421211", "12521212", "15212212", "24312211", "13412212", "22512211", "11612212", "21131125", "41131123", "61131121", "11122126", "31122124", "51122122", "11131216", "31131214", "51131212", "21113125", "41113123", "61113121", "21122215", "41122213", "61122211", "11113216", "31113214", "51113212", "22131124", "42131122", "11231125", "31231123", "51231121", "12122125", "32122123", "52122121", "12131215", "32131213", "52131211", "21231214", "41231212", "22113124", "42113122", "11213125", "22122214", "42122212", "11222215", "31222213", "51222211", "12113215", "32113213", "52113211", "21213214", "41213212", "23131123", "43131121", "12231124", "32231122", "21331123", "41331121", "13122124", "33122122", "13131214", "33131212", "11322124", "22231213", "42231211", "11331214", "31331212", "23113123", "43113121", "12213124", "23122213", "43122211", "12222214", "32222212", "21322213", "41322211", "13113214", "33113212", "22213213", "42213211", "11313214", "31313212", "24131122", "13231123", "33231121", "22331122", "11431123", "31431121", "14122123", "34122121", "14131213", "34131211", "12322123", "23231212", "12331213", "32331211", "21431212", "24113122", "13213123", "24122212", "13222213", "33222211", "11413123", "22322212", "11422213", "31422211", "14113213", "34113211", "23213212", "12313213", "32313211", "21413212", "25131121", "14231122", "23331121", "12431122", "15122122", "15131212", "13322122", "24231211", "13331212", "11522122", "22431211", "25113121", "14213122", "25122211", "14222212", "12413122", "23322211", "12422212", "21522211", "15113212", "24213211", "13313212", "22413211", "11513212", "15231121", "13431121", "16122121", "16131211", "14322121", "14331211", "12522121", "15213121", "15222211", "13413121", "13422211", "11613121", "16113211", "14313211", "12513211", "21141124", "41141122", "11132125", "31132123", "51132121", "11141215", "31141213", "51141211", "21123124", "41123122", "21132214", "41132212", "11114125", "31114123", "51114121", "11123215", "31123213", "51123211", "21114214", "41114212", "22141123", "42141121", "11241124", "31241122", "12132124", "32132122", "12141214", "32141212", "21241213", "41241211", "22123123", "42123121", "11223124", "22132213", "42132211", "11232214", "31232212", "12114124", "32114122", "12123214", "32123212", "21223213", "41223211", "22114213", "42114211", "11214214", "31214212", "23141122", "12241123", "32241121", "21341122", "13132123", "33132121", "13141213", "33141211", "11332123", "22241212", "11341213", "31341211", "23123122", "12223123", "23132212", "12232213", "32232211", "21332212", "13114123", "33114121", "13123213", "33123211", "11314123", "22223212", "11323213", "31323211", "23114212", "12214213", "32214211", "21314212", "24141121", "13241122", "22341121", "14132122", "14141212", "12332122", "23241211", "12341212", "24123121", "13223122", "24132211", "13232212", "11423122", "22332211", "11432212", "14114122", "14123212", "12314122", "23223211", "12323212", "21423211", "24114211", "13214212", "22314211", "11414212", "14241121", "15132121", "15141211", "13332121", "13341211", "14223121", "14232211", "12423121", "12432211", "15114121", "15123211", "13314121", "13323211", "11514121", "11523211", "14214211", "12414211", "21151123", "41151121", "11142124", "31142122", "11151214", "31151212", "21133123", "41133121", "21142213", "41142211", "11124124", "31124122", "11133214", "31133212", "21115123", "41115121", "21124213", "41124211", "11115214", "31115212", "22151122", "11251123", "31251121", "12142123", "32142121", "12151213", "32151211", "21251212", "22133122", "11233123", "22142212", "11242213", "31242211", "12124123", "32124121", "12133213", "32133211", "21233212", "22115122", "11215123", "22124212", "11224213", "31224211", "12115213", "32115211", "21215212", "23151121", "12251122", "13142122", "13151212", "11342122", "22251211", "23133121", "12233122", "23142211", "12242212", "21342211", "13124122", "13133212", "11324122", "22233211", "11333212", "23115121", "12215122", "23124211", "12224212", "21324211", "13115212", "22215211", "11315212", "13251121", "14142121", "14151211", "12342121", "13233121", "13242211", "11433121", "14124121", "14133211", "12324121", "12333211", "13215121", "13224211", "11415121", "11424211", "14115211", "12315211", "21161122", "11152123", "31152121", "11161213", "31161211", "21143122", "21152212", "11134123", "31134121", "11143213", "31143211", "21125122", "21134212", "11116123", "31116121", "11125213", "31125211", "22161121", "12152122", "12161212", "22143121", "11243122", "22152211", "11252212", "12134122", "12143212", "21243211", "22125121", "11225122", "22134211", "11234212", "12116122", "12125212", "21225211", "13152121", "13161211", "12243121", "12252211", "13134121", "13143211", "11334121", "11343211", "12225121", "12234211", "13116121", "13125211", "11316121", "11325211", "21111226", "41111224", "61111222", "31111315", "51111313", "21211135", "41211133", "61211131", "22111225", "42111223", "11211226", "31211224", "51211222", "12111316", "32111314", "52111312", "21211315", "41211313", "61211311", "22211134", "42211132", "11311135", "31311133", "51311131", "23111224", "43111222", "12211225", "32211223", "52211221", "21311224", "41311222", "13111315", "33111313", "22211314", "42211312", "11311315", "31311313", "51311311", "23211133", "43211131", "12311134", "32311132", "21411133", "41411131", "24111223", "13211224", "33211222", "22311223", "42311221", "11411224", "31411222", "14111314", "34111312", "23211313", "43211311", "12311314", "32311312", "21411313", "41411311", "24211132", "13311133", "33311131", "22411132", "11511133", "31511131", "25111222", "14211223", "34211221", "23311222", "12411223", "32411221", "21511222", "15111313", "24211312", "13311313", "33311311", "22411312", "11511313", "31511311", "25211131", "14311132", "23411131", "12511132", "21611131", "15211222", "24311221", "13411222", "22511221", "11611222", "16111312", "25211311", "14311312", "23411311", "12511312", "21611311", "31121134", "51121132", "21112135", "41112133", "61112131", "21121225", "41121223", "61121221", "11112226", "31112224", "51112222", "11121316", "31121314", "51121312", "21112315", "41112313", "61112311", "12121135", "32121133", "52121131", "21221134", "41221132", "22112134", "42112132", "11212135", "22121224", "42121222", "11221225", "31221223", "51221221", "12112225", "32112223", "52112221", "12121315", "32121313", "52121311", "21221314", "41221312", "22112314", "42112312", "11212315", "31212313", "51212311", "13121134", "33121132", "22221133", "42221131", "11321134", "31321132", "23112133", "43112131", "12212134", "23121223", "43121221", "12221224", "32221222", "21321223", "41321221", "13112224", "33112222", "13121314", "33121312", "11312224", "22221313", "42221311", "11321314", "31321312", "23112313", "43112311", "12212314", "32212312", "21312313", "41312311", "14121133", "34121131", "23221132", "12321133", "32321131", "21421132", "24112132", "13212133", "24121222", "13221223", "33221221", "11412133", "22321222", "11421223", "31421221", "14112223", "34112221", "14121313", "34121311", "12312223", "23221312", "12321313", "32321311", "21421312", "24112312", "13212313", "33212311", "22312312", "11412313", "31412311", "15121132", "24221131", "13321132", "22421131"]), $a(["22121116", "42121114", "31221115", "51221113", "32112115", "52112113", "21212116", "41212114", "61212112", "23121115", "43121113", "12221116", "32221114", "52221112", "21321115", "41321113", "61321111", "13112116", "33112114", "22212115", "42212113", "11312116", "31312114", "51312112", "24121114", "13221115", "33221113", "22321114", "42321112", "11421115", "31421113", "51421111", "14112115", "34112113", "23212114", "43212112", "12312115", "32312113", "52312111", "21412114", "41412112", "25121113", "14221114", "34221112", "23321113", "43321111", "12421114", "32421112", "21521113", "41521111", "15112114", "24212113", "13312114", "33312112", "22412113", "42412111", "11512114", "31512112", "15221113", "24321112", "13421113", "33421111", "22521112", "16112113", "25212112", "14312113", "34312111", "23412112", "12512113", "32512111", "21612112", "21131116", "41131114", "61131112", "31122115", "51122113", "21113116", "41113114", "61113112", "22131115", "42131113", "11231116", "31231114", "51231112", "12122116", "32122114", "52122112", "21222115", "41222113", "61222111", "22113115", "42113113", "11213116", "31213114", "51213112", "23131114", "43131112", "12231115", "32231113", "52231111", "21331114", "41331112", "13122115", "33122113", "22222114", "42222112", "11322115", "31322113", "51322111", "23113114", "43113112", "12213115", "32213113", "52213111", "21313114", "41313112", "24131113", "13231114", "33231112", "22331113", "42331111", "11431114", "31431112", "14122114", "34122112", "23222113", "43222111", "12322114", "32322112", "21422113", "41422111", "24113113", "13213114", "33213112", "22313113", "42313111", "11413114", "31413112", "25131112", "14231113", "34231111", "23331112", "12431113", "32431111", "15122113", "24222112", "13322113", "33322111", "22422112", "11522113", "31522111", "25113112", "14213113", "34213111", "23313112", "12413113", "32413111", "21513112", "15231112", "24331111", "13431112", "16122112", "25222111", "14322112", "23422111", "12522112", "15213112", "24313111", "13413112", "22513111", "11613112", "21141115", "41141113", "61141111", "11132116", "31132114", "51132112", "21123115", "41123113", "61123111", "11114116", "31114114", "51114112", "22141114", "42141112", "11241115", "31241113", "51241111", "12132115", "32132113", "52132111", "21232114", "41232112", "22123114", "42123112", "11223115", "31223113", "51223111", "12114115", "32114113", "52114111", "21214114", "41214112", "23141113", "43141111", "12241114", "32241112", "21341113", "41341111", "13132114", "33132112", "22232113", "42232111", "11332114", "31332112", "23123113", "43123111", "12223114", "32223112", "21323113", "41323111", "13114114", "33114112", "22214113", "42214111", "11314114", "31314112", "24141112", "13241113", "33241111", "22341112", "14132113", "34132111", "23232112", "12332113", "32332111", "21432112", "24123112", "13223113", "33223111", "22323112", "11423113", "31423111", "14114113", "34114111", "23214112", "12314113", "32314111", "21414112", "25141111", "14241112", "23341111", "15132112", "24232111", "13332112", "22432111", "25123111", "14223112", "23323111", "12423112", "21523111", "15114112", "24214111", "13314112", "22414111", "11514112", "15241111", "16132111", "14332111", "15223111", "13423111", "16114111", "14314111", "12514111", "21151114", "41151112", "11142115", "31142113", "51142111", "21133114", "41133112", "11124115", "31124113", "51124111", "21115114", "41115112", "22151113", "42151111", "11251114", "31251112", "12142114", "32142112", "21242113", "41242111", "22133113", "42133111", "11233114", "31233112", "12124114", "32124112", "21224113", "41224111", "22115113", "42115111", "11215114", "31215112", "23151112", "12251113", "32251111", "13142113", "33142111", "22242112", "11342113", "31342111", "23133112", "12233113", "32233111", "21333112", "13124113", "33124111", "22224112", "11324113", "31324111", "23115112", "12215113", "32215111", "21315112", "24151111", "13251112", "14142112", "23242111", "12342112", "24133111", "13233112", "22333111", "11433112", "14124112", "23224111", "12324112", "21424111", "24115111", "13215112", "22315111", "11415112", "14251111", "15142111", "13342111", "14233111", "12433111", "15124111", "13324111", "11524111", "14215111", "12415111", "21161113", "41161111", "11152114", "31152112", "21143113", "41143111", "11134114", "31134112", "21125113", "41125111", "11116114", "31116112", "22161112", "12152113", "32152111", "21252112", "22143112", "11243113", "31243111", "12134113", "32134111", "21234112", "22125112", "11225113", "31225111", "12116113", "32116111", "21216112", "23161111", "13152112", "22252111", "23143111", "12243112", "21343111", "13134112", "22234111", "11334112", "23125111", "12225112", "21325111", "13116112", "22216111", "11316112", "14152111", "13243111", "14134111", "12334111", "13225111", "11425111", "14116111", "12316111", "41111215", "61111213", "21211126", "41211124", "61211122", "22111216", "42111214", "31211215", "51211213", "22211125", "42211123", "11311126", "31311124", "51311122", "23111215", "43111213", "12211216", "32211214", "52211212", "21311215", "41311213", "61311211", "23211124", "43211122", "12311125", "32311123", "52311121", "21411124", "41411122", "24111214", "13211215", "33211213", "22311214", "42311212", "11411215", "31411213", "51411211", "24211123", "13311124", "33311122", "22411123", "42411121", "11511124", "31511122", "25111213", "14211214", "34211212", "23311213", "43311211", "12411214", "32411212", "21511213", "41511211", "25211122", "14311123", "34311121", "23411122", "12511123", "32511121", "21611122", "15211213", "24311212", "13411213", "33411211", "22511212", "11611213", "31611211", "31121125", "51121123", "21112126", "41112124", "61112122", "21121216", "41121214", "61121212", "31112215", "51112213", "12121126", "32121124", "52121122", "21221125", "41221123", "61221121", "22112125", "42112123", "11212126", "22121215", "42121213", "11221216", "31221214", "51221212", "12112216", "32112214", "52112212", "21212215", "41212213", "61212211", "13121125", "33121123", "22221124", "42221122", "11321125", "31321123", "51321121", "23112124", "43112122", "12212125", "23121214", "43121212", "12221215", "32221213", "52221211", "21321214", "41321212", "13112215", "33112213", "22212214", "42212212", "11312215", "31312213", "51312211", "14121124", "34121122", "23221123", "43221121", "12321124", "32321122", "21421123", "41421121", "24112123", "13212124", "24121213", "13221214", "33221212", "11412124", "22321213", "42321211", "11421214", "31421212", "14112214", "34112212", "23212213", "43212211", "12312214", "32312212", "21412213", "41412211", "15121123", "24221122", "13321123", "33321121", "22421122", "11521123", "31521121", "25112122", "14212123", "25121212", "14221213", "34221211", "12412123", "23321212", "12421213", "32421211", "21521212", "15112213", "24212212", "13312213", "33312211", "22412212", "11512213", "31512211", "16121122", "25221121", "14321122", "23421121", "12521122", "15212122", "15221212", "13412122", "24321211", "13421212", "11612122", "22521211", "16112212", "25212211", "14312212", "23412211", "12512212", "21612211", "11131126", "31131124", "51131122", "21122125", "41122123", "61122121", "21131215", "41131213", "61131211", "11113126", "31113124", "51113122", "11122216", "31122214", "51122212", "21113215", "41113213", "61113211", "12131125", "32131123", "52131121", "21231124", "41231122", "22122124", "42122122", "11222125", "22131214", "42131212", "11231215", "31231213", "51231211", "12113125", "32113123", "52113121", "12122215", "32122213", "52122211", "21222214", "41222212", "22113214", "42113212", "11213215", "31213213", "51213211", "13131124", "33131122", "22231123", "42231121", "11331124", "31331122", "23122123", "43122121", "12222124", "23131213", "43131211", "12231214", "32231212", "21331213", "41331211", "13113124", "33113122", "13122214", "33122212", "11313124", "22222213", "42222211", "11322214", "31322212", "23113213", "43113211", "12213214", "32213212", "21313213", "41313211", "14131123", "34131121", "23231122", "12331123", "32331121", "21431122", "24122122", "13222123", "24131212", "13231213", "33231211", "11422123", "22331212", "11431213", "31431211", "14113123", "34113121", "14122213", "34122211", "12313123", "23222212", "12322213", "32322211", "21422212", "24113212", "13213213", "33213211", "22313212", "11413213", "31413211", "15131122", "24231121", "13331122", "22431121", "25122121", "14222122", "25131211", "14231212", "12422122", "23331211", "12431212", "15113122", "15122212", "13313122", "24222211", "13322212", "11513122", "22422211", "11522212", "25113211", "14213212", "23313211", "12413212", "21513211", "16131121", "14331121", "15222121", "15231211", "13422121", "13431211", "16113121", "16122211", "14313121", "14322211", "12513121", "12522211", "15213211", "13413211", "11613211", "11141125", "31141123", "51141121", "21132124", "41132122", "21141214", "41141212", "11123125", "31123123", "51123121", "11132215", "31132213", "51132211", "21114124", "41114122", "21123214", "41123212", "11114215", "31114213", "51114211", "12141124", "32141122", "21241123", "41241121", "22132123", "42132121", "11232124", "22141213", "42141211", "11241214", "31241212", "12123124", "32123122", "12132214", "32132212", "21232213", "41232211", "22114123", "42114121", "11214124", "22123213", "42123211", "11223214", "31223212", "12114214", "32114212", "21214213", "41214211", "13141123", "33141121", "22241122", "11341123", "31341121", "23132122", "12232123", "23141212", "12241213", "32241211", "21341212", "13123123", "33123121", "13132213", "33132211", "11323123", "22232212", "11332213", "31332211", "23114122", "12214123", "23123212", "12223213", "32223211", "21323212", "13114213", "33114211", "22214212", "11314213", "31314211", "14141122", "23241121", "12341122", "24132121", "13232122", "24141211", "13241212", "11432122", "22341211", "14123122", "14132212", "12323122", "23232211", "12332212", "21432211", "24114121", "13214122", "24123211", "13223212", "11414122", "22323211", "11423212", "14114212", "23214211", "12314212", "21414211", "15141121", "13341121", "14232121", "14241211", "12432121", "15123121", "15132211", "13323121", "13332211", "11523121", "14214121", "14223211", "12414121", "12423211", "15114211", "13314211", "11514211", "11151124", "31151122", "21142123", "41142121", "21151213", "41151211", "11133124", "31133122", "11142214", "31142212", "21124123", "41124121", "21133213", "41133211", "11115124", "31115122", "11124214", "31124212", "21115213", "41115211", "12151123", "32151121", "21251122", "22142122", "11242123", "22151212", "11251213", "31251211", "12133123", "32133121", "12142213", "32142211", "21242212", "22124122", "11224123", "22133212", "11233213", "31233211", "12115123", "32115121", "12124213", "32124211", "21224212", "22115212", "11215213", "31215211", "13151122", "22251121", "23142121", "12242122", "23151211", "12251212", "13133122", "13142212", "11333122", "22242211", "11342212", "23124121", "12224122", "23133211", "12233212", "21333211", "13115122", "13124212", "11315122", "22224211", "11324212", "23115211", "12215212", "21315211", "14151121", "13242121", "13251211", "14133121", "14142211", "12333121", "12342211", "13224121", "13233211", "11424121", "11433211", "14115121", "14124211", "12315121", "12324211", "13215211", "11415211", "11161123", "31161121", "21152122", "21161212", "11143123", "31143121", "11152213", "31152211", "21134122", "21143212", "11125123", "31125121", "11134213", "31134211", "21116122", "21125212", "12161122", "22152121", "11252122", "22161211", "12143122", "12152212", "21252211", "22134121", "11234122", "22143211", "11243212", "12125122", "12134212", "21234211", "22116121", "11216122", "22125211", "11225212", "13161121", "12252121", "13143121", "13152211", "11343121", "12234121", "12243211", "13125121", "13134211", "11325121", "11334211", "12216121", "12225211", "31111225", "51111223", "21111316", "41111314", "61111312", "31211134", "51211132", "12111226", "32111224", "52111222", "21211225", "41211223", "61211221", "22111315", "42111313", "11211316", "31211314", "51211312", "12211135", "32211133", "52211131", "21311134", "41311132", "13111225", "33111223", "22211224", "42211222", "11311225", "31311223", "51311221", "23111314", "43111312", "12211315", "32211313", "52211311", "21311314", "41311312", "13211134", "33211132", "22311133", "42311131", "11411134", "31411132", "14111224", "34111222", "23211223", "43211221", "12311224", "32311222", "21411223", "41411221", "24111313", "13211314", "33211312", "22311313", "42311311", "11411314", "31411312", "14211133", "34211131", "23311132", "12411133", "32411131", "21511132", "15111223", "24211222", "13311223", "33311221", "22411222", "11511223", "31511221", "25111312", "14211313", "34211311", "23311312", "12411313", "32411311", "21511312", "15211132", "24311131", "13411132", "22511131", "11611132", "16111222", "25211221", "14311222", "23411221", "12511222", "21611221", "15211312", "24311311", "13411312", "22511311", "11611312", "21121135", "41121133", "61121131", "11112136", "31112134", "51112132", "11121226", "31121224", "51121222", "21112225", "41112223", "61112221", "21121315", "41121313", "61121311", "11112316", "31112314", "51112312", "22121134", "42121132", "11221135", "31221133", "51221131", "12112135", "32112133", "52112131", "12121225", "32121223", "52121221", "21221224", "41221222", "22112224", "42112222", "11212225", "22121314", "42121312", "11221315", "31221313", "51221311", "12112315", "32112313", "52112311", "21212314", "41212312", "23121133", "43121131", "12221134", "32221132", "21321133", "41321131", "13112134", "33112132", "13121224", "33121222", "11312134", "22221223", "42221221", "11321224", "31321222", "23112223", "43112221", "12212224", "23121313", "43121311", "12221314", "32221312", "21321313", "41321311", "13112314", "33112312", "22212313", "42212311", "11312314", "31312312", "24121132", "13221133", "33221131", "22321132", "11421133", "31421131", "14112133", "34112131", "14121223", "34121221", "12312133", "23221222", "12321223", "32321221", "21421222", "24112222", "13212223", "24121312", "13221313", "33221311", "11412223", "22321312", "11421313", "31421311", "14112313", "34112311", "23212312", "12312313", "32312311", "21412312", "25121131", "14221132", "23321131", "12421132", "21521131", "15112132", "15121222", "13312132", "24221221", "13321222", "11512132", "22421221", "11521222", "25112221", "14212222", "25121311", "14221312", "12412222", "23321311", "12421312", "21521311", "15112312", "24212311", "13312312", "22412311", "11512312", "15221131", "13421131", "16112131", "16121221", "14312131", "14321221", "12512131", "12521221", "15212221", "15221311", "13412221", "13421311", "11612221", "16112311", "14312311", "12512311", "21131134", "41131132", "11122135", "31122133", "51122131", "11131225", "31131223", "51131221", "21113134", "41113132", "21122224", "41122222", "21131314", "41131312", "11113225", "31113223", "51113221", "11122315", "31122313", "51122311", "21113314", "41113312", "22131133", "42131131", "11231134", "31231132", "12122134", "32122132", "12131224", "32131222", "21231223", "41231221", "22113133", "42113131", "11213134", "22122223", "42122221", "11222224", "22131313", "42131311", "11231314", "31231312", "12113224", "32113222", "12122314", "32122312", "21222313", "41222311", "22113313", "42113311", "11213314", "31213312", "23131132", "12231133", "32231131", "21331132", "13122133", "33122131", "13131223", "33131221", "11322133", "22231222", "11331223", "31331221", "23113132", "12213133", "23122222", "12222223", "23131312", "12231313", "32231311", "21331312", "13113223", "33113221", "13122313", "33122311", "11313223", "22222312", "11322313", "31322311", "23113312", "12213313", "32213311", "21313312", "24131131", "13231132", "22331131", "11431132", "14122132", "14131222", "12322132", "23231221", "12331222", "21431221", "24113131", "13213132", "24122221", "13222222", "24131311", "11413132", "13231312", "11422222", "22331311", "11431312", "14113222", "14122312", "12313222", "23222311", "12322312", "21422311", "24113311", "13213312", "22313311", "11413312", "14231131", "12431131", "15122131", "15131221", "13322131", "13331221", "11522131", "14213131", "14222221", "12413131", "14231311", "12422221", "12431311", "15113221", "15122311", "13313221", "13322311", "11513221", "11522311", "14213311", "12413311", "21141133", "41141131", "11132134", "31132132", "11141224", "31141222", "21123133", "41123131", "21132223", "41132221", "21141313", "41141311", "11114134", "31114132", "11123224", "31123222", "11132314", "31132312", "21114223", "41114221", "21123313", "41123311", "11114314", "31114312", "22141132", "11241133", "31241131", "12132133", "32132131", "12141223", "32141221", "21241222", "22123132", "11223133", "22132222", "11232223", "22141312", "11241313", "31241311", "12114133", "32114131", "12123223", "32123221", "12132313", "32132311", "21232312", "22114222", "11214223", "22123312", "11223313", "31223311", "12114313", "32114311", "21214312", "23141131", "12241132", "21341131", "13132132", "13141222", "11332132", "22241221", "11341222", "23123131", "12223132", "23132221", "12232222", "23141311", "12241312", "21341311", "13114132", "13123222", "11314132", "13132312", "11323222", "22232311", "11332312", "23114221", "12214222", "23123311", "12223312", "21323311", "13114312", "22214311", "11314312", "13241131", "14132131", "14141221", "12332131", "12341221", "13223131", "13232221", "11423131", "13241311", "11432221", "14114131", "14123221", "12314131", "14132311", "12323221", "12332311", "13214221", "13223311", "11414221", "11423311", "14114311", "12314311", "21151132", "11142133", "31142131", "11151223", "31151221", "21133132", "21142222", "21151312", "11124133", "31124131", "11133223", "31133221", "11142313", "31142311", "21115132", "21124222", "21133312", "11115223", "31115221", "11124313", "31124311", "22151131", "11251132", "12142132", "12151222", "21251221", "22133131", "11233132", "22142221", "11242222", "22151311", "11251312", "12124132", "12133222", "12142312", "21242311", "22115131", "11215132", "22124221", "11224222", "22133311", "11233312", "12115222", "12124312", "21224311", "12251131", "13142131", "13151221", "11342131", "12233131", "12242221", "12251311", "13124131", "13133221", "11324131", "13142311", "11333221", "11342311", "12215131", "12224221", "12233311", "13115221", "13124311", "11315221", "11324311", "21161131", "11152132", "11161222", "21143131", "21152221", "21161311", "11134132", "11143222", "11152312", "21125131", "21134221", "21143311", "11116132", "11125222", "11134312", "12152131", "12161221", "11243131", "11252221", "12134131", "12143221", "12152311", "11225131", "11234221", "11243311", "12116131", "12125221", "12134311", "21111235", "41111233", "61111231", "11111326", "31111324", "51111322", "21111415", "41111413", "61111411", "21211144", "41211142", "22111234", "42111232", "11211235", "31211233", "51211231", "12111325", "32111323", "52111321", "21211324", "41211322", "22111414", "42111412", "11211415", "31211413", "51211411", "22211143", "42211141", "11311144", "31311142", "23111233", "43111231", "12211234", "32211232", "21311233", "41311231", "13111324", "33111322", "22211323", "42211321", "11311324", "31311322", "23111413", "43111411", "12211414", "32211412", "21311413", "41311411", "23211142", "12311143", "32311141", "21411142", "24111232", "13211233", "33211231", "22311232", "11411233", "31411231", "14111323", "34111321", "23211322", "12311323", "32311321", "21411322", "24111412", "13211413", "33211411", "22311412", "11411413", "31411411", "24211141", "13311142", "22411141", "11511142", "25111231", "14211232", "23311231", "12411232", "21511231", "15111322", "24211321", "13311322", "22411321", "11511322", "25111411", "14211412", "23311411", "12411412", "21511411", "14311141", "12511141", "15211231", "13411231", "11611231", "16111321", "14311321", "12511321", "15211411", "13411411", "11611411", "31121143", "51121141", "21112144", "41112142", "21121234", "41121232", "11112235", "31112233", "51112231", "11121325", "31121323", "51121321", "21112324", "41112322", "21121414", "41121412", "11112415", "31112413", "51112411", "12121144", "32121142", "21221143", "41221141", "22112143", "42112141", "11212144", "22121233", "42121231", "11221234", "31221232", "12112234", "32112232", "12121324", "32121322", "21221323", "41221321", "22112323", "42112321", "11212324", "22121413", "42121411", "11221414", "31221412", "12112414", "32112412", "21212413", "41212411", "13121143", "33121141", "22221142", "11321143", "31321141", "23112142", "12212143", "23121232", "12221233", "32221231", "21321232", "13112233", "33112231", "13121323", "33121321", "11312233", "22221322", "11321323", "31321321", "23112322", "12212323", "23121412", "12221413", "32221411", "21321412", "13112413", "33112411", "22212412", "11312413", "31312411", "14121142", "23221141", "12321142", "21421141", "24112141", "13212142", "24121231", "13221232", "11412142", "22321231", "11421232", "14112232", "14121322", "12312232", "23221321", "12321322", "21421321", "24112321", "13212322", "24121411", "13221412", "11412322", "22321411", "11421412", "14112412", "23212411", "12312412", "21412411", "15121141", "13321141", "11521141", "14212141", "14221231", "12412141", "12421231", "15112231", "15121321", "13312231", "13321321", "11512231", "11521321", "14212321", "14221411", "12412321", "12421411", "15112411", "13312411", "11512411", "11131144", "31131142", "21122143", "41122141", "21131233", "41131231", "11113144", "31113142", "11122234", "31122232", "11131324", "31131322", "21113233", "41113231", "21122323", "41122321", "21131413", "41131411", "11113324", "31113322", "11122414", "31122412", "21113413", "41113411", "12131143", "32131141", "21231142", "22122142", "11222143", "22131232", "11231233", "31231231", "12113143", "32113141", "12122233", "32122231", "12131323", "32131321", "21231322", "22113232", "11213233", "22122322", "11222323", "22131412", "11231413", "31231411", "12113323", "32113321", "12122413", "32122411", "21222412", "22113412", "11213413", "31213411", "13131142", "22231141", "11331142", "23122141", "12222142", "23131231", "12231232", "21331231", "13113142", "13122232", "11313142", "13131322", "11322232", "22231321", "11331322", "23113231", "12213232", "23122321", "12222322", "23131411", "12231412", "21331411", "13113322", "13122412", "11313322", "22222411", "11322412", "23113411", "12213412", "21313411", "14131141", "12331141", "13222141", "13231231", "11422141", "11431231", "14113141", "14122231", "12313141", "14131321", "12322231", "12331321", "13213231", "13222321", "11413231", "13231411", "11422321", "11431411", "14113321", "14122411", "12313321", "12322411", "13213411", "11413411", "11141143", "31141141", "21132142", "21141232", "11123143", "31123141", "11132233", "31132231", "11141323", "31141321", "21114142", "21123232", "21132322", "21141412", "11114233", "31114231", "11123323", "31123321", "11132413", "31132411", "21114322", "21123412", "12141142", "21241141", "22132141", "11232142", "22141231", "11241232", "12123142", "12132232", "12141322", "21241321", "22114141", "11214142", "22123231", "11223232", "22132321", "11232322", "22141411", "11241412", "12114232", "12123322", "12132412", "21232411", "22114321", "11214322", "22123411", "11223412", "13141141", "11341141", "12232141", "12241231", "13123141", "13132231", "11323141", "13141321", "11332231", "11341321", "12214141", "12223231", "12232321", "12241411", "13114231", "13123321", "11314231", "13132411", "11323321", "11332411", "12214321", "12223411", "11151142", "21142141", "21151231", "11133142", "11142232", "11151322", "21124141", "21133231", "21142321", "21151411", "11115142", "11124232", "11133322", "11142412", "21115231", "21124321", "21133411", "12151141", "11242141", "11251231", "12133141", "12142231", "12151321", "11224141", "11233231", "11242321", "11251411", "12115141", "12124231", "12133321", "12142411", "11215231", "11224321", "11233411", "11161141", "11143141", "11152231", "11161321", "11125141", "11134231", "11143321", "11152411", "11111245", "31111243", "51111241", "21111334", "41111332", "11111425", "31111423", "51111421", "21111514", "41111512", "31211152", "12111244", "32111242", "21211243", "41211241", "22111333", "42111331", "11211334", "31211332", "12111424", "32111422", "21211423", "41211421", "22111513", "42111511", "11211514", "31211512", "12211153", "32211151", "21311152", "13111243", "33111241", "22211242", "11311243", "31311241", "23111332", "12211333", "32211331", "21311332", "13111423", "33111421", "22211422", "11311423", "31311421", "23111512", "12211513", "32211511", "21311512", "13211152", "22311151", "11411152", "14111242", "23211241", "12311242", "21411241", "24111331", "13211332", "22311331", "11411332", "14111422", "23211421", "12311422", "21411421", "24111511", "13211512", "22311511", "11411512", "14211151", "12411151", "15111241", "13311241", "11511241", "14211331", "12411331", "15111421", "13311421", "11511421", "14211511", "12411511", "21121153", "41121151", "11112154", "31112152", "11121244", "31121242", "21112243", "41112241", "21121333", "41121331", "11112334", "31112332", "11121424", "31121422", "21112423", "41112421", "21121513", "41121511", "11112514", "31112512", "22121152", "11221153", "31221151", "12112153", "32112151", "12121243", "32121241", "21221242", "22112242", "11212243", "22121332", "11221333", "31221331", "12112333", "32112331", "12121423", "32121421", "21221422", "22112422", "11212423", "22121512", "11221513", "31221511", "12112513", "32112511", "21212512", "23121151", "12221152", "21321151", "13112152", "13121242", "11312152", "22221241", "11321242", "23112241", "12212242", "23121331", "12221332", "21321331", "13112332", "13121422", "11312332", "22221421", "11321422", "23112421", "12212422", "23121511", "12221512", "21321511", "13112512", "22212511", "11312512", "13221151", "11421151", "14112151", "14121241", "12312151", "12321241", "13212241", "13221331", "11412241", "11421331", "14112331", "14121421", "12312331", "12321421", "13212421", "13221511", "11412421", "11421511", "14112511", "12312511", "21131152", "11122153", "31122151", "11131243", "31131241", "21113152", "21122242", "21131332", "11113243", "31113241", "11122333", "31122331", "11131423", "31131421", "21113332", "21122422", "21131512", "11113423", "31113421", "11122513", "31122511", "22131151", "11231152", "12122152", "12131242", "21231241", "22113151", "11213152", "22122241", "11222242", "22131331", "11231332", "12113242", "12122332", "12131422", "21231421", "22113331", "11213332", "22122421", "11222422", "22131511", "11231512", "12113422", "12122512", "21222511", "12231151", "13122151", "13131241", "11322151", "11331241", "12213151", "12222241", "12231331", "13113241", "13122331", "11313241", "13131421", "11322331", "11331421", "12213331", "12222421", "12231511", "13113421", "13122511", "11313421", "11322511", "21141151", "11132152", "11141242", "21123151", "21132241", "21141331", "11114152", "11123242", "11132332", "11141422", "21114241", "21123331", "21132421", "21141511", "11114332", "11123422", "11132512", "11241151", "12132151", "12141241", "11223151", "11232241", "11241331", "12114151", "12123241", "12132331", "12141421", "11214241", "11223331", "11232421", "11241511", "12114331", "12123421", "12132511", "11142151", "11151241", "11124151", "11133241", "11142331", "11151421", "11115241", "11124331", "11133421", "11142511", "21111253", "41111251", "11111344", "31111342", "21111433", "41111431", "11111524", "31111522", "21111613", "41111611", "21211162", "22111252", "11211253", "31211251", "12111343", "32111341", "21211342", "22111432", "11211433", "31211431", "12111523", "32111521", "21211522", "22111612", "11211613", "31211611", "22211161", "11311162", "23111251", "12211252", "21311251", "13111342", "22211341", "11311342", "23111431", "12211432", "21311431", "13111522", "22211521", "11311522", "23111611", "12211612", "21311611", "12311161", "13211251", "11411251", "14111341", "12311341", "13211431", "11411431", "14111521", "12311521", "13211611", "11411611", "31121161", "21112162", "21121252", "11112253", "31112251", "11121343", "31121341", "21112342", "21121432", "11112433", "31112431", "11121523", "31121521", "21112522", "21121612", "12121162", "21221161", "22112161", "11212162", "22121251", "11221252", "12112252", "12121342", "21221341", "22112341", "11212342", "22121431", "11221432", "12112432", "12121522", "21221521", "22112521", "11212522", "22121611", "11221612", "13121161", "11321161", "12212161", "12221251", "13112251", "13121341", "11312251", "11321341", "12212341", "12221431", "13112431", "13121521", "11312431", "11321521", "12212521", "12221611", "11131162", "21122161", "21131251", "11113162"])]);
        $ctx.parity = $a(["1001", "0101", "1100", "0011", "1010", "0110", "1111", "0000"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_code49.$ctx[id] = $ctx[id]);
        bwipp_code49.__15616__ = 1;
      })();
    }
    $1.rowbits = $a($1.r);
    for (var _6C = 0, _6B = $f($1.r - 1); _6C <= _6B; _6C += 1) {
      $1.i = _6C;
      $k[$j++] = "p";
      if ($1.i != $f($1.r - 1)) {
        $k[$j++] = $get($1.parity, $1.i);
      } else {
        $k[$j++] = "0000";
      }
      var _6I = $k[--$j];
      $1[$k[--$j]] = _6I;
      $1.ccrow = $geti($1.ccs, $1.i * 8, 8);
      $k[$j++] = Infinity;
      for (var _6N = 0; _6N <= 7; _6N += 2) {
        $aload($geti($1.ccrow, _6N, 2));
        var _6Q = $k[--$j];
        var _6R = $k[--$j];
        $k[$j++] = $f(_6Q + _6R * 49);
      }
      $1.scrow = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 10;
      $k[$j++] = 1;
      $k[$j++] = 1;
      for (var _6T = 0; _6T <= 3; _6T += 1) {
        $1.j = _6T;
        $forall($get($get($1.patterns, $f($get($1.p, $1.j) - 48)), $get($1.scrow, $1.j)), function() {
          var _6d = $k[--$j];
          $k[$j++] = $f(_6d - 48);
        });
      }
      $k[$j++] = 4;
      $k[$j++] = 1;
      $1.sbs = $a();
      $k[$j++] = Infinity;
      var _6f = $1.sbs;
      $k[$j++] = 1;
      for (var _6g = 0, _6h = _6f.length; _6g < _6h; _6g++) {
        var _6j = $k[--$j];
        var _6k = _6j == 0 ? 1 : 0;
        $k[$j++] = _6j;
        for (var _6l = 0, _6m = $get(_6f, _6g); _6l < _6m; _6l++) {
          $k[$j++] = _6k;
        }
      }
      $astore($a($counttomark() - 1));
      var _6p = $k[--$j];
      var _6q = $k[--$j];
      $k[$j++] = _6p;
      $k[$j++] = _6q;
      $j--;
      var _6r = $k[--$j];
      var _6s = $k[--$j];
      $k[$j++] = _6r;
      $k[$j++] = _6s;
      $j--;
      $put($1.rowbits, $1.i, $k[--$j]);
    }
    $k[$j++] = Infinity;
    for (var _6x = 0, _6y = 81 * $1.sepheight; _6x < _6y; _6x++) {
      $k[$j++] = 1;
    }
    for (var _71 = 0, _70 = $f($1.r - 2); _71 <= _70; _71 += 1) {
      $1.i = _71;
      for (var _73 = 0, _74 = $1.rowheight; _73 < _74; _73++) {
        $aload($get($1.rowbits, $1.i));
      }
      for (var _79 = 0, _7A = $1.sepheight; _79 < _7A; _79++) {
        for (var _7B = 0, _7C = 10; _7B < _7C; _7B++) {
          $k[$j++] = 0;
        }
        for (var _7D = 0, _7E = 70; _7D < _7E; _7D++) {
          $k[$j++] = 1;
        }
        $k[$j++] = 0;
      }
    }
    for (var _7G = 0, _7H = $1.rowheight; _7G < _7H; _7G++) {
      $aload($get($1.rowbits, $f($1.r - 1)));
    }
    for (var _7M = 0, _7N = 81 * $1.sepheight; _7M < _7N; _7M++) {
      $k[$j++] = 1;
    }
    $1.pixs = $a();
    var _7T = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", 81],
      ["pixy", ~~($1.pixs.length / 81)],
      ["height", ~~($1.pixs.length / 81) / 72],
      ["width", 81 / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _7T;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_flattermarken() {
    var $1 = Object.create(bwipp_flattermarken.$ctx || (bwipp_flattermarken.$ctx = {}));
    $1.dontdraw = false;
    $1.includetext = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.height = 0.3;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $forall($1.barcode, function() {
      var _3 = $k[--$j];
      if (_3 < 48 || _3 > 57) {
        $k[$j++] = "bwipp.flattermarkenBadCharacter#15978";
        $k[$j++] = "Flattermarken must contain only digits";
        bwipp_raiseerror();
      }
    });
    if (!bwipp_flattermarken.__15991__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["0018", "0117", "0216", "0315", "0414", "0513", "0612", "0711", "0810", "0900"]);
        $ctx.barchars = "1234567890";
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_flattermarken.$ctx[id] = $ctx[id]);
        bwipp_flattermarken.__15991__ = 1;
      })();
    }
    $1.barlen = $1.barcode.length;
    $1.sbs = $s($1.barlen * 4);
    $1.txt = $a($1.barlen);
    for (var _D = 0, _C = $1.barlen - 1; _D <= _C; _D += 1) {
      $1.i = _D;
      $search($1.barchars, $geti($1.barcode, $1.i, 1));
      $j--;
      $1.indx = $k[--$j].length;
      $j -= 2;
      $1.enc = $get($1.encs, $1.indx);
      $puti($1.sbs, $1.i * 4, $1.enc);
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), $1.i * 9, $1.textyoffset, $1.textfont, $1.textsize]));
    }
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    var _Z = $1.sbs;
    for (var _a = 0, _b = _Z.length; _a < _b; _a++) {
      $k[$j++] = $get(_Z, _a) - 48;
    }
    var _d = $a();
    $k[$j++] = Infinity;
    for (var _f = 0, _g = ~~(($1.sbs.length + 1) / 2); _f < _g; _f++) {
      $k[$j++] = $1.height;
    }
    var _i = $a();
    $k[$j++] = Infinity;
    for (var _k = 0, _l = ~~(($1.sbs.length + 1) / 2); _k < _l; _k++) {
      $k[$j++] = 0;
    }
    var _m = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _d;
    $k[$j++] = "bhs";
    $k[$j++] = _i;
    $k[$j++] = "bbs";
    $k[$j++] = _m;
    $k[$j++] = "txt";
    $k[$j++] = $1.txt;
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _p = $d();
    $k[$j++] = _p;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_raw() {
    var $1 = Object.create(bwipp_raw.$ctx || (bwipp_raw.$ctx = {}));
    $1.dontdraw = false;
    $1.height = 1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $forall($1.barcode, function() {
      var _3 = $k[--$j];
      if (_3 < 49 || _3 > 57) {
        $k[$j++] = "bwipp.rawBadCharacter#16064";
        $k[$j++] = "Raw must contain only digits 1 to 9";
        bwipp_raiseerror();
      }
    });
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    $forall($1.barcode, function() {
      var _5 = $k[--$j];
      $k[$j++] = $f(_5 - 48);
    });
    var _6 = $a();
    $k[$j++] = Infinity;
    for (var _8 = 0, _9 = ~~(($1.barcode.length + 1) / 2); _8 < _9; _8++) {
      $k[$j++] = $1.height;
    }
    var _B = $a();
    $k[$j++] = Infinity;
    for (var _D = 0, _E = ~~(($1.barcode.length + 1) / 2); _D < _E; _D++) {
      $k[$j++] = 0;
    }
    var _F = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _6;
    $k[$j++] = "bhs";
    $k[$j++] = _B;
    $k[$j++] = "bbs";
    $k[$j++] = _F;
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _H = $d();
    $k[$j++] = _H;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_daft() {
    var $1 = Object.create(bwipp_daft.$ctx || (bwipp_daft.$ctx = {}));
    $1.dontdraw = false;
    $1.height = 0.175;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $forall($1.barcode, function() {
      var _3 = $k[--$j];
      if (_3 != 68 && (_3 != 65 && (_3 != 70 && _3 != 84))) {
        $k[$j++] = "bwipp.daftBadCharacter#16118";
        $k[$j++] = "DAFT must contain only characters D, A, F and T";
        bwipp_raiseerror();
      }
    });
    $1.barlen = $1.barcode.length;
    $1.bbs = $a($1.barlen);
    $1.bhs = $a($1.barlen);
    for (var _B = 0, _A = $1.barlen - 1; _B <= _A; _B += 1) {
      $1.i = _B;
      $1.enc = $geti($1.barcode, $1.i, 1);
      if ($eq($1.enc, "D")) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($eq($1.enc, "A")) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 5 * $1.height / 8);
      }
      if ($eq($1.enc, "F")) {
        $put($1.bbs, $1.i, 0 * $1.height / 8);
        $put($1.bhs, $1.i, 8 * $1.height / 8);
      }
      if ($eq($1.enc, "T")) {
        $put($1.bbs, $1.i, 3 * $1.height / 8);
        $put($1.bhs, $1.i, 2 * $1.height / 8);
      }
    }
    $k[$j++] = Infinity;
    var _h = $1.bbs;
    var _i = $1.bhs;
    $k[$j++] = Infinity;
    for (var _k = 0, _l = $1.bhs.length - 1; _k < _l; _k++) {
      $k[$j++] = 1.44;
      $k[$j++] = 1.872;
    }
    $k[$j++] = 1.44;
    var _m = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "bbs";
    $k[$j++] = _h;
    $k[$j++] = "bhs";
    $k[$j++] = _i;
    $k[$j++] = "sbs";
    $k[$j++] = _m;
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _o = $d();
    $k[$j++] = _o;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_symbol() {
    var $1 = Object.create(bwipp_symbol.$ctx || (bwipp_symbol.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _H = /* @__PURE__ */ new Map([
      ["fima", function() {
        $1.sbs = $a([2.25, 2.25, 2.25, 11.25, 2.25, 11.25, 2.25, 2.25, 2.25]);
        $1.bhs = $a([0.625, 0.625, 0.625, 0.625, 0.625]);
        $1.bbs = $a([0, 0, 0, 0, 0]);
      }],
      ["fimb", function() {
        $1.sbs = $a([2.25, 6.75, 2.25, 2.25, 2.25, 6.25, 2.25, 2.25, 2.25, 6.75, 2.25]);
        $1.bhs = $a([0.625, 0.625, 0.625, 0.625, 0.625, 0.625]);
        $1.bbs = $a([0, 0, 0, 0, 0, 0]);
      }],
      ["fimc", function() {
        $1.sbs = $a([2.25, 2.25, 2.25, 6.75, 2.25, 6.75, 2.25, 6.75, 2.25, 2.25, 2.25]);
        $1.bhs = $a([0.625, 0.625, 0.625, 0.625, 0.625, 0.625]);
        $1.bbs = $a([0, 0, 0, 0, 0, 0]);
      }],
      ["fimd", function() {
        $1.sbs = $a([2.25, 2.25, 2.25, 2.25, 2.25, 6.75, 2.25, 6.75, 2.25, 2.25, 2.25, 2.25, 2.25]);
        $1.bhs = $a([0.625, 0.625, 0.625, 0.625, 0.625, 0.625, 0.625]);
        $1.bbs = $a([0, 0, 0, 0, 0, 0, 0]);
      }],
      ["fime", function() {
        $1.sbs = $a([2.25, 6.75, 2.25, 15.75, 2.25, 6.75, 2.25]);
        $1.bhs = $a([0.625, 0.625, 0.625, 0.625, 0.625, 0.625, 0.625]);
        $1.bbs = $a([0, 0, 0, 0, 0, 0, 0]);
      }]
    ]);
    $1.symbols = _H;
    var _K = $get($1.symbols, $1.barcode) !== void 0;
    if (!_K) {
      $k[$j++] = "bwipp.symbolUnknownSymbol#16224";
      $k[$j++] = "Unknown symbol name provided";
      bwipp_raiseerror();
    }
    if ($get($1.symbols, $1.barcode)() === true) {
      return true;
    }
    var _S = /* @__PURE__ */ new Map([
      ["ren", bwipp_renlinear],
      ["sbs", $1.sbs],
      ["bhs", $1.bhs],
      ["bbs", $1.bbs],
      ["opt", $1.options]
    ]);
    $k[$j++] = _S;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_pdf417() {
    var $1 = Object.create(bwipp_pdf417.$ctx || (bwipp_pdf417.$ctx = {}));
    $1.dontdraw = false;
    $1.compact = false;
    $1.eclevel = -1;
    $1.columns = 0;
    $1.rows = 0;
    $1.rowmult = 3;
    $1.ccc = false;
    $1.raw = false;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.barcode, "")) {
      $k[$j++] = "bwipp.pdf417emptyData#16289";
      $k[$j++] = "The data must not be empty";
      bwipp_raiseerror();
    }
    if ($1.eclevel != -1 && ($1.eclevel < 0 || $1.eclevel > 8)) {
      $k[$j++] = "bwipp.pdf417InvalidErrorCorrectionLevel#16293";
      $k[$j++] = "Valid error correction levels are 0 to 8";
      bwipp_raiseerror();
    }
    if ($1.ccc && $1.raw) {
      $k[$j++] = "bwipp.pdf417cccAndRaw#16297";
      $k[$j++] = "Cannot combine ccc and raw";
      bwipp_raiseerror();
    }
    if ($1.ccc && $1.compact) {
      $k[$j++] = "bwipp.pdf417cccAndCompact#16301";
      $k[$j++] = "Cannot combine ccc and compact";
      bwipp_raiseerror();
    }
    if ($1.rows != 0 && ($1.rows < 3 || $1.rows > 90)) {
      $k[$j++] = "bwipp.pdf417invalidRows#16305";
      $k[$j++] = "There must be between 3 and 90 rows";
      bwipp_raiseerror();
    }
    if ($1.columns != 0 && ($1.columns < 1 || $1.columns > 30)) {
      $k[$j++] = "bwipp.pdf417invalidColumns#16309";
      $k[$j++] = "There must be between 1 and 30 columns";
      bwipp_raiseerror();
    }
    if ($1.rowmult <= 0) {
      $k[$j++] = "bwipp.pdf417badRowMult#16313";
      $k[$j++] = "The row multiplier must be greater than zero";
      bwipp_raiseerror();
    }
    if (!bwipp_pdf417.__16407__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.T = 0;
        $ctx.N = 1;
        $ctx.B = 2;
        $ctx.A = 0;
        $ctx.L = 1;
        $ctx.M = 2;
        $ctx.P = 3;
        $ctx.tl = -1;
        $ctx.nl = -2;
        $ctx.bl = -3;
        $ctx.bl6 = -4;
        $ctx.bs = -5;
        $ctx.al = -6;
        $ctx.ll = -7;
        $ctx.ml = -8;
        $ctx.pl = -9;
        $ctx.as = -10;
        $ctx.ps = -11;
        $ctx.charmaps = $a([$a(["A", "a", "0", ";"]), $a(["B", "b", "1", "<"]), $a(["C", "c", "2", ">"]), $a(["D", "d", "3", "@"]), $a(["E", "e", "4", "["]), $a(["F", "f", "5", 92]), $a(["G", "g", "6", "]"]), $a(["H", "h", "7", "_"]), $a(["I", "i", "8", "`"]), $a(["J", "j", "9", "~"]), $a(["K", "k", "&", "!"]), $a(["L", "l", 13, 13]), $a(["M", "m", 9, 9]), $a(["N", "n", ",", ","]), $a(["O", "o", ":", ":"]), $a(["P", "p", "#", 10]), $a(["Q", "q", "-", "-"]), $a(["R", "r", ".", "."]), $a(["S", "s", "$", "$"]), $a(["T", "t", "/", "/"]), $a(["U", "u", "+", '"']), $a(["V", "v", "%", "|"]), $a(["W", "w", "*", "*"]), $a(["X", "x", "=", 40]), $a(["Y", "y", "^", 41]), $a(["Z", "z", $ctx.pl, "?"]), $a([" ", " ", " ", "{"]), $a([$ctx.ll, $ctx.as, $ctx.ll, "}"]), $a([$ctx.ml, $ctx.ml, $ctx.al, "'"]), $a([$ctx.ps, $ctx.ps, $ctx.ps, $ctx.al])]);
        $ctx.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
        $ctx.alltext = /* @__PURE__ */ new Map();
        for (var _10 = 0, _z = $ctx.charmaps.length - 1; _10 <= _z; _10 += 1) {
          $ctx.i = _10;
          $ctx.encs = $get($ctx.charmaps, $ctx.i);
          for (var _14 = 0; _14 <= 3; _14 += 1) {
            $ctx.j = _14;
            var _17 = $get($ctx.encs, $ctx.j);
            $k[$j++] = _17;
            if ($eq($type(_17), "stringtype")) {
              var _1A = $get($k[--$j], 0);
              $k[$j++] = _1A;
            }
            var _1B = $k[--$j];
            $put($get($ctx.charvals, $ctx.j), _1B, $ctx.i);
            $put($ctx.alltext, _1B, -1);
          }
        }
        $ctx.e = 1e4;
        $ctx.latlen = $a([$a([0, 1, 1, 2]), $a([2, 0, 1, 2]), $a([1, 1, 0, 1]), $a([1, 2, 2, 0])]);
        $ctx.latseq = $a([$a([$a([]), $a([$ctx.ll]), $a([$ctx.ml]), $a([$ctx.ml, $ctx.pl])]), $a([$a([$ctx.ml, $ctx.al]), $a([]), $a([$ctx.ml]), $a([$ctx.ml, $ctx.pl])]), $a([$a([$ctx.al]), $a([$ctx.ll]), $a([]), $a([$ctx.pl])]), $a([$a([$ctx.al]), $a([$ctx.al, $ctx.ll]), $a([$ctx.al, $ctx.ml]), $a([])])]);
        $ctx.shftlen = $a([$a([$ctx.e, $ctx.e, $ctx.e, 1]), $a([1, $ctx.e, $ctx.e, 1]), $a([$ctx.e, $ctx.e, $ctx.e, 1]), $a([$ctx.e, $ctx.e, $ctx.e, $ctx.e])]);
        $k[$j++] = Infinity;
        $k[$j++] = $ctx.tl;
        $k[$j++] = 900;
        $k[$j++] = $ctx.bl;
        $k[$j++] = 901;
        $k[$j++] = $ctx.bl6;
        $k[$j++] = 924;
        $k[$j++] = $ctx.nl;
        $k[$j++] = 902;
        $k[$j++] = $ctx.bs;
        $k[$j++] = 913;
        $ctx.latchcws = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_pdf417.$ctx[id] = $ctx[id]);
        bwipp_pdf417.__16407__ = 1;
      })();
    }
    if ($1.raw) {
      $1.datcws = $a($1.barcode.length);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i >= $1.barcode.length - 3) {
          break;
        }
        if ($get($1.barcode, $1.i) != 94) {
          break;
        }
        var _2W = $geti($1.barcode, $1.i + 1, 3);
        $k[$j++] = _2W;
        $k[$j++] = false;
        for (var _2X = 0, _2Y = _2W.length; _2X < _2Y; _2X++) {
          var _2Z = $get(_2W, _2X);
          if (_2Z < 48 || _2Z > 57) {
            $j--;
            $k[$j++] = true;
          }
        }
        if ($k[--$j]) {
          $j--;
          break;
        }
        $1.cw = $cvi($k[--$j]);
        $put($1.datcws, $1.j, $1.cw);
        $1.i = $1.i + 4;
        $1.j = $1.j + 1;
      }
      if ($1.i != $1.barcode.length) {
        $k[$j++] = "bwipp.pdf417badRawFormat#16425";
        $k[$j++] = "raw data must be formatted as ^NNN";
        bwipp_raiseerror();
      }
      $1.datcws = $geti($1.datcws, 0, $1.j);
    }
    $1.encb = function() {
      $1.in = $k[--$j];
      $1.inlen = $1.in.length;
      $1.out = $a(~~($1.inlen / 6) * 5 + $1.inlen % 6);
      for (var _2t = 0, _2s = ~~($1.inlen / 6) - 1; _2t <= _2s; _2t += 1) {
        $1.k = _2t;
        $k[$j++] = Infinity;
        $aload($geti($1.in, $1.k * 6, 3));
        $1.msbs = $a();
        $k[$j++] = Infinity;
        $aload($1.msbs);
        var _2z = $k[--$j];
        var _30 = $k[--$j];
        var _31 = $k[--$j];
        $k[$j++] = $f($f(_2z + _30 * 256) + _31 * 65536);
        for (var _32 = 0, _33 = 3; _32 < _33; _32++) {
          var _34 = $k[--$j];
          $k[$j++] = _34 % 900;
          $k[$j++] = ~~(_34 / 900);
        }
        $1.mscs = $a();
        $k[$j++] = Infinity;
        $aload($geti($1.in, $1.k * 6 + 3, 3));
        $1.lsbs = $a();
        $k[$j++] = Infinity;
        $aload($1.lsbs);
        var _3B = $k[--$j];
        var _3C = $k[--$j];
        var _3D = $k[--$j];
        $k[$j++] = $f($f(_3B + _3C * 256) + _3D * 65536);
        for (var _3E = 0, _3F = 3; _3E < _3F; _3E++) {
          var _3G = $k[--$j];
          $k[$j++] = _3G % 900;
          $k[$j++] = ~~(_3G / 900);
        }
        $1.lscs = $a();
        var _3J = $get($1.lscs, 0);
        var _3L = $get($1.mscs, 0);
        $put($1.out, $1.k * 5 + 4, $f(_3J + _3L * 316) % 900);
        var _3P = $get($1.lscs, 1);
        var _3R = $get($1.mscs, 0);
        var _3T = $get($1.mscs, 1);
        $put($1.out, $1.k * 5 + 3, $f($f($f(~~($f(_3J + _3L * 316) / 900) + _3P) + _3R * 641) + _3T * 316) % 900);
        var _3X = $get($1.lscs, 2);
        var _3Z = $get($1.mscs, 0);
        var _3b = $get($1.mscs, 1);
        var _3d = $get($1.mscs, 2);
        $put($1.out, $1.k * 5 + 2, $f($f($f($f(~~($f($f($f(~~($f(_3J + _3L * 316) / 900) + _3P) + _3R * 641) + _3T * 316) / 900) + _3X) + _3Z * 20) + _3b * 641) + _3d * 316) % 900);
        var _3h = $get($1.lscs, 3);
        var _3j = $get($1.mscs, 1);
        var _3l = $get($1.mscs, 2);
        $put($1.out, $1.k * 5 + 1, $f($f($f(~~($f($f($f($f(~~($f($f($f(~~($f(_3J + _3L * 316) / 900) + _3P) + _3R * 641) + _3T * 316) / 900) + _3X) + _3Z * 20) + _3b * 641) + _3d * 316) / 900) + _3h) + _3j * 20) + _3l * 641) % 900);
        $put($1.out, $1.k * 5, $f(~~($f($f($f(~~($f($f($f($f(~~($f($f($f(~~($f(_3J + _3L * 316) / 900) + _3P) + _3R * 641) + _3T * 316) / 900) + _3X) + _3Z * 20) + _3b * 641) + _3d * 316) / 900) + _3h) + _3j * 20) + _3l * 641) / 900) + $get($1.mscs, 2) * 20) % 900);
      }
      $1.rem = $1.inlen % 6;
      if ($1.rem != 0) {
        $k[$j++] = $1.out;
        $k[$j++] = $1.out.length - $1.rem;
        $k[$j++] = Infinity;
        $aload($geti($1.in, $1.inlen - $1.rem, $1.rem));
        var _42 = $a();
        var _43 = $k[--$j];
        $puti($k[--$j], _43, _42);
      }
      $k[$j++] = $1.out;
    };
    if ($1.ccc) {
      $1.barlen = $1.barcode.length;
      $1.datcws = $a(~~($1.barlen / 6) * 5 + $1.barlen % 6 + 2);
      $put($1.datcws, 0, 920);
      var _4E = $1.barlen % 6 == 0 ? 924 : 901;
      $put($1.datcws, 1, _4E);
      $k[$j++] = $1.datcws;
      $k[$j++] = 2;
      $k[$j++] = Infinity;
      $forall($1.barcode);
      var _4H = $a();
      $k[$j++] = _4H;
      $1.encb();
      var _4I = $k[--$j];
      var _4J = $k[--$j];
      $puti($k[--$j], _4J, _4I);
    }
    if (!$1.raw && !$1.ccc) {
      var _4P = /* @__PURE__ */ new Map([
        ["parse", $1.parse],
        ["parsefnc", $1.parsefnc],
        ["eci", true]
      ]);
      $1.fncvals = _4P;
      $k[$j++] = "msg";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.fncvals;
      bwipp_parseinput();
      var _4S = $k[--$j];
      $1[$k[--$j]] = _4S;
      $1.msglen = $1.msg.length;
      $k[$j++] = Infinity;
      for (var _4W = 0, _4X = $1.msglen; _4W < _4X; _4W++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numdigits = $a();
      $k[$j++] = Infinity;
      for (var _4a = 0, _4b = $1.msglen; _4a < _4b; _4a++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numtext = $a();
      $k[$j++] = Infinity;
      for (var _4e = 0, _4f = $1.msglen; _4e < _4f; _4e++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numbytes = $a();
      $k[$j++] = Infinity;
      for (var _4i = 0, _4j = $1.msglen; _4i < _4j; _4i++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.iseci = $a();
      for (var _4m = $1.msglen - 1; _4m >= 0; _4m -= 1) {
        $1.i = _4m;
        var _4p = $get($1.msg, $1.i);
        if (_4p >= 48 && _4p <= 57) {
          $put($1.numdigits, $1.i, $f($get($1.numdigits, $1.i + 1) + 1));
        }
        var _4z = $get($1.alltext, $get($1.msg, $1.i)) !== void 0;
        if (_4z && $get($1.numdigits, $1.i) < 13) {
          $put($1.numtext, $1.i, $f($get($1.numtext, $1.i + 1) + 1));
        }
        if ($get($1.msg, $1.i) >= 0 && $get($1.numtext, $1.i) < 5 && $get($1.numdigits, $1.i) < 13) {
          $put($1.numbytes, $1.i, $f($get($1.numbytes, $1.i + 1) + 1));
        }
        $put($1.iseci, $1.i, $get($1.msg, $1.i) <= -1e6);
      }
      $1.numdigits = $geti($1.numdigits, 0, $1.msglen);
      $1.numtext = $geti($1.numtext, 0, $1.msglen);
      $1.numbytes = $geti($1.numbytes, 0, $1.msglen);
      $1.seq = $a([]);
      $1.seqlen = 0;
      $1.state = $1.T;
      $1.p = 0;
      for (; ; ) {
        if ($1.p == $1.msglen) {
          break;
        }
        if ($get($1.iseci, $1.p)) {
          $1.eci = $get($1.msg, $1.p);
          $k[$j++] = Infinity;
          $aload($1.seq);
          $k[$j++] = $a([$1.eci]);
          $1.seq = $a();
          $1.p = $1.p + 1;
          $k[$j++] = "seqlen";
          $k[$j++] = $1.seqlen;
          if ($1.eci <= -1810900) {
            $k[$j++] = 2;
          } else {
            var _5s = $1.eci <= -1000900 ? 3 : 2;
            $k[$j++] = _5s;
          }
          var _5t = $k[--$j];
          var _5u = $k[--$j];
          $1[$k[--$j]] = $f(_5u + _5t);
        } else {
          $1.n = $get($1.numdigits, $1.p);
          if ($1.n >= 13 || $1.n == $1.msglen && $1.n >= 8) {
            $k[$j++] = Infinity;
            $aload($1.seq);
            $k[$j++] = $1.nl;
            $k[$j++] = Infinity;
            $aload($geti($1.msg, $1.p, $1.n));
            var _69 = $a();
            $k[$j++] = _69;
            $1.seq = $a();
            $1.state = $1.N;
            $1.p = $f($1.p + $1.n);
            $1.seqlen = $f($1.seqlen + 1 + $1.n);
          } else {
            $1.t = $get($1.numtext, $1.p);
            if ($1.t >= 5) {
              $k[$j++] = Infinity;
              $aload($1.seq);
              if ($1.state != $1.T) {
                $k[$j++] = $1.tl;
              }
              $k[$j++] = Infinity;
              $aload($geti($1.msg, $1.p, $1.t));
              var _6S = $a();
              $k[$j++] = _6S;
              $1.seq = $a();
              $1.state = $1.T;
              $1.p = $f($1.p + $1.t);
              $1.seqlen = $f($f($1.seqlen + 1) + $1.t);
            } else {
              $1.b = $get($1.numbytes, $1.p);
              if ($1.b == 1 && $1.state == $1.T) {
                $k[$j++] = Infinity;
                $aload($1.seq);
                $k[$j++] = $1.bs;
                $k[$j++] = $a([$get($1.msg, $1.p)]);
                $1.seq = $a();
                $1.p = $f($1.p + $1.b);
                $1.seqlen = $f($1.seqlen + 2);
              } else {
                $k[$j++] = Infinity;
                $aload($1.seq);
                var _6r = $1.b % 6 != 0 ? $1.bl : $1.bl6;
                $k[$j++] = _6r;
                $k[$j++] = Infinity;
                $aload($geti($1.msg, $1.p, $1.b));
                var _6w = $a();
                $k[$j++] = _6w;
                $1.seq = $a();
                $1.state = $1.B;
                $1.p = $f($1.p + $1.b);
                $1.seqlen = $f($f($1.seqlen + 1) + $1.b);
              }
            }
          }
        }
      }
      $1.enca = function() {
        var _77 = $get($get($1.charvals, $1.A), $k[--$j]);
        $k[$j++] = _77;
      };
      $1.encl = function() {
        var _7C = $get($get($1.charvals, $1.L), $k[--$j]);
        $k[$j++] = _7C;
      };
      $1.encm = function() {
        var _7H = $get($get($1.charvals, $1.M), $k[--$j]);
        $k[$j++] = _7H;
      };
      $1.encp = function() {
        var _7M = $get($get($1.charvals, $1.P), $k[--$j]);
        $k[$j++] = _7M;
      };
      $1.textencfuncs = $a(["enca", "encl", "encm", "encp"]);
      $1.addtotext = function() {
        $put($1.text, $1.l, $k[--$j]);
        $1.l = $1.l + 1;
      };
      $1.enct = function() {
        $1.in = $k[--$j];
        $1.curlen = $a([$1.e, $1.e, $1.e, $1.e]);
        $put($1.curlen, $1.submode, 0);
        $1.curseq = $a([$a([]), $a([]), $a([]), $a([])]);
        $forall($1.in, function() {
          $1.char = $k[--$j];
          for (; ; ) {
            $1.imp = false;
            var _7l = $a([$1.A, $1.L, $1.M, $1.P]);
            for (var _7m = 0, _7n = _7l.length; _7m < _7n; _7m++) {
              $1.x = $get(_7l, _7m);
              var _7t = $a([$1.A, $1.L, $1.M, $1.P]);
              for (var _7u = 0, _7v = _7t.length; _7u < _7v; _7u++) {
                $1.y = $get(_7t, _7u);
                $1.cost = $f($get($1.curlen, $1.x) + $get($get($1.latlen, $1.x), $1.y));
                if ($1.cost < $get($1.curlen, $1.y)) {
                  $put($1.curlen, $1.y, $1.cost);
                  $k[$j++] = $1.curseq;
                  $k[$j++] = $1.y;
                  $k[$j++] = Infinity;
                  $aload($get($1.curseq, $1.x));
                  $aload($get($get($1.latseq, $1.x), $1.y));
                  var _8M = $a();
                  var _8N = $k[--$j];
                  $put($k[--$j], _8N, _8M);
                  $1.imp = true;
                }
              }
            }
            if (!$1.imp) {
              break;
            }
          }
          $1.nxtlen = $a([$1.e, $1.e, $1.e, $1.e]);
          $1.nxtseq = $a(4);
          var _8a = $a([$1.A, $1.L, $1.M, $1.P]);
          for (var _8b = 0, _8c = _8a.length; _8b < _8c; _8b++) {
            $1.x = $get(_8a, _8b);
            for (; ; ) {
              var _8i = $get($get($1.charvals, $1.x), $1.char) !== void 0;
              if (!_8i) {
                break;
              }
              $1.cost = $f($get($1.curlen, $1.x) + 1);
              if ($1.cost < $get($1.nxtlen, $1.x)) {
                $put($1.nxtlen, $1.x, $1.cost);
                $k[$j++] = $1.nxtseq;
                $k[$j++] = $1.x;
                $k[$j++] = Infinity;
                $aload($get($1.curseq, $1.x));
                $k[$j++] = $1.char;
                var _8z = $a();
                var _90 = $k[--$j];
                $put($k[--$j], _90, _8z);
              }
              var _96 = $a([$1.A, $1.L, $1.M, $1.P]);
              for (var _97 = 0, _98 = _96.length; _97 < _98; _97++) {
                $1.y = $get(_96, _97);
                if ($ne($1.x, $1.y)) {
                  $1.cost = $f($f($get($1.curlen, $1.y) + $get($get($1.shftlen, $1.y), $1.x)) + 1);
                  if ($1.cost < $get($1.nxtlen, $1.y)) {
                    $put($1.nxtlen, $1.y, $1.cost);
                    $k[$j++] = $1.nxtseq;
                    $k[$j++] = $1.y;
                    $k[$j++] = Infinity;
                    $aload($get($1.curseq, $1.y));
                    var _9Y = $1.x == $1.A ? $1.as : $1.ps;
                    $k[$j++] = _9Y;
                    $k[$j++] = $1.char;
                    var _9a = $a();
                    var _9b = $k[--$j];
                    $put($k[--$j], _9b, _9a);
                  }
                }
              }
              break;
            }
          }
          $1.curlen = $1.nxtlen;
          $1.curseq = $1.nxtseq;
        });
        $1.minseq = $1.e;
        var _9k = $a([$1.A, $1.L, $1.M, $1.P]);
        for (var _9l = 0, _9m = _9k.length; _9l < _9m; _9l++) {
          $1.k = $get(_9k, _9l);
          if ($get($1.curlen, $1.k) < $1.minseq) {
            $1.minseq = $get($1.curlen, $1.k);
            $1.txtseq = $get($1.curseq, $1.k);
          }
        }
        $1.text = $a($1.minseq);
        $1.k = 0;
        $1.l = 0;
        for (; ; ) {
          if ($1.k >= $1.txtseq.length) {
            break;
          }
          $1.char = $get($1.txtseq, $1.k);
          $k[$j++] = $1.char;
          if ($1[$get($1.textencfuncs, $1.submode)]() === true) {
            break;
          }
          $1.addtotext();
          $1.k = $1.k + 1;
          if ($1.char == $1.as || $1.char == $1.ps) {
            $k[$j++] = $get($1.txtseq, $1.k);
            if ($1.char == $1.as) {
              $1.enca();
            } else {
              $1.encp();
            }
            $1.addtotext();
            $1.k = $1.k + 1;
          }
          if ($1.char == $1.al) {
            $1.submode = $1.A;
          }
          if ($1.char == $1.ll) {
            $1.submode = $1.L;
          }
          if ($1.char == $1.ml) {
            $1.submode = $1.M;
          }
          if ($1.char == $1.pl) {
            $1.submode = $1.P;
          }
        }
        if ($1.text.length % 2 == 1) {
          if ($1.submode == $1.P) {
            $k[$j++] = "pad";
            $k[$j++] = $1.al;
            $1.encp();
            var _Ab = $k[--$j];
            $1[$k[--$j]] = _Ab;
            $1.submode = $1.A;
          } else {
            $1.nextecitext = false;
            for (var _Ah = $1.i + 1, _Ag = $1.seq.length - 1; _Ah <= _Ag; _Ah += 1) {
              $1.ti = _Ah;
              if ($ne($type($get($1.seq, $1.ti)), "arraytype")) {
                $1.nextecitext = false;
                break;
              }
              if ($get($get($1.seq, $1.ti), 0) > -1e6) {
                break;
              }
              $1.nextecitext = true;
            }
            if ($1.nextecitext) {
              if ($1.submode == $1.A) {
                var _B0 = $get($get($1.charvals, $1.L), $get($get($1.seq, $1.ti), 0)) !== void 0;
                if (_B0) {
                  $k[$j++] = "pad";
                  $k[$j++] = $1.ll;
                  $1.enca();
                  var _B2 = $k[--$j];
                  $1[$k[--$j]] = _B2;
                  $1.submode = $1.L;
                } else {
                  $k[$j++] = "pad";
                  $k[$j++] = $1.ml;
                  $1.enca();
                  var _B6 = $k[--$j];
                  $1[$k[--$j]] = _B6;
                  $1.submode = $1.M;
                }
              } else {
                if ($1.submode == $1.M) {
                  var _BI = $get($get($1.charvals, $1.L), $get($get($1.seq, $1.ti), 0)) !== void 0;
                  if (_BI) {
                    $k[$j++] = "pad";
                    $k[$j++] = $1.ll;
                    $1.encm();
                    var _BK = $k[--$j];
                    $1[$k[--$j]] = _BK;
                    $1.submode = $1.L;
                  } else {
                    var _BU = $get($get($1.charvals, $1.P), $get($get($1.seq, $1.ti), 0)) !== void 0;
                    if (_BU) {
                      $k[$j++] = "pad";
                      $k[$j++] = $1.pl;
                      $1.encm();
                      var _BW = $k[--$j];
                      $1[$k[--$j]] = _BW;
                      $1.submode = $1.P;
                    } else {
                      $k[$j++] = "pad";
                      $k[$j++] = $1.al;
                      $1.encm();
                      var _Ba = $k[--$j];
                      $1[$k[--$j]] = _Ba;
                      $1.submode = $1.A;
                    }
                  }
                } else {
                  $k[$j++] = "pad";
                  $k[$j++] = $1.ml;
                  $1.encl();
                  var _Be = $k[--$j];
                  $1[$k[--$j]] = _Be;
                  $1.submode = $1.M;
                }
              }
            } else {
              $k[$j++] = "pad";
              $k[$j++] = $1.ps;
              if ($1[$get($1.textencfuncs, $1.submode)]() === true) {
                return true;
              }
              var _Bm = $k[--$j];
              $1[$k[--$j]] = _Bm;
            }
          }
          $k[$j++] = Infinity;
          $aload($1.text);
          $k[$j++] = $1.pad;
          $1.text = $a();
        }
        $1.out = $a(~~($1.text.length / 2));
        for (var _Bv = 0, _Bu = $1.out.length - 1; _Bv <= _Bu; _Bv += 1) {
          $1.k = _Bv;
          $put($1.out, $1.k, $f($get($1.text, $1.k * 2) * 30 + $get($1.text, $1.k * 2 + 1)));
        }
        $k[$j++] = $1.out;
      };
      $1.encn = function() {
        $1.in = $k[--$j];
        $1.out = $a([]);
        for (var _C9 = 0, _C8 = $1.in.length - 1; _C9 <= _C8; _C9 += 44) {
          $1.k = _C9;
          $k[$j++] = Infinity;
          var _CE = $1.in.length - $1.k;
          $k[$j++] = 1;
          $k[$j++] = $1.in;
          $k[$j++] = $1.k;
          $k[$j++] = _CE;
          if (_CE > 44) {
            $j--;
            $k[$j++] = 44;
          }
          var _CF = $k[--$j];
          var _CG = $k[--$j];
          var _CI = $geti($k[--$j], _CG, _CF);
          for (var _CJ = 0, _CK = _CI.length; _CJ < _CK; _CJ++) {
            $k[$j++] = $f($get(_CI, _CJ) - 48);
          }
          $1.gmod = $a();
          $1.cwn = $a([]);
          for (; ; ) {
            $1.dv = 900;
            $1.gmul = $a([]);
            $1.val = 0;
            for (; ; ) {
              if ($1.gmod.length == 0) {
                break;
              }
              $1.val = $f($1.val * 10 + $get($1.gmod, 0));
              $1.gmod = $geti($1.gmod, 1, $1.gmod.length - 1);
              if ($1.val < $1.dv) {
                if ($1.gmul.length != 0) {
                  $k[$j++] = Infinity;
                  $aload($1.gmul);
                  $k[$j++] = 0;
                  $1.gmul = $a();
                }
              } else {
                $k[$j++] = Infinity;
                $aload($1.gmul);
                $k[$j++] = ~~($1.val / $1.dv);
                $1.gmul = $a();
              }
              $1.val = $1.val % $1.dv;
            }
            $1.dv = $1.val;
            $k[$j++] = Infinity;
            $k[$j++] = $1.dv;
            $aload($1.cwn);
            $1.cwn = $a();
            $1.gmod = $1.gmul;
            if ($1.gmul.length == 0) {
              break;
            }
          }
          $k[$j++] = Infinity;
          $aload($1.out);
          $aload($1.cwn);
          $1.out = $a();
        }
        $k[$j++] = $1.out;
      };
      $1.ence = function() {
        var _Ct = $f(-$get($k[--$j], 0) - 1e6);
        $k[$j++] = _Ct;
        if (_Ct <= 899) {
          var _Cu = $k[--$j];
          $k[$j++] = 927;
          $k[$j++] = _Cu;
          $astore($a(2));
        } else {
          var _Cw = $k[--$j];
          $k[$j++] = _Cw;
          if (_Cw <= 810899) {
            var _Cx = $k[--$j];
            $k[$j++] = 926;
            $k[$j++] = ~~(_Cx / 900) - 1;
            $k[$j++] = _Cx % 900;
            $astore($a(3));
          } else {
            var _Cz = $k[--$j];
            $k[$j++] = _Cz;
            if (_Cz <= 811799) {
              var _D0 = $k[--$j];
              $k[$j++] = 925;
              $k[$j++] = $f(_D0 - 810900);
              $astore($a(2));
            } else {
              $k[$j++] = "bwipp.pdf417badECI#16787";
              $k[$j++] = "PDF417 supports ECIs 000000 to 811799";
              bwipp_raiseerror();
            }
          }
        }
      };
      $1.encfuncs = $a(["enct", "encn", "encb"]);
      $1.addtocws = function() {
        var _D3 = $k[--$j];
        $puti($1.datcws, $1.j, _D3);
        $1.j = _D3.length + $1.j;
      };
      $1.state = $1.T;
      $1.submode = $1.A;
      $1.datcws = $a($1.seqlen);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i >= $1.seq.length) {
          break;
        }
        $1.chars = $get($1.seq, $1.i);
        if ($eq($type($1.chars), "arraytype")) {
          if ($get($1.chars, 0) <= -1e6) {
            $k[$j++] = $1.chars;
            $1.ence();
            $1.addtocws();
          } else {
            $k[$j++] = $1.chars;
            if ($1[$get($1.encfuncs, $1.state)]() === true) {
              break;
            }
            $1.addtocws();
          }
        } else {
          $k[$j++] = $a([$get($1.latchcws, $1.chars)]);
          $1.addtocws();
          if ($1.chars == $1.tl) {
            $1.state = $1.T;
            $1.submode = $1.A;
          }
          if ($1.chars == $1.nl) {
            $1.state = $1.N;
          }
          if ($1.chars == $1.bl || $1.chars == $1.bl6) {
            $1.state = $1.B;
          }
          if ($1.chars == $1.bs) {
            $1.i = $1.i + 1;
            $k[$j++] = $get($1.seq, $1.i);
            $1.encb();
            $1.addtocws();
          }
        }
        $1.i = $1.i + 1;
      }
      $1.datcws = $geti($1.datcws, 0, $1.j);
    }
    $1.m = $1.datcws.length;
    if ($1.eclevel == -1) {
      if ($1.m <= 40) {
        $1.eclevel = 2;
      }
      if ($1.m >= 41 && $1.m <= 160) {
        $1.eclevel = 3;
      }
      if ($1.m >= 161 && $1.m <= 320) {
        $1.eclevel = 4;
      }
      if ($1.m >= 321) {
        $1.eclevel = 5;
      }
    }
    $1.maxeclevel = ~~(Math.log(928 - 1 - $1.m) / Math.log(2)) - 1;
    if ($1.eclevel > $1.maxeclevel) {
      $1.eclevel = $1.maxeclevel;
    }
    $1.k = ~~Math.pow(2, $1.eclevel + 1);
    if ($1.columns == 0) {
      $1.columns = ~~Math.round(Math.sqrt(($1.m + $1.k) / 3));
    }
    $k[$j++] = "c";
    if ($1.columns >= 1) {
      $k[$j++] = $1.columns;
    } else {
      $k[$j++] = 1;
    }
    var _E8 = $k[--$j];
    $1[$k[--$j]] = _E8;
    $1.r = ~~Math.ceil(($1.m + $1.k + 1) / $1.columns);
    if ($1.r < $1.rows && $1.rows <= 90) {
      $1.r = $1.rows;
    }
    if ($1.r < 3) {
      $1.r = 3;
    }
    if ($1.r > 90) {
      $k[$j++] = "bwipp.pdf417insufficientCapacity#16850";
      $k[$j++] = "Insufficient capacity in the symbol";
      bwipp_raiseerror();
    }
    var _EJ = $1.c;
    var _EK = $1.r;
    var _EL = $1.m;
    var _EM = 8;
    var _EN = ~~(Math.log($f($f(_EJ * _EK - 1) - _EL)) / Math.log(2)) - 1;
    if (~~(Math.log($f($f(_EJ * _EK - 1) - _EL)) / Math.log(2)) - 1 > 8) {
      var _ = _EM;
      _EM = _EN;
      _EN = _;
    }
    $1.maxeclevel = _EN;
    if ($1.maxeclevel > $1.eclevel) {
      $1.eclevel = $1.maxeclevel;
      $1.k = ~~Math.pow(2, $1.eclevel + 1);
    }
    $1.n = $f($1.c * $1.r - $1.k);
    $1.cws = $a($f($1.c * $1.r + 1));
    $put($1.cws, 0, $1.n);
    $puti($1.cws, 1, $1.datcws);
    $k[$j++] = $1.cws;
    $k[$j++] = $1.m + 1;
    $k[$j++] = Infinity;
    for (var _Eg = 0, _Eh = $f($f($1.n - $1.m) - 1); _Eg < _Eh; _Eg++) {
      $k[$j++] = 900;
    }
    var _Ei = $a();
    var _Ej = $k[--$j];
    $puti($k[--$j], _Ej, _Ei);
    $k[$j++] = $1.cws;
    $k[$j++] = $1.n;
    $k[$j++] = Infinity;
    for (var _Eo = 0, _Ep = $1.k; _Eo < _Ep; _Eo++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    var _Eq = $a();
    var _Er = $k[--$j];
    $puti($k[--$j], _Er, _Eq);
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _Et = 0, _Eu = 928; _Et < _Eu; _Et++) {
      var _Ev = $k[--$j];
      $k[$j++] = _Ev;
      $k[$j++] = _Ev * 3 % 929;
    }
    $1.rsalog = $a();
    $1.rslog = $a(929);
    for (var _Ey = 1; _Ey <= 928; _Ey += 1) {
      $put($1.rslog, $get($1.rsalog, _Ey), _Ey);
    }
    $1.rsprod = function() {
      var _F2 = $k[--$j];
      var _F3 = $k[--$j];
      $k[$j++] = _F3;
      $k[$j++] = _F2;
      if (_F2 != 0 && _F3 != 0) {
        var _F6 = $get($1.rslog, $k[--$j]);
        var _FB = $get($1.rsalog, $f(_F6 + $get($1.rslog, $k[--$j])) % 928);
        $k[$j++] = _FB;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _FD = 0, _FE = $1.k; _FD < _FE; _FD++) {
      $k[$j++] = 0;
    }
    $1.coeffs = $a();
    for (var _FI = 1, _FH = $1.k; _FI <= _FH; _FI += 1) {
      $1.i = _FI;
      $put($1.coeffs, $1.i, $get($1.coeffs, $1.i - 1));
      for (var _FP = $1.i - 1; _FP >= 1; _FP -= 1) {
        $1.j = _FP;
        $k[$j++] = $1.coeffs;
        $k[$j++] = $1.j;
        $k[$j++] = $get($1.coeffs, $1.j - 1);
        $k[$j++] = $get($1.coeffs, $1.j);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _Fb = $k[--$j];
        var _Fc = $k[--$j];
        var _Fd = $k[--$j];
        $put($k[--$j], _Fd, $f(_Fc + _Fb) % 929);
      }
      $k[$j++] = $1.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($1.coeffs, 0);
      $k[$j++] = $get($1.rsalog, $1.i);
      $1.rsprod();
      var _Fl = $k[--$j];
      var _Fm = $k[--$j];
      $put($k[--$j], _Fm, _Fl);
    }
    $1.coeffs = $geti($1.coeffs, 0, $1.coeffs.length - 1);
    for (var _Fs = $1.coeffs.length - 1; _Fs >= 0; _Fs -= 2) {
      var _Ft = $1.coeffs;
      $put(_Ft, _Fs, $f(929 - $get(_Ft, _Fs)));
    }
    for (var _Fx = 0, _Fw = $f($1.n - 1); _Fx <= _Fw; _Fx += 1) {
      $1.t = $f($get($1.cws, _Fx) + $get($1.cws, $1.n)) % 929;
      for (var _G5 = 0, _G4 = $1.k - 1; _G5 <= _G4; _G5 += 1) {
        $1.j = _G5;
        $put($1.cws, $f($1.n + $1.j), $f($get($1.cws, $f($f($1.n + $1.j) + 1)) + $f(929 - $1.t * $get($1.coeffs, $1.k - $1.j - 1) % 929)) % 929);
      }
    }
    for (var _GM = $1.n, _GL = $f($1.n + $1.k); _GM <= _GL; _GM += 1) {
      $put($1.cws, _GM, $f(929 - $get($1.cws, _GM)) % 929);
    }
    $1.cws = $geti($1.cws, 0, $1.cws.length - 1);
    var _GU = $get($1.options, "debugcws") !== void 0;
    if (_GU) {
      $k[$j++] = "bwipp.debugcws#16909";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    if (!bwipp_pdf417.__17153__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.clusters = $a([$a([120256, 125680, 128380, 120032, 125560, 128318, 108736, 119920, 108640, 86080, 108592, 86048, 110016, 120560, 125820, 109792, 120440, 125758, 88256, 109680, 88160, 89536, 110320, 120700, 89312, 110200, 120638, 89200, 110140, 89840, 110460, 89720, 110398, 89980, 128506, 119520, 125304, 128190, 107712, 119408, 125244, 107616, 119352, 84032, 107568, 119324, 84e3, 107544, 83984, 108256, 119672, 125374, 85184, 108144, 119612, 85088, 108088, 119582, 85040, 108060, 85728, 108408, 119742, 85616, 108348, 85560, 108318, 85880, 108478, 85820, 85790, 107200, 119152, 125116, 107104, 119096, 125086, 83008, 107056, 119068, 82976, 107032, 82960, 82952, 83648, 107376, 119228, 83552, 107320, 119198, 83504, 107292, 83480, 83468, 83824, 107452, 83768, 107422, 83740, 83900, 106848, 118968, 125022, 82496, 106800, 118940, 82464, 106776, 118926, 82448, 106764, 82440, 106758, 82784, 106936, 119006, 82736, 106908, 82712, 106894, 82700, 82694, 106974, 82830, 82240, 106672, 118876, 82208, 106648, 118862, 82192, 106636, 82184, 106630, 82180, 82352, 82328, 82316, 82080, 118830, 106572, 106566, 82050, 117472, 124280, 127678, 103616, 117360, 124220, 103520, 117304, 124190, 75840, 103472, 75808, 104160, 117624, 124350, 76992, 104048, 117564, 76896, 103992, 76848, 76824, 77536, 104312, 117694, 77424, 104252, 77368, 77340, 77688, 104382, 77628, 77758, 121536, 126320, 128700, 121440, 126264, 128670, 111680, 121392, 126236, 111648, 121368, 126222, 111632, 121356, 103104, 117104, 124092, 112320, 103008, 117048, 124062, 112224, 121656, 126366, 93248, 74784, 102936, 117006, 93216, 112152, 93200, 75456, 103280, 117180, 93888, 75360, 103224, 117150, 93792, 112440, 121758, 93744, 75288, 93720, 75632, 103356, 94064, 75576, 103326, 94008, 112542, 93980, 75708, 94140, 75678, 94110, 121184, 126136, 128606, 111168, 121136, 126108, 111136, 121112, 126094, 111120, 121100, 111112, 111108, 102752, 116920, 123998, 111456, 102704, 116892, 91712, 74272, 121244, 116878, 91680, 74256, 102668, 91664, 111372, 102662, 74244, 74592, 102840, 116958, 92e3, 74544, 102812, 91952, 111516, 102798, 91928, 74508, 74502, 74680, 102878, 92088, 74652, 92060, 74638, 92046, 92126, 110912, 121008, 126044, 110880, 120984, 126030, 110864, 120972, 110856, 120966, 110852, 110850, 74048, 102576, 116828, 90944, 74016, 102552, 116814, 90912, 111e3, 121038, 90896, 73992, 102534, 90888, 110982, 90884, 74160, 102620, 91056, 74136, 102606, 91032, 111054, 91020, 74118, 91014, 91100, 91086, 110752, 120920, 125998, 110736, 120908, 110728, 120902, 110724, 110722, 73888, 102488, 116782, 90528, 73872, 102476, 90512, 110796, 102470, 90504, 73860, 90500, 73858, 73944, 90584, 90572, 90566, 120876, 120870, 110658, 102444, 73800, 90312, 90308, 90306, 101056, 116080, 123580, 100960, 116024, 70720, 100912, 115996, 70688, 100888, 70672, 70664, 71360, 101232, 116156, 71264, 101176, 116126, 71216, 101148, 71192, 71180, 71536, 101308, 71480, 101278, 71452, 71612, 71582, 118112, 124600, 127838, 105024, 118064, 124572, 104992, 118040, 124558, 104976, 118028, 104968, 118022, 100704, 115896, 123486, 105312, 100656, 115868, 79424, 70176, 118172, 115854, 79392, 105240, 100620, 79376, 70152, 79368, 70496, 100792, 115934, 79712, 70448, 118238, 79664, 105372, 100750, 79640, 70412, 79628, 70584, 100830, 79800, 70556, 79772, 70542, 70622, 79838, 122176, 126640, 128860, 122144, 126616, 128846, 122128, 126604, 122120, 126598, 122116, 104768, 117936, 124508, 113472, 104736, 126684, 124494, 113440, 122264, 126670, 113424, 104712, 117894, 113416, 122246, 104706, 69952, 100528, 115804, 78656, 69920, 100504, 115790, 96064, 78624, 104856, 117966, 96032, 113560, 122318, 100486, 96016, 78600, 104838, 96008, 69890, 70064, 100572, 78768, 70040, 100558, 96176, 78744, 104910, 96152, 113614, 70022, 78726, 70108, 78812, 70094, 96220, 78798, 122016, 126552, 128814, 122e3, 126540, 121992, 126534, 121988, 121986, 104608, 117848, 124462, 113056, 104592, 126574, 113040, 122060, 117830, 113032, 104580, 113028, 104578, 113026, 69792, 100440, 115758, 78240, 69776, 100428, 95136, 78224, 104652, 100422, 95120, 113100, 69764, 95112, 78212, 69762, 78210, 69848, 100462, 78296, 69836, 95192, 78284, 69830, 95180, 78278, 69870, 95214, 121936, 126508, 121928, 126502, 121924, 121922, 104528, 117804, 112848, 104520, 117798, 112840, 121958, 112836, 104514, 112834, 69712, 100396, 78032, 69704, 100390, 94672, 78024, 104550, 94664, 112870, 69698, 94660, 78018, 94658, 78060, 94700, 94694, 126486, 121890, 117782, 104484, 104482, 69672, 77928, 94440, 69666, 77922, 99680, 68160, 99632, 68128, 99608, 115342, 68112, 99596, 68104, 99590, 68448, 99768, 115422, 68400, 99740, 68376, 99726, 68364, 68358, 68536, 99806, 68508, 68494, 68574, 101696, 116400, 123740, 101664, 116376, 101648, 116364, 101640, 116358, 101636, 67904, 99504, 115292, 72512, 67872, 116444, 115278, 72480, 101784, 116430, 72464, 67848, 99462, 72456, 101766, 67842, 68016, 99548, 72624, 67992, 99534, 72600, 101838, 72588, 67974, 68060, 72668, 68046, 72654, 118432, 124760, 127918, 118416, 124748, 118408, 124742, 118404, 118402, 101536, 116312, 105888, 101520, 116300, 105872, 118476, 116294, 105864, 101508, 105860, 101506, 105858, 67744, 99416, 72096, 67728, 116334, 80800, 72080, 101580, 99398, 80784, 105932, 67716, 80776, 72068, 67714, 72066, 67800, 99438, 72152, 67788, 80856, 72140, 67782, 80844, 72134, 67822, 72174, 80878, 126800, 128940, 126792, 128934, 126788, 126786, 118352, 124716, 122576, 126828, 124710, 122568, 126822, 122564, 118338, 122562, 101456, 116268, 105680, 101448, 116262, 114128, 105672, 118374, 114120, 122598, 101442, 114116, 105666, 114114, 67664, 99372, 71888, 67656, 99366, 80336, 71880, 101478, 97232, 80328, 105702, 67650, 97224, 114150, 71874, 97220, 67692, 71916, 67686, 80364, 71910, 97260, 80358, 97254, 126760, 128918, 126756, 126754, 118312, 124694, 122472, 126774, 122468, 118306, 122466, 101416, 116246, 105576, 101412, 113896, 105572, 101410, 113892, 105570, 113890, 67624, 99350, 71784, 101430, 80104, 71780, 67618, 96744, 80100, 71778, 96740, 80098, 96738, 71798, 96758, 126738, 122420, 122418, 105524, 113780, 113778, 71732, 79988, 96500, 96498, 66880, 66848, 98968, 66832, 66824, 66820, 66992, 66968, 66956, 66950, 67036, 67022, 1e5, 99984, 115532, 99976, 115526, 99972, 99970, 66720, 98904, 69024, 100056, 98892, 69008, 100044, 69e3, 100038, 68996, 66690, 68994, 66776, 98926, 69080, 100078, 69068, 66758, 69062, 66798, 69102, 116560, 116552, 116548, 116546, 99920, 102096, 116588, 115494, 102088, 116582, 102084, 99906, 102082, 66640, 68816, 66632, 98854, 73168, 68808, 66628, 73160, 68804, 66626, 73156, 68802, 66668, 68844, 66662, 73196, 68838, 73190, 124840, 124836, 124834, 116520, 118632, 124854, 118628, 116514, 118626, 99880, 115478, 101992, 116534, 106216, 101988, 99874, 106212, 101986, 106210, 66600, 98838, 68712, 99894, 72936, 68708, 66594, 81384, 72932, 68706, 81380, 72930, 66614, 68726, 72950, 81398, 128980, 128978, 124820, 126900, 124818, 126898, 116500, 118580, 116498, 122740, 118578, 122738, 99860, 101940, 99858, 106100, 101938, 114420]), $a([128352, 129720, 125504, 128304, 129692, 125472, 128280, 129678, 125456, 128268, 125448, 128262, 125444, 125792, 128440, 129758, 120384, 125744, 128412, 120352, 125720, 128398, 120336, 125708, 120328, 125702, 120324, 120672, 125880, 128478, 110144, 120624, 125852, 110112, 120600, 125838, 110096, 120588, 110088, 120582, 110084, 110432, 120760, 125918, 89664, 110384, 120732, 89632, 110360, 120718, 89616, 110348, 89608, 110342, 89952, 110520, 120798, 89904, 110492, 89880, 110478, 89868, 90040, 110558, 90012, 89998, 125248, 128176, 129628, 125216, 128152, 129614, 125200, 128140, 125192, 128134, 125188, 125186, 119616, 125360, 128220, 119584, 125336, 128206, 119568, 125324, 119560, 125318, 119556, 119554, 108352, 119728, 125404, 108320, 119704, 125390, 108304, 119692, 108296, 119686, 108292, 108290, 85824, 108464, 119772, 85792, 108440, 119758, 85776, 108428, 85768, 108422, 85764, 85936, 108508, 85912, 108494, 85900, 85894, 85980, 85966, 125088, 128088, 129582, 125072, 128076, 125064, 128070, 125060, 125058, 119200, 125144, 128110, 119184, 125132, 119176, 125126, 119172, 119170, 107424, 119256, 125166, 107408, 119244, 107400, 119238, 107396, 107394, 83872, 107480, 119278, 83856, 107468, 83848, 107462, 83844, 83842, 83928, 107502, 83916, 83910, 83950, 125008, 128044, 125e3, 128038, 124996, 124994, 118992, 125036, 118984, 125030, 118980, 118978, 106960, 119020, 106952, 119014, 106948, 106946, 82896, 106988, 82888, 106982, 82884, 82882, 82924, 82918, 124968, 128022, 124964, 124962, 118888, 124982, 118884, 118882, 106728, 118902, 106724, 106722, 82408, 106742, 82404, 82402, 124948, 124946, 118836, 118834, 106612, 106610, 124224, 127664, 129372, 124192, 127640, 129358, 124176, 127628, 124168, 127622, 124164, 124162, 117568, 124336, 127708, 117536, 124312, 127694, 117520, 124300, 117512, 124294, 117508, 117506, 104256, 117680, 124380, 104224, 117656, 124366, 104208, 117644, 104200, 117638, 104196, 104194, 77632, 104368, 117724, 77600, 104344, 117710, 77584, 104332, 77576, 104326, 77572, 77744, 104412, 77720, 104398, 77708, 77702, 77788, 77774, 128672, 129880, 93168, 128656, 129868, 92664, 128648, 129862, 92412, 128644, 128642, 124064, 127576, 129326, 126368, 124048, 129902, 126352, 128716, 127558, 126344, 124036, 126340, 124034, 126338, 117152, 124120, 127598, 121760, 117136, 124108, 121744, 126412, 124102, 121736, 117124, 121732, 117122, 121730, 103328, 117208, 124142, 112544, 103312, 117196, 112528, 121804, 117190, 112520, 103300, 112516, 103298, 112514, 75680, 103384, 117230, 94112, 75664, 103372, 94096, 112588, 103366, 94088, 75652, 94084, 75650, 75736, 103406, 94168, 75724, 94156, 75718, 94150, 75758, 128592, 129836, 91640, 128584, 129830, 91388, 128580, 91262, 128578, 123984, 127532, 126160, 123976, 127526, 126152, 128614, 126148, 123970, 126146, 116944, 124012, 121296, 116936, 124006, 121288, 126182, 121284, 116930, 121282, 102864, 116972, 111568, 102856, 116966, 111560, 121318, 111556, 102850, 111554, 74704, 102892, 92112, 74696, 102886, 92104, 111590, 92100, 74690, 92098, 74732, 92140, 74726, 92134, 128552, 129814, 90876, 128548, 90750, 128546, 123944, 127510, 126056, 128566, 126052, 123938, 126050, 116840, 123958, 121064, 116836, 121060, 116834, 121058, 102632, 116854, 111080, 121078, 111076, 102626, 111074, 74216, 102646, 91112, 74212, 91108, 74210, 91106, 74230, 91126, 128532, 90494, 128530, 123924, 126004, 123922, 126002, 116788, 120948, 116786, 120946, 102516, 110836, 102514, 110834, 73972, 90612, 73970, 90610, 128522, 123914, 125978, 116762, 120890, 102458, 110714, 123552, 127320, 129198, 123536, 127308, 123528, 127302, 123524, 123522, 116128, 123608, 127342, 116112, 123596, 116104, 123590, 116100, 116098, 101280, 116184, 123630, 101264, 116172, 101256, 116166, 101252, 101250, 71584, 101336, 116206, 71568, 101324, 71560, 101318, 71556, 71554, 71640, 101358, 71628, 71622, 71662, 127824, 129452, 79352, 127816, 129446, 79100, 127812, 78974, 127810, 123472, 127276, 124624, 123464, 127270, 124616, 127846, 124612, 123458, 124610, 115920, 123500, 118224, 115912, 123494, 118216, 124646, 118212, 115906, 118210, 100816, 115948, 105424, 100808, 115942, 105416, 118246, 105412, 100802, 105410, 70608, 100844, 79824, 70600, 100838, 79816, 105446, 79812, 70594, 79810, 70636, 79852, 70630, 79846, 129960, 95728, 113404, 129956, 95480, 113278, 129954, 95356, 95294, 127784, 129430, 78588, 128872, 129974, 95996, 78462, 128868, 127778, 95870, 128866, 123432, 127254, 124520, 123428, 126696, 128886, 123426, 126692, 124514, 126690, 115816, 123446, 117992, 115812, 122344, 117988, 115810, 122340, 117986, 122338, 100584, 115830, 104936, 100580, 113640, 104932, 100578, 113636, 104930, 113634, 70120, 100598, 78824, 70116, 96232, 78820, 70114, 96228, 78818, 96226, 70134, 78838, 129940, 94968, 113022, 129938, 94844, 94782, 127764, 78206, 128820, 127762, 95102, 128818, 123412, 124468, 123410, 126580, 124466, 126578, 115764, 117876, 115762, 122100, 117874, 122098, 100468, 104692, 100466, 113140, 104690, 113138, 69876, 78324, 69874, 95220, 78322, 95218, 129930, 94588, 94526, 127754, 128794, 123402, 124442, 126522, 115738, 117818, 121978, 100410, 104570, 112890, 69754, 78074, 94714, 94398, 123216, 127148, 123208, 127142, 123204, 123202, 115408, 123244, 115400, 123238, 115396, 115394, 99792, 115436, 99784, 115430, 99780, 99778, 68560, 99820, 68552, 99814, 68548, 68546, 68588, 68582, 127400, 129238, 72444, 127396, 72318, 127394, 123176, 127126, 123752, 123172, 123748, 123170, 123746, 115304, 123190, 116456, 115300, 116452, 115298, 116450, 99560, 115318, 101864, 99556, 101860, 99554, 101858, 68072, 99574, 72680, 68068, 72676, 68066, 72674, 68086, 72694, 129492, 80632, 105854, 129490, 80508, 80446, 127380, 72062, 127924, 127378, 80766, 127922, 123156, 123700, 123154, 124788, 123698, 124786, 115252, 116340, 115250, 118516, 116338, 118514, 99444, 101620, 99442, 105972, 101618, 105970, 67828, 72180, 67826, 80884, 72178, 80882, 97008, 114044, 96888, 113982, 96828, 96798, 129482, 80252, 130010, 97148, 80190, 97086, 127370, 127898, 128954, 123146, 123674, 124730, 126842, 115226, 116282, 118394, 122618, 99386, 101498, 105722, 114170, 67706, 71930, 80378, 96632, 113854, 96572, 96542, 80062, 96702, 96444, 96414, 96350, 123048, 123044, 123042, 115048, 123062, 115044, 115042, 99048, 115062, 99044, 99042, 67048, 99062, 67044, 67042, 67062, 127188, 68990, 127186, 123028, 123316, 123026, 123314, 114996, 115572, 114994, 115570, 98932, 100084, 98930, 100082, 66804, 69108, 66802, 69106, 129258, 73084, 73022, 127178, 127450, 123018, 123290, 123834, 114970, 115514, 116602, 98874, 99962, 102138, 66682, 68858, 73210, 81272, 106174, 81212, 81182, 72894, 81342, 97648, 114364, 97592, 114334, 97564, 97550, 81084, 97724, 81054, 97694, 97464, 114270, 97436, 97422, 80990, 97502, 97372, 97358, 97326, 114868, 114866, 98676, 98674, 66292, 66290, 123098, 114842, 115130, 98618, 99194, 66170, 67322, 69310, 73404, 73374, 81592, 106334, 81564, 81550, 73310, 81630, 97968, 114524, 97944, 114510, 97932, 97926, 81500, 98012, 81486, 97998, 97880, 114478, 97868, 97862, 81454, 97902, 97836, 97830, 69470, 73564, 73550, 81752, 106414, 81740, 81734, 73518, 81774, 81708, 81702]), $a([109536, 120312, 86976, 109040, 120060, 86496, 108792, 119934, 86256, 108668, 86136, 129744, 89056, 110072, 129736, 88560, 109820, 129732, 88312, 109694, 129730, 88188, 128464, 129772, 89592, 128456, 129766, 89340, 128452, 89214, 128450, 125904, 128492, 125896, 128486, 125892, 125890, 120784, 125932, 120776, 125926, 120772, 120770, 110544, 120812, 110536, 120806, 110532, 84928, 108016, 119548, 84448, 107768, 119422, 84208, 107644, 84088, 107582, 84028, 129640, 85488, 108284, 129636, 85240, 108158, 129634, 85116, 85054, 128232, 129654, 85756, 128228, 85630, 128226, 125416, 128246, 125412, 125410, 119784, 125430, 119780, 119778, 108520, 119798, 108516, 108514, 83424, 107256, 119166, 83184, 107132, 83064, 107070, 83004, 82974, 129588, 83704, 107390, 129586, 83580, 83518, 128116, 83838, 128114, 125172, 125170, 119284, 119282, 107508, 107506, 82672, 106876, 82552, 106814, 82492, 82462, 129562, 82812, 82750, 128058, 125050, 119034, 82296, 106686, 82236, 82206, 82366, 82108, 82078, 76736, 103920, 117500, 76256, 103672, 117374, 76016, 103548, 75896, 103486, 75836, 129384, 77296, 104188, 129380, 77048, 104062, 129378, 76924, 76862, 127720, 129398, 77564, 127716, 77438, 127714, 124392, 127734, 124388, 124386, 117736, 124406, 117732, 117730, 104424, 117750, 104420, 104418, 112096, 121592, 126334, 92608, 111856, 121468, 92384, 111736, 121406, 92272, 111676, 92216, 111646, 92188, 75232, 103160, 117118, 93664, 74992, 103036, 93424, 112252, 102974, 93304, 74812, 93244, 74782, 93214, 129332, 75512, 103294, 129908, 129330, 93944, 75388, 129906, 93820, 75326, 93758, 127604, 75646, 128756, 127602, 94078, 128754, 124148, 126452, 124146, 126450, 117236, 121844, 117234, 121842, 103412, 103410, 91584, 111344, 121212, 91360, 111224, 121150, 91248, 111164, 91192, 111134, 91164, 91150, 74480, 102780, 91888, 74360, 102718, 91768, 111422, 91708, 74270, 91678, 129306, 74620, 129850, 92028, 74558, 91966, 127546, 128634, 124026, 126202, 116986, 121338, 102906, 90848, 110968, 121022, 90736, 110908, 90680, 110878, 90652, 90638, 74104, 102590, 91e3, 74044, 90940, 74014, 90910, 74174, 91070, 90480, 110780, 90424, 110750, 90396, 90382, 73916, 90556, 73886, 90526, 90296, 110686, 90268, 90254, 73822, 90334, 90204, 90190, 71136, 101112, 116094, 70896, 100988, 70776, 100926, 70716, 70686, 129204, 71416, 101246, 129202, 71292, 71230, 127348, 71550, 127346, 123636, 123634, 116212, 116210, 101364, 101362, 79296, 105200, 118140, 79072, 105080, 118078, 78960, 105020, 78904, 104990, 78876, 78862, 70384, 100732, 79600, 70264, 100670, 79480, 105278, 79420, 70174, 79390, 129178, 70524, 129466, 79740, 70462, 79678, 127290, 127866, 123514, 124666, 115962, 118266, 100858, 113376, 122232, 126654, 95424, 113264, 122172, 95328, 113208, 122142, 95280, 113180, 95256, 113166, 95244, 78560, 104824, 117950, 95968, 78448, 104764, 95856, 113468, 104734, 95800, 78364, 95772, 78350, 95758, 70008, 100542, 78712, 69948, 96120, 78652, 69918, 96060, 78622, 96030, 70078, 78782, 96190, 94912, 113008, 122044, 94816, 112952, 122014, 94768, 112924, 94744, 112910, 94732, 94726, 78192, 104636, 95088, 78136, 104606, 95032, 113054, 95004, 78094, 94990, 69820, 78268, 69790, 95164, 78238, 95134, 94560, 112824, 121950, 94512, 112796, 94488, 112782, 94476, 94470, 78008, 104542, 94648, 77980, 94620, 77966, 94606, 69726, 78046, 94686, 94384, 112732, 94360, 112718, 94348, 94342, 77916, 94428, 77902, 94414, 94296, 112686, 94284, 94278, 77870, 94318, 94252, 94246, 68336, 99708, 68216, 99646, 68156, 68126, 68476, 68414, 127162, 123258, 115450, 99834, 72416, 101752, 116414, 72304, 101692, 72248, 101662, 72220, 72206, 67960, 99518, 72568, 67900, 72508, 67870, 72478, 68030, 72638, 80576, 105840, 118460, 80480, 105784, 118430, 80432, 105756, 80408, 105742, 80396, 80390, 72048, 101564, 80752, 71992, 101534, 80696, 71964, 80668, 71950, 80654, 67772, 72124, 67742, 80828, 72094, 80798, 114016, 122552, 126814, 96832, 113968, 122524, 96800, 113944, 122510, 96784, 113932, 96776, 113926, 96772, 80224, 105656, 118366, 97120, 80176, 105628, 97072, 114076, 105614, 97048, 80140, 97036, 80134, 97030, 71864, 101470, 80312, 71836, 97208, 80284, 71822, 97180, 80270, 97166, 67678, 71902, 80350, 97246, 96576, 113840, 122460, 96544, 113816, 122446, 96528, 113804, 96520, 113798, 96516, 96514, 80048, 105564, 96688, 80024, 105550, 96664, 113870, 96652, 80006, 96646, 71772, 80092, 71758, 96732, 80078, 96718, 96416, 113752, 122414, 96400, 113740, 96392, 113734, 96388, 96386, 79960, 105518, 96472, 79948, 96460, 79942, 96454, 71726, 79982, 96494, 96336, 113708, 96328, 113702, 96324, 96322, 79916, 96364, 79910, 96358, 96296, 113686, 96292, 96290, 79894, 96310, 66936, 99006, 66876, 66846, 67006, 68976, 100028, 68920, 99998, 68892, 68878, 66748, 69052, 66718, 69022, 73056, 102072, 116574, 73008, 102044, 72984, 102030, 72972, 72966, 68792, 99934, 73144, 68764, 73116, 68750, 73102, 66654, 68830, 73182, 81216, 106160, 118620, 81184, 106136, 118606, 81168, 106124, 81160, 106118, 81156, 81154, 72880, 101980, 81328, 72856, 101966, 81304, 106190, 81292, 72838, 81286, 68700, 72924, 68686, 81372, 72910, 81358, 114336, 122712, 126894, 114320, 122700, 114312, 122694, 114308, 114306, 81056, 106072, 118574, 97696, 81040, 106060, 97680, 114380, 106054, 97672, 81028, 97668, 81026, 97666, 72792, 101934, 81112, 72780, 97752, 81100, 72774, 97740, 81094, 97734, 68654, 72814, 81134, 97774, 114256, 122668, 114248, 122662, 114244, 114242, 80976, 106028, 97488, 80968, 106022, 97480, 114278, 97476, 80962, 97474, 72748, 81004, 72742, 97516, 80998, 97510, 114216, 122646, 114212, 114210, 80936, 106006, 97384, 80932, 97380, 80930, 97378, 72726, 80950, 97398, 114196, 114194, 80916, 97332, 80914, 97330, 66236, 66206, 67256, 99166, 67228, 67214, 66142, 67294, 69296, 100188, 69272, 100174, 69260, 69254, 67164, 69340, 67150, 69326, 73376, 102232, 116654, 73360, 102220, 73352, 102214, 73348, 73346, 69208, 100142, 73432, 102254, 73420, 69190, 73414, 67118, 69230, 73454, 106320, 118700, 106312, 118694, 106308, 106306, 73296, 102188, 81616, 106348, 102182, 81608, 73284, 81604, 73282, 81602, 69164, 73324, 69158, 81644, 73318, 81638, 122792, 126934, 122788, 122786, 106280, 118678, 114536, 106276, 114532, 106274, 114530, 73256, 102166, 81512, 73252, 98024, 81508, 73250, 98020, 81506, 98018, 69142, 73270, 81526, 98038, 122772, 122770, 106260, 114484, 106258, 114482, 73236, 81460, 73234, 97908, 81458, 97906, 122762, 106250, 114458, 73226, 81434, 97850, 66396, 66382, 67416, 99246, 67404, 67398, 66350, 67438, 69456, 100268, 69448, 100262, 69444, 69442, 67372, 69484, 67366, 69478, 102312, 116694, 102308, 102306, 69416, 100246, 73576, 102326, 73572, 69410, 73570, 67350, 69430, 73590, 118740, 118738, 102292, 106420, 102290, 106418, 69396, 73524, 69394, 81780, 73522, 81778, 118730, 102282, 106394, 69386, 73498, 81722, 66476, 66470, 67496, 99286, 67492, 67490, 66454, 67510, 100308, 100306, 67476, 69556, 67474, 69554, 116714])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_pdf417.$ctx[id] = $ctx[id]);
        bwipp_pdf417.__17153__ = 1;
      })();
    }
    $1.cwtobits = function() {
      var _Gd = $get($1.clusters, $k[--$j]);
      $1.v = $get(_Gd, $k[--$j]);
      $k[$j++] = Infinity;
      for (var _Gg = 0, _Gh = 17; _Gg < _Gh; _Gg++) {
        $k[$j++] = 0;
      }
      var _Gk = $cvrs($s(17), $1.v, 2);
      for (var _Gl = 0, _Gm = _Gk.length; _Gl < _Gm; _Gl++) {
        $k[$j++] = $get(_Gk, _Gl) - 48;
      }
      var _Go = $a();
      $k[$j++] = $geti(_Go, _Go.length - 17, 17);
    };
    if ($1.compact) {
      $1.rwid = $f($f($f(17 * $1.c + 17) + 17) + 1);
    } else {
      $1.rwid = $f($f($f($f(17 * $1.c + 17) + 17) + 17) + 18);
    }
    $1.pixs = $a($1.rwid * $1.r);
    for (var _Gy = 0, _Gx = $1.r - 1; _Gy <= _Gx; _Gy += 1) {
      $1.i = _Gy;
      if ($1.i % 3 == 0) {
        $1.lcw = ~~($1.i / 3) * 30 + ~~(($1.r - 1) / 3);
        $1.rcw = $f($f(~~($1.i / 3) * 30 + $1.c) - 1);
      }
      if ($1.i % 3 == 1) {
        $1.lcw = ~~($1.i / 3) * 30 + $1.eclevel * 3 + ($1.r - 1) % 3;
        $1.rcw = ~~($1.i / 3) * 30 + ~~(($1.r - 1) / 3);
      }
      if ($1.i % 3 == 2) {
        $1.lcw = $f($f(~~($1.i / 3) * 30 + $1.c) - 1);
        $1.rcw = ~~($1.i / 3) * 30 + $1.eclevel * 3 + ($1.r - 1) % 3;
      }
      $k[$j++] = $1.pixs;
      $k[$j++] = $1.rwid * $1.i;
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = $1.lcw;
      $k[$j++] = $1.i % 3;
      $1.cwtobits();
      $forall($k[--$j]);
      var _HQ = $geti($1.cws, $1.c * $1.i, $1.c);
      for (var _HR = 0, _HS = _HQ.length; _HR < _HS; _HR++) {
        $k[$j++] = $get(_HQ, _HR);
        $k[$j++] = $1.i % 3;
        $1.cwtobits();
        $forall($k[--$j]);
      }
      if ($1.compact) {
        $k[$j++] = 1;
      } else {
        $k[$j++] = $1.rcw;
        $k[$j++] = $1.i % 3;
        $1.cwtobits();
        $forall($k[--$j]);
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 1;
      }
      var _Ha = $a();
      var _Hb = $k[--$j];
      $puti($k[--$j], _Hb, _Ha);
    }
    var _Hk = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.rwid],
      ["pixy", $1.r],
      ["height", $1.r / 72 * $1.rowmult],
      ["width", $1.rwid / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _Hk;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_pdf417compact() {
    var $1 = Object.create(bwipp_pdf417compact.$ctx || (bwipp_pdf417compact.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "compact", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_pdf417();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_micropdf417() {
    var $1 = Object.create(bwipp_micropdf417.$ctx || (bwipp_micropdf417.$ctx = {}));
    $1.dontdraw = false;
    $1.version = "unset";
    $1.columns = 0;
    $1.rows = 0;
    $1.rowmult = 2;
    $1.cca = false;
    $1.ccb = false;
    $1.raw = false;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.barcode, "")) {
      $k[$j++] = "bwipp.micropdf417emptyData#17312";
      $k[$j++] = "The data must not be empty";
      bwipp_raiseerror();
    }
    if ($1.rowmult <= 0) {
      $k[$j++] = "bwipp.micropdf417badRowMult#17316";
      $k[$j++] = "The row multiplier must be greater than zero";
      bwipp_raiseerror();
    }
    if ($1.cca && $1.ccb || ($1.cca && $1.raw || $1.ccb && $1.raw)) {
      $k[$j++] = "bwipp.micropdf417ccaAndCcb#17320";
      $k[$j++] = "Cannot combine cca, ccb and raw";
      bwipp_raiseerror();
    }
    if ($ne($1.version, "unset")) {
      $search($1.version, "x");
      if ($k[--$j]) {
        var _D = $k[--$j];
        var _E = $k[--$j];
        $k[$j++] = _D;
        $k[$j++] = _E;
        $j--;
        var _F = $k[--$j];
        var _G = $k[--$j];
        $k[$j++] = _G;
        $k[$j++] = _F;
        $k[$j++] = _G;
        $k[$j++] = _F;
        $astore($a(2));
        $forall($k[--$j], function() {
          var _J = $k[--$j];
          $k[$j++] = _J;
          $k[$j++] = true;
          if (_J.length == 0) {
            $j--;
            $k[$j++] = false;
          }
          var _K = $k[--$j];
          var _L = $k[--$j];
          $k[$j++] = _K;
          $forall(_L, function() {
            var _M = $k[--$j];
            if (_M < 48 || _M > 57) {
              $j--;
              $k[$j++] = false;
            }
          });
          if ($nt($k[--$j])) {
            $k[$j++] = "bwipp.micropdf417BadVersionBadRowOrColumn#17334";
            $k[$j++] = "version must be formatted as RxC";
            bwipp_raiseerror();
          }
        });
        $1.rows = $cvi($k[--$j]);
        $1.columns = $cvi($k[--$j]);
      } else {
        $j--;
        $k[$j++] = "bwipp.micropdf417badVersionFormat#17340";
        $k[$j++] = "version must be formatted as RxC";
        bwipp_raiseerror();
      }
    }
    if (!bwipp_micropdf417.__17431__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.T = 0;
        $ctx.N = 1;
        $ctx.B = 2;
        $ctx.A = 0;
        $ctx.L = 1;
        $ctx.M = 2;
        $ctx.P = 3;
        $ctx.tl = -1;
        $ctx.nl = -2;
        $ctx.bl = -3;
        $ctx.bl6 = -4;
        $ctx.bs = -5;
        $ctx.al = -6;
        $ctx.ll = -7;
        $ctx.ml = -8;
        $ctx.pl = -9;
        $ctx.as = -10;
        $ctx.ps = -11;
        $ctx.charmaps = $a([$a(["A", "a", "0", ";"]), $a(["B", "b", "1", "<"]), $a(["C", "c", "2", ">"]), $a(["D", "d", "3", "@"]), $a(["E", "e", "4", "["]), $a(["F", "f", "5", 92]), $a(["G", "g", "6", "]"]), $a(["H", "h", "7", "_"]), $a(["I", "i", "8", "`"]), $a(["J", "j", "9", "~"]), $a(["K", "k", "&", "!"]), $a(["L", "l", 13, 13]), $a(["M", "m", 9, 9]), $a(["N", "n", ",", ","]), $a(["O", "o", ":", ":"]), $a(["P", "p", "#", 10]), $a(["Q", "q", "-", "-"]), $a(["R", "r", ".", "."]), $a(["S", "s", "$", "$"]), $a(["T", "t", "/", "/"]), $a(["U", "u", "+", '"']), $a(["V", "v", "%", "|"]), $a(["W", "w", "*", "*"]), $a(["X", "x", "=", 40]), $a(["Y", "y", "^", 41]), $a(["Z", "z", $ctx.pl, "?"]), $a([" ", " ", " ", "{"]), $a([$ctx.ll, $ctx.as, $ctx.ll, "}"]), $a([$ctx.ml, $ctx.ml, $ctx.al, "'"]), $a([$ctx.ps, $ctx.ps, $ctx.ps, $ctx.al])]);
        $ctx.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
        $ctx.alltext = /* @__PURE__ */ new Map();
        for (var _19 = 0, _18 = $ctx.charmaps.length - 1; _19 <= _18; _19 += 1) {
          $ctx.i = _19;
          $ctx.encs = $get($ctx.charmaps, $ctx.i);
          for (var _1D = 0; _1D <= 3; _1D += 1) {
            $ctx.j = _1D;
            var _1G = $get($ctx.encs, $ctx.j);
            $k[$j++] = _1G;
            if ($eq($type(_1G), "stringtype")) {
              var _1J = $get($k[--$j], 0);
              $k[$j++] = _1J;
            }
            var _1K = $k[--$j];
            $put($get($ctx.charvals, $ctx.j), _1K, $ctx.i);
            $put($ctx.alltext, _1K, -1);
          }
        }
        $ctx.e = 1e4;
        $ctx.latlen = $a([$a([0, 1, 1, 2]), $a([2, 0, 1, 2]), $a([1, 1, 0, 1]), $a([1, 2, 2, 0])]);
        $ctx.latseq = $a([$a([$a([]), $a([$ctx.ll]), $a([$ctx.ml]), $a([$ctx.ml, $ctx.pl])]), $a([$a([$ctx.ml, $ctx.al]), $a([]), $a([$ctx.ml]), $a([$ctx.ml, $ctx.pl])]), $a([$a([$ctx.al]), $a([$ctx.ll]), $a([]), $a([$ctx.pl])]), $a([$a([$ctx.al]), $a([$ctx.al, $ctx.ll]), $a([$ctx.al, $ctx.ml]), $a([])])]);
        $ctx.shftlen = $a([$a([$ctx.e, $ctx.e, $ctx.e, 1]), $a([1, $ctx.e, $ctx.e, 1]), $a([$ctx.e, $ctx.e, $ctx.e, 1]), $a([$ctx.e, $ctx.e, $ctx.e, $ctx.e])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_micropdf417.$ctx[id] = $ctx[id]);
        bwipp_micropdf417.__17431__ = 1;
      })();
    }
    if ($1.raw || $1.cca) {
      $1.datcws = $a($1.barcode.length);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i >= $1.barcode.length - 3) {
          break;
        }
        if ($get($1.barcode, $1.i) != 94) {
          break;
        }
        var _2a = $geti($1.barcode, $1.i + 1, 3);
        $k[$j++] = _2a;
        $k[$j++] = false;
        for (var _2b = 0, _2c = _2a.length; _2b < _2c; _2b++) {
          var _2d = $get(_2a, _2b);
          if (_2d < 48 || _2d > 57) {
            $j--;
            $k[$j++] = true;
          }
        }
        if ($k[--$j]) {
          $j--;
          break;
        }
        $1.cw = $cvi($k[--$j]);
        $put($1.datcws, $1.j, $1.cw);
        $1.i = $1.i + 4;
        $1.j = $1.j + 1;
      }
      if ($1.i != $1.barcode.length) {
        $k[$j++] = "bwipp.micropdf417badCcaRawFormat#17449";
        $k[$j++] = "cca and raw data must be formatted as ^NNN";
        bwipp_raiseerror();
      }
      $1.datcws = $geti($1.datcws, 0, $1.j);
    }
    $1.encb = function() {
      $1.in = $k[--$j];
      $1.inlen = $1.in.length;
      $1.out = $a(~~($1.inlen / 6) * 5 + $1.inlen % 6);
      for (var _2x = 0, _2w = ~~($1.inlen / 6) - 1; _2x <= _2w; _2x += 1) {
        $1.k = _2x;
        $k[$j++] = Infinity;
        $aload($geti($1.in, $1.k * 6, 3));
        $1.msbs = $a();
        $k[$j++] = Infinity;
        $aload($1.msbs);
        var _33 = $k[--$j];
        var _34 = $k[--$j];
        var _35 = $k[--$j];
        $k[$j++] = $f($f(_33 + _34 * 256) + _35 * 65536);
        for (var _36 = 0, _37 = 3; _36 < _37; _36++) {
          var _38 = $k[--$j];
          $k[$j++] = _38 % 900;
          $k[$j++] = ~~(_38 / 900);
        }
        $1.mscs = $a();
        $k[$j++] = Infinity;
        $aload($geti($1.in, $1.k * 6 + 3, 3));
        $1.lsbs = $a();
        $k[$j++] = Infinity;
        $aload($1.lsbs);
        var _3F = $k[--$j];
        var _3G = $k[--$j];
        var _3H = $k[--$j];
        $k[$j++] = $f($f(_3F + _3G * 256) + _3H * 65536);
        for (var _3I = 0, _3J = 3; _3I < _3J; _3I++) {
          var _3K = $k[--$j];
          $k[$j++] = _3K % 900;
          $k[$j++] = ~~(_3K / 900);
        }
        $1.lscs = $a();
        var _3N = $get($1.lscs, 0);
        var _3P = $get($1.mscs, 0);
        $put($1.out, $1.k * 5 + 4, $f(_3N + _3P * 316) % 900);
        var _3T = $get($1.lscs, 1);
        var _3V = $get($1.mscs, 0);
        var _3X = $get($1.mscs, 1);
        $put($1.out, $1.k * 5 + 3, $f($f($f(~~($f(_3N + _3P * 316) / 900) + _3T) + _3V * 641) + _3X * 316) % 900);
        var _3b = $get($1.lscs, 2);
        var _3d = $get($1.mscs, 0);
        var _3f = $get($1.mscs, 1);
        var _3h = $get($1.mscs, 2);
        $put($1.out, $1.k * 5 + 2, $f($f($f($f(~~($f($f($f(~~($f(_3N + _3P * 316) / 900) + _3T) + _3V * 641) + _3X * 316) / 900) + _3b) + _3d * 20) + _3f * 641) + _3h * 316) % 900);
        var _3l = $get($1.lscs, 3);
        var _3n = $get($1.mscs, 1);
        var _3p = $get($1.mscs, 2);
        $put($1.out, $1.k * 5 + 1, $f($f($f(~~($f($f($f($f(~~($f($f($f(~~($f(_3N + _3P * 316) / 900) + _3T) + _3V * 641) + _3X * 316) / 900) + _3b) + _3d * 20) + _3f * 641) + _3h * 316) / 900) + _3l) + _3n * 20) + _3p * 641) % 900);
        $put($1.out, $1.k * 5, $f(~~($f($f($f(~~($f($f($f($f(~~($f($f($f(~~($f(_3N + _3P * 316) / 900) + _3T) + _3V * 641) + _3X * 316) / 900) + _3b) + _3d * 20) + _3f * 641) + _3h * 316) / 900) + _3l) + _3n * 20) + _3p * 641) / 900) + $get($1.mscs, 2) * 20) % 900);
      }
      $1.rem = $1.inlen % 6;
      if ($1.rem != 0) {
        $k[$j++] = $1.out;
        $k[$j++] = $1.out.length - $1.rem;
        $k[$j++] = Infinity;
        $aload($geti($1.in, $1.inlen - $1.rem, $1.rem));
        var _46 = $a();
        var _47 = $k[--$j];
        $puti($k[--$j], _47, _46);
      }
      $k[$j++] = $1.out;
    };
    if ($1.ccb) {
      $1.barlen = $1.barcode.length;
      $1.datcws = $a(~~($1.barlen / 6) * 5 + $1.barlen % 6 + 2);
      $put($1.datcws, 0, 920);
      var _4I = $1.barlen % 6 == 0 ? 924 : 901;
      $put($1.datcws, 1, _4I);
      $k[$j++] = $1.datcws;
      $k[$j++] = 2;
      $k[$j++] = Infinity;
      $forall($1.barcode);
      var _4L = $a();
      $k[$j++] = _4L;
      $1.encb();
      var _4M = $k[--$j];
      var _4N = $k[--$j];
      $puti($k[--$j], _4N, _4M);
    }
    if (!$1.raw && !$1.cca && !$1.ccb) {
      var _4U = /* @__PURE__ */ new Map([
        ["parse", $1.parse],
        ["parsefnc", $1.parsefnc],
        ["eci", true]
      ]);
      $1.fncvals = _4U;
      $k[$j++] = "msg";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.fncvals;
      bwipp_parseinput();
      var _4X = $k[--$j];
      $1[$k[--$j]] = _4X;
      $1.msglen = $1.msg.length;
      $k[$j++] = Infinity;
      for (var _4b = 0, _4c = $1.msglen; _4b < _4c; _4b++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numdigits = $a();
      $k[$j++] = Infinity;
      for (var _4f = 0, _4g = $1.msglen; _4f < _4g; _4f++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numtext = $a();
      $k[$j++] = Infinity;
      for (var _4j = 0, _4k = $1.msglen; _4j < _4k; _4j++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numbytes = $a();
      $k[$j++] = Infinity;
      for (var _4n = 0, _4o = $1.msglen; _4n < _4o; _4n++) {
        $k[$j++] = 0;
      }
      $1.iseci = $a();
      for (var _4r = $1.msglen - 1; _4r >= 0; _4r -= 1) {
        $1.i = _4r;
        var _4u = $get($1.msg, $1.i);
        if (_4u >= 48 && _4u <= 57) {
          $put($1.numdigits, $1.i, $f($get($1.numdigits, $1.i + 1) + 1));
        }
        var _54 = $get($1.alltext, $get($1.msg, $1.i)) !== void 0;
        if (_54 && $get($1.numdigits, $1.i) < 13) {
          $put($1.numtext, $1.i, $f($get($1.numtext, $1.i + 1) + 1));
        }
        if ($get($1.msg, $1.i) >= 0 && $get($1.numtext, $1.i) < 5 && $get($1.numdigits, $1.i) < 13) {
          $put($1.numbytes, $1.i, $f($get($1.numbytes, $1.i + 1) + 1));
        }
        $put($1.iseci, $1.i, $get($1.msg, $1.i) <= -1e6);
      }
      $1.numdigits = $geti($1.numdigits, 0, $1.msglen);
      $1.numtext = $geti($1.numtext, 0, $1.msglen);
      $1.numbytes = $geti($1.numbytes, 0, $1.msglen);
      $1.seq = $a([]);
      $1.seqlen = 0;
      $1.state = $1.B;
      $1.p = 0;
      for (; ; ) {
        if ($1.p == $1.msglen) {
          break;
        }
        if ($get($1.iseci, $1.p)) {
          $1.eci = $get($1.msg, $1.p);
          $k[$j++] = Infinity;
          $aload($1.seq);
          $k[$j++] = $a([$1.eci]);
          $1.seq = $a();
          $1.p = $1.p + 1;
          $k[$j++] = "seqlen";
          $k[$j++] = $1.seqlen;
          if ($1.eci <= -1810900) {
            $k[$j++] = 2;
          } else {
            var _5x = $1.eci <= -1000900 ? 3 : 2;
            $k[$j++] = _5x;
          }
          var _5y = $k[--$j];
          var _5z = $k[--$j];
          $1[$k[--$j]] = $f(_5z + _5y);
        } else {
          $1.n = $get($1.numdigits, $1.p);
          if ($1.n >= 13 || $1.n == $1.msglen && $1.n >= 8) {
            $k[$j++] = Infinity;
            $aload($1.seq);
            $k[$j++] = $1.nl;
            $k[$j++] = Infinity;
            $aload($geti($1.msg, $1.p, $1.n));
            var _6E = $a();
            $k[$j++] = _6E;
            $1.seq = $a();
            $1.state = $1.N;
            $1.p = $f($1.p + $1.n);
            $1.seqlen = $f($1.seqlen + 1 + $1.n);
          } else {
            $1.t = $get($1.numtext, $1.p);
            if ($1.t >= 5) {
              $k[$j++] = Infinity;
              $aload($1.seq);
              if ($1.state != $1.T) {
                $k[$j++] = $1.tl;
              }
              $k[$j++] = Infinity;
              $aload($geti($1.msg, $1.p, $1.t));
              var _6X = $a();
              $k[$j++] = _6X;
              $1.seq = $a();
              $1.state = $1.T;
              $1.p = $f($1.p + $1.t);
              $1.seqlen = $f($f($1.seqlen + 1) + $1.t);
            } else {
              $1.b = $get($1.numbytes, $1.p);
              if ($1.b == 1 && $1.state == $1.T) {
                $k[$j++] = Infinity;
                $aload($1.seq);
                $k[$j++] = $1.bs;
                $k[$j++] = $a([$get($1.msg, $1.p)]);
                $1.seq = $a();
                $1.p = $f($1.p + $1.b);
                $1.seqlen = $f($1.seqlen + 2);
              } else {
                $k[$j++] = Infinity;
                $aload($1.seq);
                var _6w = $1.b % 6 != 0 ? $1.bl : $1.bl6;
                $k[$j++] = _6w;
                $k[$j++] = Infinity;
                $aload($geti($1.msg, $1.p, $1.b));
                var _71 = $a();
                $k[$j++] = _71;
                $1.seq = $a();
                $1.state = $1.B;
                $1.p = $f($1.p + $1.b);
                $1.seqlen = $f($f($1.seqlen + 1) + $1.b);
              }
            }
          }
        }
      }
      $k[$j++] = Infinity;
      $k[$j++] = $1.tl;
      $k[$j++] = 900;
      $k[$j++] = $1.bl;
      $k[$j++] = 901;
      $k[$j++] = $1.bl6;
      $k[$j++] = 924;
      $k[$j++] = $1.nl;
      $k[$j++] = 902;
      $k[$j++] = $1.bs;
      $k[$j++] = 913;
      $1.latchcws = $d();
      $1.enca = function() {
        var _7I = $get($get($1.charvals, $1.A), $k[--$j]);
        $k[$j++] = _7I;
      };
      $1.encl = function() {
        var _7N = $get($get($1.charvals, $1.L), $k[--$j]);
        $k[$j++] = _7N;
      };
      $1.encm = function() {
        var _7S = $get($get($1.charvals, $1.M), $k[--$j]);
        $k[$j++] = _7S;
      };
      $1.encp = function() {
        var _7X = $get($get($1.charvals, $1.P), $k[--$j]);
        $k[$j++] = _7X;
      };
      $1.textencfuncs = $a(["enca", "encl", "encm", "encp"]);
      $1.addtotext = function() {
        $put($1.text, $1.l, $k[--$j]);
        $1.l = $1.l + 1;
      };
      $1.enct = function() {
        $1.in = $k[--$j];
        $1.curlen = $a([$1.e, $1.e, $1.e, $1.e]);
        $put($1.curlen, $1.submode, 0);
        $1.curseq = $a([$a([]), $a([]), $a([]), $a([])]);
        $forall($1.in, function() {
          $1.char = $k[--$j];
          for (; ; ) {
            $1.imp = false;
            var _7w = $a([$1.A, $1.L, $1.M, $1.P]);
            for (var _7x = 0, _7y = _7w.length; _7x < _7y; _7x++) {
              $1.x = $get(_7w, _7x);
              var _84 = $a([$1.A, $1.L, $1.M, $1.P]);
              for (var _85 = 0, _86 = _84.length; _85 < _86; _85++) {
                $1.y = $get(_84, _85);
                $1.cost = $f($get($1.curlen, $1.x) + $get($get($1.latlen, $1.x), $1.y));
                if ($1.cost < $get($1.curlen, $1.y)) {
                  $put($1.curlen, $1.y, $1.cost);
                  $k[$j++] = $1.curseq;
                  $k[$j++] = $1.y;
                  $k[$j++] = Infinity;
                  $aload($get($1.curseq, $1.x));
                  $aload($get($get($1.latseq, $1.x), $1.y));
                  var _8X = $a();
                  var _8Y = $k[--$j];
                  $put($k[--$j], _8Y, _8X);
                  $1.imp = true;
                }
              }
            }
            if (!$1.imp) {
              break;
            }
          }
          $1.nxtlen = $a([$1.e, $1.e, $1.e, $1.e]);
          $1.nxtseq = $a(4);
          var _8l = $a([$1.A, $1.L, $1.M, $1.P]);
          for (var _8m = 0, _8n = _8l.length; _8m < _8n; _8m++) {
            $1.x = $get(_8l, _8m);
            for (; ; ) {
              var _8t = $get($get($1.charvals, $1.x), $1.char) !== void 0;
              if (!_8t) {
                break;
              }
              $1.cost = $f($get($1.curlen, $1.x) + 1);
              if ($1.cost < $get($1.nxtlen, $1.x)) {
                $put($1.nxtlen, $1.x, $1.cost);
                $k[$j++] = $1.nxtseq;
                $k[$j++] = $1.x;
                $k[$j++] = Infinity;
                $aload($get($1.curseq, $1.x));
                $k[$j++] = $1.char;
                var _9A = $a();
                var _9B = $k[--$j];
                $put($k[--$j], _9B, _9A);
              }
              var _9H = $a([$1.A, $1.L, $1.M, $1.P]);
              for (var _9I = 0, _9J = _9H.length; _9I < _9J; _9I++) {
                $1.y = $get(_9H, _9I);
                if ($ne($1.x, $1.y)) {
                  $1.cost = $f($f($get($1.curlen, $1.y) + $get($get($1.shftlen, $1.y), $1.x)) + 1);
                  if ($1.cost < $get($1.nxtlen, $1.y)) {
                    $put($1.nxtlen, $1.y, $1.cost);
                    $k[$j++] = $1.nxtseq;
                    $k[$j++] = $1.y;
                    $k[$j++] = Infinity;
                    $aload($get($1.curseq, $1.y));
                    var _9j = $1.x == $1.A ? $1.as : $1.ps;
                    $k[$j++] = _9j;
                    $k[$j++] = $1.char;
                    var _9l = $a();
                    var _9m = $k[--$j];
                    $put($k[--$j], _9m, _9l);
                  }
                }
              }
              break;
            }
          }
          $1.curlen = $1.nxtlen;
          $1.curseq = $1.nxtseq;
        });
        $1.minseq = $1.e;
        var _9v = $a([$1.A, $1.L, $1.M, $1.P]);
        for (var _9w = 0, _9x = _9v.length; _9w < _9x; _9w++) {
          $1.k = $get(_9v, _9w);
          if ($get($1.curlen, $1.k) < $1.minseq) {
            $1.minseq = $get($1.curlen, $1.k);
            $1.txtseq = $get($1.curseq, $1.k);
          }
        }
        $1.text = $a($1.minseq);
        $1.k = 0;
        $1.l = 0;
        for (; ; ) {
          if ($1.k >= $1.txtseq.length) {
            break;
          }
          $1.char = $get($1.txtseq, $1.k);
          $k[$j++] = $1.char;
          if ($1[$get($1.textencfuncs, $1.submode)]() === true) {
            break;
          }
          $1.addtotext();
          $1.k = $1.k + 1;
          if ($1.char == $1.as || $1.char == $1.ps) {
            $k[$j++] = $get($1.txtseq, $1.k);
            if ($1.char == $1.as) {
              $1.enca();
            } else {
              $1.encp();
            }
            $1.addtotext();
            $1.k = $1.k + 1;
          }
          if ($1.char == $1.al) {
            $1.submode = $1.A;
          }
          if ($1.char == $1.ll) {
            $1.submode = $1.L;
          }
          if ($1.char == $1.ml) {
            $1.submode = $1.M;
          }
          if ($1.char == $1.pl) {
            $1.submode = $1.P;
          }
        }
        if ($1.text.length % 2 == 1) {
          if ($1.submode == $1.P) {
            $k[$j++] = "pad";
            $k[$j++] = $1.al;
            $1.encp();
            var _Am = $k[--$j];
            $1[$k[--$j]] = _Am;
            $1.submode = $1.A;
          } else {
            $1.nextecitext = false;
            for (var _As = $1.i + 1, _Ar = $1.seq.length - 1; _As <= _Ar; _As += 1) {
              $1.ti = _As;
              if ($ne($type($get($1.seq, $1.ti)), "arraytype")) {
                $1.nextecitext = false;
                break;
              }
              if ($get($get($1.seq, $1.ti), 0) > -1e6) {
                break;
              }
              $1.nextecitext = true;
            }
            if ($1.nextecitext) {
              if ($1.submode == $1.A) {
                var _BB = $get($get($1.charvals, $1.L), $get($get($1.seq, $1.ti), 0)) !== void 0;
                if (_BB) {
                  $k[$j++] = "pad";
                  $k[$j++] = $1.ll;
                  $1.enca();
                  var _BD = $k[--$j];
                  $1[$k[--$j]] = _BD;
                  $1.submode = $1.L;
                } else {
                  $k[$j++] = "pad";
                  $k[$j++] = $1.ml;
                  $1.enca();
                  var _BH = $k[--$j];
                  $1[$k[--$j]] = _BH;
                  $1.submode = $1.M;
                }
              } else {
                if ($1.submode == $1.M) {
                  var _BT = $get($get($1.charvals, $1.L), $get($get($1.seq, $1.ti), 0)) !== void 0;
                  if (_BT) {
                    $k[$j++] = "pad";
                    $k[$j++] = $1.ll;
                    $1.encm();
                    var _BV = $k[--$j];
                    $1[$k[--$j]] = _BV;
                    $1.submode = $1.L;
                  } else {
                    var _Bf = $get($get($1.charvals, $1.P), $get($get($1.seq, $1.ti), 0)) !== void 0;
                    if (_Bf) {
                      $k[$j++] = "pad";
                      $k[$j++] = $1.pl;
                      $1.encm();
                      var _Bh = $k[--$j];
                      $1[$k[--$j]] = _Bh;
                      $1.submode = $1.P;
                    } else {
                      $k[$j++] = "pad";
                      $k[$j++] = $1.al;
                      $1.encm();
                      var _Bl = $k[--$j];
                      $1[$k[--$j]] = _Bl;
                      $1.submode = $1.A;
                    }
                  }
                } else {
                  $k[$j++] = "pad";
                  $k[$j++] = $1.ml;
                  $1.encl();
                  var _Bp = $k[--$j];
                  $1[$k[--$j]] = _Bp;
                  $1.submode = $1.M;
                }
              }
            } else {
              $k[$j++] = "pad";
              $k[$j++] = $1.ps;
              if ($1[$get($1.textencfuncs, $1.submode)]() === true) {
                return true;
              }
              var _Bx = $k[--$j];
              $1[$k[--$j]] = _Bx;
            }
          }
          $k[$j++] = Infinity;
          $aload($1.text);
          $k[$j++] = $1.pad;
          $1.text = $a();
        }
        $1.out = $a(~~($1.text.length / 2));
        for (var _C6 = 0, _C5 = $1.out.length - 1; _C6 <= _C5; _C6 += 1) {
          $1.k = _C6;
          $put($1.out, $1.k, $f($get($1.text, $1.k * 2) * 30 + $get($1.text, $1.k * 2 + 1)));
        }
        $k[$j++] = $1.out;
      };
      $1.encn = function() {
        $1.in = $k[--$j];
        $1.out = $a([]);
        for (var _CK = 0, _CJ = $1.in.length - 1; _CK <= _CJ; _CK += 44) {
          $1.k = _CK;
          $k[$j++] = Infinity;
          var _CP = $1.in.length - $1.k;
          $k[$j++] = 1;
          $k[$j++] = $1.in;
          $k[$j++] = $1.k;
          $k[$j++] = _CP;
          if (_CP > 44) {
            $j--;
            $k[$j++] = 44;
          }
          var _CQ = $k[--$j];
          var _CR = $k[--$j];
          var _CT = $geti($k[--$j], _CR, _CQ);
          for (var _CU = 0, _CV = _CT.length; _CU < _CV; _CU++) {
            $k[$j++] = $f($get(_CT, _CU) - 48);
          }
          $1.gmod = $a();
          $1.cwn = $a([]);
          for (; ; ) {
            $1.dv = 900;
            $1.gmul = $a([]);
            $1.val = 0;
            for (; ; ) {
              if ($1.gmod.length == 0) {
                break;
              }
              $1.val = $f($1.val * 10 + $get($1.gmod, 0));
              $1.gmod = $geti($1.gmod, 1, $1.gmod.length - 1);
              if ($1.val < $1.dv) {
                if ($1.gmul.length != 0) {
                  $k[$j++] = Infinity;
                  $aload($1.gmul);
                  $k[$j++] = 0;
                  $1.gmul = $a();
                }
              } else {
                $k[$j++] = Infinity;
                $aload($1.gmul);
                $k[$j++] = ~~($1.val / $1.dv);
                $1.gmul = $a();
              }
              $1.val = $1.val % $1.dv;
            }
            $1.dv = $1.val;
            $k[$j++] = Infinity;
            $k[$j++] = $1.dv;
            $aload($1.cwn);
            $1.cwn = $a();
            $1.gmod = $1.gmul;
            if ($1.gmul.length == 0) {
              break;
            }
          }
          $k[$j++] = Infinity;
          $aload($1.out);
          $aload($1.cwn);
          $1.out = $a();
        }
        $k[$j++] = $1.out;
      };
      $1.ence = function() {
        var _D4 = $f(-$get($k[--$j], 0) - 1e6);
        $k[$j++] = _D4;
        if (_D4 <= 899) {
          var _D5 = $k[--$j];
          $k[$j++] = 927;
          $k[$j++] = _D5;
          $astore($a(2));
        } else {
          var _D7 = $k[--$j];
          $k[$j++] = _D7;
          if (_D7 <= 810899) {
            var _D8 = $k[--$j];
            $k[$j++] = 926;
            $k[$j++] = ~~(_D8 / 900) - 1;
            $k[$j++] = _D8 % 900;
            $astore($a(3));
          } else {
            var _DA = $k[--$j];
            $k[$j++] = _DA;
            if (_DA <= 811799) {
              var _DB = $k[--$j];
              $k[$j++] = 925;
              $k[$j++] = $f(_DB - 810900);
              $astore($a(2));
            } else {
              $k[$j++] = "bwipp.pdf417badECI#17816";
              $k[$j++] = "PDF417 supports ECIs 000000 to 811799";
              bwipp_raiseerror();
            }
          }
        }
      };
      $1.encfuncs = $a(["enct", "encn", "encb"]);
      $1.addtocws = function() {
        var _DE = $k[--$j];
        $puti($1.datcws, $1.j, _DE);
        $1.j = _DE.length + $1.j;
      };
      $1.datcws = $a($1.seqlen);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i >= $1.seq.length) {
          break;
        }
        $1.chars = $get($1.seq, $1.i);
        if ($eq($type($1.chars), "arraytype")) {
          if ($get($1.chars, 0) <= -1e6) {
            $k[$j++] = $1.chars;
            $1.ence();
            $1.addtocws();
          } else {
            $k[$j++] = $1.chars;
            if ($1[$get($1.encfuncs, $1.state)]() === true) {
              break;
            }
            $1.addtocws();
          }
        } else {
          $k[$j++] = $a([$get($1.latchcws, $1.chars)]);
          $1.addtocws();
          if ($1.chars == $1.tl) {
            $1.state = $1.T;
            $1.submode = $1.A;
          }
          if ($1.chars == $1.nl) {
            $1.state = $1.N;
          }
          if ($1.chars == $1.bl || $1.chars == $1.bl6) {
            $1.state = $1.B;
          }
          if ($1.chars == $1.bs) {
            $1.i = $1.i + 1;
            $k[$j++] = $get($1.seq, $1.i);
            $1.encb();
            $1.addtocws();
          }
        }
        $1.i = $1.i + 1;
      }
      $1.datcws = $geti($1.datcws, 0, $1.j);
    }
    if (!bwipp_micropdf417.__17915__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.ccametrics = $a([$a([2, 5, 4, 39, 0, 19]), $a([2, 6, 4, 1, 0, 33]), $a([2, 7, 5, 32, 0, 12]), $a([2, 8, 5, 8, 0, 40]), $a([2, 9, 6, 14, 0, 46]), $a([2, 10, 6, 43, 0, 23]), $a([2, 12, 7, 20, 0, 52]), $a([3, 4, 4, 11, 43, 23]), $a([3, 5, 5, 1, 33, 13]), $a([3, 6, 6, 5, 37, 17]), $a([3, 7, 7, 15, 47, 27]), $a([3, 8, 7, 21, 1, 33]), $a([4, 3, 4, 40, 20, 52]), $a([4, 4, 5, 43, 23, 3]), $a([4, 5, 6, 46, 26, 6]), $a([4, 6, 7, 34, 14, 46]), $a([4, 7, 8, 29, 9, 41])]);
        $ctx.nonccametrics = $a([$a([1, 11, 7, 1, 0, 9]), $a([1, 14, 7, 8, 0, 8]), $a([1, 17, 7, 36, 0, 36]), $a([1, 20, 8, 19, 0, 19]), $a([1, 24, 8, 9, 0, 17]), $a([1, 28, 8, 25, 0, 33]), $a([2, 8, 8, 1, 0, 1]), $a([2, 11, 9, 1, 0, 9]), $a([2, 14, 9, 8, 0, 8]), $a([2, 17, 10, 36, 0, 36]), $a([2, 20, 11, 19, 0, 19]), $a([2, 23, 13, 9, 0, 17]), $a([2, 26, 15, 27, 0, 35]), $a([3, 6, 12, 1, 1, 1]), $a([3, 8, 14, 7, 7, 7]), $a([3, 10, 16, 15, 15, 15]), $a([3, 12, 18, 25, 25, 25]), $a([3, 15, 21, 37, 37, 37]), $a([3, 20, 26, 1, 17, 33]), $a([3, 26, 32, 1, 9, 17]), $a([3, 32, 38, 21, 29, 37]), $a([3, 38, 44, 15, 31, 47]), $a([3, 44, 50, 1, 25, 49]), $a([4, 4, 8, 47, 19, 43]), $a([4, 6, 12, 1, 1, 1]), $a([4, 8, 14, 7, 7, 7]), $a([4, 10, 16, 15, 15, 15]), $a([4, 12, 18, 25, 25, 25]), $a([4, 15, 21, 37, 37, 37]), $a([4, 20, 26, 1, 17, 33]), $a([4, 26, 32, 1, 9, 17]), $a([4, 32, 38, 21, 29, 37]), $a([4, 38, 44, 15, 31, 47]), $a([4, 44, 50, 1, 25, 49])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_micropdf417.$ctx[id] = $ctx[id]);
        bwipp_micropdf417.__17915__ = 1;
      })();
    }
    $k[$j++] = "metrics";
    if ($1.cca) {
      $k[$j++] = $1.ccametrics;
    } else {
      $k[$j++] = $1.nonccametrics;
    }
    var _Eu = $k[--$j];
    $1[$k[--$j]] = _Eu;
    $1.urows = $1.rows;
    $1.ucols = $1.columns;
    $forall($1.metrics, function() {
      $1.m = $k[--$j];
      $1.c = $get($1.m, 0);
      $1.r = $get($1.m, 1);
      $1.k = $get($1.m, 2);
      $1.rapl = $get($1.m, 3);
      $1.rapc = $get($1.m, 4);
      $1.rapr = $get($1.m, 5);
      $1.ncws = $f($1.r * $1.c - $1.k);
      $1.okay = true;
      if ($1.datcws.length > $1.ncws) {
        $1.okay = false;
      }
      if ($1.urows != 0 && $1.urows != $1.r) {
        $1.okay = false;
      }
      if ($1.ucols != 0 && $1.ucols != $1.c) {
        $1.okay = false;
      }
      if ($1.okay) {
        return true;
      }
    });
    if (!$1.okay) {
      $k[$j++] = "bwipp.micropdf417noValidSymbol#17939";
      $k[$j++] = "Maximum length exceeded or invalid size";
      bwipp_raiseerror();
    }
    $1.m = $1.datcws.length;
    $1.n = $f($1.c * $1.r - $1.k);
    $1.cws = $a($f($1.c * $1.r + 1));
    $puti($1.cws, 0, $1.datcws);
    $k[$j++] = $1.cws;
    $k[$j++] = $1.m;
    $k[$j++] = Infinity;
    for (var _Fc = 0, _Fd = $f($1.n - $1.m); _Fc < _Fd; _Fc++) {
      $k[$j++] = 900;
    }
    var _Fe = $a();
    var _Ff = $k[--$j];
    $puti($k[--$j], _Ff, _Fe);
    $k[$j++] = $1.cws;
    $k[$j++] = $1.n;
    $k[$j++] = Infinity;
    for (var _Fk = 0, _Fl = $1.k; _Fk < _Fl; _Fk++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    var _Fm = $a();
    var _Fn = $k[--$j];
    $puti($k[--$j], _Fn, _Fm);
    if (!bwipp_micropdf417.__17955__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        $k[$j++] = 1;
        for (var _Fp = 0, _Fq = 928; _Fp < _Fq; _Fp++) {
          var _Fr = $k[--$j];
          $k[$j++] = _Fr;
          $k[$j++] = _Fr * 3 % 929;
        }
        $ctx.rsalog = $a();
        $ctx.rslog = $a(929);
        for (var _Fu = 1; _Fu <= 928; _Fu += 1) {
          $put($ctx.rslog, $get($ctx.rsalog, _Fu), _Fu);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_micropdf417.$ctx[id] = $ctx[id]);
        bwipp_micropdf417.__17955__ = 1;
      })();
    }
    $1.rsprod = function() {
      var _Fz = $k[--$j];
      var _G0 = $k[--$j];
      $k[$j++] = _G0;
      $k[$j++] = _Fz;
      if (_Fz != 0 && _G0 != 0) {
        var _G3 = $get($1.rslog, $k[--$j]);
        var _G8 = $get($1.rsalog, $f(_G3 + $get($1.rslog, $k[--$j])) % 928);
        $k[$j++] = _G8;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _GA = 0, _GB = $1.k; _GA < _GB; _GA++) {
      $k[$j++] = 0;
    }
    $1.coeffs = $a();
    for (var _GF = 1, _GE = $1.k; _GF <= _GE; _GF += 1) {
      $1.i = _GF;
      $put($1.coeffs, $1.i, $get($1.coeffs, $1.i - 1));
      for (var _GM = $1.i - 1; _GM >= 1; _GM -= 1) {
        $1.j = _GM;
        $k[$j++] = $1.coeffs;
        $k[$j++] = $1.j;
        $k[$j++] = $get($1.coeffs, $1.j - 1);
        $k[$j++] = $get($1.coeffs, $1.j);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _GY = $k[--$j];
        var _GZ = $k[--$j];
        var _Ga = $k[--$j];
        $put($k[--$j], _Ga, $f(_GZ + _GY) % 929);
      }
      $k[$j++] = $1.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($1.coeffs, 0);
      $k[$j++] = $get($1.rsalog, $1.i);
      $1.rsprod();
      var _Gi = $k[--$j];
      var _Gj = $k[--$j];
      $put($k[--$j], _Gj, _Gi);
    }
    $1.coeffs = $geti($1.coeffs, 0, $1.coeffs.length - 1);
    for (var _Gp = $1.coeffs.length - 1; _Gp >= 0; _Gp -= 2) {
      var _Gq = $1.coeffs;
      $put(_Gq, _Gp, $f(929 - $get(_Gq, _Gp)));
    }
    for (var _Gu = 0, _Gt = $f($1.n - 1); _Gu <= _Gt; _Gu += 1) {
      $1.t = $f($get($1.cws, _Gu) + $get($1.cws, $1.n)) % 929;
      for (var _H2 = 0, _H1 = $f($1.k - 1); _H2 <= _H1; _H2 += 1) {
        $1.j = _H2;
        $put($1.cws, $f($1.n + $1.j), $f($get($1.cws, $f($f($1.n + $1.j) + 1)) + $f(929 - $1.t * $get($1.coeffs, $f($f($1.k - $1.j) - 1)) % 929)) % 929);
      }
    }
    for (var _HJ = $1.n, _HI = $f($1.n + $1.k); _HJ <= _HI; _HJ += 1) {
      $put($1.cws, _HJ, $f(929 - $get($1.cws, _HJ)) % 929);
    }
    $1.cws = $geti($1.cws, 0, $1.cws.length - 1);
    var _HR = $get($1.options, "debugcws") !== void 0;
    if (_HR) {
      $k[$j++] = "bwipp.debugcws#17993";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    if (!bwipp_micropdf417.__18252__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.clusters = $a([$a([120256, 125680, 128380, 120032, 125560, 128318, 108736, 119920, 108640, 86080, 108592, 86048, 110016, 120560, 125820, 109792, 120440, 125758, 88256, 109680, 88160, 89536, 110320, 120700, 89312, 110200, 120638, 89200, 110140, 89840, 110460, 89720, 110398, 89980, 128506, 119520, 125304, 128190, 107712, 119408, 125244, 107616, 119352, 84032, 107568, 119324, 84e3, 107544, 83984, 108256, 119672, 125374, 85184, 108144, 119612, 85088, 108088, 119582, 85040, 108060, 85728, 108408, 119742, 85616, 108348, 85560, 108318, 85880, 108478, 85820, 85790, 107200, 119152, 125116, 107104, 119096, 125086, 83008, 107056, 119068, 82976, 107032, 82960, 82952, 83648, 107376, 119228, 83552, 107320, 119198, 83504, 107292, 83480, 83468, 83824, 107452, 83768, 107422, 83740, 83900, 106848, 118968, 125022, 82496, 106800, 118940, 82464, 106776, 118926, 82448, 106764, 82440, 106758, 82784, 106936, 119006, 82736, 106908, 82712, 106894, 82700, 82694, 106974, 82830, 82240, 106672, 118876, 82208, 106648, 118862, 82192, 106636, 82184, 106630, 82180, 82352, 82328, 82316, 82080, 118830, 106572, 106566, 82050, 117472, 124280, 127678, 103616, 117360, 124220, 103520, 117304, 124190, 75840, 103472, 75808, 104160, 117624, 124350, 76992, 104048, 117564, 76896, 103992, 76848, 76824, 77536, 104312, 117694, 77424, 104252, 77368, 77340, 77688, 104382, 77628, 77758, 121536, 126320, 128700, 121440, 126264, 128670, 111680, 121392, 126236, 111648, 121368, 126222, 111632, 121356, 103104, 117104, 124092, 112320, 103008, 117048, 124062, 112224, 121656, 126366, 93248, 74784, 102936, 117006, 93216, 112152, 93200, 75456, 103280, 117180, 93888, 75360, 103224, 117150, 93792, 112440, 121758, 93744, 75288, 93720, 75632, 103356, 94064, 75576, 103326, 94008, 112542, 93980, 75708, 94140, 75678, 94110, 121184, 126136, 128606, 111168, 121136, 126108, 111136, 121112, 126094, 111120, 121100, 111112, 111108, 102752, 116920, 123998, 111456, 102704, 116892, 91712, 74272, 121244, 116878, 91680, 74256, 102668, 91664, 111372, 102662, 74244, 74592, 102840, 116958, 92e3, 74544, 102812, 91952, 111516, 102798, 91928, 74508, 74502, 74680, 102878, 92088, 74652, 92060, 74638, 92046, 92126, 110912, 121008, 126044, 110880, 120984, 126030, 110864, 120972, 110856, 120966, 110852, 110850, 74048, 102576, 116828, 90944, 74016, 102552, 116814, 90912, 111e3, 121038, 90896, 73992, 102534, 90888, 110982, 90884, 74160, 102620, 91056, 74136, 102606, 91032, 111054, 91020, 74118, 91014, 91100, 91086, 110752, 120920, 125998, 110736, 120908, 110728, 120902, 110724, 110722, 73888, 102488, 116782, 90528, 73872, 102476, 90512, 110796, 102470, 90504, 73860, 90500, 73858, 73944, 90584, 90572, 90566, 120876, 120870, 110658, 102444, 73800, 90312, 90308, 90306, 101056, 116080, 123580, 100960, 116024, 70720, 100912, 115996, 70688, 100888, 70672, 70664, 71360, 101232, 116156, 71264, 101176, 116126, 71216, 101148, 71192, 71180, 71536, 101308, 71480, 101278, 71452, 71612, 71582, 118112, 124600, 127838, 105024, 118064, 124572, 104992, 118040, 124558, 104976, 118028, 104968, 118022, 100704, 115896, 123486, 105312, 100656, 115868, 79424, 70176, 118172, 115854, 79392, 105240, 100620, 79376, 70152, 79368, 70496, 100792, 115934, 79712, 70448, 118238, 79664, 105372, 100750, 79640, 70412, 79628, 70584, 100830, 79800, 70556, 79772, 70542, 70622, 79838, 122176, 126640, 128860, 122144, 126616, 128846, 122128, 126604, 122120, 126598, 122116, 104768, 117936, 124508, 113472, 104736, 126684, 124494, 113440, 122264, 126670, 113424, 104712, 117894, 113416, 122246, 104706, 69952, 100528, 115804, 78656, 69920, 100504, 115790, 96064, 78624, 104856, 117966, 96032, 113560, 122318, 100486, 96016, 78600, 104838, 96008, 69890, 70064, 100572, 78768, 70040, 100558, 96176, 78744, 104910, 96152, 113614, 70022, 78726, 70108, 78812, 70094, 96220, 78798, 122016, 126552, 128814, 122e3, 126540, 121992, 126534, 121988, 121986, 104608, 117848, 124462, 113056, 104592, 126574, 113040, 122060, 117830, 113032, 104580, 113028, 104578, 113026, 69792, 100440, 115758, 78240, 69776, 100428, 95136, 78224, 104652, 100422, 95120, 113100, 69764, 95112, 78212, 69762, 78210, 69848, 100462, 78296, 69836, 95192, 78284, 69830, 95180, 78278, 69870, 95214, 121936, 126508, 121928, 126502, 121924, 121922, 104528, 117804, 112848, 104520, 117798, 112840, 121958, 112836, 104514, 112834, 69712, 100396, 78032, 69704, 100390, 94672, 78024, 104550, 94664, 112870, 69698, 94660, 78018, 94658, 78060, 94700, 94694, 126486, 121890, 117782, 104484, 104482, 69672, 77928, 94440, 69666, 77922, 99680, 68160, 99632, 68128, 99608, 115342, 68112, 99596, 68104, 99590, 68448, 99768, 115422, 68400, 99740, 68376, 99726, 68364, 68358, 68536, 99806, 68508, 68494, 68574, 101696, 116400, 123740, 101664, 116376, 101648, 116364, 101640, 116358, 101636, 67904, 99504, 115292, 72512, 67872, 116444, 115278, 72480, 101784, 116430, 72464, 67848, 99462, 72456, 101766, 67842, 68016, 99548, 72624, 67992, 99534, 72600, 101838, 72588, 67974, 68060, 72668, 68046, 72654, 118432, 124760, 127918, 118416, 124748, 118408, 124742, 118404, 118402, 101536, 116312, 105888, 101520, 116300, 105872, 118476, 116294, 105864, 101508, 105860, 101506, 105858, 67744, 99416, 72096, 67728, 116334, 80800, 72080, 101580, 99398, 80784, 105932, 67716, 80776, 72068, 67714, 72066, 67800, 99438, 72152, 67788, 80856, 72140, 67782, 80844, 72134, 67822, 72174, 80878, 126800, 128940, 126792, 128934, 126788, 126786, 118352, 124716, 122576, 126828, 124710, 122568, 126822, 122564, 118338, 122562, 101456, 116268, 105680, 101448, 116262, 114128, 105672, 118374, 114120, 122598, 101442, 114116, 105666, 114114, 67664, 99372, 71888, 67656, 99366, 80336, 71880, 101478, 97232, 80328, 105702, 67650, 97224, 114150, 71874, 97220, 67692, 71916, 67686, 80364, 71910, 97260, 80358, 97254, 126760, 128918, 126756, 126754, 118312, 124694, 122472, 126774, 122468, 118306, 122466, 101416, 116246, 105576, 101412, 113896, 105572, 101410, 113892, 105570, 113890, 67624, 99350, 71784, 101430, 80104, 71780, 67618, 96744, 80100, 71778, 96740, 80098, 96738, 71798, 96758, 126738, 122420, 122418, 105524, 113780, 113778, 71732, 79988, 96500, 96498, 66880, 66848, 98968, 66832, 66824, 66820, 66992, 66968, 66956, 66950, 67036, 67022, 1e5, 99984, 115532, 99976, 115526, 99972, 99970, 66720, 98904, 69024, 100056, 98892, 69008, 100044, 69e3, 100038, 68996, 66690, 68994, 66776, 98926, 69080, 100078, 69068, 66758, 69062, 66798, 69102, 116560, 116552, 116548, 116546, 99920, 102096, 116588, 115494, 102088, 116582, 102084, 99906, 102082, 66640, 68816, 66632, 98854, 73168, 68808, 66628, 73160, 68804, 66626, 73156, 68802, 66668, 68844, 66662, 73196, 68838, 73190, 124840, 124836, 124834, 116520, 118632, 124854, 118628, 116514, 118626, 99880, 115478, 101992, 116534, 106216, 101988, 99874, 106212, 101986, 106210, 66600, 98838, 68712, 99894, 72936, 68708, 66594, 81384, 72932, 68706, 81380, 72930, 66614, 68726, 72950, 81398, 128980, 128978, 124820, 126900, 124818, 126898, 116500, 118580, 116498, 122740, 118578, 122738, 99860, 101940, 99858, 106100, 101938, 114420]), $a([128352, 129720, 125504, 128304, 129692, 125472, 128280, 129678, 125456, 128268, 125448, 128262, 125444, 125792, 128440, 129758, 120384, 125744, 128412, 120352, 125720, 128398, 120336, 125708, 120328, 125702, 120324, 120672, 125880, 128478, 110144, 120624, 125852, 110112, 120600, 125838, 110096, 120588, 110088, 120582, 110084, 110432, 120760, 125918, 89664, 110384, 120732, 89632, 110360, 120718, 89616, 110348, 89608, 110342, 89952, 110520, 120798, 89904, 110492, 89880, 110478, 89868, 90040, 110558, 90012, 89998, 125248, 128176, 129628, 125216, 128152, 129614, 125200, 128140, 125192, 128134, 125188, 125186, 119616, 125360, 128220, 119584, 125336, 128206, 119568, 125324, 119560, 125318, 119556, 119554, 108352, 119728, 125404, 108320, 119704, 125390, 108304, 119692, 108296, 119686, 108292, 108290, 85824, 108464, 119772, 85792, 108440, 119758, 85776, 108428, 85768, 108422, 85764, 85936, 108508, 85912, 108494, 85900, 85894, 85980, 85966, 125088, 128088, 129582, 125072, 128076, 125064, 128070, 125060, 125058, 119200, 125144, 128110, 119184, 125132, 119176, 125126, 119172, 119170, 107424, 119256, 125166, 107408, 119244, 107400, 119238, 107396, 107394, 83872, 107480, 119278, 83856, 107468, 83848, 107462, 83844, 83842, 83928, 107502, 83916, 83910, 83950, 125008, 128044, 125e3, 128038, 124996, 124994, 118992, 125036, 118984, 125030, 118980, 118978, 106960, 119020, 106952, 119014, 106948, 106946, 82896, 106988, 82888, 106982, 82884, 82882, 82924, 82918, 124968, 128022, 124964, 124962, 118888, 124982, 118884, 118882, 106728, 118902, 106724, 106722, 82408, 106742, 82404, 82402, 124948, 124946, 118836, 118834, 106612, 106610, 124224, 127664, 129372, 124192, 127640, 129358, 124176, 127628, 124168, 127622, 124164, 124162, 117568, 124336, 127708, 117536, 124312, 127694, 117520, 124300, 117512, 124294, 117508, 117506, 104256, 117680, 124380, 104224, 117656, 124366, 104208, 117644, 104200, 117638, 104196, 104194, 77632, 104368, 117724, 77600, 104344, 117710, 77584, 104332, 77576, 104326, 77572, 77744, 104412, 77720, 104398, 77708, 77702, 77788, 77774, 128672, 129880, 93168, 128656, 129868, 92664, 128648, 129862, 92412, 128644, 128642, 124064, 127576, 129326, 126368, 124048, 129902, 126352, 128716, 127558, 126344, 124036, 126340, 124034, 126338, 117152, 124120, 127598, 121760, 117136, 124108, 121744, 126412, 124102, 121736, 117124, 121732, 117122, 121730, 103328, 117208, 124142, 112544, 103312, 117196, 112528, 121804, 117190, 112520, 103300, 112516, 103298, 112514, 75680, 103384, 117230, 94112, 75664, 103372, 94096, 112588, 103366, 94088, 75652, 94084, 75650, 75736, 103406, 94168, 75724, 94156, 75718, 94150, 75758, 128592, 129836, 91640, 128584, 129830, 91388, 128580, 91262, 128578, 123984, 127532, 126160, 123976, 127526, 126152, 128614, 126148, 123970, 126146, 116944, 124012, 121296, 116936, 124006, 121288, 126182, 121284, 116930, 121282, 102864, 116972, 111568, 102856, 116966, 111560, 121318, 111556, 102850, 111554, 74704, 102892, 92112, 74696, 102886, 92104, 111590, 92100, 74690, 92098, 74732, 92140, 74726, 92134, 128552, 129814, 90876, 128548, 90750, 128546, 123944, 127510, 126056, 128566, 126052, 123938, 126050, 116840, 123958, 121064, 116836, 121060, 116834, 121058, 102632, 116854, 111080, 121078, 111076, 102626, 111074, 74216, 102646, 91112, 74212, 91108, 74210, 91106, 74230, 91126, 128532, 90494, 128530, 123924, 126004, 123922, 126002, 116788, 120948, 116786, 120946, 102516, 110836, 102514, 110834, 73972, 90612, 73970, 90610, 128522, 123914, 125978, 116762, 120890, 102458, 110714, 123552, 127320, 129198, 123536, 127308, 123528, 127302, 123524, 123522, 116128, 123608, 127342, 116112, 123596, 116104, 123590, 116100, 116098, 101280, 116184, 123630, 101264, 116172, 101256, 116166, 101252, 101250, 71584, 101336, 116206, 71568, 101324, 71560, 101318, 71556, 71554, 71640, 101358, 71628, 71622, 71662, 127824, 129452, 79352, 127816, 129446, 79100, 127812, 78974, 127810, 123472, 127276, 124624, 123464, 127270, 124616, 127846, 124612, 123458, 124610, 115920, 123500, 118224, 115912, 123494, 118216, 124646, 118212, 115906, 118210, 100816, 115948, 105424, 100808, 115942, 105416, 118246, 105412, 100802, 105410, 70608, 100844, 79824, 70600, 100838, 79816, 105446, 79812, 70594, 79810, 70636, 79852, 70630, 79846, 129960, 95728, 113404, 129956, 95480, 113278, 129954, 95356, 95294, 127784, 129430, 78588, 128872, 129974, 95996, 78462, 128868, 127778, 95870, 128866, 123432, 127254, 124520, 123428, 126696, 128886, 123426, 126692, 124514, 126690, 115816, 123446, 117992, 115812, 122344, 117988, 115810, 122340, 117986, 122338, 100584, 115830, 104936, 100580, 113640, 104932, 100578, 113636, 104930, 113634, 70120, 100598, 78824, 70116, 96232, 78820, 70114, 96228, 78818, 96226, 70134, 78838, 129940, 94968, 113022, 129938, 94844, 94782, 127764, 78206, 128820, 127762, 95102, 128818, 123412, 124468, 123410, 126580, 124466, 126578, 115764, 117876, 115762, 122100, 117874, 122098, 100468, 104692, 100466, 113140, 104690, 113138, 69876, 78324, 69874, 95220, 78322, 95218, 129930, 94588, 94526, 127754, 128794, 123402, 124442, 126522, 115738, 117818, 121978, 100410, 104570, 112890, 69754, 78074, 94714, 94398, 123216, 127148, 123208, 127142, 123204, 123202, 115408, 123244, 115400, 123238, 115396, 115394, 99792, 115436, 99784, 115430, 99780, 99778, 68560, 99820, 68552, 99814, 68548, 68546, 68588, 68582, 127400, 129238, 72444, 127396, 72318, 127394, 123176, 127126, 123752, 123172, 123748, 123170, 123746, 115304, 123190, 116456, 115300, 116452, 115298, 116450, 99560, 115318, 101864, 99556, 101860, 99554, 101858, 68072, 99574, 72680, 68068, 72676, 68066, 72674, 68086, 72694, 129492, 80632, 105854, 129490, 80508, 80446, 127380, 72062, 127924, 127378, 80766, 127922, 123156, 123700, 123154, 124788, 123698, 124786, 115252, 116340, 115250, 118516, 116338, 118514, 99444, 101620, 99442, 105972, 101618, 105970, 67828, 72180, 67826, 80884, 72178, 80882, 97008, 114044, 96888, 113982, 96828, 96798, 129482, 80252, 130010, 97148, 80190, 97086, 127370, 127898, 128954, 123146, 123674, 124730, 126842, 115226, 116282, 118394, 122618, 99386, 101498, 105722, 114170, 67706, 71930, 80378, 96632, 113854, 96572, 96542, 80062, 96702, 96444, 96414, 96350, 123048, 123044, 123042, 115048, 123062, 115044, 115042, 99048, 115062, 99044, 99042, 67048, 99062, 67044, 67042, 67062, 127188, 68990, 127186, 123028, 123316, 123026, 123314, 114996, 115572, 114994, 115570, 98932, 100084, 98930, 100082, 66804, 69108, 66802, 69106, 129258, 73084, 73022, 127178, 127450, 123018, 123290, 123834, 114970, 115514, 116602, 98874, 99962, 102138, 66682, 68858, 73210, 81272, 106174, 81212, 81182, 72894, 81342, 97648, 114364, 97592, 114334, 97564, 97550, 81084, 97724, 81054, 97694, 97464, 114270, 97436, 97422, 80990, 97502, 97372, 97358, 97326, 114868, 114866, 98676, 98674, 66292, 66290, 123098, 114842, 115130, 98618, 99194, 66170, 67322, 69310, 73404, 73374, 81592, 106334, 81564, 81550, 73310, 81630, 97968, 114524, 97944, 114510, 97932, 97926, 81500, 98012, 81486, 97998, 97880, 114478, 97868, 97862, 81454, 97902, 97836, 97830, 69470, 73564, 73550, 81752, 106414, 81740, 81734, 73518, 81774, 81708, 81702]), $a([109536, 120312, 86976, 109040, 120060, 86496, 108792, 119934, 86256, 108668, 86136, 129744, 89056, 110072, 129736, 88560, 109820, 129732, 88312, 109694, 129730, 88188, 128464, 129772, 89592, 128456, 129766, 89340, 128452, 89214, 128450, 125904, 128492, 125896, 128486, 125892, 125890, 120784, 125932, 120776, 125926, 120772, 120770, 110544, 120812, 110536, 120806, 110532, 84928, 108016, 119548, 84448, 107768, 119422, 84208, 107644, 84088, 107582, 84028, 129640, 85488, 108284, 129636, 85240, 108158, 129634, 85116, 85054, 128232, 129654, 85756, 128228, 85630, 128226, 125416, 128246, 125412, 125410, 119784, 125430, 119780, 119778, 108520, 119798, 108516, 108514, 83424, 107256, 119166, 83184, 107132, 83064, 107070, 83004, 82974, 129588, 83704, 107390, 129586, 83580, 83518, 128116, 83838, 128114, 125172, 125170, 119284, 119282, 107508, 107506, 82672, 106876, 82552, 106814, 82492, 82462, 129562, 82812, 82750, 128058, 125050, 119034, 82296, 106686, 82236, 82206, 82366, 82108, 82078, 76736, 103920, 117500, 76256, 103672, 117374, 76016, 103548, 75896, 103486, 75836, 129384, 77296, 104188, 129380, 77048, 104062, 129378, 76924, 76862, 127720, 129398, 77564, 127716, 77438, 127714, 124392, 127734, 124388, 124386, 117736, 124406, 117732, 117730, 104424, 117750, 104420, 104418, 112096, 121592, 126334, 92608, 111856, 121468, 92384, 111736, 121406, 92272, 111676, 92216, 111646, 92188, 75232, 103160, 117118, 93664, 74992, 103036, 93424, 112252, 102974, 93304, 74812, 93244, 74782, 93214, 129332, 75512, 103294, 129908, 129330, 93944, 75388, 129906, 93820, 75326, 93758, 127604, 75646, 128756, 127602, 94078, 128754, 124148, 126452, 124146, 126450, 117236, 121844, 117234, 121842, 103412, 103410, 91584, 111344, 121212, 91360, 111224, 121150, 91248, 111164, 91192, 111134, 91164, 91150, 74480, 102780, 91888, 74360, 102718, 91768, 111422, 91708, 74270, 91678, 129306, 74620, 129850, 92028, 74558, 91966, 127546, 128634, 124026, 126202, 116986, 121338, 102906, 90848, 110968, 121022, 90736, 110908, 90680, 110878, 90652, 90638, 74104, 102590, 91e3, 74044, 90940, 74014, 90910, 74174, 91070, 90480, 110780, 90424, 110750, 90396, 90382, 73916, 90556, 73886, 90526, 90296, 110686, 90268, 90254, 73822, 90334, 90204, 90190, 71136, 101112, 116094, 70896, 100988, 70776, 100926, 70716, 70686, 129204, 71416, 101246, 129202, 71292, 71230, 127348, 71550, 127346, 123636, 123634, 116212, 116210, 101364, 101362, 79296, 105200, 118140, 79072, 105080, 118078, 78960, 105020, 78904, 104990, 78876, 78862, 70384, 100732, 79600, 70264, 100670, 79480, 105278, 79420, 70174, 79390, 129178, 70524, 129466, 79740, 70462, 79678, 127290, 127866, 123514, 124666, 115962, 118266, 100858, 113376, 122232, 126654, 95424, 113264, 122172, 95328, 113208, 122142, 95280, 113180, 95256, 113166, 95244, 78560, 104824, 117950, 95968, 78448, 104764, 95856, 113468, 104734, 95800, 78364, 95772, 78350, 95758, 70008, 100542, 78712, 69948, 96120, 78652, 69918, 96060, 78622, 96030, 70078, 78782, 96190, 94912, 113008, 122044, 94816, 112952, 122014, 94768, 112924, 94744, 112910, 94732, 94726, 78192, 104636, 95088, 78136, 104606, 95032, 113054, 95004, 78094, 94990, 69820, 78268, 69790, 95164, 78238, 95134, 94560, 112824, 121950, 94512, 112796, 94488, 112782, 94476, 94470, 78008, 104542, 94648, 77980, 94620, 77966, 94606, 69726, 78046, 94686, 94384, 112732, 94360, 112718, 94348, 94342, 77916, 94428, 77902, 94414, 94296, 112686, 94284, 94278, 77870, 94318, 94252, 94246, 68336, 99708, 68216, 99646, 68156, 68126, 68476, 68414, 127162, 123258, 115450, 99834, 72416, 101752, 116414, 72304, 101692, 72248, 101662, 72220, 72206, 67960, 99518, 72568, 67900, 72508, 67870, 72478, 68030, 72638, 80576, 105840, 118460, 80480, 105784, 118430, 80432, 105756, 80408, 105742, 80396, 80390, 72048, 101564, 80752, 71992, 101534, 80696, 71964, 80668, 71950, 80654, 67772, 72124, 67742, 80828, 72094, 80798, 114016, 122552, 126814, 96832, 113968, 122524, 96800, 113944, 122510, 96784, 113932, 96776, 113926, 96772, 80224, 105656, 118366, 97120, 80176, 105628, 97072, 114076, 105614, 97048, 80140, 97036, 80134, 97030, 71864, 101470, 80312, 71836, 97208, 80284, 71822, 97180, 80270, 97166, 67678, 71902, 80350, 97246, 96576, 113840, 122460, 96544, 113816, 122446, 96528, 113804, 96520, 113798, 96516, 96514, 80048, 105564, 96688, 80024, 105550, 96664, 113870, 96652, 80006, 96646, 71772, 80092, 71758, 96732, 80078, 96718, 96416, 113752, 122414, 96400, 113740, 96392, 113734, 96388, 96386, 79960, 105518, 96472, 79948, 96460, 79942, 96454, 71726, 79982, 96494, 96336, 113708, 96328, 113702, 96324, 96322, 79916, 96364, 79910, 96358, 96296, 113686, 96292, 96290, 79894, 96310, 66936, 99006, 66876, 66846, 67006, 68976, 100028, 68920, 99998, 68892, 68878, 66748, 69052, 66718, 69022, 73056, 102072, 116574, 73008, 102044, 72984, 102030, 72972, 72966, 68792, 99934, 73144, 68764, 73116, 68750, 73102, 66654, 68830, 73182, 81216, 106160, 118620, 81184, 106136, 118606, 81168, 106124, 81160, 106118, 81156, 81154, 72880, 101980, 81328, 72856, 101966, 81304, 106190, 81292, 72838, 81286, 68700, 72924, 68686, 81372, 72910, 81358, 114336, 122712, 126894, 114320, 122700, 114312, 122694, 114308, 114306, 81056, 106072, 118574, 97696, 81040, 106060, 97680, 114380, 106054, 97672, 81028, 97668, 81026, 97666, 72792, 101934, 81112, 72780, 97752, 81100, 72774, 97740, 81094, 97734, 68654, 72814, 81134, 97774, 114256, 122668, 114248, 122662, 114244, 114242, 80976, 106028, 97488, 80968, 106022, 97480, 114278, 97476, 80962, 97474, 72748, 81004, 72742, 97516, 80998, 97510, 114216, 122646, 114212, 114210, 80936, 106006, 97384, 80932, 97380, 80930, 97378, 72726, 80950, 97398, 114196, 114194, 80916, 97332, 80914, 97330, 66236, 66206, 67256, 99166, 67228, 67214, 66142, 67294, 69296, 100188, 69272, 100174, 69260, 69254, 67164, 69340, 67150, 69326, 73376, 102232, 116654, 73360, 102220, 73352, 102214, 73348, 73346, 69208, 100142, 73432, 102254, 73420, 69190, 73414, 67118, 69230, 73454, 106320, 118700, 106312, 118694, 106308, 106306, 73296, 102188, 81616, 106348, 102182, 81608, 73284, 81604, 73282, 81602, 69164, 73324, 69158, 81644, 73318, 81638, 122792, 126934, 122788, 122786, 106280, 118678, 114536, 106276, 114532, 106274, 114530, 73256, 102166, 81512, 73252, 98024, 81508, 73250, 98020, 81506, 98018, 69142, 73270, 81526, 98038, 122772, 122770, 106260, 114484, 106258, 114482, 73236, 81460, 73234, 97908, 81458, 97906, 122762, 106250, 114458, 73226, 81434, 97850, 66396, 66382, 67416, 99246, 67404, 67398, 66350, 67438, 69456, 100268, 69448, 100262, 69444, 69442, 67372, 69484, 67366, 69478, 102312, 116694, 102308, 102306, 69416, 100246, 73576, 102326, 73572, 69410, 73570, 67350, 69430, 73590, 118740, 118738, 102292, 106420, 102290, 106418, 69396, 73524, 69394, 81780, 73522, 81778, 118730, 102282, 106394, 69386, 73498, 81722, 66476, 66470, 67496, 99286, 67492, 67490, 66454, 67510, 100308, 100306, 67476, 69556, 67474, 69554, 116714])]);
        $ctx.raps = $a([$a([802, 930, 946, 818, 882, 890, 826, 954, 922, 986, 970, 906, 778, 794, 786, 914, 978, 982, 980, 916, 948, 932, 934, 942, 940, 936, 808, 812, 814, 806, 822, 950, 918, 790, 788, 820, 884, 868, 870, 878, 876, 872, 840, 856, 860, 862, 846, 844, 836, 838, 834, 866]), $a([718, 590, 622, 558, 550, 566, 534, 530, 538, 570, 562, 546, 610, 626, 634, 762, 754, 758, 630, 628, 612, 614, 582, 578, 706, 738, 742, 740, 748, 620, 556, 552, 616, 744, 712, 716, 708, 710, 646, 654, 652, 668, 664, 696, 688, 656, 720, 592, 600, 604, 732, 734])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_micropdf417.$ctx[id] = $ctx[id]);
        bwipp_micropdf417.__18252__ = 1;
      })();
    }
    $1.cwtobits = function() {
      var _Hd = $get($1.clusters, $k[--$j]);
      $1.v = $get(_Hd, $k[--$j]);
      $k[$j++] = Infinity;
      for (var _Hg = 0, _Hh = 17; _Hg < _Hh; _Hg++) {
        $k[$j++] = 0;
      }
      var _Hk = $cvrs($s(17), $1.v, 2);
      for (var _Hl = 0, _Hm = _Hk.length; _Hl < _Hm; _Hl++) {
        $k[$j++] = $get(_Hk, _Hl) - 48;
      }
      var _Ho = $a();
      $k[$j++] = $geti(_Ho, _Ho.length - 17, 17);
    };
    $1.raptobits = function() {
      var _Hs = $get($1.raps, $k[--$j]);
      $1.v = $get(_Hs, $k[--$j]);
      $k[$j++] = Infinity;
      for (var _Hv = 0, _Hw = 10; _Hv < _Hw; _Hv++) {
        $k[$j++] = 0;
      }
      var _Hz = $cvrs($s(10), $1.v, 2);
      for (var _I0 = 0, _I1 = _Hz.length; _I0 < _I1; _I0++) {
        $k[$j++] = $get(_Hz, _I0) - 48;
      }
      var _I3 = $a();
      $k[$j++] = $geti(_I3, _I3.length - 10, 10);
    };
    $1.rwid = $get($a([38, 55, 82, 99]), $f($1.c - 1));
    if ($1.c == 3 && $1.cca) {
      $1.rwid = 72;
    }
    $1.pixs = $a($1.rwid * $1.r);
    for (var _IF = 0, _IE = $f($1.r - 1); _IF <= _IE; _IF += 1) {
      $1.i = _IF;
      $1.clst = $f($f($1.i + $1.rapl) - 1) % 3;
      $k[$j++] = $1.pixs;
      $k[$j++] = $1.rwid * $1.i;
      $k[$j++] = Infinity;
      if ($1.c == 1) {
        $k[$j++] = $f($f($1.i + $1.rapl) - 1) % 52;
        $k[$j++] = 0;
        $1.raptobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $f($f($1.i + $1.rapr) - 1) % 52;
        $k[$j++] = 0;
        $1.raptobits();
        $aload($k[--$j]);
      }
      if ($1.c == 2) {
        $k[$j++] = $f($f($1.i + $1.rapl) - 1) % 52;
        $k[$j++] = 0;
        $1.raptobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i * 2);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i * 2 + 1);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $f($f($1.i + $1.rapr) - 1) % 52;
        $k[$j++] = 0;
        $1.raptobits();
        $aload($k[--$j]);
      }
      if ($1.c == 3) {
        if (!$1.cca) {
          $k[$j++] = $f($f($1.i + $1.rapl) - 1) % 52;
          $k[$j++] = 0;
          $1.raptobits();
          $aload($k[--$j]);
        }
        $k[$j++] = $get($1.cws, $1.i * 3);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $f($f($1.i + $1.rapc) - 1) % 52;
        $k[$j++] = 1;
        $1.raptobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i * 3 + 1);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i * 3 + 2);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $f($f($1.i + $1.rapr) - 1) % 52;
        $k[$j++] = 0;
        $1.raptobits();
        $aload($k[--$j]);
      }
      if ($1.c == 4) {
        $k[$j++] = $f($f($1.i + $1.rapl) - 1) % 52;
        $k[$j++] = 0;
        $1.raptobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i * 4);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i * 4 + 1);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $f($f($1.i + $1.rapc) - 1) % 52;
        $k[$j++] = 1;
        $1.raptobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i * 4 + 2);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $get($1.cws, $1.i * 4 + 3);
        $k[$j++] = $1.clst;
        $1.cwtobits();
        $aload($k[--$j]);
        $k[$j++] = $f($f($1.i + $1.rapr) - 1) % 52;
        $k[$j++] = 0;
        $1.raptobits();
        $aload($k[--$j]);
      }
      $k[$j++] = 1;
      var _Ji = $a();
      var _Jj = $k[--$j];
      $puti($k[--$j], _Jj, _Ji);
    }
    var _Js = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.rwid],
      ["pixy", $1.r],
      ["height", $1.r / 72 * $1.rowmult],
      ["width", $1.rwid / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _Js;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_datamatrix() {
    var $1 = Object.create(bwipp_datamatrix.$ctx || (bwipp_datamatrix.$ctx = {}));
    $1.dontdraw = false;
    $1.columns = 0;
    $1.rows = 0;
    $1.format = "unset";
    $1.version = "unset";
    $1.parse = false;
    $1.parsefnc = false;
    $1.c40headerlength = -1;
    $1.raw = false;
    $1.dmre = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.barcode, "")) {
      $k[$j++] = "bwipp.datamatrixEmptyData#18375";
      $k[$j++] = "The data must not be empty";
      bwipp_raiseerror();
    }
    if ($ne($1.version, "unset") && ($1.rows != 0 || $1.columns != 0)) {
      $k[$j++] = "bwipp.datamatrixVersionRowsCols#18379";
      $k[$j++] = "rows and columns must not be given if version is specified";
      bwipp_raiseerror();
    }
    if ($ne($1.version, "unset")) {
      $search($1.version, "x");
      if ($k[--$j]) {
        var _9 = $k[--$j];
        var _A = $k[--$j];
        $k[$j++] = _9;
        $k[$j++] = _A;
        $j--;
        var _B = $k[--$j];
        var _C = $k[--$j];
        $k[$j++] = _C;
        $k[$j++] = _B;
        $k[$j++] = _C;
        $k[$j++] = _B;
        $astore($a(2));
        $forall($k[--$j], function() {
          var _F = $k[--$j];
          $k[$j++] = _F;
          $k[$j++] = true;
          if (_F.length == 0) {
            $j--;
            $k[$j++] = false;
          }
          var _G = $k[--$j];
          var _H = $k[--$j];
          $k[$j++] = _G;
          $forall(_H, function() {
            var _I = $k[--$j];
            if (_I < 48 || _I > 57) {
              $j--;
              $k[$j++] = false;
            }
          });
          if ($nt($k[--$j])) {
            $k[$j++] = "bwipp.datamatrixVersionBadRowOrColumn#18393";
            $k[$j++] = "version must be formatted as RxC";
            bwipp_raiseerror();
          }
        });
        $1.rows = $cvi($k[--$j]);
        $1.columns = $cvi($k[--$j]);
        $k[$j++] = "format";
        if ($1.rows == $1.columns) {
          $k[$j++] = "square";
        } else {
          $k[$j++] = "rectangle";
        }
        var _O = $k[--$j];
        $1[$k[--$j]] = _O;
      } else {
        $j--;
        $k[$j++] = "bwipp.datamatrixVersionFormat#18400";
        $k[$j++] = "version must be formatted as RxC";
        bwipp_raiseerror();
      }
    } else {
      if ($eq($1.format, "unset")) {
        $k[$j++] = "format";
        if ($1.dmre) {
          $k[$j++] = "rectangle";
        } else {
          $k[$j++] = "square";
        }
        var _S = $k[--$j];
        $1[$k[--$j]] = _S;
      }
    }
    if ($ne($1.format, "square") && $ne($1.format, "rectangle")) {
      $k[$j++] = "bwipp.datamatrixInvalidFormat#18409";
      $k[$j++] = "The format must be either square or rectangle";
      bwipp_raiseerror();
    }
    if (!bwipp_datamatrix.__18469__) {
      (function() {
        var $ctx = Object.create($1);
        var _18 = $a([16, 64, 1, 4, 36, 1, 1]);
        $ctx.metrics = $a([$a([10, 10, 1, 1, 5, 1, 0]), $a([12, 12, 1, 1, 7, 1, 0]), $a([14, 14, 1, 1, 10, 1, 0]), $a([16, 16, 1, 1, 12, 1, 0]), $a([18, 18, 1, 1, 14, 1, 0]), $a([20, 20, 1, 1, 18, 1, 0]), $a([22, 22, 1, 1, 20, 1, 0]), $a([24, 24, 1, 1, 24, 1, 0]), $a([26, 26, 1, 1, 28, 1, 0]), $a([32, 32, 2, 2, 36, 1, 0]), $a([36, 36, 2, 2, 42, 1, 0]), $a([40, 40, 2, 2, 48, 1, 0]), $a([44, 44, 2, 2, 56, 1, 0]), $a([48, 48, 2, 2, 68, 1, 0]), $a([52, 52, 2, 2, 84, 2, 0]), $a([64, 64, 4, 4, 112, 2, 0]), $a([72, 72, 4, 4, 144, 4, 0]), $a([80, 80, 4, 4, 192, 4, 0]), $a([88, 88, 4, 4, 224, 4, 0]), $a([96, 96, 4, 4, 272, 4, 0]), $a([104, 104, 4, 4, 336, 6, 0]), $a([120, 120, 6, 6, 408, 6, 0]), $a([132, 132, 6, 6, 496, 8, 0]), $a([144, 144, 6, 6, 620, 10, 0]), $a([8, 18, 1, 1, 7, 1, 0]), $a([8, 32, 1, 2, 11, 1, 0]), $a([8, 48, 1, 2, 15, 1, 1]), $a([8, 64, 1, 4, 18, 1, 1]), $a([8, 80, 1, 4, 22, 1, 1]), $a([8, 96, 1, 4, 28, 1, 1]), $a([8, 120, 1, 6, 32, 1, 1]), $a([8, 144, 1, 6, 36, 1, 1]), $a([12, 26, 1, 1, 14, 1, 0]), $a([12, 36, 1, 2, 18, 1, 0]), $a([12, 64, 1, 4, 27, 1, 1]), $a([12, 88, 1, 4, 36, 1, 1]), $a([16, 36, 1, 2, 24, 1, 0]), $a([16, 48, 1, 2, 28, 1, 0]), _18, $a([20, 36, 1, 2, 28, 1, 1]), $a([20, 44, 1, 2, 34, 1, 1]), $a([20, 64, 1, 4, 42, 1, 1]), $a([22, 48, 1, 2, 38, 1, 1]), $a([24, 48, 1, 2, 41, 1, 1]), $a([24, 64, 1, 4, 46, 1, 1]), $a([26, 40, 1, 2, 38, 1, 1]), $a([26, 48, 1, 2, 42, 1, 1]), $a([26, 64, 1, 4, 50, 1, 1])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_datamatrix.$ctx[id] = $ctx[id]);
        bwipp_datamatrix.__18469__ = 1;
      })();
    }
    $1.urows = $1.rows;
    $1.ucols = $1.columns;
    $1.fullcws = $a([]);
    var _1N = $1.metrics;
    for (var _1O = 0, _1P = _1N.length; _1O < _1P; _1O++) {
      $1.m = $get(_1N, _1O);
      $1.rows = $get($1.m, 0);
      $1.cols = $get($1.m, 1);
      $1.regh = $get($1.m, 2);
      $1.regv = $get($1.m, 3);
      $1.rscw = $get($1.m, 4);
      $1.rsbl = $get($1.m, 5);
      $1.doly = $get($1.m, 6);
      $1.mrows = $f($1.rows - 2 * $1.regh);
      $1.mcols = $f($1.cols - 2 * $1.regv);
      $1.ncws = $f(~~($1.mrows * $1.mcols / 8) - $1.rscw);
      $1.okay = true;
      if ($1.urows != 0 && $1.urows != $1.rows) {
        $1.okay = false;
      }
      if ($1.ucols != 0 && $1.ucols != $1.cols) {
        $1.okay = false;
      }
      if ($eq($1.format, "square") && $ne($1.rows, $1.cols)) {
        $1.okay = false;
      }
      if ($eq($1.format, "rectangle") && $eq($1.rows, $1.cols)) {
        $1.okay = false;
      }
      if (!$1.dmre && $1.doly == 1) {
        $1.okay = false;
      }
      if ($1.okay) {
        $k[$j++] = Infinity;
        $aload($1.fullcws);
        $k[$j++] = $1.ncws;
        $1.fullcws = $a();
      }
    }
    $k[$j++] = Infinity;
    for (var _24 = 0, _25 = 1558; _24 < _25; _24++) {
      $k[$j++] = 1e4;
    }
    $1.numremcws = $a();
    var _27 = $1.fullcws;
    for (var _28 = 0, _29 = _27.length; _28 < _29; _28++) {
      $put($1.numremcws, $f($get(_27, _28) - 1), 1);
    }
    for (var _2C = 1556; _2C >= 0; _2C -= 1) {
      $1.i = _2C;
      if ($get($1.numremcws, $1.i) != 1) {
        $put($1.numremcws, $1.i, $f($get($1.numremcws, $1.i + 1) + 1));
      }
    }
    if (!bwipp_datamatrix.__18615__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.fnc1 = -1;
        $ctx.prog = -2;
        $ctx.m05 = -3;
        $ctx.m06 = -4;
        $ctx.lC = -5;
        $ctx.lB = -6;
        $ctx.lX = -7;
        $ctx.lT = -8;
        $ctx.lE = -9;
        $ctx.unl = -10;
        $ctx.sapp = -11;
        $ctx.usft = -12;
        $ctx.sft1 = -13;
        $ctx.sft2 = -14;
        $ctx.sft3 = -15;
        $ctx.eci = -16;
        $ctx.pad = -17;
        $ctx.unlcw = 254;
        $k[$j++] = Infinity;
        for (var _2L = 0; _2L <= 128; _2L += 1) {
          $k[$j++] = _2L;
          $k[$j++] = _2L + 1;
        }
        $k[$j++] = $ctx.pad;
        $k[$j++] = 129;
        for (var _2N = 0; _2N <= 99; _2N += 1) {
          var _2P = $cvrs($s(2), _2N, 10);
          var _2R = $strcpy($s(2), "00");
          $puti(_2R, 2 - _2P.length, _2P);
          $k[$j++] = _2R;
          $k[$j++] = _2N + 130;
        }
        var _2e = $a([$ctx.lC, $ctx.lB, $ctx.fnc1, $ctx.sapp, $ctx.prog, $ctx.usft, $ctx.m05, $ctx.m06, $ctx.lX, $ctx.lT, $ctx.lE, $ctx.eci]);
        $k[$j++] = 229;
        for (var _2f = 0, _2g = _2e.length; _2f < _2g; _2f++) {
          var _2j = $f($k[--$j] + 1);
          $k[$j++] = $get(_2e, _2f);
          $k[$j++] = _2j;
          $k[$j++] = _2j;
        }
        $j--;
        $ctx.Avals = $d();
        $k[$j++] = Infinity;
        var _2l = $ctx.Avals;
        for (var _2q = _2l.size, _2p = _2l.keys(), _2o = 0; _2o < _2q; _2o++) {
          var _2m = _2p.next().value;
          $k[$j++] = _2m;
          $k[$j++] = _2l.get(_2m);
          $k[$j++] = Infinity;
          var _2r = $k[--$j];
          var _2s = $k[--$j];
          $k[$j++] = _2r;
          $k[$j++] = _2s;
          var _2t = $a();
          $k[$j++] = _2t;
        }
        $ctx.Avals = $d();
        $k[$j++] = Infinity;
        $k[$j++] = $ctx.sft1;
        $k[$j++] = 0;
        $k[$j++] = $ctx.sft2;
        $k[$j++] = 1;
        $k[$j++] = $ctx.sft3;
        $k[$j++] = 2;
        $k[$j++] = 32;
        $k[$j++] = 3;
        for (var _2y = 48; _2y <= 57; _2y += 1) {
          $k[$j++] = _2y;
          $k[$j++] = _2y - 44;
        }
        for (var _2z = 65; _2z <= 90; _2z += 1) {
          $k[$j++] = _2z;
          $k[$j++] = _2z - 51;
        }
        $ctx.CNvals = $d();
        $k[$j++] = Infinity;
        for (var _31 = 0; _31 <= 31; _31 += 1) {
          $k[$j++] = _31;
          $k[$j++] = _31;
        }
        $ctx.C1vals = $d();
        $k[$j++] = Infinity;
        for (var _33 = 33; _33 <= 47; _33 += 1) {
          $k[$j++] = _33;
          $k[$j++] = _33 - 33;
        }
        for (var _34 = 58; _34 <= 64; _34 += 1) {
          $k[$j++] = _34;
          $k[$j++] = _34 - 43;
        }
        for (var _35 = 91; _35 <= 95; _35 += 1) {
          $k[$j++] = _35;
          $k[$j++] = _35 - 69;
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = 27;
        $k[$j++] = $ctx.usft;
        $k[$j++] = 30;
        $ctx.C2vals = $d();
        $k[$j++] = Infinity;
        for (var _39 = 96; _39 <= 127; _39 += 1) {
          $k[$j++] = _39;
          $k[$j++] = _39 - 96;
        }
        $ctx.C3vals = $d();
        $k[$j++] = Infinity;
        var _3B = $ctx.CNvals;
        for (var _3G = _3B.size, _3F = _3B.keys(), _3E = 0; _3E < _3G; _3E++) {
          var _3C = _3F.next().value;
          $k[$j++] = _3C;
          $k[$j++] = _3B.get(_3C);
          $k[$j++] = Infinity;
          var _3H = $k[--$j];
          var _3I = $k[--$j];
          $k[$j++] = _3H;
          $k[$j++] = _3I;
          var _3J = $a();
          $k[$j++] = _3J;
        }
        var _3K = $ctx.C1vals;
        for (var _3P = _3K.size, _3O = _3K.keys(), _3N = 0; _3N < _3P; _3N++) {
          var _3L = _3O.next().value;
          $k[$j++] = _3L;
          $k[$j++] = _3K.get(_3L);
          $k[$j++] = Infinity;
          var _3Q = $k[--$j];
          var _3R = $k[--$j];
          $k[$j++] = _3Q;
          $k[$j++] = $get($ctx.CNvals, $ctx.sft1);
          $k[$j++] = _3R;
          var _3V = $a();
          $k[$j++] = _3V;
        }
        var _3W = $ctx.C2vals;
        for (var _3b = _3W.size, _3a = _3W.keys(), _3Z = 0; _3Z < _3b; _3Z++) {
          var _3X = _3a.next().value;
          $k[$j++] = _3X;
          $k[$j++] = _3W.get(_3X);
          $k[$j++] = Infinity;
          var _3c = $k[--$j];
          var _3d = $k[--$j];
          $k[$j++] = _3c;
          $k[$j++] = $get($ctx.CNvals, $ctx.sft2);
          $k[$j++] = _3d;
          var _3h = $a();
          $k[$j++] = _3h;
        }
        var _3i = $ctx.C3vals;
        for (var _3n = _3i.size, _3m = _3i.keys(), _3l = 0; _3l < _3n; _3l++) {
          var _3j = _3m.next().value;
          $k[$j++] = _3j;
          $k[$j++] = _3i.get(_3j);
          $k[$j++] = Infinity;
          var _3o = $k[--$j];
          var _3p = $k[--$j];
          $k[$j++] = _3o;
          $k[$j++] = $get($ctx.CNvals, $ctx.sft3);
          $k[$j++] = _3p;
          var _3t = $a();
          $k[$j++] = _3t;
        }
        $ctx.Cvals = $d();
        $k[$j++] = Infinity;
        $k[$j++] = $ctx.sft1;
        $k[$j++] = 0;
        $k[$j++] = $ctx.sft2;
        $k[$j++] = 1;
        $k[$j++] = $ctx.sft3;
        $k[$j++] = 2;
        $k[$j++] = 32;
        $k[$j++] = 3;
        for (var _3y = 48; _3y <= 57; _3y += 1) {
          $k[$j++] = _3y;
          $k[$j++] = _3y - 44;
        }
        for (var _3z = 97; _3z <= 122; _3z += 1) {
          $k[$j++] = _3z;
          $k[$j++] = _3z - 83;
        }
        $ctx.TNvals = $d();
        $k[$j++] = Infinity;
        for (var _41 = 0; _41 <= 31; _41 += 1) {
          $k[$j++] = _41;
          $k[$j++] = _41;
        }
        $ctx.T1vals = $d();
        $k[$j++] = Infinity;
        for (var _43 = 33; _43 <= 47; _43 += 1) {
          $k[$j++] = _43;
          $k[$j++] = _43 - 33;
        }
        for (var _44 = 58; _44 <= 64; _44 += 1) {
          $k[$j++] = _44;
          $k[$j++] = _44 - 43;
        }
        for (var _45 = 91; _45 <= 95; _45 += 1) {
          $k[$j++] = _45;
          $k[$j++] = _45 - 69;
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = 27;
        $k[$j++] = $ctx.usft;
        $k[$j++] = 30;
        $ctx.T2vals = $d();
        $k[$j++] = Infinity;
        $k[$j++] = 96;
        $k[$j++] = 0;
        for (var _49 = 65; _49 <= 90; _49 += 1) {
          $k[$j++] = _49;
          $k[$j++] = _49 - 64;
        }
        for (var _4A = 123; _4A <= 127; _4A += 1) {
          $k[$j++] = _4A;
          $k[$j++] = _4A - 96;
        }
        $ctx.T3vals = $d();
        $k[$j++] = Infinity;
        var _4C = $ctx.TNvals;
        for (var _4H = _4C.size, _4G = _4C.keys(), _4F = 0; _4F < _4H; _4F++) {
          var _4D = _4G.next().value;
          $k[$j++] = _4D;
          $k[$j++] = _4C.get(_4D);
          $k[$j++] = Infinity;
          var _4I = $k[--$j];
          var _4J = $k[--$j];
          $k[$j++] = _4I;
          $k[$j++] = _4J;
          var _4K = $a();
          $k[$j++] = _4K;
        }
        var _4L = $ctx.T1vals;
        for (var _4Q = _4L.size, _4P = _4L.keys(), _4O = 0; _4O < _4Q; _4O++) {
          var _4M = _4P.next().value;
          $k[$j++] = _4M;
          $k[$j++] = _4L.get(_4M);
          $k[$j++] = Infinity;
          var _4R = $k[--$j];
          var _4S = $k[--$j];
          $k[$j++] = _4R;
          $k[$j++] = $get($ctx.TNvals, $ctx.sft1);
          $k[$j++] = _4S;
          var _4W = $a();
          $k[$j++] = _4W;
        }
        var _4X = $ctx.T2vals;
        for (var _4c = _4X.size, _4b = _4X.keys(), _4a = 0; _4a < _4c; _4a++) {
          var _4Y = _4b.next().value;
          $k[$j++] = _4Y;
          $k[$j++] = _4X.get(_4Y);
          $k[$j++] = Infinity;
          var _4d = $k[--$j];
          var _4e = $k[--$j];
          $k[$j++] = _4d;
          $k[$j++] = $get($ctx.TNvals, $ctx.sft2);
          $k[$j++] = _4e;
          var _4i = $a();
          $k[$j++] = _4i;
        }
        var _4j = $ctx.T3vals;
        for (var _4o = _4j.size, _4n = _4j.keys(), _4m = 0; _4m < _4o; _4m++) {
          var _4k = _4n.next().value;
          $k[$j++] = _4k;
          $k[$j++] = _4j.get(_4k);
          $k[$j++] = Infinity;
          var _4p = $k[--$j];
          var _4q = $k[--$j];
          $k[$j++] = _4p;
          $k[$j++] = $get($ctx.TNvals, $ctx.sft3);
          $k[$j++] = _4q;
          var _4u = $a();
          $k[$j++] = _4u;
        }
        $ctx.Tvals = $d();
        for (var _4w = 128; _4w <= 255; _4w += 1) {
          $ctx.i = _4w;
          $k[$j++] = $ctx.Avals;
          $k[$j++] = $ctx.i;
          $k[$j++] = Infinity;
          $aload($get($ctx.Avals, $ctx.usft));
          $aload($get($ctx.Avals, $ctx.i - 128));
          var _55 = $a();
          var _56 = $k[--$j];
          $put($k[--$j], _56, _55);
          $k[$j++] = $ctx.Cvals;
          $k[$j++] = $ctx.i;
          $k[$j++] = Infinity;
          $aload($get($ctx.Cvals, $ctx.usft));
          $aload($get($ctx.Cvals, $ctx.i - 128));
          var _5G = $a();
          var _5H = $k[--$j];
          $put($k[--$j], _5H, _5G);
          $k[$j++] = $ctx.Tvals;
          $k[$j++] = $ctx.i;
          $k[$j++] = Infinity;
          $aload($get($ctx.Tvals, $ctx.usft));
          $aload($get($ctx.Tvals, $ctx.i - 128));
          var _5R = $a();
          var _5S = $k[--$j];
          $put($k[--$j], _5S, _5R);
        }
        $k[$j++] = Infinity;
        $k[$j++] = 13;
        $k[$j++] = 0;
        $k[$j++] = 42;
        $k[$j++] = 1;
        $k[$j++] = 62;
        $k[$j++] = 2;
        $k[$j++] = 32;
        $k[$j++] = 3;
        for (var _5U = 48; _5U <= 57; _5U += 1) {
          $k[$j++] = _5U;
          $k[$j++] = _5U - 44;
        }
        for (var _5V = 65; _5V <= 90; _5V += 1) {
          $k[$j++] = _5V;
          $k[$j++] = _5V - 51;
        }
        $ctx.Xvals = $d();
        $k[$j++] = Infinity;
        var _5X = $ctx.Xvals;
        for (var _5c = _5X.size, _5b = _5X.keys(), _5a = 0; _5a < _5c; _5a++) {
          var _5Y = _5b.next().value;
          $k[$j++] = _5Y;
          $k[$j++] = _5X.get(_5Y);
          $k[$j++] = Infinity;
          var _5d = $k[--$j];
          var _5e = $k[--$j];
          $k[$j++] = _5d;
          $k[$j++] = _5e;
          var _5f = $a();
          $k[$j++] = _5f;
        }
        $ctx.Xvals = $d();
        $k[$j++] = Infinity;
        for (var _5h = 64; _5h <= 94; _5h += 1) {
          $k[$j++] = _5h;
          $k[$j++] = _5h - 64;
        }
        $k[$j++] = $ctx.unl;
        $k[$j++] = 31;
        for (var _5j = 32; _5j <= 63; _5j += 1) {
          $k[$j++] = _5j;
          $k[$j++] = _5j;
        }
        $ctx.Evals = $d();
        $k[$j++] = Infinity;
        var _5l = $ctx.Evals;
        for (var _5q = _5l.size, _5p = _5l.keys(), _5o = 0; _5o < _5q; _5o++) {
          var _5m = _5p.next().value;
          $k[$j++] = _5m;
          $k[$j++] = _5l.get(_5m);
          $k[$j++] = Infinity;
          var _5r = $k[--$j];
          var _5s = $k[--$j];
          $k[$j++] = _5r;
          $k[$j++] = _5s;
          var _5t = $a();
          $k[$j++] = _5t;
        }
        $ctx.Evals = $d();
        $k[$j++] = Infinity;
        for (var _5v = 0; _5v <= 255; _5v += 1) {
          $k[$j++] = _5v;
          $k[$j++] = _5v;
        }
        $ctx.Bvals = $d();
        $k[$j++] = Infinity;
        var _5x = $ctx.Bvals;
        for (var _62 = _5x.size, _61 = _5x.keys(), _60 = 0; _60 < _62; _60++) {
          var _5y = _61.next().value;
          $k[$j++] = _5y;
          $k[$j++] = _5x.get(_5y);
          $k[$j++] = Infinity;
          var _63 = $k[--$j];
          var _64 = $k[--$j];
          $k[$j++] = _63;
          $k[$j++] = _64;
          var _65 = $a();
          $k[$j++] = _65;
        }
        $ctx.Bvals = $d();
        $ctx.encvals = $a([$ctx.Avals, $ctx.Cvals, $ctx.Tvals, $ctx.Xvals, $ctx.Evals, $ctx.Bvals]);
        $ctx.A = 0;
        $ctx.C = 1;
        $ctx.T = 2;
        $ctx.X = 3;
        $ctx.E = 4;
        $ctx.B = 5;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_datamatrix.$ctx[id] = $ctx[id]);
        bwipp_datamatrix.__18615__ = 1;
      })();
    }
    if ($1.raw) {
      $1.cws = $a($1.barcode.length);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i == $1.barcode.length) {
          break;
        }
        $1.cw = $cvi($geti($1.barcode, $1.i + 1, 3));
        $put($1.cws, $1.j, $1.cw);
        $1.i = $1.i + 4;
        $1.j = $1.j + 1;
      }
      $1.cws = $geti($1.cws, 0, $1.j);
    } else {
      var _6Z = /* @__PURE__ */ new Map([
        ["parse", $1.parse],
        ["parsefnc", $1.parsefnc],
        ["eci", true],
        ["FNC1", $1.fnc1],
        ["PROG", $1.prog]
      ]);
      $1.fncvals = _6Z;
      $k[$j++] = "msg";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.fncvals;
      bwipp_parseinput();
      var _6c = $k[--$j];
      $1[$k[--$j]] = _6c;
      $1.msglen = $1.msg.length;
      if ($1.msglen >= 9) {
        $aload($geti($1.msg, 0, 7));
        var _6i = $k[--$j];
        var _6j = $k[--$j];
        $k[$j++] = _6i == 29;
        $k[$j++] = _6j;
        $j--;
        var _6k = $k[--$j];
        var _6l = $k[--$j];
        var _6m = $k[--$j];
        var _6n = $k[--$j];
        var _6o = $k[--$j];
        var _6p = $k[--$j];
        if (_6k && _6l == 48 && _6m == 30 && _6n == 62 && _6o == 41 && _6p == 91) {
          $aload($geti($1.msg, $1.msglen - 2, 2));
          var _6t = $k[--$j];
          var _6u = $k[--$j];
          if (_6t == 4 && _6u == 30) {
            if ($get($1.msg, 5) == 53) {
              $k[$j++] = Infinity;
              $k[$j++] = $1.m05;
              $aload($geti($1.msg, 7, $1.msg.length - 9));
              $1.msg = $a();
            } else {
              if ($get($1.msg, 5) == 54) {
                $k[$j++] = Infinity;
                $k[$j++] = $1.m06;
                $aload($geti($1.msg, 7, $1.msg.length - 9));
                $1.msg = $a();
              }
            }
          }
        }
      }
      $1.msglen = $1.msg.length;
      $k[$j++] = Infinity;
      for (var _7B = 0, _7C = $1.msglen; _7B < _7C; _7B++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numD = $a();
      $k[$j++] = Infinity;
      for (var _7F = 0, _7G = $1.msglen; _7F < _7G; _7F++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 9999;
      $1.nextXterm = $a();
      $k[$j++] = Infinity;
      for (var _7J = 0, _7K = $1.msglen; _7J < _7K; _7J++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 9999;
      $1.nextNonX = $a();
      $k[$j++] = Infinity;
      for (var _7N = 0, _7O = $1.msglen; _7N < _7O; _7N++) {
        $k[$j++] = false;
      }
      $k[$j++] = false;
      $1.isECI = $a();
      for (var _7R = $1.msglen - 1; _7R >= 0; _7R -= 1) {
        $1.i = _7R;
        $1.barchar = $get($1.msg, $1.i);
        if ($1.barchar >= 48 && $1.barchar <= 57) {
          $put($1.numD, $1.i, $f($get($1.numD, $1.i + 1) + 1));
        }
        if ($1.barchar == 13 || $1.barchar == 42 || $1.barchar == 62) {
          $put($1.nextXterm, $1.i, 0);
        } else {
          $put($1.nextXterm, $1.i, $f($get($1.nextXterm, $1.i + 1) + 1));
        }
        var _7o = $get($1.Xvals, $1.barchar) !== void 0;
        if (!_7o) {
          $put($1.nextNonX, $1.i, 0);
        } else {
          $put($1.nextNonX, $1.i, $f($get($1.nextNonX, $1.i + 1) + 1));
        }
        $put($1.isECI, $1.i, $1.barchar <= -1e6);
      }
      $k[$j++] = Infinity;
      var _7z = $1.nextXterm;
      for (var _80 = 0, _81 = _7z.length; _80 < _81; _80++) {
        var _82 = $get(_7z, _80);
        $k[$j++] = _82;
        if (_82 > 1e4) {
          $j--;
          $k[$j++] = 1e4;
        }
      }
      $1.nextXterm = $a();
      $k[$j++] = Infinity;
      var _84 = $1.nextNonX;
      for (var _85 = 0, _86 = _84.length; _85 < _86; _85++) {
        var _87 = $get(_84, _85);
        $k[$j++] = _87;
        if (_87 > 1e4) {
          $j--;
          $k[$j++] = 1e4;
        }
      }
      $1.nextNonX = $a();
      $1.isD = function() {
        $k[$j++] = $1.char >= 48 && $1.char <= 57;
      };
      $1.isC = function() {
        var _8D = $get($1.CNvals, $1.char) !== void 0;
        $k[$j++] = _8D;
      };
      $1.isT = function() {
        var _8G = $get($1.TNvals, $1.char) !== void 0;
        $k[$j++] = _8G;
      };
      $1.isX = function() {
        var _8J = $get($1.Xvals, $1.char) !== void 0;
        $k[$j++] = _8J;
      };
      $1.isE = function() {
        var _8M = $get($1.Evals, $1.char) !== void 0;
        $k[$j++] = _8M;
      };
      $1.isEA = function() {
        $k[$j++] = $1.char > 127;
      };
      $1.isFN = function() {
        $k[$j++] = $1.char < 0;
      };
      $1.XtermFirst = function() {
        var _8P = $k[--$j];
        $k[$j++] = $lt($get($1.nextXterm, _8P), $get($1.nextNonX, _8P));
      };
      $1.lookup = function() {
        $1.ac = 1;
        $1.cc = 2;
        $1.tc = 2;
        $1.xc = 2;
        $1.ec = 2;
        $1.bc = 2.25;
        if ($1.mode == $1.A) {
          $1.ac = 0;
          $1.cc = 1;
          $1.tc = 1;
          $1.xc = 1;
          $1.ec = 1;
          $1.bc = 1.25;
        }
        if ($1.mode == $1.C) {
          $1.cc = 0;
        }
        if ($1.mode == $1.T) {
          $1.tc = 0;
        }
        if ($1.mode == $1.X) {
          $1.xc = 0;
        }
        if ($1.mode == $1.E) {
          $1.ec = 0;
        }
        if ($1.mode == $1.B) {
          $1.bc = 0;
        }
        for (var _8g = 0, _8h = 1; _8g < _8h; _8g++) {
          if ($get($1.isECI, $1.i)) {
            $k[$j++] = $1.A;
            break;
          }
          if ($1.c40headerlength != -1 && $1.i < $1.c40headerlength) {
            $k[$j++] = $1.C;
            break;
          }
          $1.k = 0;
          for (; ; ) {
            if ($1.i + $1.k == $1.msglen) {
              var _8t = $a(["ac", "cc", "tc", "xc", "ec", "bc"]);
              for (var _8u = 0, _8v = _8t.length; _8u < _8v; _8u++) {
                var _8w = $get(_8t, _8u);
                $1[_8w] = Math.ceil($1[_8w]);
              }
              var _93 = $a([$1.cc, $1.tc, $1.xc, $1.ec, $1.bc]);
              $k[$j++] = true;
              for (var _94 = 0, _95 = _93.length; _94 < _95; _94++) {
                var _98 = $k[--$j];
                $k[$j++] = _98 && $1.ac <= $get(_93, _94);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.A;
                break;
              }
              var _9G = $a([$1.ac, $1.cc, $1.tc, $1.xc, $1.ec]);
              $k[$j++] = true;
              for (var _9H = 0, _9I = _9G.length; _9H < _9I; _9H++) {
                var _9L = $k[--$j];
                $k[$j++] = _9L && $1.bc < $get(_9G, _9H);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.B;
                break;
              }
              var _9T = $a([$1.ac, $1.cc, $1.tc, $1.xc, $1.bc]);
              $k[$j++] = true;
              for (var _9U = 0, _9V = _9T.length; _9U < _9V; _9U++) {
                var _9Y = $k[--$j];
                $k[$j++] = _9Y && $1.ec < $get(_9T, _9U);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.E;
                break;
              }
              var _9g = $a([$1.ac, $1.cc, $1.xc, $1.ec, $1.bc]);
              $k[$j++] = true;
              for (var _9h = 0, _9i = _9g.length; _9h < _9i; _9h++) {
                var _9l = $k[--$j];
                $k[$j++] = _9l && $1.tc < $get(_9g, _9h);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.T;
                break;
              }
              var _9t = $a([$1.ac, $1.cc, $1.tc, $1.ec, $1.bc]);
              $k[$j++] = true;
              for (var _9u = 0, _9v = _9t.length; _9u < _9v; _9u++) {
                var _9y = $k[--$j];
                $k[$j++] = _9y && $1.xc < $get(_9t, _9u);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.X;
                break;
              }
              $k[$j++] = $1.C;
              break;
            }
            $1.char = $get($1.msg, $1.i + $1.k);
            $k[$j++] = "ac";
            $k[$j++] = $1.ac;
            $1.isD();
            if ($k[--$j]) {
              var _A8 = $k[--$j];
              $k[$j++] = $f(_A8 + 1 / 2);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _AA = $k[--$j];
                $k[$j++] = Math.ceil(_AA) + 2;
              } else {
                var _AB = $k[--$j];
                $k[$j++] = Math.ceil(_AB) + 1;
              }
            }
            var _AC = $k[--$j];
            $1[$k[--$j]] = _AC;
            $k[$j++] = "cc";
            $k[$j++] = $1.cc;
            $1.isC();
            if ($k[--$j]) {
              var _AG = $k[--$j];
              $k[$j++] = $f(_AG + 0.6666667);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _AI = $k[--$j];
                $k[$j++] = $f(_AI + 2.6666667);
              } else {
                var _AJ = $k[--$j];
                $k[$j++] = $f(_AJ + 1.3333334);
              }
            }
            var _AK = $k[--$j];
            $1[$k[--$j]] = _AK;
            $k[$j++] = "tc";
            $k[$j++] = $1.tc;
            $1.isT();
            if ($k[--$j]) {
              var _AO = $k[--$j];
              $k[$j++] = $f(_AO + 0.6666667);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _AQ = $k[--$j];
                $k[$j++] = $f(_AQ + 2.6666667);
              } else {
                var _AR = $k[--$j];
                $k[$j++] = $f(_AR + 1.3333334);
              }
            }
            var _AS = $k[--$j];
            $1[$k[--$j]] = _AS;
            $k[$j++] = "xc";
            $k[$j++] = $1.xc;
            $1.isX();
            if ($k[--$j]) {
              var _AW = $k[--$j];
              $k[$j++] = $f(_AW + 0.6666667);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _AY = $k[--$j];
                $k[$j++] = $f(_AY + 4.3333334);
              } else {
                var _AZ = $k[--$j];
                $k[$j++] = $f(_AZ + 3.3333334);
              }
            }
            var _Aa = $k[--$j];
            $1[$k[--$j]] = _Aa;
            $k[$j++] = "ec";
            $k[$j++] = $1.ec;
            $1.isE();
            if ($k[--$j]) {
              var _Ae = $k[--$j];
              $k[$j++] = $f(_Ae + 3 / 4);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _Ag = $k[--$j];
                $k[$j++] = $f(_Ag + 17 / 4);
              } else {
                var _Ah = $k[--$j];
                $k[$j++] = $f(_Ah + 13 / 4);
              }
            }
            var _Ai = $k[--$j];
            $1[$k[--$j]] = _Ai;
            $k[$j++] = "bc";
            $k[$j++] = $1.bc;
            $1.isFN();
            if ($k[--$j]) {
              var _Am = $k[--$j];
              $k[$j++] = $f(_Am + 4);
            } else {
              var _An = $k[--$j];
              $k[$j++] = $f(_An + 1);
            }
            var _Ao = $k[--$j];
            $1[$k[--$j]] = _Ao;
            if ($1.k >= 4) {
              var _Aw = $a([$1.cc, $1.tc, $1.xc, $1.ec, $1.bc]);
              $k[$j++] = true;
              for (var _Ax = 0, _Ay = _Aw.length; _Ax < _Ay; _Ax++) {
                var _B1 = $k[--$j];
                $k[$j++] = _B1 && $1.ac + 1 <= $get(_Aw, _Ax);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.A;
                break;
              }
              if ($1.bc + 1 <= $1.ac) {
                $k[$j++] = $1.B;
                break;
              }
              var _BB = $a([$1.cc, $1.tc, $1.xc, $1.ec]);
              $k[$j++] = true;
              for (var _BC = 0, _BD = _BB.length; _BC < _BD; _BC++) {
                var _BG = $k[--$j];
                $k[$j++] = _BG && $1.bc + 1 < $get(_BB, _BC);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.B;
                break;
              }
              var _BO = $a([$1.ac, $1.cc, $1.tc, $1.xc, $1.bc]);
              $k[$j++] = true;
              for (var _BP = 0, _BQ = _BO.length; _BP < _BQ; _BP++) {
                var _BT = $k[--$j];
                $k[$j++] = _BT && $1.ec + 1 < $get(_BO, _BP);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.E;
                break;
              }
              var _Bb = $a([$1.ac, $1.cc, $1.xc, $1.ec, $1.bc]);
              $k[$j++] = true;
              for (var _Bc = 0, _Bd = _Bb.length; _Bc < _Bd; _Bc++) {
                var _Bg = $k[--$j];
                $k[$j++] = _Bg && $1.tc + 1 < $get(_Bb, _Bc);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.T;
                break;
              }
              var _Bo = $a([$1.ac, $1.cc, $1.tc, $1.ec, $1.bc]);
              $k[$j++] = true;
              for (var _Bp = 0, _Bq = _Bo.length; _Bp < _Bq; _Bp++) {
                var _Bt = $k[--$j];
                $k[$j++] = _Bt && $1.xc + 1 < $get(_Bo, _Bp);
              }
              if ($k[--$j]) {
                $k[$j++] = $1.X;
                break;
              }
              var _C0 = $a([$1.ac, $1.tc, $1.ec, $1.bc]);
              $k[$j++] = true;
              for (var _C1 = 0, _C2 = _C0.length; _C1 < _C2; _C1++) {
                var _C5 = $k[--$j];
                $k[$j++] = _C5 && $1.cc + 1 < $get(_C0, _C1);
              }
              if ($k[--$j]) {
                if ($1.cc < $1.xc) {
                  $k[$j++] = $1.C;
                  break;
                }
                if ($1.cc == $1.xc) {
                  $k[$j++] = $1.i + $1.k + 1;
                  $1.XtermFirst();
                  if ($k[--$j]) {
                    $k[$j++] = $1.X;
                    break;
                  } else {
                    $k[$j++] = $1.C;
                    break;
                  }
                }
              }
            }
            $1.k = $1.k + 1;
          }
        }
      };
      $1.addtocws = function() {
        var _CI = $k[--$j];
        $puti($1.cws, $1.j, _CI);
        $1.j = _CI.length + $1.j;
      };
      $1.ECItocws = function() {
        var _CN = $f(-$k[--$j] - 1e6);
        $k[$j++] = _CN;
        if (_CN <= 126) {
          var _CO = $k[--$j];
          $k[$j++] = $f(_CO + 1);
          $astore($a(1));
        } else {
          var _CQ = $k[--$j];
          $k[$j++] = _CQ;
          if (_CQ <= 16382) {
            var _CS = $f($k[--$j] - 127);
            $k[$j++] = ~~(_CS / 254) + 128;
            $k[$j++] = $f(_CS % 254 + 1);
            $astore($a(2));
          } else {
            var _CV = $f($k[--$j] - 16383);
            $k[$j++] = ~~(_CV / 64516) + 192;
            $k[$j++] = ~~(_CV / 254) % 254 + 1;
            $k[$j++] = $f(_CV % 254 + 1);
            $astore($a(3));
          }
        }
      };
      $1.encA = function() {
        for (var _CX = 0, _CY = 1; _CX < _CY; _CX++) {
          if ($get($1.isECI, $1.i)) {
            $k[$j++] = $get($1.Avals, $1.eci);
            $1.addtocws();
            $k[$j++] = $get($1.msg, $1.i);
            $1.ECItocws();
            $1.addtocws();
            $1.i = $1.i + 1;
            break;
          }
          if ($get($1.numD, $1.i) >= 2) {
            var _Cm = $s(2);
            $put(_Cm, 0, $get($1.msg, $1.i));
            $put(_Cm, 1, $get($1.msg, $1.i + 1));
            $k[$j++] = $get($1.Avals, _Cm);
            $1.addtocws();
            $1.i = $1.i + 2;
            break;
          }
          $k[$j++] = "newmode";
          $1.lookup();
          var _Cw = $k[--$j];
          $1[$k[--$j]] = _Cw;
          if ($1.newmode != $1.mode) {
            $k[$j++] = $get($1.Avals, $get($a([-1, $1.lC, $1.lT, $1.lX, $1.lE, $1.lB]), $1.newmode));
            $1.addtocws();
            $1.mode = $1.newmode;
            break;
          }
          $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
          $1.addtocws();
          $1.i = $1.i + 1;
          break;
        }
      };
      $1.CTXvalstocws = function() {
        $1.in = $k[--$j];
        $k[$j++] = Infinity;
        for (var _DK = 0, _DJ = $1.in.length - 1; _DK <= _DJ; _DK += 3) {
          var _DM = $geti($1.in, _DK, 3);
          $k[$j++] = 0;
          for (var _DN = 0, _DO = _DM.length; _DN < _DO; _DN++) {
            var _DQ = $k[--$j];
            $k[$j++] = $f(_DQ + $get(_DM, _DN)) * 40;
          }
          var _DS = ~~($k[--$j] / 40) + 1;
          $k[$j++] = ~~(_DS / 256);
          $k[$j++] = _DS % 256;
        }
        $astore($a($counttomark()));
        var _DV = $k[--$j];
        var _DW = $k[--$j];
        $k[$j++] = _DV;
        $k[$j++] = _DW;
        $j--;
      };
      $1.encCTX = function() {
        $1.p = 0;
        $1.ctxvals = $a(2500);
        $1.done = false;
        for (; ; ) {
          if ($1.i == $1.msglen) {
            break;
          }
          var _Dg = $get($get($1.encvals, $1.mode), $get($1.msg, $1.i)) !== void 0;
          if (!_Dg) {
            break;
          }
          if ($1.p % 3 == 0) {
            if ($1.p > 0) {
              $k[$j++] = "newmode";
              $1.lookup();
              var _Dj = $k[--$j];
              $1[$k[--$j]] = _Dj;
              if ($ne($1.newmode, $1.mode)) {
                $k[$j++] = $geti($1.ctxvals, 0, $1.p);
                $1.CTXvalstocws();
                $1.addtocws();
                $k[$j++] = $a([$1.unlcw]);
                $1.addtocws();
                if ($1.newmode != $1.A) {
                  $k[$j++] = $get($1.Avals, $get($a([-1, $1.lC, $1.lT, $1.lX, $1.lE, $1.lB]), $1.newmode));
                  $1.addtocws();
                }
                $1.mode = $1.newmode;
                $1.done = true;
                break;
              }
            }
            if ($1.msglen - $1.i <= 3) {
              $1.remcws = $get($1.numremcws, $1.j + ~~($1.p / 3) * 2);
              $k[$j++] = Infinity;
              var _EF = $geti($1.msg, $1.i, $1.msglen - $1.i);
              for (var _EG = 0, _EH = _EF.length; _EG < _EH; _EG++) {
                var _EI = $get(_EF, _EG);
                var _EM = $get($get($1.encvals, $1.mode), _EI) !== void 0;
                $k[$j++] = _EI;
                if (_EM) {
                  $aload($get($get($1.encvals, $1.mode), $k[--$j]));
                } else {
                  $j--;
                  $k[$j++] = -1;
                  $k[$j++] = -1;
                  $k[$j++] = -1;
                  $k[$j++] = -1;
                }
              }
              $1.remvals = $a();
              if ($1.remcws == 2 && $1.remvals.length == 3) {
                $k[$j++] = Infinity;
                $aload($geti($1.ctxvals, 0, $1.p));
                $aload($1.remvals);
                var _EZ = $a();
                $k[$j++] = _EZ;
                $1.CTXvalstocws();
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                $1.done = true;
                break;
              }
              if ($1.remcws == 2 && $1.remvals.length == 2 && $1.mode != $1.X) {
                $k[$j++] = Infinity;
                $aload($geti($1.ctxvals, 0, $1.p));
                $aload($1.remvals);
                $aload($get($get($1.encvals, $1.mode), $1.sft1));
                var _Ep = $a();
                $k[$j++] = _Ep;
                $1.CTXvalstocws();
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                $1.done = true;
                break;
              }
              if ($1.remcws == 2 && $1.remvals.length == 1) {
                $k[$j++] = $geti($1.ctxvals, 0, $1.p);
                $1.CTXvalstocws();
                $1.addtocws();
                $k[$j++] = $a([$1.unlcw]);
                $1.addtocws();
                $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                $1.done = true;
                break;
              }
              if ($1.remcws == 1 && $1.remvals.length == 1) {
                $k[$j++] = $geti($1.ctxvals, 0, $1.p);
                $1.CTXvalstocws();
                $1.addtocws();
                $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                $1.done = true;
                break;
              }
            }
          }
          var _FO = $get($get($1.encvals, $1.mode), $get($1.msg, $1.i));
          $puti($1.ctxvals, $1.p, _FO);
          $1.p = _FO.length + $1.p;
          $1.i = $1.i + 1;
        }
        if (!$1.done) {
          for (; ; ) {
            if ($1.p % 3 == 0) {
              break;
            }
            $1.i = $1.i - 1;
            $1.p = $1.p - $get($get($1.encvals, $1.mode), $get($1.msg, $1.i)).length;
          }
          $k[$j++] = Infinity;
          $aload($geti($1.ctxvals, 0, $1.p));
          var _Fh = $a();
          $k[$j++] = _Fh;
          $1.CTXvalstocws();
          $1.addtocws();
          $k[$j++] = $a([$1.unlcw]);
          $1.addtocws();
          $1.mode = $1.A;
          if ($1.i != $1.msglen && $nt($get($1.isECI, $1.i))) {
            if ($get($1.numD, $1.i) >= 2) {
              var _Ft = $s(2);
              $put(_Ft, 0, $get($1.msg, $1.i));
              $put(_Ft, 1, $get($1.msg, $1.i + 1));
              $k[$j++] = $get($1.Avals, _Ft);
              $1.addtocws();
              $1.i = $1.i + 2;
            } else {
              $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
              $1.addtocws();
              $1.i = $1.i + 1;
            }
          }
        }
      };
      $1.Evalstocws = function() {
        $1.in = $k[--$j];
        $1.inlen = $1.in.length;
        $1.outlen = ~~Math.ceil($1.in.length / 4 * 3);
        $k[$j++] = Infinity;
        $aload($1.in);
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $1.in = $a();
        $k[$j++] = Infinity;
        for (var _GG = 0, _GF = $1.inlen - 1; _GG <= _GF; _GG += 4) {
          var _GI = $geti($1.in, _GG, 4);
          $k[$j++] = 0;
          for (var _GJ = 0, _GK = _GI.length; _GJ < _GK; _GJ++) {
            var _GM = $k[--$j];
            $k[$j++] = $or(_GM, $get(_GI, _GJ)) << 6;
          }
          var _GO = $k[--$j] >>> 6;
          $k[$j++] = _GO >>> 16 & 255;
          $k[$j++] = _GO >>> 8 & 255;
          $k[$j++] = _GO & 255;
        }
        $astore($a($counttomark()));
        var _GR = $k[--$j];
        var _GS = $k[--$j];
        $k[$j++] = _GR;
        $k[$j++] = _GS;
        $j--;
        var _GV = $geti($k[--$j], 0, $1.outlen);
        $k[$j++] = _GV;
      };
      $1.encE = function() {
        $1.p = 0;
        $1.edifactvals = $a(2100);
        for (; ; ) {
          if ($1.i == $1.msglen) {
            break;
          }
          var _Gd = $get($1.Evals, $get($1.msg, $1.i)) !== void 0;
          if (!_Gd) {
            break;
          }
          if ($1.p % 4 == 0) {
            if ($1.msglen - $1.i <= 2) {
              $1.remcws = $get($1.numremcws, $1.j + ~~($1.p / 4) * 3);
              $k[$j++] = Infinity;
              var _Gp = $geti($1.msg, $1.i, $1.msglen - $1.i);
              for (var _Gq = 0, _Gr = _Gp.length; _Gq < _Gr; _Gq++) {
                $aload($get($1.Avals, $get(_Gp, _Gq)));
              }
              $1.remvals = $a();
              if (($1.remcws == 1 || $1.remcws == 2) && $1.remvals.length <= $1.remcws) {
                $k[$j++] = $geti($1.edifactvals, 0, $1.p);
                $1.Evalstocws();
                $1.addtocws();
                $k[$j++] = $1.remvals;
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                break;
              }
            }
            $1.lookup();
            if ($k[--$j] != $1.mode) {
              break;
            }
          }
          var _HC = $get($1.Evals, $get($1.msg, $1.i));
          $puti($1.edifactvals, $1.p, _HC);
          $1.p = _HC.length + $1.p;
          $1.i = $1.i + 1;
        }
        if ($1.mode != $1.A) {
          $1.remcws = $f($get($1.numremcws, $1.j + ~~($1.p / 4) * 3 - 1) - 1);
          if ($1.p % 4 != 0 || $1.i != $1.msglen || $1.remcws >= 3) {
            var _HT = $get($1.Evals, $1.unl);
            $puti($1.edifactvals, $1.p, _HT);
            $1.p = _HT.length + $1.p;
          }
          $k[$j++] = $geti($1.edifactvals, 0, $1.p);
          $1.Evalstocws();
          $1.addtocws();
          $1.mode = $1.A;
          if ($1.i != $1.msglen && $nt($get($1.isECI, $1.i))) {
            if ($get($1.numD, $1.i) >= 2) {
              var _Hj = $s(2);
              $put(_Hj, 0, $get($1.msg, $1.i));
              $put(_Hj, 1, $get($1.msg, $1.i + 1));
              $k[$j++] = $get($1.Avals, _Hj);
              $1.addtocws();
              $1.i = $1.i + 2;
            } else {
              $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
              $1.addtocws();
              $1.i = $1.i + 1;
            }
          }
        }
      };
      $1.encB = function() {
        $1.p = 0;
        $1.bvals = $a(1558);
        for (; ; ) {
          if ($1.i == $1.msglen) {
            break;
          }
          $1.lookup();
          if ($k[--$j] != $1.mode) {
            break;
          }
          $put($1.bvals, $1.p, $get($1.msg, $1.i));
          $1.p = $1.p + 1;
          $1.i = $1.i + 1;
        }
        $1.remcws = $f($get($1.numremcws, $1.j + $1.p) - 1);
        $k[$j++] = Infinity;
        if ($1.remcws == 0 && $1.i == $1.msglen) {
          $k[$j++] = 0;
        } else {
          if ($1.p < 250) {
            $k[$j++] = $1.p;
          } else {
            $k[$j++] = ~~($1.p / 250) + 249;
            $k[$j++] = $1.p % 250;
          }
        }
        $aload($geti($1.bvals, 0, $1.p));
        $1.bvals = $a();
        for (var _IS = 0, _IR = $1.bvals.length - 1; _IS <= _IR; _IS += 1) {
          $1.p = _IS;
          var _IY = $f(($1.j + $1.p + 1) * 149 % 255 + 1 + $get($1.bvals, $1.p));
          $k[$j++] = _IY;
          if (_IY >= 256) {
            var _IZ = $k[--$j];
            $k[$j++] = $f(_IZ - 256);
          }
          $put($1.bvals, $1.p, $k[--$j]);
        }
        $k[$j++] = $1.bvals;
        $1.addtocws();
        $1.mode = $1.A;
      };
      $1.cws = $a(1558);
      $1.mode = $1.A;
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i >= $1.msglen) {
          break;
        }
        if ($1[$get($a(["encA", "encCTX", "encCTX", "encCTX", "encE", "encB"]), $1.mode)]() === true) {
          break;
        }
      }
      $1.cws = $geti($1.cws, 0, $1.j);
    }
    $1.datlen = $1.cws.length;
    $1.remcws = $f($get($1.numremcws, $1.j - 1) - 1);
    if ($1.remcws > 0) {
      $k[$j++] = Infinity;
      $aload($1.cws);
      for (var _Ix = 0, _Iy = $1.remcws; _Ix < _Iy; _Ix++) {
        $k[$j++] = 129;
      }
      $1.cws = $a();
      for (var _J4 = $1.datlen + 1, _J3 = $f($f($1.datlen + $1.remcws) - 1); _J4 <= _J3; _J4 += 1) {
        $1.i = _J4;
        var _J6 = ($1.i + 1) * 149 % 253 + 1 + 129;
        $k[$j++] = _J6;
        if (_J6 > 254) {
          var _J7 = $k[--$j];
          $k[$j++] = $f(_J7 - 254);
        }
        $put($1.cws, $1.i, $k[--$j]);
      }
    }
    var _JC = $get($1.options, "debugcws") !== void 0;
    if (_JC) {
      $k[$j++] = "bwipp.debugcws#19036";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    var _JE = $1.metrics;
    for (var _JF = 0, _JG = _JE.length; _JF < _JG; _JF++) {
      $1.m = $get(_JE, _JF);
      $1.rows = $get($1.m, 0);
      $1.cols = $get($1.m, 1);
      $1.regh = $get($1.m, 2);
      $1.regv = $get($1.m, 3);
      $1.rscw = $get($1.m, 4);
      $1.rsbl = $get($1.m, 5);
      $1.doly = $get($1.m, 6);
      $1.mrows = $f($1.rows - 2 * $1.regh);
      $1.mcols = $f($1.cols - 2 * $1.regv);
      $1.rrows = ~~($1.mrows / $1.regh);
      $1.rcols = ~~($1.mcols / $1.regv);
      $1.ncws = $f(~~($1.mrows * $1.mcols / 8) - $1.rscw);
      $1.okay = true;
      if ($1.cws.length != $1.ncws) {
        $1.okay = false;
      }
      if ($1.urows != 0 && $1.urows != $1.rows) {
        $1.okay = false;
      }
      if ($1.ucols != 0 && $1.ucols != $1.cols) {
        $1.okay = false;
      }
      if ($eq($1.format, "square") && $ne($1.rows, $1.cols)) {
        $1.okay = false;
      }
      if ($eq($1.format, "rectangle") && $eq($1.rows, $1.cols)) {
        $1.okay = false;
      }
      if (!$1.dmre && $1.doly == 1) {
        $1.okay = false;
      }
      if ($1.okay) {
        break;
      }
    }
    if (!$1.okay) {
      $k[$j++] = "bwipp.datamatrixNoValidSymbol#19064";
      $k[$j++] = "Maximum length exceeded or invalid size";
      bwipp_raiseerror();
    }
    $1.cwbs = $a($1.rsbl);
    $1.ecbs = $a($1.rsbl);
    for (var _K5 = 0, _K4 = $f($1.rsbl - 1); _K5 <= _K4; _K5 += 1) {
      $1.i = _K5;
      if ($1.cws.length != 1558) {
        $1.cwbsize = ~~($1.cws.length / $1.rsbl);
      } else {
        if ($1.i <= 7) {
          $1.cwbsize = 156;
        } else {
          $1.cwbsize = 155;
        }
      }
      $1.cwb = $a($1.cwbsize);
      for (var _KE = 0, _KD = $1.cwbsize - 1; _KE <= _KD; _KE += 1) {
        $1.j = _KE;
        $put($1.cwb, $1.j, $get($1.cws, $f($1.j * $1.rsbl + $1.i)));
      }
      $put($1.cwbs, $1.i, $1.cwb);
      $k[$j++] = $1.ecbs;
      $k[$j++] = $1.i;
      $k[$j++] = Infinity;
      for (var _KT = 0, _KU = ~~($1.rscw / $1.rsbl); _KT < _KU; _KT++) {
        $k[$j++] = 0;
      }
      var _KV = $a();
      var _KW = $k[--$j];
      $put($k[--$j], _KW, _KV);
    }
    if (!bwipp_datamatrix.__19091__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        $k[$j++] = 1;
        for (var _KY = 0, _KZ = 255; _KY < _KZ; _KY++) {
          var _Ka = $k[--$j];
          var _Kb = _Ka * 2;
          $k[$j++] = _Ka;
          $k[$j++] = _Kb;
          if (_Kb >= 256) {
            var _Kc = $k[--$j];
            $k[$j++] = _Kc ^ 301;
          }
        }
        $ctx.rsalog = $a();
        $ctx.rslog = $a(256);
        for (var _Kf = 1; _Kf <= 255; _Kf += 1) {
          $put($ctx.rslog, $get($ctx.rsalog, _Kf), _Kf);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_datamatrix.$ctx[id] = $ctx[id]);
        bwipp_datamatrix.__19091__ = 1;
      })();
    }
    $1.rsprod = function() {
      var _Kk = $k[--$j];
      var _Kl = $k[--$j];
      $k[$j++] = _Kl;
      $k[$j++] = _Kk;
      if (_Kk != 0 && _Kl != 0) {
        var _Ko = $get($1.rslog, $k[--$j]);
        var _Kt = $get($1.rsalog, $f(_Ko + $get($1.rslog, $k[--$j])) % 255);
        $k[$j++] = _Kt;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _Kw = 0, _Kx = ~~($1.rscw / $1.rsbl); _Kw < _Kx; _Kw++) {
      $k[$j++] = 0;
    }
    $1.coeffs = $a();
    for (var _L2 = 1, _L1 = ~~($1.rscw / $1.rsbl); _L2 <= _L1; _L2 += 1) {
      $1.i = _L2;
      $put($1.coeffs, $1.i, $get($1.coeffs, $1.i - 1));
      for (var _L9 = $1.i - 1; _L9 >= 1; _L9 -= 1) {
        $1.j = _L9;
        $k[$j++] = $1.coeffs;
        $k[$j++] = $1.j;
        $k[$j++] = $get($1.coeffs, $1.j - 1);
        $k[$j++] = $get($1.coeffs, $1.j);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _LL = $k[--$j];
        var _LM = $k[--$j];
        var _LN = $k[--$j];
        $put($k[--$j], _LN, $xo(_LM, _LL));
      }
      $k[$j++] = $1.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($1.coeffs, 0);
      $k[$j++] = $get($1.rsalog, $1.i);
      $1.rsprod();
      var _LV = $k[--$j];
      var _LW = $k[--$j];
      $put($k[--$j], _LW, _LV);
    }
    $1.coeffs = $geti($1.coeffs, 0, $1.coeffs.length - 1);
    for (var _Ld = 0, _Lc = $1.cwbs.length - 1; _Ld <= _Lc; _Ld += 1) {
      $1.i = _Ld;
      $1.cwb = $get($1.cwbs, $1.i);
      $1.ecb = $get($1.ecbs, $1.i);
      for (var _Lm = 0, _Ll = $1.cwb.length - 1; _Lm <= _Ll; _Lm += 1) {
        $1.t = $xo($get($1.cwb, _Lm), $get($1.ecb, 0));
        for (var _Ls = $1.ecb.length - 1; _Ls >= 0; _Ls -= 1) {
          $1.j = _Ls;
          $1.p = $1.ecb.length - $1.j - 1;
          $k[$j++] = $1.ecb;
          $k[$j++] = $1.p;
          $k[$j++] = $1.t;
          $k[$j++] = $get($1.coeffs, $1.j);
          $1.rsprod();
          var _M1 = $k[--$j];
          var _M2 = $k[--$j];
          $put($k[--$j], _M2, _M1);
          if ($1.j > 0) {
            $put($1.ecb, $1.p, $xo($get($1.ecb, $1.p + 1), $get($1.ecb, $1.p)));
          }
        }
      }
    }
    if ($1.ncws == 1558) {
      $k[$j++] = Infinity;
      var _MF = $geti($1.ecbs, 8, 2);
      for (var _MG = 0, _MH = _MF.length; _MG < _MH; _MG++) {
        $k[$j++] = $get(_MF, _MG);
      }
      var _MK = $geti($1.ecbs, 0, 8);
      for (var _ML = 0, _MM = _MK.length; _ML < _MM; _ML++) {
        $k[$j++] = $get(_MK, _ML);
      }
      $1.ecbs = $a();
    }
    $k[$j++] = Infinity;
    var _MP = $1.cws;
    for (var _MQ = 0, _MR = _MP.length; _MQ < _MR; _MQ++) {
      $k[$j++] = $get(_MP, _MQ);
    }
    for (var _MU = 0, _MV = $1.rscw; _MU < _MV; _MU++) {
      $k[$j++] = 0;
    }
    $1.cws = $a();
    for (var _MZ = 0, _MY = $f($1.rscw - 1); _MZ <= _MY; _MZ += 1) {
      $1.i = _MZ;
      $put($1.cws, $f($1.ncws + $1.i), $get($get($1.ecbs, $1.i % $1.rsbl), ~~($1.i / $1.rsbl)));
    }
    $1.module = function() {
      var _Mk = $k[--$j];
      var _Ml = $k[--$j];
      var _Mm = $k[--$j];
      var _Mp = $strcpy($s(8), "00000000");
      var _Mr = $cvrs($s(8), $k[--$j], 2);
      $puti(_Mp, 8 - _Mr.length, _Mr);
      $k[$j++] = _Mm;
      $k[$j++] = _Ml;
      $k[$j++] = _Mk;
      $k[$j++] = _Mp;
      for (var _Ms = 7; _Ms >= 0; _Ms -= 1) {
        var _Mt = $k[--$j];
        $k[$j++] = $f($get(_Mt, _Ms) - 48);
        $k[$j++] = _Mt;
      }
      $j--;
      var _Mv = $k[--$j];
      var _Mw = $k[--$j];
      var _Mx = $k[--$j];
      var _My = $k[--$j];
      var _Mz = $k[--$j];
      var _N0 = $k[--$j];
      var _N1 = $k[--$j];
      var _N2 = $k[--$j];
      var _N3 = $k[--$j];
      var _N4 = $k[--$j];
      var _N5 = $k[--$j];
      $k[$j++] = _N2;
      $k[$j++] = _N1;
      $k[$j++] = _N0;
      $k[$j++] = _Mz;
      $k[$j++] = _My;
      $k[$j++] = _Mx;
      $k[$j++] = _Mw;
      $k[$j++] = _Mv;
      $k[$j++] = _N5;
      $k[$j++] = _N4;
      $forall(_N3, function() {
        if ($k[--$j]() === true) {
          return true;
        }
        var _N7 = $k[--$j];
        var _N8 = $k[--$j];
        $k[$j++] = _N8;
        $k[$j++] = _N7;
        if (_N8 < 0) {
          var _N9 = $k[--$j];
          var _NA = $k[--$j];
          $k[$j++] = $f(_NA + $1.mrows);
          $k[$j++] = $f(_N9 + $f(4 - $f($1.mrows + 4) % 8));
        }
        var _ND = $k[--$j];
        $k[$j++] = _ND;
        if (_ND < 0) {
          var _NF = $k[--$j];
          var _NG = $k[--$j];
          $k[$j++] = $f(_NG + $f(4 - $f($1.mcols + 4) % 8));
          $k[$j++] = $f(_NF + $1.mcols);
        }
        var _NI = $k[--$j];
        var _NJ = $k[--$j];
        $k[$j++] = _NJ;
        $k[$j++] = _NI;
        if (_NJ >= $1.mrows) {
          var _NL = $k[--$j];
          var _NM = $k[--$j];
          $k[$j++] = $f(_NM - $1.mrows);
          $k[$j++] = _NL;
        }
        var _NO = $k[--$j];
        var _NP = $k[--$j];
        var _NS = $k[--$j];
        var _NT = $k[--$j];
        $put($1.mmat, $f(_NO + _NP * $1.mcols), $k[--$j]);
        $k[$j++] = _NT;
        $k[$j++] = _NS;
      });
    };
    var _Nl = $a([function() {
      var _NV = $k[--$j];
      var _NW = $k[--$j];
      $k[$j++] = _NW;
      $k[$j++] = _NV;
      $k[$j++] = $f(_NW - 2);
      $k[$j++] = $f(_NV - 2);
    }, function() {
      var _NX = $k[--$j];
      var _NY = $k[--$j];
      $k[$j++] = _NY;
      $k[$j++] = _NX;
      $k[$j++] = $f(_NY - 2);
      $k[$j++] = $f(_NX - 1);
    }, function() {
      var _NZ = $k[--$j];
      var _Na = $k[--$j];
      $k[$j++] = _Na;
      $k[$j++] = _NZ;
      $k[$j++] = $f(_Na - 1);
      $k[$j++] = $f(_NZ - 2);
    }, function() {
      var _Nb = $k[--$j];
      var _Nc = $k[--$j];
      $k[$j++] = _Nc;
      $k[$j++] = _Nb;
      $k[$j++] = $f(_Nc - 1);
      $k[$j++] = $f(_Nb - 1);
    }, function() {
      var _Nd = $k[--$j];
      var _Ne = $k[--$j];
      $k[$j++] = _Ne;
      $k[$j++] = _Nd;
      $k[$j++] = $f(_Ne - 1);
      $k[$j++] = _Nd;
    }, function() {
      var _Nf = $k[--$j];
      var _Ng = $k[--$j];
      $k[$j++] = _Ng;
      $k[$j++] = _Nf;
      $k[$j++] = _Ng;
      $k[$j++] = $f(_Nf - 2);
    }, function() {
      var _Nh = $k[--$j];
      var _Ni = $k[--$j];
      $k[$j++] = _Ni;
      $k[$j++] = _Nh;
      $k[$j++] = _Ni;
      $k[$j++] = $f(_Nh - 1);
    }, function() {
      var _Nj = $k[--$j];
      var _Nk = $k[--$j];
      $k[$j++] = _Nk;
      $k[$j++] = _Nj;
      $k[$j++] = _Nk;
      $k[$j++] = _Nj;
    }]);
    $1.dmn = _Nl;
    var _Nu = $a([function() {
      $k[$j++] = $f($1.mrows - 1);
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = $f($1.mrows - 1);
      $k[$j++] = 1;
    }, function() {
      $k[$j++] = $f($1.mrows - 1);
      $k[$j++] = 2;
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 2);
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 1;
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 2;
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 3;
      $k[$j++] = $f($1.mcols - 1);
    }]);
    $1.dmc1 = _Nu;
    var _O3 = $a([function() {
      $k[$j++] = $f($1.mrows - 3);
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = $f($1.mrows - 2);
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = $f($1.mrows - 1);
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 4);
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 3);
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 2);
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 1;
      $k[$j++] = $f($1.mcols - 1);
    }]);
    $1.dmc2 = _O3;
    var _OC = $a([function() {
      $k[$j++] = $f($1.mrows - 3);
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = $f($1.mrows - 2);
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = $f($1.mrows - 1);
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 2);
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 1;
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 2;
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 3;
      $k[$j++] = $f($1.mcols - 1);
    }]);
    $1.dmc3 = _OC;
    var _OM = $a([function() {
      $k[$j++] = $f($1.mrows - 1);
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = $f($1.mrows - 1);
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 3);
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 2);
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = $f($1.mcols - 1);
    }, function() {
      $k[$j++] = 1;
      $k[$j++] = $f($1.mcols - 3);
    }, function() {
      $k[$j++] = 1;
      $k[$j++] = $f($1.mcols - 2);
    }, function() {
      $k[$j++] = 1;
      $k[$j++] = $f($1.mcols - 1);
    }]);
    $1.dmc4 = _OM;
    $k[$j++] = Infinity;
    for (var _OP = 0, _OQ = $1.mrows * $1.mcols; _OP < _OQ; _OP++) {
      $k[$j++] = -1;
    }
    $1.mmat = $a();
    for (var _OT = $1.cws.length - 1; _OT >= 0; _OT -= 1) {
      $k[$j++] = $get($1.cws, _OT);
    }
    $k[$j++] = 4;
    $k[$j++] = 0;
    for (; ; ) {
      var _OW = $k[--$j];
      var _OX = $k[--$j];
      $k[$j++] = _OX;
      $k[$j++] = _OW;
      if (_OW == 0 && _OX == $1.mrows) {
        $k[$j++] = $1.dmc1;
        $1.module();
      }
      var _Oa = $k[--$j];
      var _Ob = $k[--$j];
      $k[$j++] = _Ob;
      $k[$j++] = _Oa;
      if (_Oa == 0 && _Ob == $f($1.mrows - 2) && $1.mcols % 4 != 0) {
        $k[$j++] = $1.dmc2;
        $1.module();
      }
      var _Of = $k[--$j];
      var _Og = $k[--$j];
      $k[$j++] = _Og;
      $k[$j++] = _Of;
      if (_Of == 0 && _Og == $f($1.mrows - 2) && $1.mcols % 8 == 4) {
        $k[$j++] = $1.dmc3;
        $1.module();
      }
      var _Ok = $k[--$j];
      var _Ol = $k[--$j];
      $k[$j++] = _Ol;
      $k[$j++] = _Ok;
      if (_Ok == 2 && _Ol == $f($1.mrows + 4) && $1.mcols % 8 == 0) {
        $k[$j++] = $1.dmc4;
        $1.module();
      }
      for (; ; ) {
        var _Op = $k[--$j];
        var _Oq = $k[--$j];
        $k[$j++] = _Oq;
        $k[$j++] = _Op;
        if (_Op >= 0 && _Oq < $1.mrows) {
          var _Os = $k[--$j];
          var _Ot = $k[--$j];
          $k[$j++] = _Ot;
          $k[$j++] = _Os;
          if ($get($1.mmat, $f(_Os + _Ot * $1.mcols)) == -1) {
            $k[$j++] = $1.dmn;
            $1.module();
          }
        }
        var _Oy = $k[--$j];
        var _Oz = $k[--$j];
        $k[$j++] = $f(_Oz - 2);
        $k[$j++] = $f(_Oy + 2);
        if (!($f(_Oy + 2) < $1.mcols && $f(_Oz - 2) >= 0)) {
          break;
        }
      }
      var _P1 = $k[--$j];
      var _P2 = $k[--$j];
      $k[$j++] = $f(_P2 + 1);
      $k[$j++] = $f(_P1 + 3);
      for (; ; ) {
        var _P3 = $k[--$j];
        var _P4 = $k[--$j];
        $k[$j++] = _P4;
        $k[$j++] = _P3;
        if (_P3 < $1.mcols && _P4 >= 0) {
          var _P6 = $k[--$j];
          var _P7 = $k[--$j];
          $k[$j++] = _P7;
          $k[$j++] = _P6;
          if ($get($1.mmat, $f(_P6 + _P7 * $1.mcols)) == -1) {
            $k[$j++] = $1.dmn;
            $1.module();
          }
        }
        var _PC = $k[--$j];
        var _PD = $k[--$j];
        $k[$j++] = $f(_PD + 2);
        $k[$j++] = $f(_PC - 2);
        if (!($f(_PC - 2) >= 0 && $f(_PD + 2) < $1.mrows)) {
          break;
        }
      }
      var _PF = $k[--$j];
      var _PG = $k[--$j];
      $k[$j++] = $f(_PG + 3);
      $k[$j++] = $f(_PF + 1);
      if (!($f(_PF + 1) < $1.mcols || $f(_PG + 3) < $1.mrows)) {
        $j -= 2;
        break;
      }
    }
    if ($get($1.mmat, $f($1.mrows * $1.mcols - 1)) == -1) {
      $puti($1.mmat, $f($1.mrows * $f($1.mcols - 1) - 2), $a([1, 0]));
      $puti($1.mmat, $f($1.mrows * $1.mcols - 2), $a([0, 1]));
    }
    $1.pixs = $a($1.rows * $1.cols);
    $1.cwpos = 0;
    for (var _Pa = 0, _PZ = $f($1.rows - 1); _Pa <= _PZ; _Pa += 1) {
      $1.i = _Pa;
      if ($1.i % ($1.rrows + 2) == 0) {
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.i * $1.cols;
        $k[$j++] = Infinity;
        for (var _Ph = 0, _Pi = ~~($1.cols / 2); _Ph < _Pi; _Ph++) {
          $k[$j++] = 1;
          $k[$j++] = 0;
        }
        var _Pj = $a();
        var _Pk = $k[--$j];
        $puti($k[--$j], _Pk, _Pj);
      }
      if ($1.i % ($1.rrows + 2) == $1.rrows + 1) {
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.i * $1.cols;
        $k[$j++] = Infinity;
        for (var _Pt = 0, _Pu = $1.cols; _Pt < _Pu; _Pt++) {
          $k[$j++] = 1;
        }
        var _Pv = $a();
        var _Pw = $k[--$j];
        $puti($k[--$j], _Pw, _Pv);
      }
      if ($1.i % ($1.rrows + 2) != 0 && $1.i % ($1.rrows + 2) != $1.rrows + 1) {
        for (var _Q5 = 0, _Q4 = $f($1.cols - 1); _Q5 <= _Q4; _Q5 += 1) {
          $1.j = _Q5;
          if ($1.j % ($1.rcols + 2) == 0) {
            $put($1.pixs, $f($1.i * $1.cols + $1.j), 1);
          }
          if ($1.j % ($1.rcols + 2) == $1.rcols + 1) {
            $put($1.pixs, $f($1.i * $1.cols + $1.j), $1.i % 2);
          }
          if ($1.j % ($1.rcols + 2) != 0 && $1.j % ($1.rcols + 2) != $1.rcols + 1) {
            $put($1.pixs, $f($1.i * $1.cols + $1.j), $get($1.mmat, $1.cwpos));
            $1.cwpos = $1.cwpos + 1;
          }
        }
      }
    }
    var _Qd = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.cols],
      ["pixy", $1.rows],
      ["height", $1.rows * 2 / 72],
      ["width", $1.cols * 2 / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _Qd;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_datamatrixrectangular() {
    var $1 = Object.create(bwipp_datamatrixrectangular.$ctx || (bwipp_datamatrixrectangular.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "rectangle");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_datamatrix();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_datamatrixrectangularextension() {
    var $1 = Object.create(bwipp_datamatrixrectangularextension.$ctx || (bwipp_datamatrixrectangularextension.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "dmre", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_datamatrix();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_mailmark() {
    var $1 = Object.create(bwipp_mailmark.$ctx || (bwipp_mailmark.$ctx = {}));
    $1.type = "unset";
    $1.parse = false;
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _3 = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parseonly", true],
      ["parsefnc", false]
    ]);
    $1.fncvals = _3;
    $k[$j++] = "barcode";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $1.barlen = $1.barcode.length;
    delete $1.options["parse"];
    var _A = $1["type"];
    if ($ne(_A, "7") && ($ne(_A, "9") && $ne(_A, "29"))) {
      $k[$j++] = "bwipp.mailmarkBadType#19438";
      $k[$j++] = "Royal Mail Mailmark type must be 7, 9 or 29";
      bwipp_raiseerror();
    }
    var _B = /* @__PURE__ */ new Map([
      ["7", "24x24"],
      ["9", "32x32"],
      ["29", "16x48"]
    ]);
    $1.version = $get(_B, $1["type"]);
    var _E = /* @__PURE__ */ new Map([
      ["7", "square"],
      ["9", "square"],
      ["29", "rectangle"]
    ]);
    $1.format = $get(_E, $1["type"]);
    if ($1.barcode.length < 45) {
      $k[$j++] = "bwipp.mailmarkBadLength#19454";
      $k[$j++] = "Royal Mail Mailmark must contain at least 45 characters of Mailmark formatted data, including any required space padding";
      bwipp_raiseerror();
    }
    if ($ne($geti($1.barcode, 0, 4), "JGB ")) {
      $k[$j++] = "bwipp.mailmarkBadIndicator#19457";
      $k[$j++] = "Royal Mail Mailmark must begin with JGB<space> identifier";
      bwipp_raiseerror();
    }
    $put($1.options, "dontdraw", true);
    $put($1.options, "version", $1.version);
    $put($1.options, "format", $1.format);
    $put($1.options, "c40headerlength", 45);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_datamatrix();
    var _S = $k[--$j];
    $1[$k[--$j]] = _S;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_qrcode() {
    var $1 = Object.create(bwipp_qrcode.$ctx || (bwipp_qrcode.$ctx = {}));
    $1.dontdraw = false;
    $1.format = "unset";
    $1.version = "unset";
    $1.eclevel = "unset";
    $1.parse = false;
    $1.parsefnc = false;
    $1.mask = -1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.barcode, "")) {
      $k[$j++] = "bwipp.qrcodeEmptyData#19520";
      $k[$j++] = "The data must not be empty";
      bwipp_raiseerror();
    }
    if ($ne($1.version, "unset")) {
      if ($eq($1.format, "unset")) {
        $k[$j++] = "full";
        if ($eq($geti($1.version, 0, 1), "M")) {
          $j--;
          $k[$j++] = "micro";
        }
        if ($eq($geti($1.version, 0, 1), "R")) {
          $j--;
          $k[$j++] = "rmqr";
        }
        $1.format = $k[--$j];
      }
    } else {
      if ($eq($1.format, "unset")) {
        $1.format = "full";
      }
    }
    if ($ne($1.format, "full") && ($ne($1.format, "micro") && $ne($1.format, "rmqr"))) {
      $k[$j++] = "bwipp.qrcodeInvalidFormat#19536";
      $k[$j++] = "The format must be either full, micro or rmqr";
      bwipp_raiseerror();
    }
    if ($eq($1.format, "rmqr") && $eq($1.version, "unset")) {
      $k[$j++] = "bwipp.qrcodeRMQRwithoutVersion#19540";
      $k[$j++] = "A version must be provided for RMQR";
      bwipp_raiseerror();
    }
    if ($eq($1.eclevel, "unset")) {
      $k[$j++] = "eclevel";
      if ($ne($1.format, "micro")) {
        $k[$j++] = "M";
      } else {
        $k[$j++] = "L";
      }
      var _I = $k[--$j];
      $1[$k[--$j]] = _I;
    }
    if ($ne($1.eclevel, "L") && ($ne($1.eclevel, "M") && ($ne($1.eclevel, "Q") && $ne($1.eclevel, "H")))) {
      $k[$j++] = "bwipp.qrcodeInvalidEClevel#19547";
      $k[$j++] = "Error correction level must be either L, M, Q, or H";
      bwipp_raiseerror();
    }
    if ($1.mask != -1 && $eq($1.format, "rmqr")) {
      $k[$j++] = "bwipp.qrcodeRMQRmask#19551";
      $k[$j++] = "A mask cannot be supplied for RMQR";
      bwipp_raiseerror();
    }
    if ($1.mask != -1) {
      var _U = $eq($1.format, "full") ? 8 : 4;
      if ($1.mask < 1 || $1.mask > _U) {
        $k[$j++] = "bwipp.qrcodeBadMask#19556";
        $k[$j++] = "An invalid mask was supplied";
        bwipp_raiseerror();
      }
    }
    $1.fn1 = -1;
    var _Y = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["eci", true],
      ["FNC1", $1.fn1]
    ]);
    $1.fncvals = _Y;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _b = $k[--$j];
    $1[$k[--$j]] = _b;
    $1.msglen = $1.msg.length;
    $1.fnc1first = false;
    if ($1.msglen > 0) {
      if ($get($1.msg, 0) == $1.fn1) {
        $1.fnc1first = true;
        $k[$j++] = Infinity;
        var _k = $geti($1.msg, 1, $1.msglen - 1);
        for (var _l = 0, _m = _k.length; _l < _m; _l++) {
          var _n = $get(_k, _l);
          $k[$j++] = _n;
          if (_n == 37) {
            var _o = $k[--$j];
            $k[$j++] = _o;
            $k[$j++] = _o;
          }
        }
        $1.msg = $a();
        $1.msglen = $1.msg.length;
      }
    }
    if (!bwipp_qrcode.__19700__) {
      (function() {
        var $ctx = Object.create($1);
        var _r = $a(["v1to9", "v10to26", "v27to40", "vM1", "vM2", "vM3", "vM4", "vR7x43", "vR7x59", "vR7x77", "vR7x99", "vR7x139", "vR9x43", "vR9x59", "vR9x77", "vR9x99", "vR9x139", "vR11x27", "vR11x43", "vR11x59", "vR11x77", "vR11x99", "vR11x139", "vR13x27", "vR13x43", "vR13x59", "vR13x77", "vR13x99", "vR13x139", "vR15x43", "vR15x59", "vR15x77", "vR15x99", "vR15x139", "vR17x43", "vR17x59", "vR17x77", "vR17x99", "vR17x139"]);
        $k[$j++] = 0;
        for (var _s = 0, _t = _r.length; _s < _t; _s++) {
          var _v = $k[--$j];
          $ctx[$get(_r, _s)] = _v;
          $k[$j++] = $f(_v + 1);
        }
        $j--;
        $ctx.N = 0;
        $ctx.A = 1;
        $ctx.B = 2;
        $ctx.K = 3;
        $ctx.E = 4;
        $k[$j++] = Infinity;
        $k[$j++] = Infinity;
        for (var _w = 48; _w <= 57; _w += 1) {
          $k[$j++] = _w;
        }
        var _x = $a();
        for (var _y = 0, _z = _x.length; _y < _z; _y++) {
          $k[$j++] = $get(_x, _y);
          $k[$j++] = -1;
        }
        $ctx.Nexcl = $d();
        $k[$j++] = Infinity;
        $k[$j++] = Infinity;
        $k[$j++] = 32;
        $k[$j++] = 36;
        $k[$j++] = 37;
        $k[$j++] = 42;
        $k[$j++] = 43;
        $k[$j++] = 45;
        $k[$j++] = 46;
        $k[$j++] = 47;
        $k[$j++] = 58;
        for (var _12 = 65; _12 <= 90; _12 += 1) {
          $k[$j++] = _12;
        }
        $k[$j++] = $ctx.fn1;
        var _14 = $a();
        for (var _15 = 0, _16 = _14.length; _15 < _16; _15++) {
          $k[$j++] = $get(_14, _15);
          $k[$j++] = -1;
        }
        $ctx.Aexcl = $d();
        $k[$j++] = Infinity;
        $k[$j++] = Infinity;
        for (var _19 = 129; _19 <= 159; _19 += 1) {
          $k[$j++] = _19;
        }
        for (var _1A = 224; _1A <= 235; _1A += 1) {
          $k[$j++] = _1A;
        }
        var _1B = $a();
        for (var _1C = 0, _1D = _1B.length; _1C < _1D; _1C++) {
          $k[$j++] = $get(_1B, _1C);
          $k[$j++] = -1;
        }
        $ctx.Kexcl = $d();
        $k[$j++] = Infinity;
        $k[$j++] = $a(["0001", "0010", "0100", "1000", "0111"]);
        $k[$j++] = $a(["0001", "0010", "0100", "1000", "0111"]);
        $k[$j++] = $a(["0001", "0010", "0100", "1000", "0111"]);
        $k[$j++] = $a(["", -1, -1, -1, -1]);
        $k[$j++] = $a(["0", "1", -1, -1, -1]);
        $k[$j++] = $a(["00", "01", "10", "11", -1]);
        $k[$j++] = $a(["000", "001", "010", "011", -1]);
        for (var _1N = 0, _1O = 32; _1N < _1O; _1N++) {
          $k[$j++] = $a(["001", "010", "011", "100", "111"]);
        }
        $ctx.mids = $a();
        $ctx.cclens = $a([$a([10, 9, 8, 8]), $a([12, 11, 16, 10]), $a([14, 13, 16, 12]), $a([3, -1, -1, -1]), $a([4, 3, -1, -1]), $a([5, 4, 4, 3]), $a([6, 5, 5, 4]), $a([4, 3, 3, 2]), $a([5, 5, 4, 3]), $a([6, 5, 5, 4]), $a([7, 6, 5, 5]), $a([7, 6, 6, 5]), $a([5, 5, 4, 3]), $a([6, 5, 5, 4]), $a([7, 6, 5, 5]), $a([7, 6, 6, 5]), $a([8, 7, 6, 6]), $a([4, 4, 3, 2]), $a([6, 5, 5, 4]), $a([7, 6, 5, 5]), $a([7, 6, 6, 5]), $a([8, 7, 6, 6]), $a([8, 7, 7, 6]), $a([5, 5, 4, 3]), $a([6, 6, 5, 5]), $a([7, 6, 6, 5]), $a([7, 7, 6, 6]), $a([8, 7, 7, 6]), $a([8, 8, 7, 7]), $a([7, 6, 6, 5]), $a([7, 7, 6, 5]), $a([8, 7, 7, 6]), $a([8, 7, 7, 6]), $a([9, 8, 7, 7]), $a([7, 6, 6, 5]), $a([8, 7, 6, 6]), $a([8, 7, 7, 6]), $a([8, 8, 7, 6]), $a([9, 8, 8, 7])]);
        $k[$j++] = Infinity;
        for (var _25 = 0, _26 = 3; _25 < _26; _25++) {
          $k[$j++] = 4;
        }
        $k[$j++] = 3;
        $k[$j++] = 5;
        $k[$j++] = 7;
        $k[$j++] = 9;
        for (var _27 = 0, _28 = 32; _27 < _28; _27++) {
          $k[$j++] = 3;
        }
        $ctx.termlens = $a();
        $ctx.padstrs = $a(["11101100", "00010001"]);
        $ctx.charmap = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2B = 0; _2B <= 44; _2B += 1) {
          $put($ctx.charvals, $get($ctx.charmap, _2B), _2B);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__19700__ = 1;
      })();
    }
    $1.tobin = function() {
      var _2H = $s($k[--$j]);
      $k[$j++] = _2H;
      for (var _2J = 0, _2I = _2H.length - 1; _2J <= _2I; _2J += 1) {
        var _2K = $k[--$j];
        $put(_2K, _2J, 48);
        $k[$j++] = _2K;
      }
      var _2L = $k[--$j];
      var _2O = $cvrs($s(_2L.length), $k[--$j], 2);
      $puti(_2L, _2L.length - _2O.length, _2O);
      $k[$j++] = _2L;
    };
    $1.encA = function() {
      $1.in = $k[--$j];
      if ($1.fnc1first) {
        $k[$j++] = Infinity;
        $forall($1.in, function() {
          var _2S = $k[--$j];
          $k[$j++] = _2S;
          if (_2S == $1.fn1) {
            $j--;
            $k[$j++] = 37;
          }
        });
        $1.in = $a();
      }
      $1.out = $s(~~($1.in.length * 11 / 2) + 1);
      $1.k = 0;
      $1.m = 0;
      for (; ; ) {
        if ($1.k == $1.in.length) {
          break;
        }
        if ($1.k < $1.in.length - 1) {
          $k[$j++] = $f($get($1.charvals, $get($1.in, $1.k)) * 45 + $get($1.charvals, $get($1.in, $1.k + 1)));
          $k[$j++] = 11;
          $1.tobin();
          $1.k = $1.k + 2;
        } else {
          $k[$j++] = $get($1.charvals, $get($1.in, $1.k));
          $k[$j++] = 6;
          $1.tobin();
          $1.k = $1.k + 1;
        }
        var _2s = $k[--$j];
        $puti($1.out, $1.m, _2s);
        $1.m = _2s.length + $1.m;
      }
      $k[$j++] = $geti($1.out, 0, $1.m);
    };
    $1.encN = function() {
      $1.in = $k[--$j];
      $1.out = $s(~~($1.in.length * 10 / 3) + 1);
      $1.k = 0;
      $1.m = 0;
      for (; ; ) {
        if ($1.k == $1.in.length) {
          break;
        }
        if ($1.k < $1.in.length - 2) {
          var _38 = $geti($1.in, $1.k, 3);
          $k[$j++] = 0;
          for (var _39 = 0, _3A = _38.length; _39 < _3A; _39++) {
            var _3C = $k[--$j];
            $k[$j++] = $f($get(_38, _39) + $f(_3C * 10 - 48));
          }
          $k[$j++] = 10;
          $1.tobin();
          $1.k = $1.k + 3;
        } else {
          if ($1.k == $1.in.length - 2) {
            var _3I = $geti($1.in, $1.k, 2);
            $k[$j++] = 0;
            for (var _3J = 0, _3K = _3I.length; _3J < _3K; _3J++) {
              var _3M = $k[--$j];
              $k[$j++] = $f($get(_3I, _3J) + $f(_3M * 10 - 48));
            }
            $k[$j++] = 7;
            $1.tobin();
            $1.k = $1.k + 2;
          } else {
            var _3Q = $geti($1.in, $1.k, 1);
            $k[$j++] = 0;
            for (var _3R = 0, _3S = _3Q.length; _3R < _3S; _3R++) {
              var _3U = $k[--$j];
              $k[$j++] = $f($get(_3Q, _3R) + $f(_3U * 10 - 48));
            }
            $k[$j++] = 4;
            $1.tobin();
            $1.k = $1.k + 1;
          }
        }
        var _3W = $k[--$j];
        $puti($1.out, $1.m, _3W);
        $1.m = _3W.length + $1.m;
      }
      $k[$j++] = $geti($1.out, 0, $1.m);
    };
    $1.encB = function() {
      $1.in = $k[--$j];
      if ($1.fnc1first) {
        $k[$j++] = Infinity;
        $forall($1.in, function() {
          var _3g = $k[--$j];
          $k[$j++] = _3g;
          if (_3g == $1.fn1) {
            $j--;
            $k[$j++] = 29;
          }
        });
        $1.in = $a();
      }
      $1.out = $s($1.in.length * 8);
      for (var _3n = 0, _3m = $1.in.length - 1; _3n <= _3m; _3n += 1) {
        $1.k = _3n;
        $k[$j++] = $cvi($get($1.in, $1.k));
        $k[$j++] = 8;
        $1.tobin();
        $puti($1.out, $1.k * 8, $k[--$j]);
      }
      $k[$j++] = $1.out;
    };
    $1.encK = function() {
      $1.in = $k[--$j];
      $1.out = $s(~~($1.in.length / 2) * 13);
      $1.k = 0;
      $1.m = 0;
      for (; ; ) {
        if ($1.k == $1.in.length) {
          break;
        }
        var _46 = $f($get($1.in, $1.k) * 256 + $get($1.in, $1.k + 1));
        $k[$j++] = _46;
        if (_46 < 57408) {
          $k[$j++] = 33088;
        } else {
          $k[$j++] = 49472;
        }
        var _47 = $k[--$j];
        var _49 = $f($k[--$j] - _47);
        $k[$j++] = $f((_49 >>> 8) * 192 + (_49 & 255));
        $k[$j++] = 13;
        $1.tobin();
        var _4A = $k[--$j];
        $puti($1.out, $1.m, _4A);
        $1.m = _4A.length + $1.m;
        $1.k = $1.k + 2;
      }
      $k[$j++] = $1.out;
    };
    $1.encE = function() {
      var _4I = $f(-$get($k[--$j], 0) - 1e6);
      $k[$j++] = _4I;
      if (_4I <= 127) {
        $k[$j++] = 8;
        $1.tobin();
      } else {
        var _4J = $k[--$j];
        $k[$j++] = _4J;
        if (_4J <= 16383) {
          var _4K = $k[--$j];
          $k[$j++] = $f(_4K + 32768);
          $k[$j++] = 16;
          $1.tobin();
        } else {
          var _4L = $k[--$j];
          $k[$j++] = $f(_4L + 12582912);
          $k[$j++] = 24;
          $1.tobin();
        }
      }
    };
    $1.encfuncs = $a(["encN", "encA", "encB", "encK", "encE"]);
    $1.addtobits = function() {
      var _4N = $k[--$j];
      $puti($1.bits, $1.j, _4N);
      $1.j = _4N.length + $1.j;
    };
    $k[$j++] = Infinity;
    for (var _4S = 0, _4T = $1.msglen; _4S < _4T; _4S++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.numNs = $a();
    $k[$j++] = Infinity;
    for (var _4W = 0, _4X = $1.msglen; _4W < _4X; _4W++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.numAs = $a();
    $k[$j++] = Infinity;
    for (var _4a = 0, _4b = $1.msglen; _4a < _4b; _4a++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.numAorNs = $a();
    $k[$j++] = Infinity;
    for (var _4e = 0, _4f = $1.msglen; _4e < _4f; _4e++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.numBs = $a();
    $k[$j++] = Infinity;
    for (var _4i = 0, _4j = $1.msglen; _4i < _4j; _4i++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.numKs = $a();
    $k[$j++] = Infinity;
    for (var _4m = 0, _4n = $1.msglen; _4m < _4n; _4m++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $1.nextNs = $a();
    $k[$j++] = Infinity;
    for (var _4q = 0, _4r = $1.msglen; _4q < _4r; _4q++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $1.nextBs = $a();
    $k[$j++] = Infinity;
    for (var _4u = 0, _4v = $1.msglen; _4u < _4v; _4u++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $1.nextAs = $a();
    $k[$j++] = Infinity;
    for (var _4y = 0, _4z = $1.msglen; _4y < _4z; _4y++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $1.nextKs = $a();
    $1.isECI = $a($1.msglen);
    for (var _54 = $1.msglen - 1; _54 >= 0; _54 -= 1) {
      $1.i = _54;
      $1.barchar = $get($1.msg, $1.i);
      var _5A = $get($1.Kexcl, $1.barchar) !== void 0;
      if (_5A) {
        $k[$j++] = "sjis";
        if ($1.i + 1 < $1.msglen) {
          $k[$j++] = $f($1.barchar * 256 + $get($1.msg, $1.i + 1));
        } else {
          $k[$j++] = 0;
        }
        var _5H = $k[--$j];
        $1[$k[--$j]] = _5H;
        if ($1.sjis >= 33088 && $1.sjis <= 40956 || $1.sjis >= 57408 && $1.sjis <= 60351) {
          $put($1.nextKs, $1.i, 0);
          $put($1.numKs, $1.i, $f($get($1.numKs, $1.i + 2) + 1));
        } else {
          $put($1.nextKs, $1.i, $f($get($1.nextKs, $1.i + 1) + 1));
        }
      } else {
        $put($1.nextKs, $1.i, $f($get($1.nextKs, $1.i + 1) + 1));
      }
      var _5g = $get($1.Nexcl, $1.barchar) !== void 0;
      if (_5g) {
        $put($1.nextNs, $1.i, 0);
        $put($1.numNs, $1.i, $f($get($1.numNs, $1.i + 1) + 1));
        $put($1.numAorNs, $1.i, $f($get($1.numAorNs, $1.i + 1) + 1));
      } else {
        $put($1.nextNs, $1.i, $f($get($1.nextNs, $1.i + 1) + 1));
      }
      var _60 = $get($1.Aexcl, $1.barchar) !== void 0;
      if (_60) {
        $put($1.nextAs, $1.i, 0);
        $put($1.numAs, $1.i, $f($get($1.numAs, $1.i + 1) + 1));
        $put($1.numAorNs, $1.i, $f($get($1.numAorNs, $1.i + 1) + 1));
      } else {
        $put($1.nextAs, $1.i, $f($get($1.nextAs, $1.i + 1) + 1));
      }
      $put($1.isECI, $1.i, $1.barchar <= -1e6);
    }
    for (var _6N = 0, _6M = $1.msglen - 1; _6N <= _6M; _6N += 1) {
      $1.i = _6N;
      if ($get($1.numKs, $1.i) > 0) {
        $put($1.numKs, $1.i + 1, 0);
        $put($1.nextKs, $1.i + 1, $f($get($1.nextKs, $1.i + 1) + 1));
      }
    }
    for (var _6Z = $1.msglen - 1; _6Z >= 0; _6Z -= 1) {
      $1.i = _6Z;
      if ($f($get($1.numNs, $1.i) + $f($get($1.numAs, $1.i) + $get($1.numKs, $1.i))) == 0 && $nt($get($1.isECI, $1.i))) {
        $put($1.nextBs, $1.i, 0);
        $put($1.numBs, $1.i, $f($get($1.numBs, $1.i + 1) + 1));
      } else {
        $put($1.nextBs, $1.i, $f($get($1.nextBs, $1.i + 1) + 1));
      }
    }
    $1.KbeforeB = function() {
      var _71 = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numK, _71) && $get($1.nextBs, $f($1.numK * 2 + $1.i)) == 0;
    };
    $1.KbeforeA = function() {
      var _79 = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numK, _79) && $get($1.nextAs, $f($1.numK * 2 + $1.i)) == 0;
    };
    $1.KbeforeN = function() {
      var _7H = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numK, _7H) && $get($1.nextNs, $f($1.numK * 2 + $1.i)) == 0;
    };
    $1.KbeforeE = function() {
      var _7P = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numK, _7P) && $f($1.numK * 2 + $1.i) == $1.msglen;
    };
    $1.AbeforeK = function() {
      var _7W = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numA, _7W) && $get($1.nextKs, $f($1.numA + $1.i)) == 0;
    };
    $1.AbeforeB = function() {
      var _7e = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numA, _7e) && $get($1.nextBs, $f($1.numA + $1.i)) == 0;
    };
    $1.AbeforeN = function() {
      var _7m = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numA, _7m) && $get($1.nextNs, $f($1.numA + $1.i)) == 0;
    };
    $1.AbeforeE = function() {
      var _7u = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numA, _7u) && $f($1.numA + $1.i) == $1.msglen;
    };
    $1.NbeforeK = function() {
      var _81 = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numN, _81) && $get($1.nextKs, $f($1.numN + $1.i)) == 0;
    };
    $1.NbeforeB = function() {
      var _89 = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numN, _89) && $get($1.nextBs, $f($1.numN + $1.i)) == 0;
    };
    $1.NbeforeA = function() {
      var _8H = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numN, _8H) && $get($1.nextAs, $f($1.numN + $1.i)) == 0;
    };
    $1.NbeforeE = function() {
      var _8P = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numN, _8P) && $f($1.numN + $1.i) == $1.msglen;
    };
    $1.AorNbeforeB = function() {
      var _8W = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numAorN, _8W) && $get($1.nextBs, $f($1.numAorN + $1.i)) == 0;
    };
    $1.AorNbeforeE = function() {
      var _8e = $get($k[--$j], $1.ver);
      $k[$j++] = $ge($1.numAorN, _8e) && $f($1.numAorN + $1.i) == $1.msglen;
    };
    $1.nextNslt = function() {
      if ($get($1.nextNs, $1.i) >= $1.msglen) {
        $j--;
        $k[$j++] = true;
      } else {
        var _8u = $get($k[--$j], $1.ver);
        $k[$j++] = $lt($get($1.numNs, $f($get($1.nextNs, $1.i) + $1.i)), _8u);
      }
    };
    if (!bwipp_qrcode.__19901__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        $k[$j++] = "full";
        $k[$j++] = Infinity;
        for (var _8v = 0; _8v <= 9; _8v += 1) {
          $k[$j++] = $cvrs($s(2), _8v, 10);
          $k[$j++] = $ctx.v1to9;
        }
        for (var _8z = 10; _8z <= 26; _8z += 1) {
          $k[$j++] = $cvrs($s(2), _8z, 10);
          $k[$j++] = $ctx.v10to26;
        }
        for (var _93 = 27; _93 <= 40; _93 += 1) {
          $k[$j++] = $cvrs($s(2), _93, 10);
          $k[$j++] = $ctx.v27to40;
        }
        var _97 = $d();
        var _9C = /* @__PURE__ */ new Map([
          ["M1", $ctx.vM1],
          ["M2", $ctx.vM2],
          ["M3", $ctx.vM3],
          ["M4", $ctx.vM4]
        ]);
        var _9j = /* @__PURE__ */ new Map([
          ["R7x43", $ctx.vR7x43],
          ["R7x59", $ctx.vR7x59],
          ["R7x77", $ctx.vR7x77],
          ["R7x99", $ctx.vR7x99],
          ["R7x139", $ctx.vR7x139],
          ["R9x43", $ctx.vR9x43],
          ["R9x59", $ctx.vR9x59],
          ["R9x77", $ctx.vR9x77],
          ["R9x99", $ctx.vR9x99],
          ["R9x139", $ctx.vR9x139],
          ["R11x27", $ctx.vR11x27],
          ["R11x43", $ctx.vR11x43],
          ["R11x59", $ctx.vR11x59],
          ["R11x77", $ctx.vR11x77],
          ["R11x99", $ctx.vR11x99],
          ["R11x139", $ctx.vR11x139],
          ["R13x27", $ctx.vR13x27],
          ["R13x43", $ctx.vR13x43],
          ["R13x59", $ctx.vR13x59],
          ["R13x77", $ctx.vR13x77],
          ["R13x99", $ctx.vR13x99],
          ["R13x139", $ctx.vR13x139],
          ["R15x43", $ctx.vR15x43],
          ["R15x59", $ctx.vR15x59],
          ["R15x77", $ctx.vR15x77],
          ["R15x99", $ctx.vR15x99],
          ["R15x139", $ctx.vR15x139],
          ["R17x43", $ctx.vR17x43],
          ["R17x59", $ctx.vR17x59],
          ["R17x77", $ctx.vR17x77],
          ["R17x99", $ctx.vR17x99],
          ["R17x139", $ctx.vR17x139]
        ]);
        $k[$j++] = _97;
        $k[$j++] = "micro";
        $k[$j++] = _9C;
        $k[$j++] = "rmqr";
        $k[$j++] = _9j;
        $ctx.versetmap = $d();
        $ctx.versetfull = $a([$ctx.v1to9, $ctx.v10to26, $ctx.v27to40]);
        $ctx.versetmicro = $a([$ctx.vM1, $ctx.vM2, $ctx.vM3, $ctx.vM4]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__19901__ = 1;
      })();
    }
    if ($ne($1.version, "unset")) {
      var _9y = $get($1.versetmap, $1.format);
      var _9z = $1.version;
      var _A0 = $get(_9y, _9z) !== void 0;
      $k[$j++] = _9y;
      $k[$j++] = _9z;
      if (!_A0) {
        $j -= 2;
        if ($eq($1.format, "full")) {
          $k[$j++] = "bwipp.qrcodeInvalidFullVersion#19907";
          $k[$j++] = "Valid versions for QR Code symbols are 1 to 40";
          bwipp_raiseerror();
        } else {
          if ($eq($1.format, "micro")) {
            $k[$j++] = "bwipp.qrcodeInvalidMicroVersion#19910";
            $k[$j++] = "Valid versions for Micro QR Code symbols are M1 to M4";
            bwipp_raiseerror();
          } else {
            $k[$j++] = "bwipp.qrcodeInvalidRMQRversion#19912";
            $k[$j++] = "Invalid version for an RMQR symbol";
            bwipp_raiseerror();
          }
        }
      }
      var _A3 = $k[--$j];
      var _A5 = $get($k[--$j], _A3);
      $k[$j++] = _A5;
      $k[$j++] = Infinity;
      var _A6 = $k[--$j];
      var _A7 = $k[--$j];
      $k[$j++] = _A6;
      $k[$j++] = _A7;
      $1.verset = $a();
    } else {
      if ($eq($1.format, "full")) {
        $1.verset = $1.versetfull;
      }
      if ($eq($1.format, "micro")) {
        $1.verset = $1.versetmicro;
      }
    }
    $k[$j++] = Infinity;
    for (var _AD = 0, _AE = 39; _AD < _AE; _AD++) {
      $k[$j++] = -1;
    }
    $1.msgbits = $a();
    $1.e = 1e4;
    if (!bwipp_qrcode.__19955__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.mode0forceKB = $a([1, 1, 1, $ctx.e, $ctx.e, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
        $ctx.mode0forceA = $a([1, 1, 1, $ctx.e, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
        $ctx.mode0forceN = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
        $ctx.mode0NbeforeB = $a([4, 4, 5, $ctx.e, $ctx.e, 2, 3, 2, 2, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]);
        $ctx.modeBKbeforeB = $a([9, 12, 13, $ctx.e, $ctx.e, 4, 6, 4, 5, 6, 6, 6, 5, 6, 6, 6, 7, 4, 6, 6, 6, 7, 7, 5, 6, 6, 7, 7, 7, 6, 6, 7, 7, 7, 6, 7, 7, 7, 8]);
        $ctx.modeBKbeforeA = $a([8, 10, 11, $ctx.e, $ctx.e, 4, 5, 4, 5, 5, 6, 6, 5, 5, 6, 6, 6, 4, 5, 6, 6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 6, 6, 6, 7, 6, 6, 6, 7, 7]);
        $ctx.modeBKbeforeN = $a([8, 9, 11, $ctx.e, $ctx.e, 3, 5, 3, 4, 5, 5, 5, 4, 5, 5, 5, 6, 3, 5, 5, 5, 6, 6, 4, 5, 5, 6, 6, 6, 5, 5, 6, 6, 7, 5, 6, 6, 6, 7]);
        $ctx.modeBKbeforeE = $a([5, 5, 6, $ctx.e, $ctx.e, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 2, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 4, 3, 3, 4, 4, 4, 3, 4, 4, 4, 4]);
        $ctx.modeBAbeforeK = $a([11, 12, 14, $ctx.e, $ctx.e, 5, 7, 5, 6, 7, 8, 8, 6, 7, 8, 8, 8, 6, 7, 8, 8, 8, 8, 6, 8, 8, 8, 8, 9, 8, 8, 8, 8, 9, 8, 8, 8, 9, 9]);
        $ctx.modeBAbeforeB = $a([11, 15, 16, $ctx.e, $ctx.e, 6, 7, 6, 7, 7, 8, 8, 7, 7, 8, 8, 8, 6, 7, 8, 8, 8, 9, 7, 8, 8, 8, 9, 9, 8, 8, 9, 9, 9, 8, 8, 9, 9, 10]);
        $ctx.modeBAbeforeN = $a([12, 13, 15, $ctx.e, $ctx.e, 6, 8, 6, 7, 8, 8, 8, 7, 8, 8, 8, 9, 6, 8, 8, 8, 9, 9, 7, 8, 8, 9, 9, 10, 8, 9, 9, 9, 10, 8, 9, 9, 10, 10]);
        $ctx.modeBAbeforeE = $a([6, 7, 8, $ctx.e, $ctx.e, 3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 5, 4, 4, 4, 5, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5]);
        $ctx.modeBNbeforeK = $a([6, 7, 8, $ctx.e, $ctx.e, 3, 4, 3, 4, 4, 5, 5, 4, 4, 5, 5, 5, 3, 4, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]);
        $ctx.modeBNbeforeB = $a([6, 8, 9, $ctx.e, $ctx.e, 3, 4, 3, 4, 4, 5, 5, 4, 4, 5, 5, 5, 3, 4, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6]);
        $ctx.modeBNbeforeA = $a([6, 7, 8, $ctx.e, $ctx.e, 3, 4, 3, 4, 4, 5, 5, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6]);
        $ctx.modeBNbeforeE = $a([3, 4, 4, $ctx.e, $ctx.e, 2, 3, 2, 2, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]);
        $ctx.modeANbeforeA = $a([13, 15, 17, $ctx.e, 5, 7, 9, 7, 8, 9, 9, 9, 8, 9, 9, 9, 11, 7, 9, 9, 9, 11, 11, 8, 9, 9, 10, 11, 11, 9, 10, 11, 11, 11, 9, 11, 11, 11, 11]);
        $ctx.modeANbeforeB = $a([13, 17, 18, $ctx.e, $ctx.e, 7, 9, 7, 8, 9, 9, 9, 8, 9, 9, 9, 10, 7, 9, 9, 9, 10, 11, 8, 9, 9, 9, 11, 11, 9, 9, 11, 11, 11, 9, 10, 11, 11, 11]);
        $ctx.modeANbeforeE = $a([7, 8, 9, $ctx.e, 3, 4, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 4, 5, 5, 5, 6, 6, 5, 5, 5, 5, 6, 6, 5, 5, 6, 6, 6, 5, 6, 6, 6, 6]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__19955__ = 1;
      })();
    }
    var _B7 = $1.verset;
    for (var _B8 = 0, _B9 = _B7.length; _B8 < _B9; _B8++) {
      $1.ver = $get(_B7, _B8);
      $1.mode = -1;
      $1.seq = $a([]);
      $1.i = 0;
      for (; ; ) {
        if ($1.i >= $1.msglen) {
          break;
        }
        $1.numK = $get($1.numKs, $1.i);
        $1.numB = $get($1.numBs, $1.i);
        $1.numA = $get($1.numAs, $1.i);
        $1.numN = $get($1.numNs, $1.i);
        $1.numAorN = $get($1.numAorNs, $1.i);
        $1.eci = $get($1.isECI, $1.i);
        if ($eq($1.ver, $1.vM1) && $1.numA >= 1) {
          $1.seq = -1;
          break;
        }
        if ($eq($1.ver, $1.vM1) && $1.numB >= 1) {
          $1.seq = -1;
          break;
        }
        if ($eq($1.ver, $1.vM1) && $1.numK >= 1) {
          $1.seq = -1;
          break;
        }
        if ($eq($1.ver, $1.vM1) && $1.eci) {
          $1.seq = -1;
          break;
        }
        if ($eq($1.ver, $1.vM2) && $1.numB >= 1) {
          $1.seq = -1;
          break;
        }
        if ($eq($1.ver, $1.vM2) && $1.numK >= 1) {
          $1.seq = -1;
          break;
        }
        if ($eq($1.ver, $1.vM2) && $1.eci) {
          $1.seq = -1;
          break;
        }
        if ($eq($1.ver, $1.vM3) && $1.eci) {
          $1.seq = -1;
          break;
        }
        if ($eq($1.ver, $1.vM4) && $1.eci) {
          $1.seq = -1;
          break;
        }
        for (; ; ) {
          if ($1.eci) {
            $k[$j++] = $1.E;
            break;
          }
          if ($1.mode == -1) {
            $k[$j++] = $1.mode0forceKB;
            $1.KbeforeA();
            if ($k[--$j]) {
              $k[$j++] = $1.K;
              break;
            }
            $k[$j++] = $1.mode0forceKB;
            $1.KbeforeN();
            if ($k[--$j]) {
              $k[$j++] = $1.K;
              break;
            }
            $k[$j++] = $1.modeBKbeforeE;
            $1.KbeforeB();
            if ($k[--$j]) {
              $k[$j++] = $1.K;
              break;
            }
            $k[$j++] = $1.mode0forceKB;
            $1.KbeforeE();
            if ($k[--$j]) {
              $k[$j++] = $1.K;
              break;
            }
            if ($1.numK >= 1) {
              $k[$j++] = $1.B;
              break;
            }
            $k[$j++] = $1.mode0NbeforeB;
            $1.NbeforeB();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.mode0forceKB;
            $1.NbeforeB();
            if ($k[--$j]) {
              $k[$j++] = $1.B;
              break;
            }
            $k[$j++] = $1.modeANbeforeE;
            $1.NbeforeA();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.mode0forceN;
            $1.NbeforeE();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.modeBAbeforeE;
            $1.AbeforeK();
            if ($k[--$j]) {
              $k[$j++] = $1.A;
              break;
            }
            $k[$j++] = $1.modeBAbeforeE;
            $1.AorNbeforeB();
            if ($k[--$j]) {
              $k[$j++] = $1.A;
              break;
            }
            $k[$j++] = $1.mode0forceA;
            $1.AorNbeforeE();
            if ($k[--$j]) {
              $k[$j++] = $1.A;
              break;
            }
            $k[$j++] = $1.B;
            break;
          }
          if ($1.mode == $1.B) {
            $k[$j++] = $1.modeBKbeforeB;
            $1.KbeforeB();
            if ($k[--$j]) {
              $k[$j++] = $1.K;
              break;
            }
            $k[$j++] = $1.modeBKbeforeA;
            $1.KbeforeA();
            if ($k[--$j]) {
              $k[$j++] = $1.K;
              break;
            }
            $k[$j++] = $1.modeBKbeforeN;
            $1.KbeforeN();
            if ($k[--$j]) {
              $k[$j++] = $1.K;
              break;
            }
            $k[$j++] = $1.modeBKbeforeE;
            $1.KbeforeE();
            if ($k[--$j]) {
              $k[$j++] = $1.K;
              break;
            }
            $k[$j++] = $1.modeBAbeforeK;
            $1.AbeforeK();
            if ($k[--$j]) {
              $k[$j++] = $1.A;
              break;
            }
            $k[$j++] = $1.modeBAbeforeB;
            $1.AbeforeB();
            if ($k[--$j]) {
              $k[$j++] = $1.A;
              break;
            }
            $k[$j++] = $1.modeBAbeforeN;
            $1.AbeforeN();
            if ($k[--$j]) {
              $k[$j++] = $1.A;
              break;
            }
            $k[$j++] = $1.modeBAbeforeE;
            $1.AbeforeE();
            if ($k[--$j]) {
              $k[$j++] = $1.A;
              break;
            }
            $k[$j++] = $1.modeBNbeforeK;
            $1.NbeforeK();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.modeBNbeforeB;
            $1.NbeforeB();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.modeBNbeforeA;
            $1.NbeforeA();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.modeBNbeforeE;
            $1.NbeforeE();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.modeBAbeforeE;
            $1.AorNbeforeE();
            var _DH = $k[--$j];
            if (_DH && $le($1.numAorN, $get($1.modeBAbeforeN, $1.ver))) {
              $k[$j++] = $1.modeBNbeforeA;
              $1.nextNslt();
              if ($k[--$j]) {
                $k[$j++] = $1.A;
                break;
              }
            }
            $k[$j++] = $1.B;
            break;
          }
          if ($1.mode == $1.A) {
            if ($1.numK >= 1) {
              $k[$j++] = $1.K;
              break;
            }
            if ($1.numB >= 1) {
              $k[$j++] = $1.B;
              break;
            }
            $k[$j++] = $1.modeANbeforeA;
            $1.NbeforeA();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.modeANbeforeB;
            $1.NbeforeB();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.modeANbeforeE;
            $1.NbeforeE();
            if ($k[--$j]) {
              $k[$j++] = $1.N;
              break;
            }
            if ($1.numA >= 1 || $1.numN >= 1) {
              $k[$j++] = $1.A;
              break;
            }
            $k[$j++] = $1.B;
            break;
          }
          if ($1.mode == $1.N) {
            if ($1.numK >= 1) {
              $k[$j++] = $1.K;
              break;
            }
            if ($1.numB >= 1) {
              $k[$j++] = $1.B;
              break;
            }
            if ($1.numA >= 1) {
              $k[$j++] = $1.A;
              break;
            }
            if ($1.numN >= 1) {
              $k[$j++] = $1.N;
              break;
            }
            $k[$j++] = $1.B;
            break;
          }
          if ($1.mode == $1.K) {
            if ($1.numB >= 1) {
              $k[$j++] = $1.B;
              break;
            }
            if ($1.numA >= 1) {
              $k[$j++] = $1.A;
              break;
            }
            if ($1.numN >= 1) {
              $k[$j++] = $1.N;
              break;
            }
            if ($1.numK >= 1) {
              $k[$j++] = $1.K;
              break;
            }
            $k[$j++] = $1.B;
            break;
          }
        }
        var _E1 = $k[--$j];
        $k[$j++] = _E1;
        if (_E1 == $1.K && $1.fnc1first) {
          $j--;
          $k[$j++] = $1.B;
        }
        var _E5 = $k[--$j];
        $k[$j++] = _E5;
        if (_E5 == $1.mode) {
          $j--;
          var _EB = $1.mode == $1.K ? 2 : 1;
          $1.dat = $geti($1.msg, $1.i, _EB);
          $k[$j++] = Infinity;
          $aload($1.seq);
          $k[$j++] = Infinity;
          var _EE = $k[--$j];
          var _EF = $k[--$j];
          $k[$j++] = _EE;
          $aload(_EF);
          $aload($1.dat);
          var _EH = $a();
          $k[$j++] = _EH;
          $1.seq = $a();
        } else {
          $1.mode = $k[--$j];
          if ($1.mode == $1.K) {
            $k[$j++] = $1.K;
            $k[$j++] = $geti($1.msg, $1.i, $1.numK * 2);
          }
          if ($1.mode == $1.B) {
            $k[$j++] = $1.B;
            $k[$j++] = $geti($1.msg, $1.i, $1.numB);
          }
          if ($1.mode == $1.A) {
            $k[$j++] = $1.A;
            $k[$j++] = $geti($1.msg, $1.i, $1.numA);
          }
          if ($1.mode == $1.N) {
            $k[$j++] = $1.N;
            $k[$j++] = $geti($1.msg, $1.i, $1.numN);
          }
          if ($1.mode == $1.E) {
            $1.mode = -1;
            $k[$j++] = $1.E;
            $k[$j++] = $geti($1.msg, $1.i, 1);
          }
          $1.dat = $k[--$j];
          $1.sw = $k[--$j];
          $k[$j++] = Infinity;
          $aload($1.seq);
          $k[$j++] = $1.sw;
          $k[$j++] = $1.dat;
          $1.seq = $a();
        }
        $1.i = $1.i + $1.dat.length;
      }
      for (; ; ) {
        if ($1.seq == -1) {
          break;
        }
        $1.bits = $s(23648);
        $1.j = 0;
        if ($1.fnc1first) {
          if ($lt($1.ver, $1.vR7x43)) {
            $k[$j++] = "0101";
          } else {
            $k[$j++] = "101";
          }
          $1.addtobits();
        }
        $1.abort = false;
        for (var _F7 = 0, _F6 = $1.seq.length - 1; _F7 <= _F6; _F7 += 2) {
          $1.i = _F7;
          $1.mode = $get($1.seq, $1.i);
          $k[$j++] = $get($get($1.mids, $1.ver), $1.mode);
          $1.addtobits();
          $1.chars = $get($1.seq, $1.i + 1);
          $k[$j++] = "charslen";
          $k[$j++] = $1.chars.length;
          if ($1.mode == $1.K) {
            var _FM = $k[--$j];
            $k[$j++] = ~~(_FM / 2);
          }
          var _FN = $k[--$j];
          $1[$k[--$j]] = _FN;
          if ($1.mode != $1.E) {
            $1.cclen = $get($get($1.cclens, $1.ver), $1.mode);
            if ($1.charslen >= ~~Math.pow(2, $1.cclen)) {
              $1.abort = true;
              break;
            }
            $k[$j++] = $1.charslen;
            $k[$j++] = $1.cclen;
            $1.tobin();
            $1.addtobits();
          }
          $k[$j++] = $1.chars;
          if ($1[$get($1.encfuncs, $1.mode)]() === true) {
            break;
          }
          $1.addtobits();
        }
        if ($1.abort) {
          break;
        }
        $1.bits = $geti($1.bits, 0, $1.j);
        $put($1.msgbits, $1.ver, $1.bits);
        break;
      }
    }
    if (!bwipp_qrcode.__20173__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.metrics = $a([$a(["micro", "M1", $ctx.vM1, 11, 11, 98, 99, 36, $a([2, 99, 99, 99]), $a([1, 0, -1, -1, -1, -1, -1, -1])]), $a(["micro", "M2", $ctx.vM2, 13, 13, 98, 99, 80, $a([5, 6, 99, 99]), $a([1, 0, 1, 0, -1, -1, -1, -1])]), $a(["micro", "M3", $ctx.vM3, 15, 15, 98, 99, 132, $a([6, 8, 99, 99]), $a([1, 0, 1, 0, -1, -1, -1, -1])]), $a(["micro", "M4", $ctx.vM4, 17, 17, 98, 99, 192, $a([8, 10, 14, 99]), $a([1, 0, 1, 0, 1, 0, -1, -1])]), $a(["full", "1", $ctx.v1to9, 21, 21, 98, 99, 208, $a([7, 10, 13, 17]), $a([1, 0, 1, 0, 1, 0, 1, 0])]), $a(["full", "2", $ctx.v1to9, 25, 25, 18, 99, 359, $a([10, 16, 22, 28]), $a([1, 0, 1, 0, 1, 0, 1, 0])]), $a(["full", "3", $ctx.v1to9, 29, 29, 22, 99, 567, $a([15, 26, 36, 44]), $a([1, 0, 1, 0, 2, 0, 2, 0])]), $a(["full", "4", $ctx.v1to9, 33, 33, 26, 99, 807, $a([20, 36, 52, 64]), $a([1, 0, 2, 0, 2, 0, 4, 0])]), $a(["full", "5", $ctx.v1to9, 37, 37, 30, 99, 1079, $a([26, 48, 72, 88]), $a([1, 0, 2, 0, 2, 2, 2, 2])]), $a(["full", "6", $ctx.v1to9, 41, 41, 34, 99, 1383, $a([36, 64, 96, 112]), $a([2, 0, 4, 0, 4, 0, 4, 0])]), $a(["full", "7", $ctx.v1to9, 45, 45, 22, 38, 1568, $a([40, 72, 108, 130]), $a([2, 0, 4, 0, 2, 4, 4, 1])]), $a(["full", "8", $ctx.v1to9, 49, 49, 24, 42, 1936, $a([48, 88, 132, 156]), $a([2, 0, 2, 2, 4, 2, 4, 2])]), $a(["full", "9", $ctx.v1to9, 53, 53, 26, 46, 2336, $a([60, 110, 160, 192]), $a([2, 0, 3, 2, 4, 4, 4, 4])]), $a(["full", "10", $ctx.v10to26, 57, 57, 28, 50, 2768, $a([72, 130, 192, 224]), $a([2, 2, 4, 1, 6, 2, 6, 2])]), $a(["full", "11", $ctx.v10to26, 61, 61, 30, 54, 3232, $a([80, 150, 224, 264]), $a([4, 0, 1, 4, 4, 4, 3, 8])]), $a(["full", "12", $ctx.v10to26, 65, 65, 32, 58, 3728, $a([96, 176, 260, 308]), $a([2, 2, 6, 2, 4, 6, 7, 4])]), $a(["full", "13", $ctx.v10to26, 69, 69, 34, 62, 4256, $a([104, 198, 288, 352]), $a([4, 0, 8, 1, 8, 4, 12, 4])]), $a(["full", "14", $ctx.v10to26, 73, 73, 26, 46, 4651, $a([120, 216, 320, 384]), $a([3, 1, 4, 5, 11, 5, 11, 5])]), $a(["full", "15", $ctx.v10to26, 77, 77, 26, 48, 5243, $a([132, 240, 360, 432]), $a([5, 1, 5, 5, 5, 7, 11, 7])]), $a(["full", "16", $ctx.v10to26, 81, 81, 26, 50, 5867, $a([144, 280, 408, 480]), $a([5, 1, 7, 3, 15, 2, 3, 13])]), $a(["full", "17", $ctx.v10to26, 85, 85, 30, 54, 6523, $a([168, 308, 448, 532]), $a([1, 5, 10, 1, 1, 15, 2, 17])]), $a(["full", "18", $ctx.v10to26, 89, 89, 30, 56, 7211, $a([180, 338, 504, 588]), $a([5, 1, 9, 4, 17, 1, 2, 19])]), $a(["full", "19", $ctx.v10to26, 93, 93, 30, 58, 7931, $a([196, 364, 546, 650]), $a([3, 4, 3, 11, 17, 4, 9, 16])]), $a(["full", "20", $ctx.v10to26, 97, 97, 34, 62, 8683, $a([224, 416, 600, 700]), $a([3, 5, 3, 13, 15, 5, 15, 10])]), $a(["full", "21", $ctx.v10to26, 101, 101, 28, 50, 9252, $a([224, 442, 644, 750]), $a([4, 4, 17, 0, 17, 6, 19, 6])]), $a(["full", "22", $ctx.v10to26, 105, 105, 26, 50, 10068, $a([252, 476, 690, 816]), $a([2, 7, 17, 0, 7, 16, 34, 0])]), $a(["full", "23", $ctx.v10to26, 109, 109, 30, 54, 10916, $a([270, 504, 750, 900]), $a([4, 5, 4, 14, 11, 14, 16, 14])]), $a(["full", "24", $ctx.v10to26, 113, 113, 28, 54, 11796, $a([300, 560, 810, 960]), $a([6, 4, 6, 14, 11, 16, 30, 2])]), $a(["full", "25", $ctx.v10to26, 117, 117, 32, 58, 12708, $a([312, 588, 870, 1050]), $a([8, 4, 8, 13, 7, 22, 22, 13])]), $a(["full", "26", $ctx.v10to26, 121, 121, 30, 58, 13652, $a([336, 644, 952, 1110]), $a([10, 2, 19, 4, 28, 6, 33, 4])]), $a(["full", "27", $ctx.v27to40, 125, 125, 34, 62, 14628, $a([360, 700, 1020, 1200]), $a([8, 4, 22, 3, 8, 26, 12, 28])]), $a(["full", "28", $ctx.v27to40, 129, 129, 26, 50, 15371, $a([390, 728, 1050, 1260]), $a([3, 10, 3, 23, 4, 31, 11, 31])]), $a(["full", "29", $ctx.v27to40, 133, 133, 30, 54, 16411, $a([420, 784, 1140, 1350]), $a([7, 7, 21, 7, 1, 37, 19, 26])]), $a(["full", "30", $ctx.v27to40, 137, 137, 26, 52, 17483, $a([450, 812, 1200, 1440]), $a([5, 10, 19, 10, 15, 25, 23, 25])]), $a(["full", "31", $ctx.v27to40, 141, 141, 30, 56, 18587, $a([480, 868, 1290, 1530]), $a([13, 3, 2, 29, 42, 1, 23, 28])]), $a(["full", "32", $ctx.v27to40, 145, 145, 34, 60, 19723, $a([510, 924, 1350, 1620]), $a([17, 0, 10, 23, 10, 35, 19, 35])]), $a(["full", "33", $ctx.v27to40, 149, 149, 30, 58, 20891, $a([540, 980, 1440, 1710]), $a([17, 1, 14, 21, 29, 19, 11, 46])]), $a(["full", "34", $ctx.v27to40, 153, 153, 34, 62, 22091, $a([570, 1036, 1530, 1800]), $a([13, 6, 14, 23, 44, 7, 59, 1])]), $a(["full", "35", $ctx.v27to40, 157, 157, 30, 54, 23008, $a([570, 1064, 1590, 1890]), $a([12, 7, 12, 26, 39, 14, 22, 41])]), $a(["full", "36", $ctx.v27to40, 161, 161, 24, 50, 24272, $a([600, 1120, 1680, 1980]), $a([6, 14, 6, 34, 46, 10, 2, 64])]), $a(["full", "37", $ctx.v27to40, 165, 165, 28, 54, 25568, $a([630, 1204, 1770, 2100]), $a([17, 4, 29, 14, 49, 10, 24, 46])]), $a(["full", "38", $ctx.v27to40, 169, 169, 32, 58, 26896, $a([660, 1260, 1860, 2220]), $a([4, 18, 13, 32, 48, 14, 42, 32])]), $a(["full", "39", $ctx.v27to40, 173, 173, 26, 54, 28256, $a([720, 1316, 1950, 2310]), $a([20, 4, 40, 7, 43, 22, 10, 67])]), $a(["full", "40", $ctx.v27to40, 177, 177, 30, 58, 29648, $a([750, 1372, 2040, 2430]), $a([19, 6, 18, 31, 34, 34, 20, 61])]), $a(["rmqr", "R7x43", $ctx.vR7x43, 7, 43, 22, 99, 104, $a([99, 7, 99, 10]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R7x59", $ctx.vR7x59, 7, 59, 20, 40, 171, $a([99, 9, 99, 14]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R7x77", $ctx.vR7x77, 7, 77, 26, 52, 261, $a([99, 12, 99, 22]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R7x99", $ctx.vR7x99, 7, 99, 24, 50, 358, $a([99, 16, 99, 30]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R7x139", $ctx.vR7x139, 7, 139, 28, 56, 545, $a([99, 24, 99, 44]), $a([-1, -1, 1, 0, -1, -1, 2, 0])]), $a(["rmqr", "R9x43", $ctx.vR9x43, 9, 43, 22, 99, 170, $a([99, 9, 99, 14]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R9x59", $ctx.vR9x59, 9, 59, 20, 40, 267, $a([99, 12, 99, 22]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R9x77", $ctx.vR9x77, 9, 77, 26, 52, 393, $a([99, 18, 99, 32]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R9x99", $ctx.vR9x99, 9, 99, 24, 50, 532, $a([99, 24, 99, 44]), $a([-1, -1, 1, 0, -1, -1, 2, 0])]), $a(["rmqr", "R9x139", $ctx.vR9x139, 9, 139, 28, 56, 797, $a([99, 36, 99, 66]), $a([-1, -1, 1, 1, -1, -1, 3, 0])]), $a(["rmqr", "R11x27", $ctx.vR11x27, 11, 27, 98, 99, 122, $a([99, 8, 99, 10]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R11x43", $ctx.vR11x43, 11, 43, 22, 99, 249, $a([99, 12, 99, 20]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R11x59", $ctx.vR11x59, 11, 59, 20, 40, 376, $a([99, 16, 99, 32]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R11x77", $ctx.vR11x77, 11, 77, 26, 52, 538, $a([99, 24, 99, 44]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R11x99", $ctx.vR11x99, 11, 99, 24, 50, 719, $a([99, 32, 99, 60]), $a([-1, -1, 1, 1, -1, -1, 1, 1])]), $a(["rmqr", "R11x139", $ctx.vR11x139, 11, 139, 28, 56, 1062, $a([99, 48, 99, 90]), $a([-1, -1, 2, 0, -1, -1, 3, 0])]), $a(["rmqr", "R13x27", $ctx.vR13x27, 13, 27, 98, 99, 172, $a([99, 9, 99, 14]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R13x43", $ctx.vR13x43, 13, 43, 22, 99, 329, $a([99, 14, 99, 28]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R13x59", $ctx.vR13x59, 13, 59, 20, 40, 486, $a([99, 22, 99, 40]), $a([-1, -1, 1, 0, -1, -1, 2, 0])]), $a(["rmqr", "R13x77", $ctx.vR13x77, 13, 77, 26, 52, 684, $a([99, 32, 99, 56]), $a([-1, -1, 1, 1, -1, -1, 1, 1])]), $a(["rmqr", "R13x99", $ctx.vR13x99, 13, 99, 24, 50, 907, $a([99, 40, 99, 78]), $a([-1, -1, 1, 1, -1, -1, 1, 2])]), $a(["rmqr", "R13x139", $ctx.vR13x139, 13, 139, 28, 56, 1328, $a([99, 60, 99, 112]), $a([-1, -1, 2, 1, -1, -1, 2, 2])]), $a(["rmqr", "R15x43", $ctx.vR15x43, 15, 43, 22, 99, 409, $a([99, 18, 99, 36]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R15x59", $ctx.vR15x59, 15, 59, 20, 40, 596, $a([99, 26, 99, 48]), $a([-1, -1, 1, 0, -1, -1, 2, 0])]), $a(["rmqr", "R15x77", $ctx.vR15x77, 15, 77, 26, 52, 830, $a([99, 36, 99, 72]), $a([-1, -1, 1, 1, -1, -1, 2, 1])]), $a(["rmqr", "R15x99", $ctx.vR15x99, 15, 99, 24, 50, 1095, $a([99, 48, 99, 88]), $a([-1, -1, 2, 0, -1, -1, 4, 0])]), $a(["rmqr", "R15x139", $ctx.vR15x139, 15, 139, 28, 56, 1594, $a([99, 72, 99, 130]), $a([-1, -1, 2, 1, -1, -1, 1, 4])]), $a(["rmqr", "R17x43", $ctx.vR17x43, 17, 43, 22, 99, 489, $a([99, 22, 99, 40]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R17x59", $ctx.vR17x59, 17, 59, 20, 40, 706, $a([99, 32, 99, 60]), $a([-1, -1, 2, 0, -1, -1, 2, 0])]), $a(["rmqr", "R17x77", $ctx.vR17x77, 17, 77, 26, 52, 976, $a([99, 44, 99, 84]), $a([-1, -1, 2, 0, -1, -1, 1, 2])]), $a(["rmqr", "R17x99", $ctx.vR17x99, 17, 99, 24, 50, 1283, $a([99, 60, 99, 104]), $a([-1, -1, 2, 1, -1, -1, 4, 0])]), $a(["rmqr", "R17x139", $ctx.vR17x139, 17, 139, 28, 56, 1860, $a([99, 80, 99, 156]), $a([-1, -1, 4, 0, -1, -1, 2, 4])])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__20173__ = 1;
      })();
    }
    $k[$j++] = "eclval";
    $search("LMQH", $1.eclevel);
    $j--;
    var _Kj = $k[--$j];
    var _Kk = $k[--$j];
    $k[$j++] = _Kj.length;
    $k[$j++] = _Kk;
    $j--;
    var _Kl = $k[--$j];
    var _Km = $k[--$j];
    $k[$j++] = _Kl;
    $k[$j++] = _Km;
    $j--;
    var _Kn = $k[--$j];
    $1[$k[--$j]] = _Kn;
    for (var _Kr = 0, _Kq = $1.metrics.length - 1; _Kr <= _Kq; _Kr += 1) {
      $1.i = _Kr;
      $1.m = $get($1.metrics, $1.i);
      $1.frmt = $get($1.m, 0);
      $1.vers = $get($1.m, 1);
      $1.vergrp = $get($1.m, 2);
      $1.verind = $1.i - 44;
      $1.rows = $get($1.m, 3);
      $1.cols = $get($1.m, 4);
      $1.asp2 = $get($1.m, 5);
      $1.asp3 = $get($1.m, 6);
      $1.nmod = $get($1.m, 7);
      $1.ncws = ~~($1.nmod / 8);
      $1.rbit = $1.nmod % 8;
      $1.lc4b = false;
      if ($eq($1.vers, "M1") || $eq($1.vers, "M3")) {
        $1.ncws = $1.ncws + 1;
        $1.rbit = 0;
        $1.lc4b = true;
      }
      $1.ecws = $get($get($1.m, 8), $1.eclval);
      $1.dcws = $f($1.ncws - $1.ecws);
      var _LP = $1.lc4b ? 4 : 0;
      $1.dmod = $f($1.dcws * 8 - _LP);
      $1.ecb1 = $get($get($1.m, 9), $1.eclval * 2);
      $1.ecb2 = $get($get($1.m, 9), $f($1.eclval * 2 + 1));
      $1.okay = true;
      if ($ne($1.format, $1.frmt)) {
        $1.okay = false;
      }
      if ($eq($1.frmt, "micro") && $1.fnc1first) {
        $1.okay = false;
      }
      if ($ne($1.version, "unset") && $ne($1.version, $1.vers)) {
        $1.okay = false;
      }
      if ($1.ecb1 == -1 || $1.ecb2 == -1) {
        $1.okay = false;
      }
      $1.verbits = $get($1.msgbits, $1.vergrp);
      if ($1.verbits == -1) {
        $1.okay = false;
      } else {
        if ($1.verbits.length > $1.dmod) {
          $1.okay = false;
        }
      }
      $1.term = $geti("000000000", 0, $get($1.termlens, $1.vergrp));
      if ($1.okay) {
        break;
      }
    }
    if (!$1.okay) {
      $k[$j++] = "bwipp.qrcodeNoValidSymbol#20217";
      $k[$j++] = "Maximum length exceeded or invalid content";
      bwipp_raiseerror();
    }
    $1.format = $1.frmt;
    $1.version = $1.vers;
    $1.msgbits = $1.verbits;
    $1.dcpb = ~~($1.dcws / $f($1.ecb1 + $1.ecb2));
    $1.ecpb = ~~($1.ncws / $f($1.ecb1 + $1.ecb2)) - $1.dcpb;
    var _M3 = $1.term;
    var _M4 = $1.dmod;
    var _M5 = $1.msgbits;
    var _M6 = $1.term;
    var _M7 = _M6.length;
    var _M8 = $f(_M4 - _M5.length);
    if ($f(_M4 - _M5.length) > _M6.length) {
      var _ = _M7;
      _M7 = _M8;
      _M8 = _;
    }
    $1.term = $geti(_M3, 0, _M8);
    var _MC = $s($1.msgbits.length + $1.term.length);
    $puti(_MC, 0, $1.msgbits);
    $puti(_MC, $1.msgbits.length, $1.term);
    $1.msgbits = _MC;
    $1.pad = $s($1.dmod);
    for (var _MK = 0, _MJ = $1.pad.length - 1; _MK <= _MJ; _MK += 1) {
      $put($1.pad, _MK, 48);
    }
    $puti($1.pad, 0, $1.msgbits);
    $1.padnum = 0;
    var _MR = $1.lc4b ? 5 : 1;
    for (var _MT = ~~(Math.ceil($1.msgbits.length / 8) * 8), _MS = $f($1.dmod - _MR); _MT <= _MS; _MT += 8) {
      $puti($1.pad, _MT, $get($1.padstrs, $1.padnum));
      $1.padnum = ($1.padnum + 1) % 2;
    }
    $1.cws = $a($1.dcws);
    for (var _Md = 0, _Mc = $1.cws.length - 1; _Md <= _Mc; _Md += 1) {
      $1.c = _Md;
      $1.bpcw = 8;
      if ($1.lc4b && $1.c == $1.cws.length - 1) {
        $1.bpcw = 4;
      }
      $1.cwb = $geti($1.pad, $1.c * 8, $1.bpcw);
      $1.cw = 0;
      for (var _Mn = 0, _Mm = $1.bpcw - 1; _Mn <= _Mm; _Mn += 1) {
        $1.i = _Mn;
        $1.cw = $f($1.cw + ~~Math.pow(2, $1.bpcw - $1.i - 1) * $f($get($1.cwb, $1.i) - 48));
      }
      $put($1.cws, $1.c, $1.cw);
    }
    if ($1.lc4b) {
      var _My = $1.cws;
      var _Mz = $1.cws;
      $put(_My, _Mz.length - 1, $get(_My, _Mz.length - 1) << 4);
    }
    var _N2 = $get($1.options, "debugcws") !== void 0;
    if (_N2) {
      $k[$j++] = "bwipp.debugcws#20261";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    if (!bwipp_qrcode.__20268__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        $k[$j++] = 1;
        for (var _N4 = 0, _N5 = 255; _N4 < _N5; _N4++) {
          var _N6 = $k[--$j];
          var _N7 = _N6 * 2;
          $k[$j++] = _N6;
          $k[$j++] = _N7;
          if (_N7 >= 256) {
            var _N8 = $k[--$j];
            $k[$j++] = _N8 ^ 285;
          }
        }
        $ctx.rsalog = $a();
        $ctx.rslog = $a(256);
        for (var _NB = 1; _NB <= 255; _NB += 1) {
          $put($ctx.rslog, $get($ctx.rsalog, _NB), _NB);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__20268__ = 1;
      })();
    }
    $1.rsprod = function() {
      var _NG = $k[--$j];
      var _NH = $k[--$j];
      $k[$j++] = _NH;
      $k[$j++] = _NG;
      if (_NG != 0 && _NH != 0) {
        var _NK = $get($1.rslog, $k[--$j]);
        var _NP = $get($1.rsalog, $f(_NK + $get($1.rslog, $k[--$j])) % 255);
        $k[$j++] = _NP;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _NR = 0, _NS = $1.ecpb; _NR < _NS; _NR++) {
      $k[$j++] = 0;
    }
    $1.coeffs = $a();
    for (var _NW = 0, _NV = $1.ecpb - 1; _NW <= _NV; _NW += 1) {
      $1.i = _NW;
      $put($1.coeffs, $1.i + 1, $get($1.coeffs, $1.i));
      for (var _Nd = $1.i; _Nd >= 1; _Nd -= 1) {
        $1.j = _Nd;
        $k[$j++] = $1.coeffs;
        $k[$j++] = $1.j;
        $k[$j++] = $get($1.coeffs, $1.j - 1);
        $k[$j++] = $get($1.coeffs, $1.j);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _Np = $k[--$j];
        var _Nq = $k[--$j];
        var _Nr = $k[--$j];
        $put($k[--$j], _Nr, $xo(_Nq, _Np));
      }
      $k[$j++] = $1.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($1.coeffs, 0);
      $k[$j++] = $get($1.rsalog, $1.i);
      $1.rsprod();
      var _Nz = $k[--$j];
      var _O0 = $k[--$j];
      $put($k[--$j], _O0, _Nz);
    }
    $1.coeffs = $geti($1.coeffs, 0, $1.coeffs.length - 1);
    $1.rscodes = function() {
      $1.rscws = $k[--$j];
      $1.rsnd = $1.rscws.length;
      $k[$j++] = Infinity;
      $forall($1.rscws);
      for (var _O9 = 0, _OA = $1.ecpb; _O9 < _OA; _O9++) {
        $k[$j++] = 0;
      }
      $1.rscws = $a();
      for (var _OE = 0, _OD = $1.rsnd - 1; _OE <= _OD; _OE += 1) {
        $1.m = _OE;
        $1.k = $get($1.rscws, $1.m);
        for (var _OK = 0, _OJ = $1.ecpb - 1; _OK <= _OJ; _OK += 1) {
          $1.j = _OK;
          $k[$j++] = $1.rscws;
          $k[$j++] = $1.m + $1.j + 1;
          $k[$j++] = $get($1.coeffs, $1.ecpb - $1.j - 1);
          $k[$j++] = $1.k;
          $1.rsprod();
          var _OX = $k[--$j];
          var _OY = $k[--$j];
          $put($k[--$j], _OY, $xo(_OX, $get($1.rscws, $1.m + $1.j + 1)));
        }
      }
      $k[$j++] = $geti($1.rscws, $1.rsnd, $1.ecpb);
    };
    $1.dcwsb = $a($f($1.ecb1 + $1.ecb2));
    $1.ecwsb = $a($f($1.ecb1 + $1.ecb2));
    for (var _Om = 0, _Ol = $f($1.ecb1 - 1); _Om <= _Ol; _Om += 1) {
      $1.i = _Om;
      $put($1.dcwsb, $1.i, $geti($1.cws, $1.i * $1.dcpb, $1.dcpb));
      $k[$j++] = $1.ecwsb;
      $k[$j++] = $1.i;
      $k[$j++] = $get($1.dcwsb, $1.i);
      $1.rscodes();
      var _Oz = $k[--$j];
      var _P0 = $k[--$j];
      $put($k[--$j], _P0, _Oz);
    }
    for (var _P4 = 0, _P3 = $f($1.ecb2 - 1); _P4 <= _P3; _P4 += 1) {
      $1.i = _P4;
      $put($1.dcwsb, $f($1.ecb1 + $1.i), $geti($1.cws, $f($1.ecb1 * $1.dcpb + $1.i * ($1.dcpb + 1)), $1.dcpb + 1));
      $k[$j++] = $1.ecwsb;
      $k[$j++] = $f($1.ecb1 + $1.i);
      $k[$j++] = $get($1.dcwsb, $f($1.ecb1 + $1.i));
      $1.rscodes();
      var _PM = $k[--$j];
      var _PN = $k[--$j];
      $put($k[--$j], _PN, _PM);
    }
    $1.cws = $a($1.ncws);
    $1.cw = 0;
    for (var _PT = 0, _PS = $1.dcpb; _PT <= _PS; _PT += 1) {
      $1.i = _PT;
      for (var _PX = 0, _PW = $f($f($1.ecb1 + $1.ecb2) - 1); _PX <= _PW; _PX += 1) {
        $1.j = _PX;
        if ($1.i < $get($1.dcwsb, $1.j).length) {
          $put($1.cws, $1.cw, $get($get($1.dcwsb, $1.j), $1.i));
          $1.cw = $1.cw + 1;
        }
      }
    }
    for (var _Pm = 0, _Pl = $1.ecpb - 1; _Pm <= _Pl; _Pm += 1) {
      $1.i = _Pm;
      for (var _Pq = 0, _Pp = $f($f($1.ecb1 + $1.ecb2) - 1); _Pq <= _Pp; _Pq += 1) {
        $1.j = _Pq;
        $put($1.cws, $1.cw, $get($get($1.ecwsb, $1.j), $1.i));
        $1.cw = $1.cw + 1;
      }
    }
    if ($1.rbit > 0) {
      $1.pad = $a($1.cws.length + 1);
      $puti($1.pad, 0, $1.cws);
      $put($1.pad, $1.pad.length - 1, 0);
      $1.cws = $1.pad;
    }
    if ($1.lc4b) {
      var _Q8 = $1.cws;
      var _Q9 = $1.dcws;
      $put(_Q8, $f(_Q9 - 1), $get(_Q8, $f(_Q9 - 1)) >>> 4);
      for (var _QE = $f($1.dcws - 1), _QD = $1.ncws - 2; _QE <= _QD; _QE += 1) {
        $1.i = _QE;
        $put($1.cws, $1.i, ($get($1.cws, $1.i) & 15) << 4);
        $put($1.cws, $1.i, $get($1.cws, $1.i + 1) >>> 4 & 15 | $get($1.cws, $1.i));
      }
      $put($1.cws, $1.ncws - 1, ($get($1.cws, $1.ncws - 1) & 15) << 4);
    }
    var _QY = $get($1.options, "debugecc") !== void 0;
    if (_QY) {
      $k[$j++] = "bwipp.debugecc#20363";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    $k[$j++] = Infinity;
    for (var _Qc = 0, _Qd = $1.rows * $1.cols; _Qc < _Qd; _Qc++) {
      $k[$j++] = -1;
    }
    $1.pixs = $a();
    $1.qmv = function() {
      var _Qg = $k[--$j];
      var _Qh = $k[--$j];
      $k[$j++] = $f(_Qh + _Qg * $1.cols);
    };
    if ($eq($1.format, "full")) {
      for (var _Ql = 8, _Qk = $f($1.cols - 9); _Ql <= _Qk; _Ql += 1) {
        $1.i = _Ql;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.i;
        $k[$j++] = 6;
        $1.qmv();
        var _Qp = $k[--$j];
        $put($k[--$j], _Qp, ($1.i + 1) % 2);
        $k[$j++] = $1.pixs;
        $k[$j++] = 6;
        $k[$j++] = $1.i;
        $1.qmv();
        var _Qu = $k[--$j];
        $put($k[--$j], _Qu, ($1.i + 1) % 2);
      }
    }
    if ($eq($1.format, "micro")) {
      for (var _Qz = 8, _Qy = $f($1.cols - 1); _Qz <= _Qy; _Qz += 1) {
        $1.i = _Qz;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.i;
        $k[$j++] = 0;
        $1.qmv();
        var _R3 = $k[--$j];
        $put($k[--$j], _R3, ($1.i + 1) % 2);
        $k[$j++] = $1.pixs;
        $k[$j++] = 0;
        $k[$j++] = $1.i;
        $1.qmv();
        var _R8 = $k[--$j];
        $put($k[--$j], _R8, ($1.i + 1) % 2);
      }
    }
    if ($eq($1.format, "rmqr")) {
      for (var _RD = 3, _RC = $f($1.cols - 4); _RD <= _RC; _RD += 1) {
        $1.i = _RD;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.i;
        $k[$j++] = 0;
        $1.qmv();
        var _RH = $k[--$j];
        $put($k[--$j], _RH, ($1.i + 1) % 2);
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.i;
        $k[$j++] = $f($1.rows - 1);
        $1.qmv();
        var _RN = $k[--$j];
        $put($k[--$j], _RN, ($1.i + 1) % 2);
      }
      for (var _RR = 3, _RQ = $f($1.rows - 4); _RR <= _RQ; _RR += 1) {
        $1.i = _RR;
        $k[$j++] = $1.pixs;
        $k[$j++] = 0;
        $k[$j++] = $1.i;
        $1.qmv();
        var _RV = $k[--$j];
        $put($k[--$j], _RV, ($1.i + 1) % 2);
        $k[$j++] = $1.pixs;
        $k[$j++] = $f($1.cols - 1);
        $k[$j++] = $1.i;
        $1.qmv();
        var _Rb = $k[--$j];
        $put($k[--$j], _Rb, ($1.i + 1) % 2);
      }
      for (var _Ri = $f($1.asp2 - 1), _Rj = $f($1.asp3 - $1.asp2), _Rh = $f($1.cols - 13); _Rj < 0 ? _Ri >= _Rh : _Ri <= _Rh; _Ri += _Rj) {
        $1.i = _Ri;
        for (var _Rm = 3, _Rl = $f($1.rows - 4); _Rm <= _Rl; _Rm += 1) {
          $1.j = _Rm;
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.qmv();
          var _Rr = $k[--$j];
          $put($k[--$j], _Rr, ($1.j + 1) % 2);
        }
      }
    }
    if (!bwipp_qrcode.__20452__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.fpat = $a([$a([1, 1, 1, 1, 1, 1, 1, 0]), $a([1, 0, 0, 0, 0, 0, 1, 0]), $a([1, 0, 1, 1, 1, 0, 1, 0]), $a([1, 0, 1, 1, 1, 0, 1, 0]), $a([1, 0, 1, 1, 1, 0, 1, 0]), $a([1, 0, 0, 0, 0, 0, 1, 0]), $a([1, 1, 1, 1, 1, 1, 1, 0]), $a([0, 0, 0, 0, 0, 0, 0, 0])]);
        $ctx.fsubpat = $a([$a([1, 1, 1, 1, 1, 9, 9, 9]), $a([1, 0, 0, 0, 1, 9, 9, 9]), $a([1, 0, 1, 0, 1, 9, 9, 9]), $a([1, 0, 0, 0, 1, 9, 9, 9]), $a([1, 1, 1, 1, 1, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9])]);
        $ctx.fcorpat = $a([$a([1, 1, 1, 9, 9, 9, 9, 9]), $a([1, 0, 9, 9, 9, 9, 9, 9]), $a([1, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9])]);
        $ctx.fnullpat = $a([$a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9])]);
        var _Si = /* @__PURE__ */ new Map([
          ["full", $a([$ctx.fpat, $ctx.fpat, $ctx.fpat, $ctx.fnullpat])],
          ["micro", $a([$ctx.fpat, $ctx.fnullpat, $ctx.fnullpat, $ctx.fnullpat])],
          ["rmqr", $a([$ctx.fpat, $ctx.fcorpat, $ctx.fcorpat, $ctx.fsubpat])]
        ]);
        $ctx.fpatmap = _Si;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__20452__ = 1;
      })();
    }
    $1.fpats = $get($1.fpatmap, $1.format);
    for (var _Sn = 0; _Sn <= 7; _Sn += 1) {
      $1.y = _Sn;
      for (var _So = 0; _So <= 7; _So += 1) {
        $1.x = _So;
        $1.fpb0 = $get($get($get($1.fpats, 0), $1.y), $1.x);
        $1.fpb1 = $get($get($get($1.fpats, 1), $1.y), $1.x);
        $1.fpb2 = $get($get($get($1.fpats, 2), $1.y), $1.x);
        $1.fpb3 = $get($get($get($1.fpats, 3), $1.y), $1.x);
        if ($1.fpb0 != 9 && $1.y < $1.rows) {
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.x;
          $k[$j++] = $1.y;
          $1.qmv();
          var _TK = $k[--$j];
          $put($k[--$j], _TK, $1.fpb0);
        }
        if ($1.fpb1 != 9) {
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($f($1.cols - $1.x) - 1);
          $k[$j++] = $1.y;
          $1.qmv();
          var _TS = $k[--$j];
          $put($k[--$j], _TS, $1.fpb1);
        }
        if ($1.fpb2 != 9) {
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.x;
          $k[$j++] = $f($f($1.rows - $1.y) - 1);
          $1.qmv();
          var _Ta = $k[--$j];
          $put($k[--$j], _Ta, $1.fpb2);
        }
        if ($1.fpb3 != 9) {
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($f($1.cols - $1.x) - 1);
          $k[$j++] = $f($f($1.rows - $1.y) - 1);
          $1.qmv();
          var _Tj = $k[--$j];
          $put($k[--$j], _Tj, $1.fpb3);
        }
      }
    }
    if (!bwipp_qrcode.__20485__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.algnpatfull = $a([$a([1, 1, 1, 1, 1]), $a([1, 0, 0, 0, 1]), $a([1, 0, 1, 0, 1]), $a([1, 0, 0, 0, 1]), $a([1, 1, 1, 1, 1])]);
        $ctx.algnpatrmqr = $a([$a([1, 1, 1, 9, 9]), $a([1, 0, 1, 9, 9]), $a([1, 1, 1, 9, 9]), $a([9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__20485__ = 1;
      })();
    }
    $1.putalgnpat = function() {
      $1.py = $k[--$j];
      $1.px = $k[--$j];
      for (var _U0 = 0; _U0 <= 4; _U0 += 1) {
        $1.pb = _U0;
        for (var _U1 = 0; _U1 <= 4; _U1 += 1) {
          $1.pa = _U1;
          $1.algnb = $get($get($1.algnpat, $1.pb), $1.pa);
          if ($1.algnb != 9) {
            $k[$j++] = $1.pixs;
            $k[$j++] = $f($1.px + $1.pa);
            $k[$j++] = $f($1.py + $1.pb);
            $1.qmv();
            var _UE = $k[--$j];
            $put($k[--$j], _UE, $1.algnb);
          }
        }
      }
    };
    if ($eq($1.format, "full")) {
      $1.algnpat = $1.algnpatfull;
      for (var _UN = $f($1.asp2 - 2), _UO = $f($1.asp3 - $1.asp2), _UM = $f($1.cols - 13); _UO < 0 ? _UN >= _UM : _UN <= _UM; _UN += _UO) {
        $1.i = _UN;
        $k[$j++] = $1.i;
        $k[$j++] = 4;
        $1.putalgnpat();
        $k[$j++] = 4;
        $k[$j++] = $1.i;
        $1.putalgnpat();
      }
      for (var _UW = $f($1.asp2 - 2), _UX = $f($1.asp3 - $1.asp2), _UV = $f($1.cols - 9); _UX < 0 ? _UW >= _UV : _UW <= _UV; _UW += _UX) {
        $1.x = _UW;
        for (var _Ud = $f($1.asp2 - 2), _Ue = $f($1.asp3 - $1.asp2), _Uc = $f($1.rows - 9); _Ue < 0 ? _Ud >= _Uc : _Ud <= _Uc; _Ud += _Ue) {
          $1.y = _Ud;
          $k[$j++] = $1.x;
          $k[$j++] = $1.y;
          $1.putalgnpat();
        }
      }
    }
    if ($eq($1.format, "rmqr")) {
      $1.algnpat = $1.algnpatrmqr;
      for (var _Uo = $f($1.asp2 - 2), _Up = $f($1.asp3 - $1.asp2), _Un = $f($1.cols - 13); _Up < 0 ? _Uo >= _Un : _Uo <= _Un; _Uo += _Up) {
        $1.i = _Uo;
        $k[$j++] = $1.i;
        $k[$j++] = 0;
        $1.putalgnpat();
        $k[$j++] = $1.i;
        $k[$j++] = $f($1.rows - 3);
        $1.putalgnpat();
      }
    }
    if (!bwipp_qrcode.__20532__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.formatmapmicro = $a([$a([$a([1, 8])]), $a([$a([2, 8])]), $a([$a([3, 8])]), $a([$a([4, 8])]), $a([$a([5, 8])]), $a([$a([6, 8])]), $a([$a([7, 8])]), $a([$a([8, 8])]), $a([$a([8, 7])]), $a([$a([8, 6])]), $a([$a([8, 5])]), $a([$a([8, 4])]), $a([$a([8, 3])]), $a([$a([8, 2])]), $a([$a([8, 1])])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__20532__ = 1;
      })();
    }
    var _Xs = /* @__PURE__ */ new Map([
      ["full", $a([$a([$a([0, 8]), $a([8, $f($1.cols - 1)])]), $a([$a([1, 8]), $a([8, $f($1.cols - 2)])]), $a([$a([2, 8]), $a([8, $f($1.cols - 3)])]), $a([$a([3, 8]), $a([8, $f($1.cols - 4)])]), $a([$a([4, 8]), $a([8, $f($1.cols - 5)])]), $a([$a([5, 8]), $a([8, $f($1.cols - 6)])]), $a([$a([7, 8]), $a([8, $f($1.cols - 7)])]), $a([$a([8, 8]), $a([$f($1.cols - 8), 8])]), $a([$a([8, 7]), $a([$f($1.cols - 7), 8])]), $a([$a([8, 5]), $a([$f($1.cols - 6), 8])]), $a([$a([8, 4]), $a([$f($1.cols - 5), 8])]), $a([$a([8, 3]), $a([$f($1.cols - 4), 8])]), $a([$a([8, 2]), $a([$f($1.cols - 3), 8])]), $a([$a([8, 1]), $a([$f($1.cols - 2), 8])]), $a([$a([8, 0]), $a([$f($1.cols - 1), 8])])])],
      ["micro", $1.formatmapmicro],
      ["rmqr", $a([$a([$a([11, 3]), $a([$f($1.cols - 3), $f($1.rows - 6)])]), $a([$a([11, 2]), $a([$f($1.cols - 4), $f($1.rows - 6)])]), $a([$a([11, 1]), $a([$f($1.cols - 5), $f($1.rows - 6)])]), $a([$a([10, 5]), $a([$f($1.cols - 6), $f($1.rows - 2)])]), $a([$a([10, 4]), $a([$f($1.cols - 6), $f($1.rows - 3)])]), $a([$a([10, 3]), $a([$f($1.cols - 6), $f($1.rows - 4)])]), $a([$a([10, 2]), $a([$f($1.cols - 6), $f($1.rows - 5)])]), $a([$a([10, 1]), $a([$f($1.cols - 6), $f($1.rows - 6)])]), $a([$a([9, 5]), $a([$f($1.cols - 7), $f($1.rows - 2)])]), $a([$a([9, 4]), $a([$f($1.cols - 7), $f($1.rows - 3)])]), $a([$a([9, 3]), $a([$f($1.cols - 7), $f($1.rows - 4)])]), $a([$a([9, 2]), $a([$f($1.cols - 7), $f($1.rows - 5)])]), $a([$a([9, 1]), $a([$f($1.cols - 7), $f($1.rows - 6)])]), $a([$a([8, 5]), $a([$f($1.cols - 8), $f($1.rows - 2)])]), $a([$a([8, 4]), $a([$f($1.cols - 8), $f($1.rows - 3)])]), $a([$a([8, 3]), $a([$f($1.cols - 8), $f($1.rows - 4)])]), $a([$a([8, 2]), $a([$f($1.cols - 8), $f($1.rows - 5)])]), $a([$a([8, 1]), $a([$f($1.cols - 8), $f($1.rows - 6)])])])]
    ]);
    $1.formatmap = $get(_Xs, $1.format);
    $forall($1.formatmap, function() {
      $forall($k[--$j], function() {
        $forall($k[--$j]);
        $1.qmv();
        $put($1.pixs, $k[--$j], 1);
      });
    });
    if ($eq($1.format, "full") && $1.cols >= 45) {
      $1.versionmap = $a([$a([$a([$f($1.cols - 9), 5]), $a([5, $f($1.cols - 9)])]), $a([$a([$f($1.cols - 10), 5]), $a([5, $f($1.cols - 10)])]), $a([$a([$f($1.cols - 11), 5]), $a([5, $f($1.cols - 11)])]), $a([$a([$f($1.cols - 9), 4]), $a([4, $f($1.cols - 9)])]), $a([$a([$f($1.cols - 10), 4]), $a([4, $f($1.cols - 10)])]), $a([$a([$f($1.cols - 11), 4]), $a([4, $f($1.cols - 11)])]), $a([$a([$f($1.cols - 9), 3]), $a([3, $f($1.cols - 9)])]), $a([$a([$f($1.cols - 10), 3]), $a([3, $f($1.cols - 10)])]), $a([$a([$f($1.cols - 11), 3]), $a([3, $f($1.cols - 11)])]), $a([$a([$f($1.cols - 9), 2]), $a([2, $f($1.cols - 9)])]), $a([$a([$f($1.cols - 10), 2]), $a([2, $f($1.cols - 10)])]), $a([$a([$f($1.cols - 11), 2]), $a([2, $f($1.cols - 11)])]), $a([$a([$f($1.cols - 9), 1]), $a([1, $f($1.cols - 9)])]), $a([$a([$f($1.cols - 10), 1]), $a([1, $f($1.cols - 10)])]), $a([$a([$f($1.cols - 11), 1]), $a([1, $f($1.cols - 11)])]), $a([$a([$f($1.cols - 9), 0]), $a([0, $f($1.cols - 9)])]), $a([$a([$f($1.cols - 10), 0]), $a([0, $f($1.cols - 10)])]), $a([$a([$f($1.cols - 11), 0]), $a([0, $f($1.cols - 11)])])]);
    } else {
      $1.versionmap = $a([]);
    }
    var _ZW = $1.versionmap;
    for (var _ZX = 0, _ZY = _ZW.length; _ZX < _ZY; _ZX++) {
      $forall($get(_ZW, _ZX), function() {
        $forall($k[--$j]);
        $1.qmv();
        $put($1.pixs, $k[--$j], 0);
      });
    }
    if ($eq($1.format, "full")) {
      $k[$j++] = $1.pixs;
      $k[$j++] = 8;
      $k[$j++] = $f($1.rows - 8);
      $1.qmv();
      var _Zg = $k[--$j];
      $put($k[--$j], _Zg, 0);
    }
    var _a0 = $a([function() {
      var _Zi = $k[--$j];
      var _Zj = $k[--$j];
      $k[$j++] = $f(_Zj + _Zi) % 2;
    }, function() {
      var _Zk = $k[--$j];
      var _Zl = $k[--$j];
      $k[$j++] = _Zk;
      $k[$j++] = _Zl;
      $j--;
      var _Zm = $k[--$j];
      $k[$j++] = _Zm % 2;
    }, function() {
      $j--;
      var _Zn = $k[--$j];
      $k[$j++] = _Zn % 3;
    }, function() {
      var _Zo = $k[--$j];
      var _Zp = $k[--$j];
      $k[$j++] = $f(_Zp + _Zo) % 3;
    }, function() {
      var _Zq = $k[--$j];
      var _Zr = $k[--$j];
      $k[$j++] = (~~(_Zq / 2) + ~~(_Zr / 3)) % 2;
    }, function() {
      var _Zs = $k[--$j];
      var _Zu = $k[--$j] * _Zs;
      $k[$j++] = $f(_Zu % 2 + _Zu % 3);
    }, function() {
      var _Zv = $k[--$j];
      var _Zx = $k[--$j] * _Zv;
      $k[$j++] = $f(_Zx % 2 + _Zx % 3) % 2;
    }, function() {
      var _Zy = $k[--$j];
      var _Zz = $k[--$j];
      $k[$j++] = $f(_Zz * _Zy % 3 + $f(_Zz + _Zy) % 2) % 2;
    }]);
    var _aB = $a([function() {
      var _a1 = $k[--$j];
      var _a2 = $k[--$j];
      $k[$j++] = _a1;
      $k[$j++] = _a2;
      $j--;
      var _a3 = $k[--$j];
      $k[$j++] = _a3 % 2;
    }, function() {
      var _a4 = $k[--$j];
      var _a5 = $k[--$j];
      $k[$j++] = (~~(_a4 / 2) + ~~(_a5 / 3)) % 2;
    }, function() {
      var _a6 = $k[--$j];
      var _a8 = $k[--$j] * _a6;
      $k[$j++] = $f(_a8 % 2 + _a8 % 3) % 2;
    }, function() {
      var _a9 = $k[--$j];
      var _aA = $k[--$j];
      $k[$j++] = $f(_aA * _a9 % 3 + $f(_aA + _a9) % 2) % 2;
    }]);
    var _aE = $a([function() {
      var _aC = $k[--$j];
      var _aD = $k[--$j];
      $k[$j++] = (~~(_aC / 2) + ~~(_aD / 3)) % 2;
    }]);
    var _aF = /* @__PURE__ */ new Map([
      ["full", _a0],
      ["micro", _aB],
      ["rmqr", _aE]
    ]);
    $1.maskfuncs = $get(_aF, $1.format);
    if ($1.mask != -1) {
      $1.maskfuncs = $a([$get($1.maskfuncs, $1.mask - 1)]);
      $1.bestmaskval = $1.mask - 1;
    }
    $1.masks = $a($1.maskfuncs.length);
    for (var _aS = 0, _aR = $1.masks.length - 1; _aS <= _aR; _aS += 1) {
      $1.m = _aS;
      $1.mask = $a($1.rows * $1.cols);
      for (var _aY = 0, _aX = $f($1.rows - 1); _aY <= _aX; _aY += 1) {
        $1.j = _aY;
        for (var _ab = 0, _aa = $f($1.cols - 1); _ab <= _aa; _ab += 1) {
          $1.i = _ab;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          if ($get($1.maskfuncs, $1.m)() === true) {
            break;
          }
          var _ah = $k[--$j];
          $k[$j++] = _ah == 0;
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.qmv();
          var _al = $k[--$j];
          var _an = $get($k[--$j], _al);
          var _ao = $k[--$j];
          var _ap = _ao && _an == -1 ? 1 : 0;
          $k[$j++] = _ap;
          $k[$j++] = $1.mask;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.qmv();
          var _at = $k[--$j];
          var _au = $k[--$j];
          $put(_au, _at, $k[--$j]);
        }
      }
      $put($1.masks, $1.m, $1.mask);
    }
    var _b1 = $ne($1.format, "rmqr") ? 1 : 2;
    $1.posx = $f($1.cols - _b1);
    $1.posy = $f($1.rows - 1);
    $1.dir = -1;
    $1.col = 1;
    $1.num = 0;
    for (; ; ) {
      if ($1.posx < 0) {
        break;
      }
      $k[$j++] = $1.pixs;
      $k[$j++] = $1.posx;
      $k[$j++] = $1.posy;
      $1.qmv();
      var _b7 = $k[--$j];
      if ($get($k[--$j], _b7) == -1) {
        var _bC = $get($1.cws, ~~($1.num / 8));
        var _bE = -(7 - $1.num % 8);
        $k[$j++] = (_bE < 0 ? _bC >>> -_bE : _bC << _bE) & 1;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.posx;
        $k[$j++] = $1.posy;
        $1.qmv();
        var _bI = $k[--$j];
        var _bJ = $k[--$j];
        $put(_bJ, _bI, $k[--$j]);
        $1.num = $1.num + 1;
      }
      if ($1.col == 1) {
        $1.col = 0;
        $1.posx = $f($1.posx - 1);
      } else {
        $1.col = 1;
        $1.posx = $f($1.posx + 1);
        $1.posy = $f($1.posy + $1.dir);
        if ($1.posy < 0 || $1.posy >= $1.rows) {
          $1.dir = $1.dir * -1;
          $1.posy = $f($1.posy + $1.dir);
          $1.posx = $f($1.posx - 2);
          if ($eq($1.format, "full") && $1.posx == 6) {
            $1.posx = $f($1.posx - 1);
          }
        }
      }
    }
    $1.evalfulln1n3 = function() {
      $1.scrle = $k[--$j];
      $k[$j++] = "scr1";
      $k[$j++] = 0;
      $forall($1.scrle, function() {
        var _bd = $k[--$j];
        $k[$j++] = _bd;
        if (_bd >= 5) {
          var _be = $k[--$j];
          var _bg = $f($f($k[--$j] + _be) - 2);
          $k[$j++] = _bg;
          $k[$j++] = _bg;
        }
        $j--;
      });
      var _bh = $k[--$j];
      $1[$k[--$j]] = _bh;
      $1.scr3 = 0;
      for (var _bl = 3, _bk = $1.scrle.length - 3; _bl <= _bk; _bl += 2) {
        $1.j = _bl;
        if ($get($1.scrle, $1.j) % 3 == 0) {
          $1.fact = ~~($get($1.scrle, $1.j) / 3);
          var _bu = $geti($1.scrle, $1.j - 2, 5);
          for (var _bv = 0, _bw = _bu.length; _bv < _bw; _bv++) {
            $k[$j++] = $get(_bu, _bv) == $1.fact;
          }
          var _bz = $k[--$j];
          var _c0 = $k[--$j];
          var _c1 = $k[--$j];
          $k[$j++] = $an(_c0, _bz);
          $k[$j++] = _c1;
          $j--;
          var _c2 = $k[--$j];
          var _c3 = $k[--$j];
          var _c4 = $k[--$j];
          if (_c4 && (_c3 && _c2)) {
            if ($1.j == 3 || $1.j + 4 >= $1.scrle.length) {
              $1.scr3 = $1.scr3 + 40;
            } else {
              if ($get($1.scrle, $1.j - 3) >= 4 || $get($1.scrle, $1.j + 3) >= 4) {
                $1.scr3 = $1.scr3 + 40;
              }
            }
          }
        }
      }
      $k[$j++] = $1.scr1;
      $k[$j++] = $1.scr3;
    };
    $1.evalfull = function() {
      $1.sym = $k[--$j];
      $1.n1 = 0;
      $1.n2 = 0;
      $1.n3 = 0;
      $1.rle = $a($f($1.cols + 1));
      $1.lastpairs = $a($1.cols);
      $1.thispairs = $a($1.cols);
      $1.colsadd1 = $f($1.cols + 1);
      for (var _cS = 0, _cR = $f($1.cols - 1); _cS <= _cR; _cS += 1) {
        $1.i = _cS;
        $k[$j++] = Infinity;
        var _cU = $1.cols;
        $k[$j++] = 0;
        $k[$j++] = 0;
        for (var _cW = $1.i, _cX = _cU, _cV = $f(_cU * _cU - 1); _cX < 0 ? _cW >= _cV : _cW <= _cV; _cW += _cX) {
          var _cZ = $get($1.sym, _cW);
          var _ca = $k[--$j];
          $k[$j++] = _cZ;
          if ($eq(_ca, _cZ)) {
            var _cb = $k[--$j];
            var _cc = $k[--$j];
            $k[$j++] = $f(_cc + 1);
            $k[$j++] = _cb;
          } else {
            var _cd = $k[--$j];
            $k[$j++] = 1;
            $k[$j++] = _cd;
          }
        }
        $j--;
        var _cf = $counttomark() + 2;
        $astore($geti($1.rle, 0, _cf - 2));
        $1.evalfulln1n3();
        $1.n3 = $f($k[--$j] + $1.n3);
        $1.n1 = $f($k[--$j] + $1.n1);
        $j--;
        $1.symrow = $geti($1.sym, $1.i * $1.cols, $1.cols);
        $k[$j++] = Infinity;
        var _cq = $1.symrow;
        $k[$j++] = 0;
        $k[$j++] = 0;
        for (var _cr = 0, _cs = _cq.length; _cr < _cs; _cr++) {
          var _ct = $get(_cq, _cr);
          var _cu = $k[--$j];
          $k[$j++] = _ct;
          if ($eq(_cu, _ct)) {
            var _cv = $k[--$j];
            var _cw = $k[--$j];
            $k[$j++] = $f(_cw + 1);
            $k[$j++] = _cv;
          } else {
            var _cx = $k[--$j];
            $k[$j++] = 1;
            $k[$j++] = _cx;
          }
        }
        $j--;
        var _cz = $counttomark() + 2;
        $astore($geti($1.rle, 0, _cz - 2));
        $1.evalfulln1n3();
        $1.n3 = $f($k[--$j] + $1.n3);
        $1.n1 = $f($k[--$j] + $1.n1);
        $j--;
        var _d5 = $1.thispairs;
        $1.thispairs = $1.lastpairs;
        $1.lastpairs = _d5;
        var _d9 = $get($1.symrow, 0) == 1 ? 0 : 1;
        var _dA = $1.symrow;
        $k[$j++] = _d9;
        for (var _dB = 0, _dC = _dA.length; _dB < _dC; _dB++) {
          var _dD = $get(_dA, _dB);
          var _dE = $k[--$j];
          $k[$j++] = $f(_dE + _dD);
          $k[$j++] = _dD;
        }
        $j--;
        $astore($1.thispairs);
        $j--;
        if ($1.i > 0) {
          $k[$j++] = Infinity;
          $aload($1.lastpairs);
          $aload($1.thispairs);
          $k[$j++] = $1.n2;
          for (var _dL = 0, _dM = $1.cols; _dL < _dM; _dL++) {
            var _dN = $k[--$j];
            var _dO = $k[--$j];
            $k[$j++] = _dN;
            $k[$j++] = _dO;
            var _dQ = $k[$j - 1 - $1.colsadd1];
            if (($f($k[--$j] + _dQ) & 3) == 0) {
              var _dS = $k[--$j];
              $k[$j++] = $f(_dS + 3);
            }
          }
          $1.n2 = $k[--$j];
          $cleartomark();
        }
      }
      $k[$j++] = "dark";
      $k[$j++] = 0;
      $forall($1.sym, function() {
        var _dV = $k[--$j];
        var _dW = $k[--$j];
        $k[$j++] = $f(_dW + _dV);
      });
      var _dX = $k[--$j];
      $1[$k[--$j]] = _dX;
      var _da = $1.cols;
      $1.n4 = ~~(Math.abs($f($1.dark * 100 / (_da * _da) - 50)) / 5) * 10;
      $k[$j++] = $f($f($f($1.n1 + $1.n2) + $1.n3) + $1.n4);
    };
    $1.evalmicro = function() {
      $1.sym = $k[--$j];
      $1.dkrhs = 0;
      $1.dkbot = 0;
      for (var _di = 1, _dh = $f($1.cols - 1); _di <= _dh; _di += 1) {
        $1.i = _di;
        $k[$j++] = "dkrhs";
        $k[$j++] = $1.dkrhs;
        $k[$j++] = $1.sym;
        $k[$j++] = $f($1.cols - 1);
        $k[$j++] = $1.i;
        $1.qmv();
        var _dn = $k[--$j];
        var _dp = $get($k[--$j], _dn);
        var _dq = $k[--$j];
        $1[$k[--$j]] = $f(_dq + _dp);
        $k[$j++] = "dkbot";
        $k[$j++] = $1.dkbot;
        $k[$j++] = $1.sym;
        $k[$j++] = $1.i;
        $k[$j++] = $f($1.cols - 1);
        $1.qmv();
        var _dw = $k[--$j];
        var _dy = $get($k[--$j], _dw);
        var _dz = $k[--$j];
        $1[$k[--$j]] = $f(_dz + _dy);
      }
      if ($1.dkrhs <= $1.dkbot) {
        $k[$j++] = -($1.dkrhs * 16 + $1.dkbot);
      } else {
        $k[$j++] = -($1.dkbot * 16 + $1.dkrhs);
      }
    };
    $1.bestscore = 999999999;
    for (var _e9 = 0, _e8 = $1.masks.length - 1; _e9 <= _e8; _e9 += 1) {
      $1.m = _e9;
      $1.masksym = $a($1.rows * $1.cols);
      for (var _eG = 0, _eF = $f($1.rows * $1.cols - 1); _eG <= _eF; _eG += 1) {
        $1.i = _eG;
        $put($1.masksym, $1.i, $xo($get($1.pixs, $1.i), $get($get($1.masks, $1.m), $1.i)));
      }
      if ($1.masks.length != 1) {
        if ($eq($1.format, "full")) {
          $k[$j++] = $1.masksym;
          $1.evalfull();
          $1.score = $k[--$j];
        } else {
          $k[$j++] = $1.masksym;
          $1.evalmicro();
          $1.score = $k[--$j];
        }
        if ($1.score < $1.bestscore) {
          $1.bestsym = $1.masksym;
          $1.bestmaskval = $1.m;
          $1.bestscore = $1.score;
        }
      } else {
        $1.bestsym = $1.masksym;
      }
    }
    $1.pixs = $1.bestsym;
    if ($eq($1.format, "full")) {
      $k[$j++] = $1.pixs;
      $k[$j++] = 8;
      $k[$j++] = $f($1.cols - 8);
      $1.qmv();
      var _eh = $k[--$j];
      $put($k[--$j], _eh, 1);
    }
    if (!bwipp_qrcode.__20814__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.fmtvalsfull = $a([21522, 20773, 24188, 23371, 17913, 16590, 20375, 19104, 30660, 29427, 32170, 30877, 26159, 25368, 27713, 26998, 5769, 5054, 7399, 6608, 1890, 597, 3340, 2107, 13663, 12392, 16177, 14854, 9396, 8579, 11994, 11245]);
        $ctx.fmtvalsmicro = $a([17477, 16754, 20011, 19228, 21934, 20633, 24512, 23287, 26515, 25252, 28157, 26826, 30328, 29519, 31766, 31009, 1758, 1001, 3248, 2439, 5941, 4610, 7515, 6252, 9480, 8255, 12134, 10833, 13539, 12756, 16013, 15290]);
        $ctx.fmtvalsrmqr1 = $a([129714, 124311, 121821, 115960, 112748, 108361, 104707, 99878, 98062, 90155, 89697, 82244, 81360, 74485, 72895, 66458, 61898, 61167, 53413, 53120, 45844, 44081, 37499, 36190, 29814, 27475, 21785, 19004, 13992, 10637, 6087, 2274, 258919, 257090, 250376, 249133, 242105, 241308, 233686, 233459, 227035, 223742, 219060, 215185, 209925, 207648, 202090, 199247, 194591, 190266, 186736, 181845, 178881, 173540, 170926, 165003, 163235, 156294, 154828, 148457, 147325, 139352, 138770, 131383]);
        $ctx.fmtvalsrmqr2 = $a([133755, 136542, 142100, 144433, 149669, 153472, 158154, 161519, 167879, 168162, 175784, 176525, 183577, 184892, 191606, 193363, 196867, 204326, 204908, 212809, 213981, 220408, 221874, 228759, 230591, 236442, 239056, 244469, 247393, 252228, 255758, 260139, 942, 7307, 8897, 15844, 16752, 24149, 24607, 32570, 34322, 39223, 42877, 47192, 50380, 56297, 58787, 64134, 67798, 71667, 76217, 79516, 84488, 87341, 93031, 95298, 101738, 102991, 109573, 111392, 118708, 118929, 126683, 127486]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__20814__ = 1;
      })();
    }
    if ($eq($1.format, "full")) {
      $k[$j++] = "ecid";
      $search("MLHQ", $1.eclevel);
      $j--;
      var _eq = $k[--$j];
      var _er = $k[--$j];
      $k[$j++] = _eq.length;
      $k[$j++] = _er;
      $j--;
      var _es = $k[--$j];
      var _et = $k[--$j];
      $k[$j++] = _es;
      $k[$j++] = _et;
      $j--;
      var _eu = $k[--$j];
      $1[$k[--$j]] = _eu;
      $1.fmtval = $get($1.fmtvalsfull, ($1.ecid << 3) + $1.bestmaskval);
      for (var _f2 = 0, _f1 = $1.formatmap.length - 1; _f2 <= _f1; _f2 += 1) {
        $1.i = _f2;
        $forall($get($1.formatmap, $1.i), function() {
          var _f7 = $k[--$j];
          $k[$j++] = $1.pixs;
          $aload(_f7);
          $1.qmv();
          var _f8 = $1.fmtval;
          var _fA = -(14 - $1.i);
          var _fB = $k[--$j];
          $put($k[--$j], _fB, (_fA < 0 ? _f8 >>> -_fA : _f8 << _fA) & 1);
        });
      }
    }
    if ($eq($1.format, "micro")) {
      $1.symid = $get($get($a([$a([0]), $a([1, 2]), $a([3, 4]), $a([5, 6, 7])]), ~~($f($1.cols - 11) / 2)), $1.eclval);
      $1.fmtval = $get($1.fmtvalsmicro, ($1.symid << 2) + $1.bestmaskval);
      for (var _fT = 0, _fS = $1.formatmap.length - 1; _fT <= _fS; _fT += 1) {
        $1.i = _fT;
        $k[$j++] = $1.pixs;
        $aload($get($get($1.formatmap, $1.i), 0));
        $1.qmv();
        var _fZ = $1.fmtval;
        var _fb = -(14 - $1.i);
        var _fc = $k[--$j];
        $put($k[--$j], _fc, (_fb < 0 ? _fZ >>> -_fb : _fZ << _fb) & 1);
      }
    }
    if ($eq($1.format, "rmqr")) {
      $k[$j++] = "fmtvalu";
      $search("MH", $1.eclevel);
      $j--;
      var _fg = $k[--$j];
      var _fh = $k[--$j];
      $k[$j++] = _fg.length;
      $k[$j++] = _fh;
      $j--;
      var _fi = $k[--$j];
      var _fj = $k[--$j];
      $k[$j++] = _fi;
      $k[$j++] = _fj;
      $j--;
      var _fk = $k[--$j];
      $1[$k[--$j]] = (_fk << 5) + $1.verind;
      $1.fmtval1 = $get($1.fmtvalsrmqr1, $1.fmtvalu);
      $1.fmtval2 = $get($1.fmtvalsrmqr2, $1.fmtvalu);
      for (var _fv = 0, _fu = $1.formatmap.length - 1; _fv <= _fu; _fv += 1) {
        $1.i = _fv;
        $k[$j++] = $1.pixs;
        $aload($get($get($1.formatmap, $1.i), 0));
        $1.qmv();
        var _g1 = $1.fmtval1;
        var _g3 = -(17 - $1.i);
        var _g4 = $k[--$j];
        $put($k[--$j], _g4, (_g3 < 0 ? _g1 >>> -_g3 : _g1 << _g3) & 1);
        $k[$j++] = $1.pixs;
        $aload($get($get($1.formatmap, $1.i), 1));
        $1.qmv();
        var _gB = $1.fmtval2;
        var _gD = -(17 - $1.i);
        var _gE = $k[--$j];
        $put($k[--$j], _gE, (_gD < 0 ? _gB >>> -_gD : _gB << _gD) & 1);
      }
    }
    if (!bwipp_qrcode.__20853__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.vervals = $a([31892, 34236, 39577, 42195, 48118, 51042, 55367, 58893, 63784, 68472, 70749, 76311, 79154, 84390, 87683, 92361, 96236, 102084, 102881, 110507, 110734, 117786, 119615, 126325, 127568, 133589, 136944, 141498, 145311, 150283, 152622, 158308, 161089, 167017]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_qrcode.$ctx[id] = $ctx[id]);
        bwipp_qrcode.__20853__ = 1;
      })();
    }
    if ($eq($1.format, "full") && $1.cols >= 45) {
      $1.verval = $get($1.vervals, ~~($f($1.cols - 17) / 4) - 7);
      for (var _gP = 0, _gO = $1.versionmap.length - 1; _gP <= _gO; _gP += 1) {
        $1.i = _gP;
        $forall($get($1.versionmap, $1.i), function() {
          var _gU = $k[--$j];
          $k[$j++] = $1.pixs;
          $forall(_gU);
          $1.qmv();
          var _gV = $1.verval;
          var _gX = -(17 - $1.i);
          var _gY = $k[--$j];
          $put($k[--$j], _gY, (_gX < 0 ? _gV >>> -_gX : _gV << _gX) & 1);
        });
      }
    }
    var _gg = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.cols],
      ["pixy", $1.rows],
      ["height", $1.rows * 2 / 72],
      ["width", $1.cols * 2 / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _gg;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_swissqrcode() {
    var $1 = Object.create(bwipp_swissqrcode.$ctx || (bwipp_swissqrcode.$ctx = {}));
    $1.dontdraw = false;
    $1.parse = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _3 = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parseonly", true],
      ["parsefnc", false]
    ]);
    $1.fncvals = _3;
    $k[$j++] = "barcode";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $1.barlen = $1.barcode.length;
    delete $1.options["parse"];
    if ($1.barcode.length > 997) {
      $k[$j++] = "bwipp.swissqrcodeBadLength#20930";
      $k[$j++] = "Swiss QR Code input must not exceed 997 digits";
      bwipp_raiseerror();
    }
    $put($1.options, "dontdraw", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_qrcode();
    var _E = $k[--$j];
    $1[$k[--$j]] = _E;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      $$.save();
      var _K = $$.currpos();
      $$.translate(_K.x, _K.y);
      var _L = 72 / 25.4;
      $$.scale(_L, _L);
      $$.save();
      $$.newpath();
      $$.moveto(0, 0);
      $$.lineto(46, 0);
      $$.lineto(46, 46);
      $$.lineto(0, 46);
      $$.closepath();
      $$.moveto(19.5, 19.5);
      $$.lineto(19.5, 26.5);
      $$.lineto(26.5, 26.5);
      $$.lineto(26.5, 19.5);
      $$.closepath();
      $$.clip();
      $$.save();
      $$.moveto(0, 0);
      var _O = 46 / $get($1.args, "pixx") / 2;
      $$.scale(_O, _O);
      bwipp_renmatrix();
      $$.restore();
      $$.restore();
      $$.translate(19.5, 19.5);
      var _P = 7 / 83;
      $$.scale(_P, _P);
      $$.newpath();
      $$.moveto(6, 6);
      $$.lineto(6, 77);
      $$.lineto(77, 77);
      $$.lineto(77, 6);
      $$.closepath();
      $$.moveto(49, 18);
      $$.lineto(49, 34);
      $$.lineto(65, 34);
      $$.lineto(65, 49);
      $$.lineto(49, 49);
      $$.lineto(49, 65);
      $$.lineto(34, 65);
      $$.lineto(34, 49);
      $$.lineto(18, 49);
      $$.lineto(18, 34);
      $$.lineto(34, 34);
      $$.lineto(34, 18);
      $$.closepath();
      $$.setrgbcolor(0, 0, 0);
      $$.fill();
      $$.restore();
    }
  }
  function bwipp_microqrcode() {
    var $1 = Object.create(bwipp_microqrcode.$ctx || (bwipp_microqrcode.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "micro");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_qrcode();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_rectangularmicroqrcode() {
    var $1 = Object.create(bwipp_rectangularmicroqrcode.$ctx || (bwipp_rectangularmicroqrcode.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "rmqr");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_qrcode();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_maxicode() {
    var $1 = Object.create(bwipp_maxicode.$ctx || (bwipp_maxicode.$ctx = {}));
    $1.dontdraw = false;
    $1.mode = -1;
    $1.sam = -1;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.barcode, "")) {
      $k[$j++] = "bwipp.maxicodeEmptyData#21148";
      $k[$j++] = "The data must not be empty";
      bwipp_raiseerror();
    }
    if ($1.mode != -1 && ($1.mode < 2 || $1.mode > 6)) {
      $k[$j++] = "bwipp.maxicodeBadMode#21152";
      $k[$j++] = "Mode must be 2 to 6";
      bwipp_raiseerror();
    }
    if ($1.sam != -1) {
      $k[$j++] = true;
      for (var _7 = 0, _8 = 1; _7 < _8; _7++) {
        var _9 = $1.sam;
        if (_9 < 12 || _9 > 88) {
          $j--;
          $k[$j++] = false;
          break;
        }
        var _B = $1.sam % 10;
        if (_B < 2 || _B > 8) {
          $j--;
          $k[$j++] = false;
          break;
        }
        if (~~($1.sam / 10) > $1.sam % 10) {
          $j--;
          $k[$j++] = false;
          break;
        }
      }
      if ($nt($k[--$j])) {
        $k[$j++] = "bwipp.maxicodeBadSAM#21163";
        $k[$j++] = 'SAM must be formatted as "NM" for Nth of M symbols, from 2 to 8 symbols';
        bwipp_raiseerror();
      }
    }
    var _H = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["eci", true]
    ]);
    $1.fncvals = _H;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _K = $k[--$j];
    $1[$k[--$j]] = _K;
    $1.msglen = $1.msg.length;
    if ($1.mode == 2 || $1.mode == 3) {
      $1.barcode = $s($1.msglen);
      for (var _T = 0, _S = $1.msglen - 1; _T <= _S; _T += 1) {
        $1.i = _T;
        if ($get($1.msg, $1.i) > 0) {
          $put($1.barcode, $1.i, $get($1.msg, $1.i));
        }
      }
      $1.barlen = $1.barcode.length;
      $1.fid = "";
      if ($1.barlen >= 7) {
        if ($eq($geti($1.barcode, 0, 7), "[)>01")) {
          $1.fid = $geti($1.barcode, 0, 9);
          $1.barcode = $geti($1.barcode, 9, $1.barlen - 9);
        }
      }
      $search($1.barcode, "");
      if ($k[--$j]) {
        $1.pcode = $k[--$j];
        $j--;
        if ($1.mode == 2) {
          $k[$j++] = true;
          for (var _p = 0, _q = 1; _p < _q; _p++) {
            if ($1.pcode.length > 9) {
              $j--;
              $k[$j++] = false;
              break;
            }
            $forall($1.pcode, function() {
              var _t = $k[--$j];
              if (_t < 48 || _t > 57) {
                $j--;
                $k[$j++] = false;
                return true;
              }
            });
          }
          if ($nt($k[--$j])) {
            $j--;
            $k[$j++] = "bwipp.maxicodeBadMode2PostCode#21212";
            $k[$j++] = "A mode 2 postcode must not exceed 9 digits";
            bwipp_raiseerror();
          }
        } else {
          $forall($1.pcode, function() {
            var _w = $k[--$j];
            if (!(_w == 32 || (_w >= 34 && _w <= 58 || _w >= 65 && _w <= 90))) {
              $j--;
              $k[$j++] = "bwipp.maxicodeBadMode3PostCode#21220";
              $k[$j++] = "A mode 3 postcode must not exceed 6 characters";
              bwipp_raiseerror();
            }
          });
        }
      } else {
        $j--;
        $k[$j++] = "bwipp.maxicodeExpectedPostCode#21225";
        $k[$j++] = "Expected postcode followed by group separator character";
        bwipp_raiseerror();
      }
      $search($k[--$j], "");
      if ($k[--$j]) {
        $1.ccode = $k[--$j];
        $j--;
        $k[$j++] = true;
        for (var _10 = 0, _11 = 1; _10 < _11; _10++) {
          if ($1.ccode.length != 3) {
            $j--;
            $k[$j++] = false;
            break;
          }
          $forall($1.ccode, function() {
            var _14 = $k[--$j];
            if (_14 < 48 || _14 > 57) {
              $j--;
              $k[$j++] = false;
              return true;
            }
          });
        }
        if ($nt($k[--$j])) {
          $j--;
          $k[$j++] = "bwipp.maxicodeBadCountryCode#21235";
          $k[$j++] = "Country code must be three digits";
          bwipp_raiseerror();
        }
      } else {
        $j--;
        $k[$j++] = "bwipp.maxicodeExpectedCountryCode#21238";
        $k[$j++] = "Expected country code followed by group separator character";
        bwipp_raiseerror();
      }
      $search($k[--$j], "");
      if ($k[--$j]) {
        $1.scode = $k[--$j];
        $j--;
        $k[$j++] = true;
        for (var _19 = 0, _1A = 1; _19 < _1A; _19++) {
          if ($1.scode.length != 3) {
            $j--;
            $k[$j++] = false;
            break;
          }
          $forall($1.scode, function() {
            var _1D = $k[--$j];
            if (_1D < 48 || _1D > 57) {
              $j--;
              $k[$j++] = false;
              return true;
            }
          });
        }
        if ($nt($k[--$j])) {
          $j--;
          $k[$j++] = "bwipp.maxicodeBadServiceClass#21248";
          $k[$j++] = "Service class must be three digits";
          bwipp_raiseerror();
        }
      } else {
        $j--;
        $k[$j++] = "bwipp.maxicodeExpectedServiceClass#21251";
        $k[$j++] = "Expected service class followed by group separator character";
        bwipp_raiseerror();
      }
      $1.barcode = $k[--$j];
      var _1I = $s($1.barcode.length + $1.fid.length);
      $puti(_1I, 0, $1.fid);
      $puti(_1I, $1.fid.length, $1.barcode);
      $1.barcode = _1I;
      $1.barlen = $1.barcode.length;
      $k[$j++] = Infinity;
      var _1N = $1.barcode;
      for (var _1O = 0, _1P = _1N.length; _1O < _1P; _1O++) {
        $k[$j++] = $get(_1N, _1O);
      }
      $1.msg = $a();
      $1.msglen = $1.msg.length;
    }
    if (!bwipp_maxicode.__21361__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.eci = -1;
        $ctx.pad = -2;
        $ctx.ns = -3;
        $ctx.la = -4;
        $ctx.lb = -5;
        $ctx.sa = -6;
        $ctx.sb = -7;
        $ctx.sc = -8;
        $ctx.sd = -9;
        $ctx.se = -10;
        $ctx.sa2 = -11;
        $ctx.sa3 = -12;
        $ctx.lkc = -13;
        $ctx.lkd = -14;
        $ctx.lke = -15;
        $ctx.pd2 = -16;
        $ctx.pd3 = -17;
        $ctx.charmaps = $a([$a([13, "`", 192, 224, 0]), $a(["A", "a", 193, 225, 1]), $a(["B", "b", 194, 226, 2]), $a(["C", "c", 195, 227, 3]), $a(["D", "d", 196, 228, 4]), $a(["E", "e", 197, 229, 5]), $a(["F", "f", 198, 230, 6]), $a(["G", "g", 199, 231, 7]), $a(["H", "h", 200, 232, 8]), $a(["I", "i", 201, 233, 9]), $a(["J", "j", 202, 234, 10]), $a(["K", "k", 203, 235, 11]), $a(["L", "l", 204, 236, 12]), $a(["M", "m", 205, 237, 13]), $a(["N", "n", 206, 238, 14]), $a(["O", "o", 207, 239, 15]), $a(["P", "p", 208, 240, 16]), $a(["Q", "q", 209, 241, 17]), $a(["R", "r", 210, 242, 18]), $a(["S", "s", 211, 243, 19]), $a(["T", "t", 212, 244, 20]), $a(["U", "u", 213, 245, 21]), $a(["V", "v", 214, 246, 22]), $a(["W", "w", 215, 247, 23]), $a(["X", "x", 216, 248, 24]), $a(["Y", "y", 217, 249, 25]), $a(["Z", "z", 218, 250, 26]), $a([$ctx.eci, $ctx.eci, $ctx.eci, $ctx.eci, $ctx.eci]), $a([28, 28, 28, 28, $ctx.pad]), $a([29, 29, 29, 29, $ctx.pad]), $a([30, 30, 30, 30, 27]), $a([$ctx.ns, $ctx.ns, $ctx.ns, $ctx.ns, $ctx.ns]), $a([" ", "{", 219, 251, 28]), $a([$ctx.pad, $ctx.pad, 220, 252, 29]), $a(['"', "}", 221, 253, 30]), $a(["#", "~", 222, 254, 31]), $a(["$", 127, 223, 255, 159]), $a(["%", ";", 170, 161, 160]), $a(["&", "<", 172, 168, 162]), $a(["'", "=", 177, 171, 163]), $a([40, ">", 178, 175, 164]), $a([41, "?", 179, 176, 165]), $a(["*", "[", 181, 180, 166]), $a(["+", 92, 185, 183, 167]), $a([",", "]", 186, 184, 169]), $a(["-", "^", 188, 187, 173]), $a([".", "_", 189, 191, 174]), $a(["/", " ", 190, 138, 182]), $a(["0", ",", 128, 139, 149]), $a(["1", ".", 129, 140, 150]), $a(["2", "/", 130, 141, 151]), $a(["3", ":", 131, 142, 152]), $a(["4", "@", 132, 143, 153]), $a(["5", "!", 133, 144, 154]), $a(["6", "|", 134, 145, 155]), $a(["7", $ctx.pd2, 135, 146, 156]), $a(["8", $ctx.sa2, 136, 147, 157]), $a(["9", $ctx.sa3, 137, 148, 158]), $a([":", $ctx.pd3, $ctx.la, $ctx.la, $ctx.la]), $a([$ctx.sb, $ctx.sa, " ", " ", " "]), $a([$ctx.sc, $ctx.sc, $ctx.lkc, $ctx.sc, $ctx.sc]), $a([$ctx.sd, $ctx.sd, $ctx.sd, $ctx.lkd, $ctx.sd]), $a([$ctx.se, $ctx.se, $ctx.se, $ctx.se, $ctx.lke]), $a([$ctx.lb, $ctx.la, $ctx.lb, $ctx.lb, $ctx.lb])]);
        $ctx.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
        for (var _3G = 0, _3F = $ctx.charmaps.length - 1; _3G <= _3F; _3G += 1) {
          $ctx.i = _3G;
          $ctx.encs = $get($ctx.charmaps, $ctx.i);
          for (var _3K = 0; _3K <= 4; _3K += 1) {
            $ctx.j = _3K;
            var _3N = $get($ctx.encs, $ctx.j);
            $k[$j++] = _3N;
            if ($eq($type(_3N), "stringtype")) {
              var _3Q = $get($k[--$j], 0);
              $k[$j++] = _3Q;
            }
            $put($get($ctx.charvals, $ctx.j), $k[--$j], $ctx.i);
          }
        }
        $ctx.seta = $get($ctx.charvals, 0);
        $ctx.setb = $get($ctx.charvals, 1);
        $ctx.setc = $get($ctx.charvals, 2);
        $ctx.setd = $get($ctx.charvals, 3);
        $ctx.sete = $get($ctx.charvals, 4);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_maxicode.$ctx[id] = $ctx[id]);
        bwipp_maxicode.__21361__ = 1;
      })();
    }
    $k[$j++] = Infinity;
    for (var _3i = 0, _3j = $1.msglen + 1; _3i < _3j; _3i++) {
      $k[$j++] = 0;
    }
    $1.nseq = $a();
    for (var _3m = $1.msglen - 1; _3m >= 0; _3m -= 1) {
      $1.i = _3m;
      var _3p = $get($1.msg, $1.i);
      if (_3p >= 48 && _3p <= 57) {
        $put($1.nseq, $1.i, $f($get($1.nseq, $1.i + 1) + 1));
      } else {
        $put($1.nseq, $1.i, 0);
      }
    }
    $1.nseq = $geti($1.nseq, 0, $1.msglen);
    $1.prefixinset = function() {
      $k[$j++] = 0;
      for (; ; ) {
        var _40 = $k[--$j];
        var _41 = $k[--$j];
        $k[$j++] = _41;
        $k[$j++] = _40;
        if (_40 >= _41.length) {
          break;
        }
        var _42 = $k[--$j];
        var _43 = $k[--$j];
        var _45 = $k[--$j];
        var _46 = $get(_45, $get(_43, _42)) !== void 0;
        $k[$j++] = _45;
        $k[$j++] = _43;
        $k[$j++] = _42;
        if (_46) {
          var _47 = $k[--$j];
          $k[$j++] = $f(_47 + 1);
        } else {
          break;
        }
      }
      var _48 = $k[--$j];
      var _49 = $k[--$j];
      $k[$j++] = _48;
      $k[$j++] = _49;
      $j--;
      var _4A = $k[--$j];
      var _4B = $k[--$j];
      $k[$j++] = _4A;
      $k[$j++] = _4B;
      $j--;
    };
    $1.enc = function() {
      var _4C = $k[--$j];
      $put($1.out, $1.j, $get(_4C, $k[--$j]));
      $1.j = $1.j + 1;
    };
    $1.out = $a(144);
    $1.i = 0;
    $1.j = 0;
    $1.cset = "seta";
    for (; ; ) {
      if ($1.i == $1.msglen) {
        if ($ne($1.cset, "seta") && $ne($1.cset, "setb")) {
          $k[$j++] = $1.la;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $1.cset = "seta";
        }
        break;
      }
      for (; ; ) {
        if ($get($1.msg, $1.i) <= -1e6) {
          $k[$j++] = $1.eci;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          var _4Z = $f(-$get($1.msg, $1.i) - 1e6);
          $k[$j++] = _4Z;
          if (_4Z <= 31) {
            var _4a = $k[--$j];
            $k[$j++] = _4a & 63;
            $astore($a(1));
          } else {
            var _4c = $k[--$j];
            $k[$j++] = _4c;
            if (_4c <= 1023) {
              var _4d = $k[--$j];
              $k[$j++] = _4d >>> 6 & 31 | 32;
              $k[$j++] = _4d & 63;
              $astore($a(2));
            } else {
              var _4f = $k[--$j];
              $k[$j++] = _4f;
              if (_4f <= 32767) {
                var _4g = $k[--$j];
                $k[$j++] = _4g >>> 12 & 47 | 48;
                $k[$j++] = _4g >>> 6 & 63;
                $k[$j++] = _4g & 63;
                $astore($a(3));
              } else {
                var _4i = $k[--$j];
                $k[$j++] = _4i >>> 18 & 55 | 56;
                $k[$j++] = _4i >>> 12 & 63;
                $k[$j++] = _4i >>> 6 & 63;
                $k[$j++] = _4i & 63;
                $astore($a(4));
              }
            }
          }
          var _4k = $k[--$j];
          $puti($1.out, $1.j, _4k);
          $1.j = _4k.length + $1.j;
          $1.i = $1.i + 1;
          break;
        }
        if ($get($1.nseq, $1.i) >= 9) {
          var _4u = $geti($1.msg, $1.i, 9);
          $k[$j++] = 0;
          for (var _4v = 0, _4w = _4u.length; _4v < _4w; _4v++) {
            var _4y = $k[--$j];
            $k[$j++] = $f(_4y + $f($get(_4u, _4v) - 48)) * 10;
          }
          var _4z = $k[--$j];
          $k[$j++] = ~~(_4z / 10);
          for (var _50 = 0, _51 = 4; _50 < _51; _50++) {
            var _52 = $k[--$j];
            $k[$j++] = _52 & 63;
            $k[$j++] = _52 >>> 6;
          }
          $k[$j++] = $get($1[$1.cset], $1.ns);
          for (var _57 = 0; _57 <= 10; _57 += 2) {
            var _58 = $k[$j - 1 - _57];
            $k[$j++] = _58;
          }
          $astore($a(6));
          var _5A = $k[--$j];
          var _5B = $k[--$j];
          var _5C = $k[--$j];
          var _5D = $k[--$j];
          var _5E = $k[--$j];
          var _5F = $k[--$j];
          var _5G = $k[--$j];
          $k[$j++] = _5A;
          $k[$j++] = _5G;
          $k[$j++] = _5F;
          $k[$j++] = _5E;
          $k[$j++] = _5D;
          $k[$j++] = _5C;
          $k[$j++] = _5B;
          for (var _5H = 0, _5I = 6; _5H < _5I; _5H++) {
            $j--;
          }
          $puti($1.out, $1.j, $k[--$j]);
          $1.i = $1.i + 9;
          $1.j = $1.j + 6;
          break;
        }
        $1.char1 = $get($1.msg, $1.i);
        $k[$j++] = "char2";
        if ($1.i + 1 < $1.msglen) {
          $k[$j++] = $get($1.msg, $1.i + 1);
        } else {
          $k[$j++] = -99;
        }
        var _5W = $k[--$j];
        $1[$k[--$j]] = _5W;
        $k[$j++] = "char3";
        if ($1.i + 2 < $1.msglen) {
          $k[$j++] = $get($1.msg, $1.i + 2);
        } else {
          $k[$j++] = -99;
        }
        var _5d = $k[--$j];
        $1[$k[--$j]] = _5d;
        var _5i = $get($1[$1.cset], $1.char1) !== void 0;
        if (_5i) {
          $k[$j++] = $1.char1;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $1.i = $1.i + 1;
          break;
        }
        var _5q = $get($1.setb, $1.char1) !== void 0;
        if ($eq($1.cset, "seta") && _5q) {
          var _5t = $get($1.setb, $1.char2) !== void 0;
          if (_5t) {
            $k[$j++] = $1.lb;
            $k[$j++] = $1.seta;
            $1.enc();
            $1.cset = "setb";
          } else {
            $k[$j++] = $1.sb;
            $k[$j++] = $1.seta;
            $1.enc();
            $k[$j++] = $1.char1;
            $k[$j++] = $1.setb;
            $1.enc();
            $1.i = $1.i + 1;
          }
          break;
        }
        var _64 = $get($1.seta, $1.char1) !== void 0;
        if ($eq($1.cset, "setb") && _64) {
          var _65 = $1.seta;
          var _66 = $1.msg;
          var _67 = $1.i;
          var _68 = $1.msglen;
          var _69 = $1.i;
          var _6A = _68 - _69;
          var _6B = 4;
          if (4 > _68 - _69) {
            var _ = _6A;
            _6A = _6B;
            _6B = _;
          }
          $k[$j++] = "p";
          $k[$j++] = _65;
          $k[$j++] = $geti(_66, _67, _6B);
          $1.prefixinset();
          var _6D = $k[--$j];
          $1[$k[--$j]] = _6D;
          if ($1.p == 1) {
            $k[$j++] = $1.sa;
            $k[$j++] = $1.setb;
            $1.enc();
            $k[$j++] = $1.char1;
            $k[$j++] = $1.seta;
            $1.enc();
            $1.i = $1.i + 1;
          }
          if ($1.p == 2) {
            $k[$j++] = $1.sa2;
            $k[$j++] = $1.setb;
            $1.enc();
            $k[$j++] = $1.char1;
            $k[$j++] = $1.seta;
            $1.enc();
            $k[$j++] = $1.char2;
            $k[$j++] = $1.seta;
            $1.enc();
            $1.i = $1.i + 2;
          }
          if ($1.p == 3) {
            $k[$j++] = $1.sa3;
            $k[$j++] = $1.setb;
            $1.enc();
            $k[$j++] = $1.char1;
            $k[$j++] = $1.seta;
            $1.enc();
            $k[$j++] = $1.char2;
            $k[$j++] = $1.seta;
            $1.enc();
            $k[$j++] = $1.char3;
            $k[$j++] = $1.seta;
            $1.enc();
            $1.i = $1.i + 3;
          }
          if ($1.p >= 4) {
            $k[$j++] = $1.la;
            $k[$j++] = $1.setb;
            $1.enc();
            $1.cset = "seta";
          }
          break;
        }
        var _6i = $get($1.seta, $1.char1) !== void 0;
        if (_6i) {
          $k[$j++] = $1.la;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $1.cset = "seta";
          break;
        }
        var _6o = $get($1.setb, $1.char1) !== void 0;
        if (_6o) {
          $k[$j++] = $1.lb;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $1.cset = "setb";
          break;
        }
        var _6u = $get($1.setc, $1.char1) !== void 0;
        if (_6u) {
          $1.setx = "setc";
          $1.sx = $1.sc;
          $1.lkx = $1.lkc;
        }
        var _6z = $get($1.setd, $1.char1) !== void 0;
        if (_6z) {
          $1.setx = "setd";
          $1.sx = $1.sd;
          $1.lkx = $1.lkd;
        }
        var _74 = $get($1.sete, $1.char1) !== void 0;
        if (_74) {
          $1.setx = "sete";
          $1.sx = $1.se;
          $1.lkx = $1.lke;
        }
        var _78 = $1[$1.setx];
        var _79 = $1.msg;
        var _7A = $1.i;
        var _7B = $1.msglen;
        var _7C = $1.i;
        var _7D = _7B - _7C;
        var _7E = 4;
        if (4 > _7B - _7C) {
          var _ = _7D;
          _7D = _7E;
          _7E = _;
        }
        $k[$j++] = "p";
        $k[$j++] = _78;
        $k[$j++] = $geti(_79, _7A, _7E);
        $1.prefixinset();
        var _7G = $k[--$j];
        $1[$k[--$j]] = _7G;
        if ($1.p == 1) {
          $k[$j++] = $1.sx;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $k[$j++] = $1.char1;
          $k[$j++] = $1[$1.setx];
          $1.enc();
          $1.i = $1.i + 1;
        }
        if ($1.p == 2) {
          $k[$j++] = $1.sx;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $k[$j++] = $1.char1;
          $k[$j++] = $1[$1.setx];
          $1.enc();
          $k[$j++] = $1.sx;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $k[$j++] = $1.char2;
          $k[$j++] = $1[$1.setx];
          $1.enc();
          $1.i = $1.i + 2;
        }
        if ($1.p == 3) {
          $k[$j++] = $1.sx;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $k[$j++] = $1.char1;
          $k[$j++] = $1[$1.setx];
          $1.enc();
          $k[$j++] = $1.sx;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $k[$j++] = $1.char2;
          $k[$j++] = $1[$1.setx];
          $1.enc();
          $k[$j++] = $1.sx;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $k[$j++] = $1.char3;
          $k[$j++] = $1[$1.setx];
          $1.enc();
          $1.i = $1.i + 3;
        }
        if ($1.p >= 4) {
          $k[$j++] = $1.sx;
          $k[$j++] = $1[$1.cset];
          $1.enc();
          $k[$j++] = $1.lkx;
          $k[$j++] = $1[$1.setx];
          $1.enc();
          $1.cset = $1.setx;
        }
        break;
      }
    }
    $1.encmsg = $geti($1.out, 0, $1.j);
    $1.padval = $get($1[$1.cset], $1.pad);
    $k[$j++] = "sami";
    if ($1.sam != -1) {
      $k[$j++] = $a([$get($1.seta, $1.pad), (~~($1.sam / 10) - 1) * 8 + ($1.sam % 10 - 1)]);
    } else {
      $k[$j++] = $a([]);
    }
    var _8L = $k[--$j];
    $1[$k[--$j]] = _8L;
    $k[$j++] = Infinity;
    $aload($1.sami);
    $aload($1.encmsg);
    $1.encmsg = $a();
    if ($1.mode == 2 || $1.mode == 3) {
      if ($1.encmsg.length > 84) {
        $k[$j++] = "bwipp.maxicodeMode23TooLong#21554";
        $k[$j++] = "The secondary message is too long";
        bwipp_raiseerror();
      }
      var _8U = $strcpy($s(4), "0000");
      var _8X = $cvrs($s(4), ~~$1.mode, 2);
      $puti(_8U, 4 - _8X.length, _8X);
      $1.mdb = _8U;
      var _8Z = $strcpy($s(10), "0000000000");
      var _8c = $cvrs($s(10), $cvi($1.ccode), 2);
      $puti(_8Z, 10 - _8c.length, _8c);
      $1.ccb = _8Z;
      var _8e = $strcpy($s(10), "0000000000");
      var _8h = $cvrs($s(10), $cvi($1.scode), 2);
      $puti(_8e, 10 - _8h.length, _8h);
      $1.scb = _8e;
      $1.pcb = $strcpy($s(36), "000000000000000000000000000000000000");
      if ($1.mode == 2) {
        var _8o = $cvrs($s(6), $1.pcode.length, 2);
        $puti($1.pcb, 6 - _8o.length, _8o);
        var _8s = $cvrs($s(30), $cvi($1.pcode), 2);
        $puti($1.pcb, 36 - _8s.length, _8s);
      } else {
        $k[$j++] = Infinity;
        var _8u = $strcpy($s(6), "      ");
        $k[$j++] = _8u;
        $k[$j++] = _8u;
        $k[$j++] = 0;
        if ($1.pcode.length > 6) {
          $k[$j++] = $geti($1.pcode, 0, 6);
        } else {
          $k[$j++] = $1.pcode;
        }
        var _8z = $k[--$j];
        var _90 = $k[--$j];
        $puti($k[--$j], _90, _8z);
        $forall($k[--$j], function() {
          var _95 = $get($1.seta, $k[--$j]);
          $k[$j++] = _95;
        });
        $1.pccw = $a();
        for (var _97 = 0; _97 <= 5; _97 += 1) {
          $1.i = _97;
          var _9D = $cvrs($s(6), $get($1.pccw, $1.i), 2);
          $puti($1.pcb, 6 * $1.i + 6 - _9D.length, _9D);
        }
      }
      $1.scm = $s(60);
      $puti($1.scm, 2, $1.mdb);
      $puti($1.scm, 38, $geti($1.pcb, 0, 4));
      $puti($1.scm, 30, $geti($1.pcb, 4, 6));
      $puti($1.scm, 24, $geti($1.pcb, 10, 6));
      $puti($1.scm, 18, $geti($1.pcb, 16, 6));
      $puti($1.scm, 12, $geti($1.pcb, 22, 6));
      $puti($1.scm, 6, $geti($1.pcb, 28, 6));
      $puti($1.scm, 0, $geti($1.pcb, 34, 2));
      $puti($1.scm, 52, $geti($1.ccb, 0, 2));
      $puti($1.scm, 42, $geti($1.ccb, 2, 6));
      $puti($1.scm, 36, $geti($1.ccb, 8, 2));
      $puti($1.scm, 54, $geti($1.scb, 0, 6));
      $puti($1.scm, 48, $geti($1.scb, 6, 4));
      $1.pri = $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      for (var _9t = 0; _9t <= 59; _9t += 1) {
        $1.i = _9t;
        $1.ps = ~~($1.i / 6);
        $1.ep = ~~Math.pow(2, 5 - $1.i % 6) * ($get($1.scm, $1.i) - 48);
        $put($1.pri, $1.ps, $f($get($1.pri, $1.ps) + $1.ep));
      }
      $k[$j++] = Infinity;
      for (var _A5 = 0, _A6 = 84; _A5 < _A6; _A5++) {
        $k[$j++] = $1.padval;
      }
      $1.sec = $a();
      $puti($1.sec, 0, $1.encmsg);
    }
    if ($1.mode == 4 || $1.mode == 5 || $1.mode == 6 || $1.mode == -1) {
      if ($1.mode == -1) {
        var _AH = $1.encmsg.length <= 77 ? 5 : 4;
        $1.mode = _AH;
      }
      $k[$j++] = Infinity;
      var _AJ = $1.mode == 5 ? 78 : 94;
      for (var _AK = 0, _AL = _AJ; _AK < _AL; _AK++) {
        $k[$j++] = $1.padval;
      }
      $1.cws = $a();
      if ($1.encmsg.length > $1.cws.length - 1) {
        $k[$j++] = "bwipp.maxicodeMode56TooLong#21619";
        $k[$j++] = "The message is too long";
        bwipp_raiseerror();
      }
      $put($1.cws, 0, $1.mode);
      $puti($1.cws, 1, $1.encmsg);
      $1.pri = $geti($1.cws, 0, 10);
      $1.sec = $geti($1.cws, 10, $1.cws.length - 10);
    }
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _AZ = 0, _Aa = 63; _AZ < _Aa; _AZ++) {
      var _Ab = $k[--$j];
      var _Ac = _Ab * 2;
      $k[$j++] = _Ab;
      $k[$j++] = _Ac;
      if (_Ac >= 64) {
        var _Ad = $k[--$j];
        $k[$j++] = _Ad ^ 67;
      }
    }
    $1.rsalog = $a();
    $1.rslog = $a(64);
    for (var _Ag = 1; _Ag <= 63; _Ag += 1) {
      $put($1.rslog, $get($1.rsalog, _Ag), _Ag);
    }
    $1.rsprod = function() {
      var _Ak = $k[--$j];
      var _Al = $k[--$j];
      $k[$j++] = _Al;
      $k[$j++] = _Ak;
      if (_Ak != 0 && _Al != 0) {
        var _Ao = $get($1.rslog, $k[--$j]);
        var _At = $get($1.rsalog, $f(_Ao + $get($1.rslog, $k[--$j])) % 63);
        $k[$j++] = _At;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $1.rscodes = function() {
      $1.rsnum = $k[--$j];
      $1.cwb = $k[--$j];
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      for (var _Ax = 0, _Ay = $1.rsnum; _Ax < _Ay; _Ax++) {
        $k[$j++] = 0;
      }
      $1.coeffs = $a();
      for (var _B2 = 1, _B1 = $1.rsnum; _B2 <= _B1; _B2 += 1) {
        $1.i = _B2;
        $put($1.coeffs, $1.i, $get($1.coeffs, $1.i - 1));
        for (var _B9 = $1.i - 1; _B9 >= 1; _B9 -= 1) {
          $1.j = _B9;
          $k[$j++] = $1.coeffs;
          $k[$j++] = $1.j;
          $k[$j++] = $get($1.coeffs, $1.j - 1);
          $k[$j++] = $get($1.coeffs, $1.j);
          $k[$j++] = $get($1.rsalog, $1.i);
          $1.rsprod();
          var _BL = $k[--$j];
          var _BM = $k[--$j];
          var _BN = $k[--$j];
          $put($k[--$j], _BN, $xo(_BM, _BL));
        }
        $k[$j++] = $1.coeffs;
        $k[$j++] = 0;
        $k[$j++] = $get($1.coeffs, 0);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _BV = $k[--$j];
        var _BW = $k[--$j];
        $put($k[--$j], _BW, _BV);
      }
      $1.coeffs = $geti($1.coeffs, 0, $1.coeffs.length - 1);
      $k[$j++] = Infinity;
      for (var _Bc = 0, _Bd = $1.rsnum; _Bc < _Bd; _Bc++) {
        $k[$j++] = 0;
      }
      $1.ecb = $a();
      for (var _Bh = 0, _Bg = $1.cwb.length - 1; _Bh <= _Bg; _Bh += 1) {
        $1.t = $xo($get($1.cwb, _Bh), $get($1.ecb, 0));
        for (var _Bn = $1.ecb.length - 1; _Bn >= 0; _Bn -= 1) {
          $1.i = _Bn;
          $1.p = $1.ecb.length - $1.i - 1;
          $k[$j++] = $1.ecb;
          $k[$j++] = $1.p;
          $k[$j++] = $1.t;
          $k[$j++] = $get($1.coeffs, $1.i);
          $1.rsprod();
          var _Bw = $k[--$j];
          var _Bx = $k[--$j];
          $put($k[--$j], _Bx, _Bw);
          if ($1.i > 0) {
            $put($1.ecb, $1.p, $xo($get($1.ecb, $1.p + 1), $get($1.ecb, $1.p)));
          }
        }
      }
      $k[$j++] = $1.ecb;
    };
    $k[$j++] = Infinity;
    for (var _CB = 0, _CA = $1.sec.length - 1; _CB <= _CA; _CB += 2) {
      $k[$j++] = $get($1.sec, _CB);
    }
    $1.seco = $a();
    $k[$j++] = Infinity;
    for (var _CH = 1, _CG = $1.sec.length - 1; _CH <= _CG; _CH += 2) {
      $k[$j++] = $get($1.sec, _CH);
    }
    $1.sece = $a();
    var _CM = $1.sec.length == 84 ? 20 : 28;
    $1.scodes = _CM;
    $k[$j++] = "secochk";
    $k[$j++] = $1.seco;
    $k[$j++] = $1.scodes;
    $1.rscodes();
    var _CP = $k[--$j];
    $1[$k[--$j]] = _CP;
    $k[$j++] = "secechk";
    $k[$j++] = $1.sece;
    $k[$j++] = $1.scodes;
    $1.rscodes();
    var _CT = $k[--$j];
    $1[$k[--$j]] = _CT;
    $k[$j++] = Infinity;
    for (var _CX = 0, _CW = $1.scodes - 1; _CX <= _CW; _CX += 1) {
      $k[$j++] = $get($1.secochk, _CX);
      $k[$j++] = $get($1.secechk, _CX);
    }
    $1.secchk = $a();
    $k[$j++] = Infinity;
    $aload($1.pri);
    $k[$j++] = $1.pri;
    $k[$j++] = 10;
    $1.rscodes();
    $aload($k[--$j]);
    $aload($1.sec);
    $aload($1.secchk);
    $1.codewords = $a();
    $k[$j++] = Infinity;
    for (var _Cj = 0, _Ck = 864; _Cj < _Ck; _Cj++) {
      $k[$j++] = 0;
    }
    $1.mods = $a();
    for (var _Cm = 0; _Cm <= 143; _Cm += 1) {
      $1.i = _Cm;
      $k[$j++] = Infinity;
      var _Cr = $cvrs($s(6), $get($1.codewords, $1.i), 2);
      for (var _Cs = 0, _Ct = _Cr.length; _Cs < _Ct; _Cs++) {
        $k[$j++] = $get(_Cr, _Cs) - 48;
      }
      $1.cw = $a();
      $puti($1.mods, 6 * $1.i + (6 - $1.cw.length), $1.cw);
    }
    if (!bwipp_maxicode.__21755__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.modmap = $a([469, 529, 286, 316, 347, 346, 673, 672, 703, 702, 647, 676, 283, 282, 313, 312, 370, 610, 618, 379, 378, 409, 408, 439, 705, 704, 559, 589, 588, 619, 458, 518, 640, 701, 675, 674, 285, 284, 315, 314, 310, 340, 531, 289, 288, 319, 349, 348, 456, 486, 517, 516, 471, 470, 369, 368, 399, 398, 429, 428, 549, 548, 579, 578, 609, 608, 649, 648, 679, 678, 709, 708, 639, 638, 669, 668, 699, 698, 279, 278, 309, 308, 339, 338, 381, 380, 411, 410, 441, 440, 561, 560, 591, 590, 621, 620, 547, 546, 577, 576, 607, 606, 367, 366, 397, 396, 427, 426, 291, 290, 321, 320, 351, 350, 651, 650, 681, 680, 711, 710, 1, 0, 31, 30, 61, 60, 3, 2, 33, 32, 63, 62, 5, 4, 35, 34, 65, 64, 7, 6, 37, 36, 67, 66, 9, 8, 39, 38, 69, 68, 11, 10, 41, 40, 71, 70, 13, 12, 43, 42, 73, 72, 15, 14, 45, 44, 75, 74, 17, 16, 47, 46, 77, 76, 19, 18, 49, 48, 79, 78, 21, 20, 51, 50, 81, 80, 23, 22, 53, 52, 83, 82, 25, 24, 55, 54, 85, 84, 27, 26, 57, 56, 87, 86, 117, 116, 147, 146, 177, 176, 115, 114, 145, 144, 175, 174, 113, 112, 143, 142, 173, 172, 111, 110, 141, 140, 171, 170, 109, 108, 139, 138, 169, 168, 107, 106, 137, 136, 167, 166, 105, 104, 135, 134, 165, 164, 103, 102, 133, 132, 163, 162, 101, 100, 131, 130, 161, 160, 99, 98, 129, 128, 159, 158, 97, 96, 127, 126, 157, 156, 95, 94, 125, 124, 155, 154, 93, 92, 123, 122, 153, 152, 91, 90, 121, 120, 151, 150, 181, 180, 211, 210, 241, 240, 183, 182, 213, 212, 243, 242, 185, 184, 215, 214, 245, 244, 187, 186, 217, 216, 247, 246, 189, 188, 219, 218, 249, 248, 191, 190, 221, 220, 251, 250, 193, 192, 223, 222, 253, 252, 195, 194, 225, 224, 255, 254, 197, 196, 227, 226, 257, 256, 199, 198, 229, 228, 259, 258, 201, 200, 231, 230, 261, 260, 203, 202, 233, 232, 263, 262, 205, 204, 235, 234, 265, 264, 207, 206, 237, 236, 267, 266, 297, 296, 327, 326, 357, 356, 295, 294, 325, 324, 355, 354, 293, 292, 323, 322, 353, 352, 277, 276, 307, 306, 337, 336, 275, 274, 305, 304, 335, 334, 273, 272, 303, 302, 333, 332, 271, 270, 301, 300, 331, 330, 361, 360, 391, 390, 421, 420, 363, 362, 393, 392, 423, 422, 365, 364, 395, 394, 425, 424, 383, 382, 413, 412, 443, 442, 385, 384, 415, 414, 445, 444, 387, 386, 417, 416, 447, 446, 477, 476, 507, 506, 537, 536, 475, 474, 505, 504, 535, 534, 473, 472, 503, 502, 533, 532, 455, 454, 485, 484, 515, 514, 453, 452, 483, 482, 513, 512, 451, 450, 481, 480, 511, 510, 541, 540, 571, 570, 601, 600, 543, 542, 573, 572, 603, 602, 545, 544, 575, 574, 605, 604, 563, 562, 593, 592, 623, 622, 565, 564, 595, 594, 625, 624, 567, 566, 597, 596, 627, 626, 657, 656, 687, 686, 717, 716, 655, 654, 685, 684, 715, 714, 653, 652, 683, 682, 713, 712, 637, 636, 667, 666, 697, 696, 635, 634, 665, 664, 695, 694, 633, 632, 663, 662, 693, 692, 631, 630, 661, 660, 691, 690, 721, 720, 751, 750, 781, 780, 723, 722, 753, 752, 783, 782, 725, 724, 755, 754, 785, 784, 727, 726, 757, 756, 787, 786, 729, 728, 759, 758, 789, 788, 731, 730, 761, 760, 791, 790, 733, 732, 763, 762, 793, 792, 735, 734, 765, 764, 795, 794, 737, 736, 767, 766, 797, 796, 739, 738, 769, 768, 799, 798, 741, 740, 771, 770, 801, 800, 743, 742, 773, 772, 803, 802, 745, 744, 775, 774, 805, 804, 747, 746, 777, 776, 807, 806, 837, 836, 867, 866, 897, 896, 835, 834, 865, 864, 895, 894, 833, 832, 863, 862, 893, 892, 831, 830, 861, 860, 891, 890, 829, 828, 859, 858, 889, 888, 827, 826, 857, 856, 887, 886, 825, 824, 855, 854, 885, 884, 823, 822, 853, 852, 883, 882, 821, 820, 851, 850, 881, 880, 819, 818, 849, 848, 879, 878, 817, 816, 847, 846, 877, 876, 815, 814, 845, 844, 875, 874, 813, 812, 843, 842, 873, 872, 811, 810, 841, 840, 871, 870, 901, 900, 931, 930, 961, 960, 903, 902, 933, 932, 963, 962, 905, 904, 935, 934, 965, 964, 907, 906, 937, 936, 967, 966, 909, 908, 939, 938, 969, 968, 911, 910, 941, 940, 971, 970, 913, 912, 943, 942, 973, 972, 915, 914, 945, 944, 975, 974, 917, 916, 947, 946, 977, 976, 919, 918, 949, 948, 979, 978, 921, 920, 951, 950, 981, 980, 923, 922, 953, 952, 983, 982, 925, 924, 955, 954, 985, 984, 927, 926, 957, 956, 987, 986, 58, 89, 88, 118, 149, 148, 178, 209, 208, 238, 269, 268, 298, 329, 328, 358, 389, 388, 418, 449, 448, 478, 509, 508, 538, 569, 568, 598, 629, 628, 658, 689, 688, 718, 749, 748, 778, 809, 808, 838, 869, 868, 898, 929, 928, 958, 989, 988]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_maxicode.$ctx[id] = $ctx[id]);
        bwipp_maxicode.__21755__ = 1;
      })();
    }
    $1.pixs = $a(864);
    $1.j = 0;
    for (var _D5 = 0, _D4 = $1.mods.length - 1; _D5 <= _D4; _D5 += 1) {
      $1.i = _D5;
      if ($get($1.mods, $1.i) == 1) {
        $put($1.pixs, $1.j, $get($1.modmap, $1.i));
        $1.j = $1.j + 1;
      }
    }
    $k[$j++] = Infinity;
    $aload($geti($1.pixs, 0, $1.j));
    $k[$j++] = 28;
    $k[$j++] = 29;
    $k[$j++] = 280;
    $k[$j++] = 281;
    $k[$j++] = 311;
    $k[$j++] = 457;
    $k[$j++] = 488;
    $k[$j++] = 500;
    $k[$j++] = 530;
    $k[$j++] = 670;
    $k[$j++] = 700;
    $k[$j++] = 677;
    $k[$j++] = 707;
    $1.pixs = $a();
    var _DL = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmaximatrix],
      ["pixs", $1.pixs],
      ["opt", $1.options]
    ]);
    $k[$j++] = _DL;
    if (!$1.dontdraw) {
      bwipp_renmaximatrix();
    }
  }
  function bwipp_azteccode() {
    var $1 = Object.create(bwipp_azteccode.$ctx || (bwipp_azteccode.$ctx = {}));
    $1.dontdraw = false;
    $1.format = "full";
    $1.readerinit = false;
    $1.layers = -1;
    $1.eclevel = 23;
    $1.ecaddchars = 3;
    $1.raw = false;
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.barcode, "")) {
      $k[$j++] = "bwipp.aztecEmptyData#21830";
      $k[$j++] = "The data must not be empty";
      bwipp_raiseerror();
    }
    if ($1.eclevel < 5 || $1.eclevel > 95) {
      $k[$j++] = "bwipp.aztecInvalidEClevel#21834";
      $k[$j++] = "The EC percentage must be from 5 to 95";
      bwipp_raiseerror();
    }
    if ($1.ecaddchars < 3) {
      $k[$j++] = "bwipp.aztecInvalidECaddChars#21838";
      $k[$j++] = "The number of additional EC codewords must be 3 or more";
      bwipp_raiseerror();
    }
    if ($ne($1.format, "full") && ($ne($1.format, "compact") && $ne($1.format, "rune"))) {
      $k[$j++] = "bwipp.aztecInvalidFormat#21842";
      $k[$j++] = "The format must be either full, compact or rune";
      bwipp_raiseerror();
    }
    if ($eq($1.format, "full")) {
      if ($1.readerinit && ($1.layers < 1 || $1.layers > 22)) {
        $k[$j++] = "bwipp.aztecFullInitInvalidLayers#21847";
        $k[$j++] = "Full-range symbols for reader programming must specify from 1 to 22 layers";
        bwipp_raiseerror();
      }
      if ($1.layers != -1 && ($1.layers < 1 || $1.layers > 32)) {
        $k[$j++] = "bwipp.aztecFullInvalidLayers#21850";
        $k[$j++] = "Layers for full-range symbols must be from 1 to 32";
        bwipp_raiseerror();
      }
    }
    if ($eq($1.format, "compact")) {
      if ($1.readerinit) {
        if ($1.layers != -1 && $1.layers != 1) {
          $k[$j++] = "bwipp.aztecCompactInitInvalidLayers#21857";
          $k[$j++] = "Compact symbols for reader programming must have 1 layer";
          bwipp_raiseerror();
        }
        $1.layers = 1;
      }
      if ($1.layers != -1 && ($1.layers < 1 || $1.layers > 4)) {
        $k[$j++] = "bwipp.aztecCompactInvalidLayers#21862";
        $k[$j++] = "Layers for compact symbols must be from 1 to 4";
        bwipp_raiseerror();
      }
    }
    if ($eq($1.format, "rune")) {
      if ($1.layers != -1) {
        $k[$j++] = "bwipp.aztecRuneInvalidLayers#21868";
        $k[$j++] = "It is not valid to specify layers for runes";
        bwipp_raiseerror();
      }
      if ($1.readerinit) {
        $k[$j++] = "bwipp.aztecRuneReaderInit#21871";
        $k[$j++] = "Reader initialisation is not compactible with Aztec Runes";
        bwipp_raiseerror();
      }
      if ($1.barcode.length == 0) {
        $k[$j++] = "bwipp.aztecRuneNotNumeric#21874";
        $k[$j++] = "Aztec runes must be numeric";
        bwipp_raiseerror();
      }
      $forall($1.barcode, function() {
        var _S = $k[--$j];
        if (_S < 48 || _S > 57) {
          $k[$j++] = "bwipp.aztecRuneNotNumeric#21878";
          $k[$j++] = "Aztec runes must be numeric";
          bwipp_raiseerror();
        }
      });
      var _U = $cvi($1.barcode);
      if (_U < 0 || _U > 255) {
        $k[$j++] = "bwipp.aztecRuneInvalid#21882";
        $k[$j++] = "Aztec runes must be 0 to 255";
        bwipp_raiseerror();
      }
    }
    $1.fn1 = -1;
    var _Y = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["eci", true],
      ["FNC1", $1.fn1]
    ]);
    $1.fncvals = _Y;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _b = $k[--$j];
    $1[$k[--$j]] = _b;
    $1.msglen = $1.msg.length;
    if (!bwipp_azteccode.__21995__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.U = 0;
        $ctx.L = 1;
        $ctx.M = 2;
        $ctx.P = 3;
        $ctx.D = 4;
        $ctx.B = 5;
        $ctx.lu = -2;
        $ctx.ll = -3;
        $ctx.lm = -4;
        $ctx.lp = -5;
        $ctx.ld = -6;
        $ctx.su = -7;
        $ctx.sp = -8;
        $ctx.sb = -9;
        $ctx.fl = -10;
        $ctx.p2 = -11;
        $ctx.p3 = -12;
        $ctx.p4 = -13;
        $ctx.p5 = -14;
        $ctx.charmaps = $a([$a([$ctx.sp, $ctx.sp, $ctx.sp, $ctx.fl, $ctx.sp]), $a([32, 32, 32, 13, 32]), $a(["A", "a", 1, $ctx.p2, "0"]), $a(["B", "b", 2, $ctx.p3, "1"]), $a(["C", "c", 3, $ctx.p4, "2"]), $a(["D", "d", 4, $ctx.p5, "3"]), $a(["E", "e", 5, "!", "4"]), $a(["F", "f", 6, '"', "5"]), $a(["G", "g", 7, "#", "6"]), $a(["H", "h", 8, "$", "7"]), $a(["I", "i", 9, "%", "8"]), $a(["J", "j", 10, "&", "9"]), $a(["K", "k", 11, "'", ","]), $a(["L", "l", 12, 40, "."]), $a(["M", "m", 13, 41, $ctx.lu]), $a(["N", "n", 27, "*", $ctx.su]), $a(["O", "o", 28, "+", -99]), $a(["P", "p", 29, ",", -99]), $a(["Q", "q", 30, "-", -99]), $a(["R", "r", 31, ".", -99]), $a(["S", "s", "@", "/", -99]), $a(["T", "t", 92, ":", -99]), $a(["U", "u", "^", ";", -99]), $a(["V", "v", "_", "<", -99]), $a(["W", "w", "`", "=", -99]), $a(["X", "x", "|", ">", -99]), $a(["Y", "y", "~", "?", -99]), $a(["Z", "z", 127, "[", -99]), $a([$ctx.ll, $ctx.su, $ctx.ll, "]", -99]), $a([$ctx.lm, $ctx.lm, $ctx.lu, "{", -99]), $a([$ctx.ld, $ctx.ld, $ctx.lp, "}", -99]), $a([$ctx.sb, $ctx.sb, $ctx.sb, $ctx.lu, -99])]);
        $ctx.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
        for (var _1c = 0, _1b = $ctx.charmaps.length - 1; _1c <= _1b; _1c += 1) {
          $ctx.i = _1c;
          $ctx.encs = $get($ctx.charmaps, $ctx.i);
          for (var _1g = 0; _1g <= 4; _1g += 1) {
            $ctx.j = _1g;
            var _1j = $get($ctx.encs, $ctx.j);
            $k[$j++] = _1j;
            if ($eq($type(_1j), "stringtype")) {
              var _1m = $get($k[--$j], 0);
              $k[$j++] = _1m;
            }
            $put($get($ctx.charvals, $ctx.j), $k[--$j], $ctx.i);
          }
        }
        var _1w = /* @__PURE__ */ new Map([
          ["\r\n", $ctx.p2],
          [". ", $ctx.p3],
          [", ", $ctx.p4],
          [": ", $ctx.p5]
        ]);
        $ctx.pcomp = _1w;
        $ctx.e = 1e4;
        var _21 = $a([4, 9, 9, 14, 0, 14]);
        $ctx.latlen = $a([$a([0, 5, 5, 10, 5, 10]), $a([9, 0, 5, 10, 5, 10]), $a([5, 5, 0, 5, 10, 10]), $a([5, 10, 10, 0, 10, 15]), _21, $a([0, 0, 0, 0, 0, 0])]);
        $ctx.latseq = $a([$a([$a([]), $a([$ctx.ll]), $a([$ctx.lm]), $a([$ctx.lm, $ctx.lp]), $a([$ctx.ld]), $a([$ctx.sb])]), $a([$a([$ctx.ld, $ctx.lu]), $a([]), $a([$ctx.lm]), $a([$ctx.lm, $ctx.lp]), $a([$ctx.ld]), $a([$ctx.sb])]), $a([$a([$ctx.lu]), $a([$ctx.ll]), $a([]), $a([$ctx.lp]), $a([$ctx.lu, $ctx.ld]), $a([$ctx.sb])]), $a([$a([$ctx.lu]), $a([$ctx.lu, $ctx.ll]), $a([$ctx.lu, $ctx.lm]), $a([]), $a([$ctx.lu, $ctx.ld]), $a([$ctx.lu, $ctx.sb])]), $a([$a([$ctx.lu]), $a([$ctx.lu, $ctx.ll]), $a([$ctx.lu, $ctx.lm]), $a([$ctx.lu, $ctx.lm, $ctx.lp]), $a([]), $a([$ctx.lu, $ctx.sb])]), $a([$a([$ctx.lu]), $a([$ctx.ll]), $a([$ctx.lm]), $a([]), $a([]), $a([])])]);
        $ctx.shftlen = $a([$a([$ctx.e, $ctx.e, $ctx.e, 5, $ctx.e]), $a([5, $ctx.e, $ctx.e, 5, $ctx.e]), $a([$ctx.e, $ctx.e, $ctx.e, 5, $ctx.e]), $a([$ctx.e, $ctx.e, $ctx.e, $ctx.e, $ctx.e]), $a([4, $ctx.e, $ctx.e, 4, $ctx.e])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_azteccode.$ctx[id] = $ctx[id]);
        bwipp_azteccode.__21995__ = 1;
      })();
    }
    $1.msgbits = "";
    if ($ne($1.format, "rune") && $1.raw) {
      $1.msgbits = $1.barcode;
    }
    if ($ne($1.format, "rune") && !$1.raw) {
      $1.charsize = function() {
        var _3v = $k[--$j];
        $k[$j++] = _3v;
        if (_3v >= 0) {
          $j--;
          var _3y = $get($a([5, 5, 5, 5, 4, 8]), $k[--$j]);
          $k[$j++] = _3y;
        } else {
          var _3z = $k[--$j];
          var _40 = $k[--$j];
          $k[$j++] = _3z;
          $k[$j++] = _40;
          $j--;
          var _41 = $k[--$j];
          $k[$j++] = _41;
          if (_41 == $1.fn1) {
            $j--;
            $k[$j++] = 8;
          } else {
            var _44 = $f(-$k[--$j] - 1e6);
            $k[$j++] = _44;
            if (_44 == 0) {
              $j--;
              $k[$j++] = 1;
            }
            var _45 = $k[--$j];
            $k[$j++] = (~~(Math.log(_45) / Math.log(10)) + 1) * 4 + 8;
          }
        }
      };
      $1.curlen = $a([0, $1.e, $1.e, $1.e, $1.e, $1.e]);
      $1.curseq = $a([$a([]), $a([]), $a([]), $a([]), $a([]), $a([])]);
      $1.backto = $1.U;
      $1.lastchar = "";
      $forall($1.msg, function() {
        $1.char = $k[--$j];
        for (; ; ) {
          $1.imp = false;
          var _4S = $a([$1.U, $1.L, $1.M, $1.P, $1.D, $1.B]);
          for (var _4T = 0, _4U = _4S.length; _4T < _4U; _4T++) {
            $1.x = $get(_4S, _4T);
            var _4c = $a([$1.U, $1.L, $1.M, $1.P, $1.D, $1.B]);
            for (var _4d = 0, _4e = _4c.length; _4d < _4e; _4d++) {
              $1.y = $get(_4c, _4d);
              if ($1.x != $1.B || $1.y == $1.backto) {
                $1.cost = $f($get($1.curlen, $1.x) + $get($get($1.latlen, $1.x), $1.y));
                if ($1.cost < $get($1.curlen, $1.y)) {
                  $put($1.curlen, $1.y, $1.cost);
                  $k[$j++] = $1.curseq;
                  $k[$j++] = $1.y;
                  $k[$j++] = Infinity;
                  $aload($get($1.curseq, $1.x));
                  $aload($get($get($1.latseq, $1.x), $1.y));
                  var _59 = $a();
                  var _5A = $k[--$j];
                  $put($k[--$j], _5A, _59);
                  if ($1.y == $1.B) {
                    $k[$j++] = "backto";
                    if ($1.x == $1.P || $1.x == $1.D) {
                      $k[$j++] = $1.U;
                    } else {
                      $k[$j++] = $1.x;
                    }
                    var _5K = $k[--$j];
                    $1[$k[--$j]] = _5K;
                  }
                  $1.imp = true;
                }
              }
            }
          }
          if (!$1.imp) {
            break;
          }
        }
        $1.nxtlen = $a([$1.e, $1.e, $1.e, $1.e, $1.e, $1.e]);
        $1.nxtseq = $a(6);
        var _5b = $a([$1.U, $1.L, $1.M, $1.P, $1.D, $1.B]);
        for (var _5c = 0, _5d = _5b.length; _5c < _5d; _5c++) {
          $1.x = $get(_5b, _5c);
          for (; ; ) {
            if ($1.char >= 0) {
              if ($1.x != $1.B) {
                var _5m = $get($get($1.charvals, $1.x), $1.char) !== void 0;
                if (!_5m) {
                  break;
                }
              }
            } else {
              if ($1.x != $1.P) {
                break;
              }
            }
            $k[$j++] = "cost";
            $k[$j++] = $get($1.curlen, $1.x);
            $k[$j++] = $1.x;
            $k[$j++] = $1.char;
            $1.charsize();
            var _5u = $k[--$j];
            var _5v = $k[--$j];
            $1[$k[--$j]] = $f(_5v + _5u);
            if ($1.cost < $get($1.nxtlen, $1.x)) {
              $put($1.nxtlen, $1.x, $1.cost);
              $k[$j++] = $1.nxtseq;
              $k[$j++] = $1.x;
              $k[$j++] = Infinity;
              $aload($get($1.curseq, $1.x));
              $k[$j++] = $1.char;
              var _6A = $a();
              var _6B = $k[--$j];
              $put($k[--$j], _6B, _6A);
            }
            if ($1.x == $1.B) {
              break;
            }
            var _6K = $a([$1.U, $1.L, $1.M, $1.P, $1.D]);
            for (var _6L = 0, _6M = _6K.length; _6L < _6M; _6L++) {
              $1.y = $get(_6K, _6L);
              if ($ne($1.x, $1.y)) {
                $k[$j++] = "cost";
                $k[$j++] = $f($get($1.curlen, $1.y) + $get($get($1.shftlen, $1.y), $1.x));
                $k[$j++] = $1.x;
                $k[$j++] = $1.char;
                $1.charsize();
                var _6a = $k[--$j];
                var _6b = $k[--$j];
                $1[$k[--$j]] = $f(_6b + _6a);
                if ($1.cost < $get($1.nxtlen, $1.y)) {
                  $put($1.nxtlen, $1.y, $1.cost);
                  $k[$j++] = $1.nxtseq;
                  $k[$j++] = $1.y;
                  $k[$j++] = Infinity;
                  $aload($get($1.curseq, $1.y));
                  var _6r = $1.x == $1.U ? $1.su : $1.sp;
                  $k[$j++] = _6r;
                  $k[$j++] = $1.char;
                  var _6t = $a();
                  var _6u = $k[--$j];
                  $put($k[--$j], _6u, _6t);
                }
              }
            }
            break;
          }
        }
        if ($ne($1.lastchar, "") && $1.char >= 0) {
          var _6y = $s(2);
          $put(_6y, 0, $1.lastchar);
          $put(_6y, 1, $1.char);
          $1.pchars = _6y;
          var _73 = $get($1.pcomp, $1.pchars) !== void 0;
          if (_73) {
            var _79 = $a([$1.U, $1.L, $1.M, $1.P, $1.D]);
            for (var _7A = 0, _7B = _79.length; _7A < _7B; _7A++) {
              $1.i = $get(_79, _7A);
              $1.inP = true;
              if ($1.i == $1.M) {
                if ($1.lastchar == 13) {
                  $1.inP = false;
                }
              } else {
                if ($1.i == $1.D) {
                  if ($1.lastchar == 44 || $1.lastchar == 46) {
                    $1.inP = false;
                  }
                }
              }
              if ($1.inP && $lt($get($1.curlen, $1.i), $get($1.nxtlen, $1.i))) {
                $1.curseqi = $get($1.curseq, $1.i);
                $1.lastld = false;
                $1.lastsp = false;
                $1.lastidx = -1;
                for (var _7V = $1.curseqi.length - 1; _7V >= 0; _7V -= 1) {
                  $1.idx = _7V;
                  $1.ch = $get($1.curseqi, $1.idx);
                  if ($1.lastidx == -1) {
                    if ($eq($1.ch, $1.lastchar)) {
                      $1.lastidx = $1.idx;
                      if ($1.idx > 0) {
                        if ($get($1.curseqi, $1.idx - 1) == $1.sp) {
                          $1.lastsp = true;
                        }
                      }
                    }
                  } else {
                    if ($1.ch < 0 && $1.ch >= $1.ld) {
                      if ($1.i == $1.P) {
                        if ($1.ch == $1.ld) {
                          $1.lastld = true;
                        }
                      } else {
                        if ($1.ch != $1.lp) {
                          $1.inP = $1.lastsp;
                        }
                      }
                      break;
                    }
                  }
                }
                if ($1.inP && $1.lastidx >= 0) {
                  $put($1.nxtlen, $1.i, $get($1.curlen, $1.i));
                  if ($1.lastidx < $1.curseqi.length - 1) {
                    if ($1.i == $1.P) {
                      if ($1.lastld) {
                        $put($1.nxtlen, $1.i, $f($get($1.nxtlen, $1.i) + 1));
                      }
                      $k[$j++] = $1.nxtseq;
                      $k[$j++] = $1.i;
                      $k[$j++] = Infinity;
                      $aload($1.curseqi);
                      $r($1.curseqi.length - $1.lastidx, -1);
                      $j--;
                      $k[$j++] = $get($1.pcomp, $1.pchars);
                      var _8H = $a();
                      var _8I = $k[--$j];
                      $put($k[--$j], _8I, _8H);
                    } else {
                      $k[$j++] = $1.nxtseq;
                      $k[$j++] = $1.i;
                      $k[$j++] = Infinity;
                      $aload($1.curseqi);
                      var _8N = $a();
                      var _8O = $k[--$j];
                      $put($k[--$j], _8O, _8N);
                      $put($get($1.nxtseq, $1.i), $1.lastidx, $get($1.pcomp, $1.pchars));
                    }
                  } else {
                    $k[$j++] = $1.nxtseq;
                    $k[$j++] = $1.i;
                    $k[$j++] = Infinity;
                    $aload($1.curseqi);
                    $j--;
                    $k[$j++] = $get($1.pcomp, $1.pchars);
                    var _8d = $a();
                    var _8e = $k[--$j];
                    $put($k[--$j], _8e, _8d);
                  }
                }
              }
            }
          }
        }
        if ($ne($get($1.nxtseq, $1.B), null)) {
          $1.numbytes = 0;
          $forall($get($1.nxtseq, $1.B), function() {
            if ($k[--$j] == $1.sb) {
              $k[$j++] = 0;
            } else {
              $k[$j++] = $1.numbytes + 1;
            }
            $1.numbytes = $k[--$j];
          });
          if ($1.numbytes == 32) {
            $put($1.nxtlen, $1.B, $f($get($1.nxtlen, $1.B) + 11));
          }
        }
        $1.curlen = $1.nxtlen;
        $1.curseq = $1.nxtseq;
        $k[$j++] = "lastchar";
        if ($1.char >= 0) {
          $k[$j++] = $1.char;
        } else {
          $k[$j++] = "";
        }
        var _90 = $k[--$j];
        $1[$k[--$j]] = _90;
      });
      $1.minseq = $1.e;
      var _99 = $a([$1.U, $1.L, $1.M, $1.P, $1.D, $1.B]);
      for (var _9A = 0, _9B = _99.length; _9A < _9B; _9A++) {
        $1.i = $get(_99, _9A);
        if ($get($1.curlen, $1.i) < $1.minseq) {
          $1.minseq = $get($1.curlen, $1.i);
          $1.seq = $get($1.curseq, $1.i);
        }
      }
      $1.tobin = function() {
        var _9O = $s($k[--$j]);
        $k[$j++] = _9O;
        for (var _9Q = 0, _9P = _9O.length - 1; _9Q <= _9P; _9Q += 1) {
          var _9R = $k[--$j];
          $put(_9R, _9Q, 48);
          $k[$j++] = _9R;
        }
        var _9S = $k[--$j];
        var _9V = $cvrs($s(_9S.length), $k[--$j], 2);
        $puti(_9S, _9S.length - _9V.length, _9V);
        $k[$j++] = _9S;
      };
      $1.encu = function() {
        var _9a = $get($get($1.charvals, $1.U), $k[--$j]);
        $k[$j++] = _9a;
        $k[$j++] = 5;
        $1.tobin();
      };
      $1.encl = function() {
        var _9f = $get($get($1.charvals, $1.L), $k[--$j]);
        $k[$j++] = _9f;
        $k[$j++] = 5;
        $1.tobin();
      };
      $1.encm = function() {
        var _9k = $get($get($1.charvals, $1.M), $k[--$j]);
        $k[$j++] = _9k;
        $k[$j++] = 5;
        $1.tobin();
      };
      $1.encd = function() {
        var _9p = $get($get($1.charvals, $1.D), $k[--$j]);
        $k[$j++] = _9p;
        $k[$j++] = 4;
        $1.tobin();
      };
      $1.encp = function() {
        var _9q = $k[--$j];
        $k[$j++] = _9q;
        if (_9q == $1.fn1) {
          $j--;
          $k[$j++] = "00000000";
        } else {
          var _9s = $k[--$j];
          $k[$j++] = _9s;
          if (_9s <= -1e6) {
            var _9u = $f(-$k[--$j] - 1e6);
            $k[$j++] = _9u;
            $k[$j++] = _9u;
            if (_9u == 0) {
              $j--;
              $k[$j++] = 1;
            }
            var _9w = ~~(Math.log($k[--$j]) / Math.log(10));
            var _9x = $s((_9w + 1) * 4 + 8);
            $puti(_9x, 0, "00000");
            $k[$j++] = _9w;
            $k[$j++] = _9x;
            $k[$j++] = _9x;
            $k[$j++] = _9w + 1;
            $k[$j++] = 3;
            $1.tobin();
            var _9y = $k[--$j];
            $puti($k[--$j], 5, _9y);
            var _A0 = $k[--$j];
            var _A1 = $k[--$j];
            var _A2 = $k[--$j];
            $k[$j++] = _A0;
            $k[$j++] = _A2;
            for (var _A3 = _A1; _A3 >= 0; _A3 -= 1) {
              var _A4 = $k[--$j];
              var _A5 = $k[--$j];
              $k[$j++] = _A5;
              $k[$j++] = ~~(_A4 / 10);
              $k[$j++] = _A5;
              $k[$j++] = _A3 * 4 + 8;
              $k[$j++] = $f(_A4 % 10 + 2);
              $k[$j++] = 4;
              $1.tobin();
              var _A6 = $k[--$j];
              var _A7 = $k[--$j];
              $puti($k[--$j], _A7, _A6);
            }
            $j--;
          } else {
            var _AD = $get($get($1.charvals, $1.P), $k[--$j]);
            $k[$j++] = _AD;
            $k[$j++] = 5;
            $1.tobin();
          }
        }
      };
      $1.encfuncs = $a(["encu", "encl", "encm", "encp", "encd"]);
      $1.addtomsgbits = function() {
        $1.v = $k[--$j];
        $puti($1.msgbits, $1.j, $1.v);
        $1.j = $1.j + $1.v.length;
      };
      $1.state = $1.U;
      $1.msgbits = $s($1.minseq);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i >= $1.seq.length) {
          break;
        }
        if ($1.state != $1.B) {
          $1.char = $get($1.seq, $1.i);
          $k[$j++] = $1.char;
          if ($1[$get($1.encfuncs, $1.state)]() === true) {
            break;
          }
          $1.addtomsgbits();
          $1.i = $1.i + 1;
          if ($1.char == $1.su || $1.char == $1.sp) {
            $k[$j++] = $get($1.seq, $1.i);
            if ($1.char == $1.su) {
              $1.encu();
            } else {
              $1.encp();
            }
            $1.addtomsgbits();
            $1.i = $1.i + 1;
          }
          if ($1.char == $1.lu) {
            $1.state = $1.U;
          }
          if ($1.char == $1.ll) {
            $1.state = $1.L;
          }
          if ($1.char == $1.lm) {
            $1.state = $1.M;
          }
          if ($1.char == $1.lp) {
            $1.state = $1.P;
          }
          if ($1.char == $1.ld) {
            $1.state = $1.D;
          }
          if ($1.char == $1.sb) {
            $1.state = $1.B;
          }
        } else {
          $1.numbytes = 0;
          for (; ; ) {
            if ($1.i + $1.numbytes >= $1.seq.length) {
              break;
            }
            if ($get($1.seq, $1.i + $1.numbytes) < 0) {
              break;
            }
            $1.numbytes = $1.numbytes + 1;
          }
          if ($1.numbytes <= 31) {
            $k[$j++] = $1.numbytes;
            $k[$j++] = 5;
            $1.tobin();
            $1.addtomsgbits();
          } else {
            $k[$j++] = 0;
            $k[$j++] = 5;
            $1.tobin();
            $1.addtomsgbits();
            $k[$j++] = $1.numbytes - 31;
            $k[$j++] = 11;
            $1.tobin();
            $1.addtomsgbits();
          }
          for (var _BF = 0, _BG = $1.numbytes; _BF < _BG; _BF++) {
            $k[$j++] = $get($1.seq, $1.i);
            $k[$j++] = 8;
            $1.tobin();
            $1.addtomsgbits();
            $1.i = $1.i + 1;
          }
          if ($1.i < $1.seq.length) {
            $1.char = $get($1.seq, $1.i);
            $1.i = $1.i + 1;
            if ($1.char == $1.lu) {
              $1.state = $1.U;
            }
            if ($1.char == $1.ll) {
              $1.state = $1.L;
            }
            if ($1.char == $1.lm) {
              $1.state = $1.M;
            }
          }
        }
      }
    }
    if (!bwipp_azteccode.__22309__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.metrics = $a([$a(["rune", 0, 0, 0, 6]), $a(["compact", 1, 1, 17, 6]), $a(["full", 1, 1, 21, 6]), $a(["compact", 2, 0, 40, 6]), $a(["full", 2, 1, 48, 6]), $a(["compact", 3, 0, 51, 8]), $a(["full", 3, 1, 60, 8]), $a(["compact", 4, 0, 76, 8]), $a(["full", 4, 1, 88, 8]), $a(["full", 5, 1, 120, 8]), $a(["full", 6, 1, 156, 8]), $a(["full", 7, 1, 196, 8]), $a(["full", 8, 1, 240, 8]), $a(["full", 9, 1, 230, 10]), $a(["full", 10, 1, 272, 10]), $a(["full", 11, 1, 316, 10]), $a(["full", 12, 1, 364, 10]), $a(["full", 13, 1, 416, 10]), $a(["full", 14, 1, 470, 10]), $a(["full", 15, 1, 528, 10]), $a(["full", 16, 1, 588, 10]), $a(["full", 17, 1, 652, 10]), $a(["full", 18, 1, 720, 10]), $a(["full", 19, 1, 790, 10]), $a(["full", 20, 1, 864, 10]), $a(["full", 21, 1, 940, 10]), $a(["full", 22, 1, 1020, 10]), $a(["full", 23, 0, 920, 12]), $a(["full", 24, 0, 992, 12]), $a(["full", 25, 0, 1066, 12]), $a(["full", 26, 0, 1144, 12]), $a(["full", 27, 0, 1224, 12]), $a(["full", 28, 0, 1306, 12]), $a(["full", 29, 0, 1392, 12]), $a(["full", 30, 0, 1480, 12]), $a(["full", 31, 0, 1570, 12]), $a(["full", 32, 0, 1664, 12])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_azteccode.$ctx[id] = $ctx[id]);
        bwipp_azteccode.__22309__ = 1;
      })();
    }
    var _CD = $1.metrics;
    for (var _CE = 0, _CF = _CD.length; _CE < _CF; _CE++) {
      $1.m = $get(_CD, _CE);
      $1.frmt = $get($1.m, 0);
      $1.mlyr = $get($1.m, 1);
      $1.icap = $get($1.m, 2);
      $1.ncws = $get($1.m, 3);
      $1.bpcw = $get($1.m, 4);
      $1.numecw = ~~Math.ceil($f($1.ncws * $1.eclevel / 100 + $1.ecaddchars));
      if ($1.msgbits.length == 0) {
        $1.numecw = 0;
      }
      $1.numdcw = $f($1.ncws - $1.numecw);
      $1.okay = true;
      if ($ne($1.format, $1.frmt)) {
        $1.okay = false;
      }
      if ($1.readerinit && $1.icap != 1) {
        $1.okay = false;
      }
      if ($1.layers != -1 && $1.layers != $1.mlyr) {
        $1.okay = false;
      }
      if (~~Math.ceil($1.msgbits.length / $1.bpcw) > $1.numdcw) {
        $1.okay = false;
      }
      if ($1.okay) {
        break;
      }
    }
    if (!$1.okay) {
      $k[$j++] = "bwipp.qrcodeNoValidSymbol#22330";
      $k[$j++] = "Maximum length exceeded";
      bwipp_raiseerror();
    }
    $1.layers = $1.mlyr;
    $1.allzero = function() {
      var _Ck = $k[--$j];
      $k[$j++] = $eq(_Ck, $geti("000000000000", 0, _Ck.length));
    };
    $1.allones = function() {
      var _Cm = $k[--$j];
      $k[$j++] = $eq(_Cm, $geti("111111111111", 0, _Cm.length));
    };
    $1.cws = $a($1.ncws);
    $1.m = 0;
    $1.c = 0;
    for (; ; ) {
      if ($1.msgbits.length <= $1.m) {
        break;
      }
      if ($1.msgbits.length - $1.m >= $1.bpcw) {
        $1.cwb = $geti($1.msgbits, $1.m, $f($1.bpcw - 1));
        $1.cwf = $geti($1.msgbits, $f($f($1.m + $1.bpcw) - 1), 1);
        $k[$j++] = $1.cwb;
        $1.allzero();
        if ($k[--$j]) {
          $1.cwf = "1";
          $1.m = $1.m - 1;
        }
        $k[$j++] = $1.cwb;
        $1.allones();
        if ($k[--$j]) {
          $1.cwf = "0";
          $1.m = $1.m - 1;
        }
        var _D9 = $s(12);
        $puti(_D9, 0, $1.cwb);
        $puti(_D9, $f($1.bpcw - 1), $1.cwf);
        $1.cwb = $geti(_D9, 0, $1.bpcw);
      } else {
        $1.cwb = $geti($1.msgbits, $1.m, $1.msgbits.length - $1.m);
        var _DL = $strcpy($s(12), "111111111111");
        $puti(_DL, 0, $1.cwb);
        $1.cwb = $geti(_DL, 0, $1.bpcw);
        $k[$j++] = $1.cwb;
        $1.allones();
        if ($k[--$j]) {
          $puti($1.cwb, $1.cwb.length - 1, "0");
        }
      }
      $1.cw = 0;
      for (var _DV = 0, _DU = $f($1.bpcw - 1); _DV <= _DU; _DV += 1) {
        $1.i = _DV;
        $1.cw = $f($1.cw + ~~Math.pow(2, $f($f($1.bpcw - $1.i) - 1)) * $f($get($1.cwb, $1.i) - 48));
      }
      $put($1.cws, $1.c, $1.cw);
      $1.m = $f($1.m + $1.bpcw);
      $1.c = $1.c + 1;
    }
    $1.cws = $geti($1.cws, 0, $1.c);
    var _Dm = $get($1.options, "debugcws") !== void 0;
    if (_Dm) {
      $k[$j++] = "bwipp.debugcws#22369";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    $1.rscodes = function() {
      $1.rspm = $k[--$j];
      $1.rsgf = $k[--$j];
      $1.rsnc = $k[--$j];
      $1.rscws = $k[--$j];
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      for (var _Dt = 0, _Du = $f($1.rsgf - 1); _Dt < _Du; _Dt++) {
        var _Dv = $k[--$j];
        var _Dw = _Dv * 2;
        $k[$j++] = _Dv;
        $k[$j++] = _Dw;
        if (_Dw >= $1.rsgf) {
          var _Dz = $k[--$j];
          $k[$j++] = $xo(_Dz, $1.rspm);
        }
      }
      $1.rsalog = $a();
      $1.rslog = $a($1.rsgf);
      for (var _E5 = 1, _E4 = $f($1.rsgf - 1); _E5 <= _E4; _E5 += 1) {
        $put($1.rslog, $get($1.rsalog, _E5), _E5);
      }
      $1.rsprod = function() {
        var _E9 = $k[--$j];
        var _EA = $k[--$j];
        $k[$j++] = _EA;
        $k[$j++] = _E9;
        if (_E9 != 0 && _EA != 0) {
          var _ED = $get($1.rslog, $k[--$j]);
          var _EJ = $get($1.rsalog, $f(_ED + $get($1.rslog, $k[--$j])) % $f($1.rsgf - 1));
          $k[$j++] = _EJ;
        } else {
          $j -= 2;
          $k[$j++] = 0;
        }
      };
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      for (var _EL = 0, _EM = $1.rsnc; _EL < _EM; _EL++) {
        $k[$j++] = 0;
      }
      $1.coeffs = $a();
      for (var _EQ = 1, _EP = $1.rsnc; _EQ <= _EP; _EQ += 1) {
        $1.i = _EQ;
        $put($1.coeffs, $1.i, $get($1.coeffs, $1.i - 1));
        for (var _EX = $1.i - 1; _EX >= 1; _EX -= 1) {
          $1.j = _EX;
          $k[$j++] = $1.coeffs;
          $k[$j++] = $1.j;
          $k[$j++] = $get($1.coeffs, $1.j - 1);
          $k[$j++] = $get($1.coeffs, $1.j);
          $k[$j++] = $get($1.rsalog, $1.i);
          $1.rsprod();
          var _Ej = $k[--$j];
          var _Ek = $k[--$j];
          var _El = $k[--$j];
          $put($k[--$j], _El, $xo(_Ek, _Ej));
        }
        $k[$j++] = $1.coeffs;
        $k[$j++] = 0;
        $k[$j++] = $get($1.coeffs, 0);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _Et = $k[--$j];
        var _Eu = $k[--$j];
        $put($k[--$j], _Eu, _Et);
      }
      $1.nd = $1.rscws.length;
      $k[$j++] = Infinity;
      $forall($1.rscws);
      for (var _Ez = 0, _F0 = $1.rsnc; _Ez < _F0; _Ez++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.rscws = $a();
      for (var _F4 = 0, _F3 = $1.nd - 1; _F4 <= _F3; _F4 += 1) {
        $1.k = $xo($get($1.rscws, _F4), $get($1.rscws, $1.nd));
        for (var _FC = 0, _FB = $f($1.rsnc - 1); _FC <= _FB; _FC += 1) {
          $1.j = _FC;
          $k[$j++] = $1.rscws;
          $k[$j++] = $1.nd + $1.j;
          $k[$j++] = $get($1.rscws, $1.nd + $1.j + 1);
          $k[$j++] = $1.k;
          $k[$j++] = $get($1.coeffs, $f($f($1.rsnc - $1.j) - 1));
          $1.rsprod();
          var _FP = $k[--$j];
          var _FQ = $k[--$j];
          var _FR = $k[--$j];
          $put($k[--$j], _FR, $xo(_FQ, _FP));
        }
      }
      $k[$j++] = $geti($1.rscws, 0, $1.rscws.length - 1);
    };
    if ($eq($1.format, "full")) {
      $1.mode = ($f($1.layers - 1) << 11) + ($1.cws.length - 1);
      if ($1.readerinit) {
        $1.mode = $1.mode | 1024;
      }
      $1.mode = $a([($1.mode & 61440) >>> 12, ($1.mode & 3840) >>> 8, ($1.mode & 240) >>> 4, $1.mode & 15]);
      $k[$j++] = "mode";
      $k[$j++] = $1.mode;
      $k[$j++] = 6;
      $k[$j++] = 16;
      $k[$j++] = 19;
      $1.rscodes();
      var _Fh = $k[--$j];
      $1[$k[--$j]] = _Fh;
    }
    if ($eq($1.format, "compact")) {
      $1.mode = ($f($1.layers - 1) << 6) + ($1.cws.length - 1);
      if ($1.readerinit) {
        $1.mode = $1.mode | 32;
      }
      $1.mode = $a([($1.mode & 240) >>> 4, $1.mode & 15]);
      $k[$j++] = "mode";
      $k[$j++] = $1.mode;
      $k[$j++] = 5;
      $k[$j++] = 16;
      $k[$j++] = 19;
      $1.rscodes();
      var _Fs = $k[--$j];
      $1[$k[--$j]] = _Fs;
    }
    if ($eq($1.format, "rune")) {
      $1.mode = $cvi($1.barcode);
      $1.mode = $a([($1.mode & 240) >>> 4, $1.mode & 15]);
      $k[$j++] = "mode";
      $k[$j++] = $1.mode;
      $k[$j++] = 5;
      $k[$j++] = 16;
      $k[$j++] = 19;
      $1.rscodes();
      var _G0 = $k[--$j];
      $1[$k[--$j]] = _G0;
      $k[$j++] = Infinity;
      var _G2 = $1.mode;
      for (var _G3 = 0, _G4 = _G2.length; _G3 < _G4; _G3++) {
        $k[$j++] = $get(_G2, _G3) ^ 10;
      }
      $1.mode = $a();
    }
    $1.modebits = $s($1.mode.length * 4);
    for (var _GB = 0, _GA = $1.modebits.length - 1; _GB <= _GA; _GB += 1) {
      $puti($1.modebits, _GB, "0");
    }
    for (var _GF = 0, _GE = $1.mode.length - 1; _GF <= _GE; _GF += 1) {
      $1.i = _GF;
      var _GL = $cvrs($s(4), $get($1.mode, $1.i), 2);
      $puti($1.modebits, 4 - _GL.length + 4 * $1.i, _GL);
    }
    if (!bwipp_azteccode.__22470__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.rsparams = $a([$a([]), $a([]), $a([]), $a([]), $a([]), $a([]), $a([64, 67]), $a([]), $a([256, 301]), $a([]), $a([1024, 1033]), $a([]), $a([4096, 4201])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_azteccode.$ctx[id] = $ctx[id]);
        bwipp_azteccode.__22470__ = 1;
      })();
    }
    $k[$j++] = "cws";
    $k[$j++] = $1.cws;
    $k[$j++] = $f($1.ncws - $1.cws.length);
    $forall($get($1.rsparams, $1.bpcw));
    $1.rscodes();
    var _Gi = $k[--$j];
    $1[$k[--$j]] = _Gi;
    if ($eq($1.format, "full")) {
      $1.databits = $s($f($1.layers * $1.layers * 16 + $1.layers * 112));
    } else {
      $1.databits = $s($f($1.layers * $1.layers * 16 + $1.layers * 88));
    }
    for (var _Gv = 0, _Gu = $1.databits.length - 1; _Gv <= _Gu; _Gv += 1) {
      $puti($1.databits, _Gv, "0");
    }
    for (var _Gz = 0, _Gy = $f($1.ncws - 1); _Gz <= _Gy; _Gz += 1) {
      $1.i = _Gz;
      var _H6 = $cvrs($s($1.bpcw), $get($1.cws, $1.i), 2);
      $puti($1.databits, $f($f($f($1.bpcw - _H6.length) + $1.bpcw * $1.i) + $f($1.databits.length - $1.ncws * $1.bpcw)), _H6);
    }
    $1.cmv = function() {
      var _HE = $k[--$j];
      var _HF = $k[--$j];
      $k[$j++] = $f($f(_HF - _HE * $1.size) + $1.mid);
    };
    $1.lmv = function() {
      $1.lbit = $k[--$j];
      $1.llyr = $k[--$j];
      $1.lwid = $f($1.fw + $1.llyr * 4);
      $1.ldir = ~~(~~($1.lbit / 2) / $1.lwid);
      if ($1.ldir == 0) {
        $k[$j++] = $f(-~~($f($1.lwid - 1) / 2) + 1 + ~~($1.lbit / 2) % $1.lwid);
        $k[$j++] = $f($f(~~(($1.fw - 1) / 2) + $1.llyr * 2) + $1.lbit % 2);
        $1.cmv();
      }
      if ($1.ldir == 1) {
        $k[$j++] = $f($f(~~($1.fw / 2) + $1.llyr * 2) + $1.lbit % 2);
        $k[$j++] = $f(~~($f($1.lwid - 1) / 2) - 1 - ~~($1.lbit / 2) % $1.lwid);
        $1.cmv();
      }
      if ($1.ldir == 2) {
        $k[$j++] = -$f(-~~($1.lwid / 2) + 1 + ~~($1.lbit / 2) % $1.lwid);
        $k[$j++] = -$f($f(~~($1.fw / 2) + $1.llyr * 2) + $1.lbit % 2);
        $1.cmv();
      }
      if ($1.ldir == 3) {
        $k[$j++] = -$f($f(~~(($1.fw - 1) / 2) + $1.llyr * 2) + $1.lbit % 2);
        $k[$j++] = -$f(~~($1.lwid / 2) - 1 - ~~($1.lbit / 2) % $1.lwid);
        $1.cmv();
      }
    };
    if ($eq($1.format, "full")) {
      $1.fw = 12;
    } else {
      $1.fw = 9;
    }
    $1.size = $f($f($1.fw + $1.layers * 4) + 2);
    $k[$j++] = Infinity;
    for (var _Hu = 0, _Hv = $1.size * $1.size; _Hu < _Hv; _Hu++) {
      $k[$j++] = -1;
    }
    $1.pixs = $a();
    $1.mid = $f(~~($f($1.size - 1) / 2) * $1.size + ~~($f($1.size - 1) / 2));
    $1.i = 0;
    for (var _I2 = 1, _I1 = $1.layers; _I2 <= _I1; _I2 += 1) {
      $1.layer = _I2;
      for (var _I6 = 0, _I5 = ($1.fw + $1.layer * 4) * 8 - 1; _I6 <= _I5; _I6 += 1) {
        $1.pos = _I6;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.layer;
        $k[$j++] = $1.pos;
        $1.lmv();
        var _IE = $k[--$j];
        $put($k[--$j], _IE, $get($1.databits, $1.databits.length - $1.i - 1) - 48);
        $1.i = $1.i + 1;
      }
    }
    if ($eq($1.format, "full")) {
      $1.fw = 13;
      $1.size = $f($f($f($1.fw + $1.layers * 4) + 2) + ~~$f($f($1.layers + 10.5) / 7.5 - 1) * 2);
      $1.mid = ~~($1.size * $1.size / 2);
      $k[$j++] = Infinity;
      for (var _IP = 0, _IQ = $1.size * $1.size; _IP < _IQ; _IP++) {
        $k[$j++] = -2;
      }
      $1.npixs = $a();
      for (var _IU = 0, _IT = ~~($1.size / 2); _IU <= _IT; _IU += 16) {
        $1.i = _IU;
        for (var _IX = 0, _IW = $f($1.size - 1); _IX <= _IW; _IX += 1) {
          $1.j = _IX;
          $k[$j++] = $1.npixs;
          $k[$j++] = -~~($1.size / 2) + $1.j;
          $k[$j++] = $1.i;
          $1.cmv();
          var _Ig = $k[--$j];
          $puti($k[--$j], _Ig, $a([(~~($1.size / 2) + $1.j + $1.i + 1) % 2]));
          $k[$j++] = $1.npixs;
          $k[$j++] = -~~($1.size / 2) + $1.j;
          $k[$j++] = -$1.i;
          $1.cmv();
          var _Iq = $k[--$j];
          $puti($k[--$j], _Iq, $a([(~~($1.size / 2) + $1.j + $1.i + 1) % 2]));
          $k[$j++] = $1.npixs;
          $k[$j++] = $1.i;
          $k[$j++] = -~~($1.size / 2) + $1.j;
          $1.cmv();
          var _J0 = $k[--$j];
          $puti($k[--$j], _J0, $a([(~~($1.size / 2) + $1.j + $1.i + 1) % 2]));
          $k[$j++] = $1.npixs;
          $k[$j++] = -$1.i;
          $k[$j++] = -~~($1.size / 2) + $1.j;
          $1.cmv();
          var _JA = $k[--$j];
          $puti($k[--$j], _JA, $a([(~~($1.size / 2) + $1.j + $1.i + 1) % 2]));
        }
      }
      $1.j = 0;
      for (var _JE = 0, _JD = $1.npixs.length - 1; _JE <= _JD; _JE += 1) {
        $1.i = _JE;
        if ($get($1.npixs, $1.i) == -2) {
          $put($1.npixs, $1.i, $get($1.pixs, $1.j));
          $1.j = $1.j + 1;
        }
      }
      $1.pixs = $1.npixs;
    }
    $1.fw = ~~($1.fw / 2);
    for (var _JT = -$1.fw, _JS = $1.fw; _JT <= _JS; _JT += 1) {
      $1.i = _JT;
      for (var _JX = -$1.fw, _JW = $1.fw; _JX <= _JW; _JX += 1) {
        $1.j = _JX;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.i;
        $k[$j++] = $1.j;
        $1.cmv();
        if (Math.abs($1.i) > Math.abs($1.j)) {
          $k[$j++] = Math.abs($1.i);
        } else {
          $k[$j++] = Math.abs($1.j);
        }
        var _Jf = $k[--$j];
        var _Jg = $k[--$j];
        $put($k[--$j], _Jg, $f(_Jf + 1) % 2);
      }
    }
    var _KI = $a([$a([-($1.fw + 1), $1.fw, 1]), $a([-($1.fw + 1), $1.fw + 1, 1]), $a([-$1.fw, $1.fw + 1, 1]), $a([$1.fw + 1, $1.fw + 1, 1]), $a([$1.fw + 1, $1.fw, 1]), $a([$1.fw + 1, -$1.fw, 1]), $a([$1.fw, $1.fw + 1, 0]), $a([$1.fw + 1, -($1.fw + 1), 0]), $a([$1.fw, -($1.fw + 1), 0]), $a([-$1.fw, -($1.fw + 1), 0]), $a([-($1.fw + 1), -($1.fw + 1), 0]), $a([-($1.fw + 1), -$1.fw, 0])]);
    for (var _KJ = 0, _KK = _KI.length; _KJ < _KK; _KJ++) {
      $k[$j++] = $1.pixs;
      $forall($get(_KI, _KJ));
      var _KN = $k[--$j];
      var _KO = $k[--$j];
      var _KP = $k[--$j];
      $k[$j++] = _KN;
      $k[$j++] = _KP;
      $k[$j++] = _KO;
      $1.cmv();
      var _KQ = $k[--$j];
      var _KR = $k[--$j];
      $put($k[--$j], _KQ, _KR);
    }
    if (!bwipp_azteccode.__22596__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.modemapfull = $a([$a([-5, 7]), $a([-4, 7]), $a([-3, 7]), $a([-2, 7]), $a([-1, 7]), $a([1, 7]), $a([2, 7]), $a([3, 7]), $a([4, 7]), $a([5, 7]), $a([7, 5]), $a([7, 4]), $a([7, 3]), $a([7, 2]), $a([7, 1]), $a([7, -1]), $a([7, -2]), $a([7, -3]), $a([7, -4]), $a([7, -5]), $a([5, -7]), $a([4, -7]), $a([3, -7]), $a([2, -7]), $a([1, -7]), $a([-1, -7]), $a([-2, -7]), $a([-3, -7]), $a([-4, -7]), $a([-5, -7]), $a([-7, -5]), $a([-7, -4]), $a([-7, -3]), $a([-7, -2]), $a([-7, -1]), $a([-7, 1]), $a([-7, 2]), $a([-7, 3]), $a([-7, 4]), $a([-7, 5])]);
        $ctx.modemapcompact = $a([$a([-3, 5]), $a([-2, 5]), $a([-1, 5]), $a([0, 5]), $a([1, 5]), $a([2, 5]), $a([3, 5]), $a([5, 3]), $a([5, 2]), $a([5, 1]), $a([5, 0]), $a([5, -1]), $a([5, -2]), $a([5, -3]), $a([3, -5]), $a([2, -5]), $a([1, -5]), $a([0, -5]), $a([-1, -5]), $a([-2, -5]), $a([-3, -5]), $a([-5, -3]), $a([-5, -2]), $a([-5, -1]), $a([-5, 0]), $a([-5, 1]), $a([-5, 2]), $a([-5, 3])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_azteccode.$ctx[id] = $ctx[id]);
        bwipp_azteccode.__22596__ = 1;
      })();
    }
    $k[$j++] = "modemap";
    if ($eq($1.format, "full")) {
      $k[$j++] = $1.modemapfull;
    } else {
      $k[$j++] = $1.modemapcompact;
    }
    var _Lf = $k[--$j];
    $1[$k[--$j]] = _Lf;
    for (var _Lj = 0, _Li = $1.modemap.length - 1; _Lj <= _Li; _Lj += 1) {
      $1.i = _Lj;
      $k[$j++] = $1.pixs;
      $forall($get($1.modemap, $1.i));
      $1.cmv();
      var _Lr = $k[--$j];
      $put($k[--$j], _Lr, $get($1.modebits, $1.i) - 48);
    }
    var _Lz = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.size],
      ["pixy", $1.size],
      ["height", $1.size * 2 / 72],
      ["width", $1.size * 2 / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _Lz;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_azteccodecompact() {
    var $1 = Object.create(bwipp_azteccodecompact.$ctx || (bwipp_azteccodecompact.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "compact");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_azteccode();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_aztecrune() {
    var $1 = Object.create(bwipp_aztecrune.$ctx || (bwipp_aztecrune.$ctx = {}));
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $put($1.options, "dontdraw", true);
    $put($1.options, "format", "rune");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_azteccode();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_codeone() {
    var $1 = Object.create(bwipp_codeone.$ctx || (bwipp_codeone.$ctx = {}));
    $1.dontdraw = false;
    $1.version = "unset";
    $1.parse = false;
    $1.parsefnc = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _2 = $a(["unset", "T-16", "T-32", "T-48", "S-10", "S-20", "S-30", "A", "B", "C", "D", "E", "F", "G", "H"]);
    $k[$j++] = false;
    for (var _3 = 0, _4 = _2.length; _3 < _4; _3++) {
      var _7 = $k[--$j];
      $k[$j++] = _7 || $eq($get(_2, _3), $1.version);
    }
    if ($nt($k[--$j])) {
      $k[$j++] = "bwipp.codeoneBadVersion#22757";
      $k[$j++] = "version must be A to H, T-16, T-32, T-48, S-10, S-20 or S-30";
      bwipp_raiseerror();
    }
    $1.stype = $eq($geti($1.version, 0, 1), "S");
    if (!bwipp_codeone.__22920__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.stypevals = $a(["1", "1010", "1100100", "1111101000", "10011100010000", "11000011010100000", "11110100001001000000", "100110001001011010000000", "101111101011110000100000000", "111011100110101100101000000000", "1001010100000010111110010000000000", "1011101001000011101101110100000000000", "1110100011010100101001010001000000000000", "10010001100001001110011100101010000000000000", "10110101111001100010000011110100100000000000000", "11100011010111111010100100110001101000000000000000", "100011100001101111001001101111110000010000000000000000", "101100011010001010111100001011101100010100000000000000000"]);
        $ctx.stypemetrics = $a([$a(["S-10", 8, 11, 10, 4, 4, 1, 99, 99, 99]), $a(["S-20", 8, 21, 20, 8, 8, 1, 99, 99, 99]), $a(["S-30", 8, 31, 30, 12, 12, 1, 99, 99, 99])]);
        $ctx.nonstypemetrics = $a([$a(["A", 16, 18, 16, 10, 10, 1, 4, 99, 6]), $a(["B", 22, 22, 20, 19, 16, 1, 4, 99, 8]), $a(["C", 28, 32, 28, 44, 26, 1, 4, 22, 11]), $a(["D", 40, 42, 36, 91, 44, 1, 4, 16, 16]), $a(["E", 52, 54, 48, 182, 70, 1, 4, 22, 22]), $a(["F", 70, 76, 68, 370, 140, 2, 4, 22, 31]), $a(["G", 104, 98, 88, 732, 280, 4, 6, 21, 47]), $a(["H", 148, 134, 120, 1480, 560, 8, 6, 20, 69]), $a(["T-16", 16, 17, 16, 10, 10, 1, 99, 99, 99]), $a(["T-32", 16, 33, 32, 24, 16, 1, 99, 99, 99]), $a(["T-48", 16, 49, 48, 38, 22, 1, 99, 99, 99])]);
        $ctx.fnc1 = -1;
        $ctx.fnc3 = -2;
        $ctx.lC = -5;
        $ctx.lB = -6;
        $ctx.lX = -7;
        $ctx.lT = -8;
        $ctx.lD = -9;
        $ctx.unl = -10;
        $ctx.fnc2 = -11;
        $ctx.fnc4 = -12;
        $ctx.sft1 = -13;
        $ctx.sft2 = -14;
        $ctx.sft3 = -15;
        $ctx.eci = -16;
        $ctx.pad = -17;
        $ctx.fnc1lD = -18;
        $ctx.unlcw = 255;
        $k[$j++] = Infinity;
        for (var _S = 0; _S <= 128; _S += 1) {
          $k[$j++] = _S;
          $k[$j++] = _S + 1;
        }
        $k[$j++] = $ctx.pad;
        $k[$j++] = 129;
        for (var _U = 0; _U <= 99; _U += 1) {
          var _W = $cvrs($s(2), _U, 10);
          var _Y = $strcpy($s(2), "00");
          $puti(_Y, 2 - _W.length, _W);
          $k[$j++] = _Y;
          $k[$j++] = _U + 130;
        }
        var _g = $a([$ctx.lC, $ctx.lB, $ctx.fnc1, $ctx.fnc2, $ctx.fnc3, $ctx.fnc4, $ctx.fnc1lD]);
        $k[$j++] = 229;
        for (var _h = 0, _i = _g.length; _h < _i; _h++) {
          var _l = $f($k[--$j] + 1);
          $k[$j++] = $get(_g, _h);
          $k[$j++] = _l;
          $k[$j++] = _l;
        }
        $j--;
        $k[$j++] = $ctx.lX;
        $k[$j++] = 238;
        $k[$j++] = $ctx.lT;
        $k[$j++] = 239;
        $ctx.Avals = $d();
        $k[$j++] = Infinity;
        var _p = $ctx.Avals;
        for (var _u = _p.size, _t = _p.keys(), _s = 0; _s < _u; _s++) {
          var _q = _t.next().value;
          $k[$j++] = _q;
          $k[$j++] = _p.get(_q);
          $k[$j++] = Infinity;
          var _v = $k[--$j];
          var _w = $k[--$j];
          $k[$j++] = _v;
          $k[$j++] = _w;
          var _x = $a();
          $k[$j++] = _x;
        }
        $ctx.Avals = $d();
        $k[$j++] = Infinity;
        $k[$j++] = $ctx.sft1;
        $k[$j++] = 0;
        $k[$j++] = $ctx.sft2;
        $k[$j++] = 1;
        $k[$j++] = $ctx.sft3;
        $k[$j++] = 2;
        $k[$j++] = 32;
        $k[$j++] = 3;
        for (var _12 = 48; _12 <= 57; _12 += 1) {
          $k[$j++] = _12;
          $k[$j++] = _12 - 44;
        }
        for (var _13 = 65; _13 <= 90; _13 += 1) {
          $k[$j++] = _13;
          $k[$j++] = _13 - 51;
        }
        $ctx.CNvals = $d();
        $k[$j++] = Infinity;
        for (var _15 = 0; _15 <= 31; _15 += 1) {
          $k[$j++] = _15;
          $k[$j++] = _15;
        }
        $ctx.C1vals = $d();
        $k[$j++] = Infinity;
        for (var _17 = 33; _17 <= 47; _17 += 1) {
          $k[$j++] = _17;
          $k[$j++] = _17 - 33;
        }
        for (var _18 = 58; _18 <= 64; _18 += 1) {
          $k[$j++] = _18;
          $k[$j++] = _18 - 43;
        }
        for (var _19 = 91; _19 <= 95; _19 += 1) {
          $k[$j++] = _19;
          $k[$j++] = _19 - 69;
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = 27;
        $k[$j++] = $ctx.fnc2;
        $k[$j++] = 28;
        $k[$j++] = $ctx.fnc3;
        $k[$j++] = 29;
        $k[$j++] = $ctx.fnc4;
        $k[$j++] = 30;
        $k[$j++] = $ctx.pad;
        $k[$j++] = 31;
        $ctx.C2vals = $d();
        $k[$j++] = Infinity;
        for (var _1G = 96; _1G <= 127; _1G += 1) {
          $k[$j++] = _1G;
          $k[$j++] = _1G - 96;
        }
        $ctx.C3vals = $d();
        $k[$j++] = Infinity;
        var _1I = $ctx.CNvals;
        for (var _1N = _1I.size, _1M = _1I.keys(), _1L = 0; _1L < _1N; _1L++) {
          var _1J = _1M.next().value;
          $k[$j++] = _1J;
          $k[$j++] = _1I.get(_1J);
          $k[$j++] = Infinity;
          var _1O = $k[--$j];
          var _1P = $k[--$j];
          $k[$j++] = _1O;
          $k[$j++] = _1P;
          var _1Q = $a();
          $k[$j++] = _1Q;
        }
        var _1R = $ctx.C1vals;
        for (var _1W = _1R.size, _1V = _1R.keys(), _1U = 0; _1U < _1W; _1U++) {
          var _1S = _1V.next().value;
          $k[$j++] = _1S;
          $k[$j++] = _1R.get(_1S);
          $k[$j++] = Infinity;
          var _1X = $k[--$j];
          var _1Y = $k[--$j];
          $k[$j++] = _1X;
          $k[$j++] = $get($ctx.CNvals, $ctx.sft1);
          $k[$j++] = _1Y;
          var _1c = $a();
          $k[$j++] = _1c;
        }
        var _1d = $ctx.C2vals;
        for (var _1i = _1d.size, _1h = _1d.keys(), _1g = 0; _1g < _1i; _1g++) {
          var _1e = _1h.next().value;
          $k[$j++] = _1e;
          $k[$j++] = _1d.get(_1e);
          $k[$j++] = Infinity;
          var _1j = $k[--$j];
          var _1k = $k[--$j];
          $k[$j++] = _1j;
          $k[$j++] = $get($ctx.CNvals, $ctx.sft2);
          $k[$j++] = _1k;
          var _1o = $a();
          $k[$j++] = _1o;
        }
        var _1p = $ctx.C3vals;
        for (var _1u = _1p.size, _1t = _1p.keys(), _1s = 0; _1s < _1u; _1s++) {
          var _1q = _1t.next().value;
          $k[$j++] = _1q;
          $k[$j++] = _1p.get(_1q);
          $k[$j++] = Infinity;
          var _1v = $k[--$j];
          var _1w = $k[--$j];
          $k[$j++] = _1v;
          $k[$j++] = $get($ctx.CNvals, $ctx.sft3);
          $k[$j++] = _1w;
          var _20 = $a();
          $k[$j++] = _20;
        }
        $ctx.Cvals = $d();
        $k[$j++] = Infinity;
        $k[$j++] = $ctx.sft1;
        $k[$j++] = 0;
        $k[$j++] = $ctx.sft2;
        $k[$j++] = 1;
        $k[$j++] = $ctx.sft3;
        $k[$j++] = 2;
        $k[$j++] = 32;
        $k[$j++] = 3;
        for (var _25 = 48; _25 <= 57; _25 += 1) {
          $k[$j++] = _25;
          $k[$j++] = _25 - 44;
        }
        for (var _26 = 97; _26 <= 122; _26 += 1) {
          $k[$j++] = _26;
          $k[$j++] = _26 - 83;
        }
        $ctx.TNvals = $d();
        $k[$j++] = Infinity;
        for (var _28 = 0; _28 <= 31; _28 += 1) {
          $k[$j++] = _28;
          $k[$j++] = _28;
        }
        $ctx.T1vals = $d();
        $k[$j++] = Infinity;
        for (var _2A = 33; _2A <= 47; _2A += 1) {
          $k[$j++] = _2A;
          $k[$j++] = _2A - 33;
        }
        for (var _2B = 58; _2B <= 64; _2B += 1) {
          $k[$j++] = _2B;
          $k[$j++] = _2B - 43;
        }
        for (var _2C = 91; _2C <= 95; _2C += 1) {
          $k[$j++] = _2C;
          $k[$j++] = _2C - 69;
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = 27;
        $k[$j++] = $ctx.fnc2;
        $k[$j++] = 28;
        $k[$j++] = $ctx.fnc3;
        $k[$j++] = 29;
        $k[$j++] = $ctx.fnc4;
        $k[$j++] = 30;
        $k[$j++] = $ctx.pad;
        $k[$j++] = 31;
        $ctx.T2vals = $d();
        $k[$j++] = Infinity;
        $k[$j++] = 96;
        $k[$j++] = 0;
        for (var _2J = 65; _2J <= 90; _2J += 1) {
          $k[$j++] = _2J;
          $k[$j++] = _2J - 64;
        }
        for (var _2K = 123; _2K <= 127; _2K += 1) {
          $k[$j++] = _2K;
          $k[$j++] = _2K - 96;
        }
        $ctx.T3vals = $d();
        $k[$j++] = Infinity;
        var _2M = $ctx.TNvals;
        for (var _2R = _2M.size, _2Q = _2M.keys(), _2P = 0; _2P < _2R; _2P++) {
          var _2N = _2Q.next().value;
          $k[$j++] = _2N;
          $k[$j++] = _2M.get(_2N);
          $k[$j++] = Infinity;
          var _2S = $k[--$j];
          var _2T = $k[--$j];
          $k[$j++] = _2S;
          $k[$j++] = _2T;
          var _2U = $a();
          $k[$j++] = _2U;
        }
        var _2V = $ctx.T1vals;
        for (var _2a = _2V.size, _2Z = _2V.keys(), _2Y = 0; _2Y < _2a; _2Y++) {
          var _2W = _2Z.next().value;
          $k[$j++] = _2W;
          $k[$j++] = _2V.get(_2W);
          $k[$j++] = Infinity;
          var _2b = $k[--$j];
          var _2c = $k[--$j];
          $k[$j++] = _2b;
          $k[$j++] = $get($ctx.TNvals, $ctx.sft1);
          $k[$j++] = _2c;
          var _2g = $a();
          $k[$j++] = _2g;
        }
        var _2h = $ctx.T2vals;
        for (var _2m = _2h.size, _2l = _2h.keys(), _2k = 0; _2k < _2m; _2k++) {
          var _2i = _2l.next().value;
          $k[$j++] = _2i;
          $k[$j++] = _2h.get(_2i);
          $k[$j++] = Infinity;
          var _2n = $k[--$j];
          var _2o = $k[--$j];
          $k[$j++] = _2n;
          $k[$j++] = $get($ctx.TNvals, $ctx.sft2);
          $k[$j++] = _2o;
          var _2s = $a();
          $k[$j++] = _2s;
        }
        var _2t = $ctx.T3vals;
        for (var _2y = _2t.size, _2x = _2t.keys(), _2w = 0; _2w < _2y; _2w++) {
          var _2u = _2x.next().value;
          $k[$j++] = _2u;
          $k[$j++] = _2t.get(_2u);
          $k[$j++] = Infinity;
          var _2z = $k[--$j];
          var _30 = $k[--$j];
          $k[$j++] = _2z;
          $k[$j++] = $get($ctx.TNvals, $ctx.sft3);
          $k[$j++] = _30;
          var _34 = $a();
          $k[$j++] = _34;
        }
        $ctx.Tvals = $d();
        for (var _36 = 128; _36 <= 255; _36 += 1) {
          $ctx.i = _36;
          $k[$j++] = $ctx.Avals;
          $k[$j++] = $ctx.i;
          $k[$j++] = Infinity;
          $aload($get($ctx.Avals, $ctx.fnc4));
          $aload($get($ctx.Avals, $ctx.i - 128));
          var _3F = $a();
          var _3G = $k[--$j];
          $put($k[--$j], _3G, _3F);
          $k[$j++] = $ctx.Cvals;
          $k[$j++] = $ctx.i;
          $k[$j++] = Infinity;
          $aload($get($ctx.Cvals, $ctx.fnc4));
          $aload($get($ctx.Cvals, $ctx.i - 128));
          var _3Q = $a();
          var _3R = $k[--$j];
          $put($k[--$j], _3R, _3Q);
          $k[$j++] = $ctx.Tvals;
          $k[$j++] = $ctx.i;
          $k[$j++] = Infinity;
          $aload($get($ctx.Tvals, $ctx.fnc4));
          $aload($get($ctx.Tvals, $ctx.i - 128));
          var _3b = $a();
          var _3c = $k[--$j];
          $put($k[--$j], _3c, _3b);
        }
        $k[$j++] = Infinity;
        $k[$j++] = 13;
        $k[$j++] = 0;
        $k[$j++] = 42;
        $k[$j++] = 1;
        $k[$j++] = 62;
        $k[$j++] = 2;
        $k[$j++] = 32;
        $k[$j++] = 3;
        for (var _3e = 48; _3e <= 57; _3e += 1) {
          $k[$j++] = _3e;
          $k[$j++] = _3e - 44;
        }
        for (var _3f = 65; _3f <= 90; _3f += 1) {
          $k[$j++] = _3f;
          $k[$j++] = _3f - 51;
        }
        $ctx.Xvals = $d();
        $k[$j++] = Infinity;
        var _3h = $ctx.Xvals;
        for (var _3m = _3h.size, _3l = _3h.keys(), _3k = 0; _3k < _3m; _3k++) {
          var _3i = _3l.next().value;
          $k[$j++] = _3i;
          $k[$j++] = _3h.get(_3i);
          $k[$j++] = Infinity;
          var _3n = $k[--$j];
          var _3o = $k[--$j];
          $k[$j++] = _3n;
          $k[$j++] = _3o;
          var _3p = $a();
          $k[$j++] = _3p;
        }
        $ctx.Xvals = $d();
        $k[$j++] = Infinity;
        for (var _3r = 0; _3r <= 255; _3r += 1) {
          $k[$j++] = _3r;
          $k[$j++] = _3r;
        }
        $ctx.Bvals = $d();
        $k[$j++] = Infinity;
        var _3t = $ctx.Bvals;
        for (var _3y = _3t.size, _3x = _3t.keys(), _3w = 0; _3w < _3y; _3w++) {
          var _3u = _3x.next().value;
          $k[$j++] = _3u;
          $k[$j++] = _3t.get(_3u);
          $k[$j++] = Infinity;
          var _3z = $k[--$j];
          var _40 = $k[--$j];
          $k[$j++] = _3z;
          $k[$j++] = _40;
          var _41 = $a();
          $k[$j++] = _41;
        }
        $ctx.Bvals = $d();
        $ctx.encvals = $a([$ctx.Avals, $ctx.Cvals, $ctx.Tvals, $ctx.Xvals, -1, $ctx.Bvals]);
        $ctx.A = 0;
        $ctx.C = 1;
        $ctx.T = 2;
        $ctx.X = 3;
        $ctx.D = 4;
        $ctx.B = 5;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_codeone.$ctx[id] = $ctx[id]);
        bwipp_codeone.__22920__ = 1;
      })();
    }
    if ($1.stype) {
      $forall($1.barcode, function() {
        var _4C = $k[--$j];
        if (_4C < 48 || _4C > 57) {
          $k[$j++] = "bwipp.codeoneStypeNonDigit#22926";
          $k[$j++] = "S-Type symbols can only contain digits";
          bwipp_raiseerror();
        }
      });
      $1.barlen = $1.barcode.length;
      if ($1.barlen > 18) {
        $k[$j++] = "bwipp.codeoneStypeTooLong#22932";
        $k[$j++] = "Maximum length exceeded";
        bwipp_raiseerror();
      }
      $1.normalize = function() {
        $1.base = $k[--$j];
        $1.num = $k[--$j];
        for (var _4I = $1.num.length - 1; _4I >= 1; _4I -= 1) {
          $1.i = _4I;
          var _4J = $1.num;
          var _4K = $1.i;
          $put(_4J, _4K - 1, $f($get(_4J, _4K - 1) + ~~($get($1.num, $1.i) / $1.base)));
          $put($1.num, $1.i, $get($1.num, $1.i) % $1.base);
        }
        for (; ; ) {
          if ($lt($get($1.num, 0), $1.base)) {
            break;
          }
          $k[$j++] = Infinity;
          $k[$j++] = 0;
          $forall($1.num);
          $1.num = $a();
          $put($1.num, 0, $f($get($1.num, 0) + ~~($get($1.num, 1) / $1.base)));
          $put($1.num, 1, $get($1.num, 1) % $1.base);
        }
        $k[$j++] = Infinity;
        $1.i = true;
        var _4l = $1.num;
        for (var _4m = 0, _4n = _4l.length; _4m < _4n; _4m++) {
          var _4o = $get(_4l, _4m);
          $k[$j++] = _4o;
          if (_4o == 0 && $1.i) {
            $j--;
          } else {
            $1.i = false;
          }
        }
        $1.num = $a();
        if ($1.num.length == 0) {
          $1.num = $a([0]);
        }
        $k[$j++] = $1.num;
      };
      $1.bigadd = function() {
        var _4u = $k[--$j];
        var _4v = $k[--$j];
        $1.offset = Math.abs(_4u.length - _4v.length);
        if (_4u.length < _4v.length) {
          var _ = _4u;
          _4u = _4v;
          _4v = _;
        }
        $1.a = _4u;
        $1.b = _4v;
        for (var _4y = 0, _4x = $1.b.length - 1; _4y <= _4x; _4y += 1) {
          var _4z = $1.a;
          var _50 = $1.offset;
          $put(_4z, _4y + _50, $f($get(_4z, _4y + _50) + $get($1.b, _4y)));
        }
        $k[$j++] = $1.a;
      };
      $1.barlen = $1.barcode.length;
      $1.v = $a([1]);
      for (var _59 = 0, _58 = $1.barlen - 1; _59 <= _58; _59 += 1) {
        $1.i = _59;
        $k[$j++] = Infinity;
        $forall($get($1.stypevals, $1.i), function() {
          var _5D = $k[--$j];
          $k[$j++] = $f(_5D - 48) * $f($get($1.barcode, $1.barlen - $1.i - 1) - 48);
        });
        var _5I = $a();
        $k[$j++] = _5I;
        $k[$j++] = $1.v;
        $1.bigadd();
        $1.v = $k[--$j];
      }
      $k[$j++] = "v";
      $k[$j++] = $1.v;
      $k[$j++] = 2;
      $1.normalize();
      var _5M = $k[--$j];
      $1[$k[--$j]] = _5M;
      $k[$j++] = Infinity;
      for (var _5P = 0, _5Q = (5 - $1.v.length % 5) % 5; _5P < _5Q; _5P++) {
        $k[$j++] = 0;
      }
      $aload($1.v);
      $1.v = $a();
      $1.cws = $a(~~($1.v.length / 5));
      for (var _5X = 0, _5W = $1.cws.length - 1; _5X <= _5W; _5X += 1) {
        $1.i = _5X;
        var _5a = $geti($1.v, $1.i * 5, 5);
        $k[$j++] = 0;
        for (var _5b = 0, _5c = _5a.length; _5b < _5c; _5b++) {
          var _5e = $k[--$j];
          $k[$j++] = $f(_5e + $get(_5a, _5b)) * 2;
        }
        $put($1.cws, $1.i, ~~($k[--$j] / 2));
      }
      $1.metrics = $1.stypemetrics;
    } else {
      var _5n = /* @__PURE__ */ new Map([
        ["parse", $1.parse],
        ["parsefnc", $1.parsefnc],
        ["eci", true],
        ["FNC1", $1.fnc1],
        ["FNC3", $1.fnc3]
      ]);
      $1.fncvals = _5n;
      $k[$j++] = "msg";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.fncvals;
      bwipp_parseinput();
      var _5q = $k[--$j];
      $1[$k[--$j]] = _5q;
      $1.msglen = $1.msg.length;
      $1.eciesc = 92;
      var _5t = $1.msg;
      $k[$j++] = "numecis";
      $k[$j++] = 0;
      for (var _5u = 0, _5v = _5t.length; _5u < _5v; _5u++) {
        if ($get(_5t, _5u) <= -1e6) {
          var _5x = $k[--$j];
          $k[$j++] = $f(_5x + 1);
        }
      }
      var _5y = $k[--$j];
      $1[$k[--$j]] = _5y;
      if ($1.numecis > 0) {
        $1.msgtmp = $a($f($f($1.msg.length * 2 + $1.numecis * 6) + 2));
        $put($1.msgtmp, 0, $1.pad);
        $put($1.msgtmp, 1, $1.eciesc);
        $1.j = 2;
        for (var _6A = 0, _69 = $1.msg.length - 1; _6A <= _69; _6A += 1) {
          var _6C = $get($1.msg, _6A);
          $k[$j++] = _6C;
          if (_6C <= -1e6) {
            var _6G = $geti($cvrs($s(7), -$k[--$j], 10), 1, 6);
            for (var _6H = 0, _6I = _6G.length; _6H < _6I; _6H++) {
              $k[$j++] = $get(_6G, _6H);
            }
            $astore($a(6));
            $puti($1.msgtmp, $1.j + 1, $k[--$j]);
            $put($1.msgtmp, $1.j, $1.eciesc);
            $1.j = $1.j + 7;
          } else {
            var _6S = $k[--$j];
            $k[$j++] = _6S;
            if (_6S != $1.eciesc) {
              $put($1.msgtmp, $1.j, $k[--$j]);
              $1.j = $1.j + 1;
            } else {
              $j--;
              $put($1.msgtmp, $1.j, $1.eciesc);
              $put($1.msgtmp, $1.j + 1, $1.eciesc);
              $1.j = $1.j + 2;
            }
          }
        }
        $1.msg = $geti($1.msgtmp, 0, $1.j);
        $1.msglen = $1.msg.length;
      }
      $1.metrics = $1.nonstypemetrics;
      $1.fullcws = $a([]);
      var _6l = $1.metrics;
      for (var _6m = 0, _6n = _6l.length; _6m < _6n; _6m++) {
        $1.m = $get(_6l, _6m);
        $1.vers = $get($1.m, 0);
        $1.dcws = $get($1.m, 4);
        $1.okay = true;
        if ($eq($1.version, "unset")) {
          if ($1.vers.length != 1) {
            $1.okay = false;
          }
        } else {
          if ($ne($1.version, $1.vers)) {
            $1.okay = false;
          }
        }
        if ($1.okay) {
          $k[$j++] = Infinity;
          $aload($1.fullcws);
          $k[$j++] = $1.dcws;
          $1.fullcws = $a();
        }
      }
      $k[$j++] = Infinity;
      for (var _71 = 0, _72 = 1480; _71 < _72; _71++) {
        $k[$j++] = 1e4;
      }
      $1.numremcws = $a();
      var _74 = $1.fullcws;
      for (var _75 = 0, _76 = _74.length; _75 < _76; _75++) {
        $put($1.numremcws, $f($get(_74, _75) - 1), 1);
      }
      for (var _79 = 1478; _79 >= 0; _79 -= 1) {
        $1.i = _79;
        if ($get($1.numremcws, $1.i) != 1) {
          $put($1.numremcws, $1.i, $f($get($1.numremcws, $1.i + 1) + 1));
        }
      }
      $k[$j++] = Infinity;
      for (var _7J = 0, _7K = $1.msglen; _7J < _7K; _7J++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.numD = $a();
      $k[$j++] = Infinity;
      for (var _7N = 0, _7O = $1.msglen; _7N < _7O; _7N++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 9999;
      $1.nextXterm = $a();
      $k[$j++] = Infinity;
      for (var _7R = 0, _7S = $1.msglen; _7R < _7S; _7R++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 9999;
      $1.nextNonX = $a();
      for (var _7V = $1.msglen - 1; _7V >= 0; _7V -= 1) {
        $1.i = _7V;
        $1.barchar = $get($1.msg, $1.i);
        if ($1.barchar >= 48 && $1.barchar <= 57) {
          $put($1.numD, $1.i, $f($get($1.numD, $1.i + 1) + 1));
        }
        if ($1.barchar == 13 || $1.barchar == 42 || $1.barchar == 62) {
          $put($1.nextXterm, $1.i, 0);
        } else {
          $put($1.nextXterm, $1.i, $f($get($1.nextXterm, $1.i + 1) + 1));
        }
        var _7s = $get($1.Xvals, $1.barchar) !== void 0;
        if (!_7s) {
          $put($1.nextNonX, $1.i, 0);
        } else {
          $put($1.nextNonX, $1.i, $f($get($1.nextNonX, $1.i + 1) + 1));
        }
      }
      $k[$j++] = Infinity;
      var _80 = $1.nextXterm;
      for (var _81 = 0, _82 = _80.length; _81 < _82; _81++) {
        var _83 = $get(_80, _81);
        $k[$j++] = _83;
        if (_83 > 1e4) {
          $j--;
          $k[$j++] = 1e4;
        }
      }
      $1.nextXterm = $a();
      $k[$j++] = Infinity;
      var _85 = $1.nextNonX;
      for (var _86 = 0, _87 = _85.length; _86 < _87; _86++) {
        var _88 = $get(_85, _86);
        $k[$j++] = _88;
        if (_88 > 1e4) {
          $j--;
          $k[$j++] = 1e4;
        }
      }
      $1.nextNonX = $a();
      $1.isD = function() {
        $k[$j++] = $1.char >= 48 && $1.char <= 57;
      };
      $1.isC = function() {
        var _8E = $get($1.CNvals, $1.char) !== void 0;
        $k[$j++] = _8E;
      };
      $1.isT = function() {
        var _8H = $get($1.TNvals, $1.char) !== void 0;
        $k[$j++] = _8H;
      };
      $1.isX = function() {
        var _8K = $get($1.Xvals, $1.char) !== void 0;
        $k[$j++] = _8K;
      };
      $1.isEA = function() {
        $k[$j++] = $1.char > 127;
      };
      $1.isFN = function() {
        $k[$j++] = $1.char < 0;
      };
      $1.XtermFirst = function() {
        var _8N = $k[--$j];
        $k[$j++] = $lt($get($1.nextXterm, _8N), $get($1.nextNonX, _8N));
      };
      $1.lookup = function() {
        $1.ac = 1;
        $1.cc = 2;
        $1.tc = 2;
        $1.xc = 2;
        $1.bc = 3;
        if ($1.mode == $1.A) {
          $1.ac = 0;
          $1.cc = 1;
          $1.tc = 1;
          $1.xc = 1;
          $1.bc = 2;
        }
        if ($1.mode == $1.C) {
          $1.cc = 0;
        }
        if ($1.mode == $1.T) {
          $1.tc = 0;
        }
        if ($1.mode == $1.X) {
          $1.xc = 0;
        }
        if ($1.mode == $1.B) {
          $1.bc = 0;
        }
        for (var _8c = 0, _8d = 1; _8c < _8d; _8c++) {
          $1.k = 0;
          for (; ; ) {
            if ($1.i + $1.k == $1.msglen) {
              var _8l = $a([$1.ac, $1.cc, $1.tc, $1.xc]);
              $k[$j++] = true;
              for (var _8m = 0, _8n = _8l.length; _8m < _8n; _8m++) {
                var _8q = $k[--$j];
                $k[$j++] = _8q && $1.bc <= Math.ceil($get(_8l, _8m));
              }
              if ($k[--$j]) {
                $k[$j++] = $1.B;
                break;
              }
              var _8x = $a([$1.cc, $1.tc, $1.xc, $1.bc]);
              $k[$j++] = true;
              for (var _8y = 0, _8z = _8x.length; _8y < _8z; _8y++) {
                var _92 = $k[--$j];
                $k[$j++] = _92 && $1.ac <= Math.ceil($get(_8x, _8y));
              }
              if ($k[--$j]) {
                $k[$j++] = $1.A;
                break;
              }
              var _97 = $a([$1.tc, $1.xc]);
              $k[$j++] = true;
              for (var _98 = 0, _99 = _97.length; _98 < _99; _98++) {
                var _9C = $k[--$j];
                $k[$j++] = _9C && Math.ceil($1.cc) <= Math.ceil($get(_97, _98));
              }
              if ($k[--$j]) {
                $k[$j++] = $1.C;
                break;
              }
              var _9G = $a([$1.xc]);
              $k[$j++] = true;
              for (var _9H = 0, _9I = _9G.length; _9H < _9I; _9H++) {
                var _9L = $k[--$j];
                $k[$j++] = _9L && Math.ceil($1.tc) <= Math.ceil($get(_9G, _9H));
              }
              if ($k[--$j]) {
                $k[$j++] = $1.T;
                break;
              }
              $k[$j++] = $1.X;
              break;
            }
            $1.char = $get($1.msg, $1.i + $1.k);
            $k[$j++] = "ac";
            $k[$j++] = $1.ac;
            $1.isD();
            if ($k[--$j]) {
              var _9V = $k[--$j];
              $k[$j++] = $f(_9V + 1 / 2);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _9X = $k[--$j];
                $k[$j++] = Math.ceil(_9X) + 2;
              } else {
                var _9Y = $k[--$j];
                $k[$j++] = Math.ceil(_9Y) + 1;
              }
            }
            var _9Z = $k[--$j];
            $1[$k[--$j]] = _9Z;
            $k[$j++] = "cc";
            $k[$j++] = $1.cc;
            $1.isC();
            if ($k[--$j]) {
              var _9d = $k[--$j];
              $k[$j++] = $f(_9d + 0.6666667);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _9f = $k[--$j];
                $k[$j++] = $f(_9f + 2.6666667);
              } else {
                var _9g = $k[--$j];
                $k[$j++] = $f(_9g + 1.3333334);
              }
            }
            var _9h = $k[--$j];
            $1[$k[--$j]] = _9h;
            $k[$j++] = "tc";
            $k[$j++] = $1.tc;
            $1.isT();
            if ($k[--$j]) {
              var _9l = $k[--$j];
              $k[$j++] = $f(_9l + 0.6666667);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _9n = $k[--$j];
                $k[$j++] = $f(_9n + 2.6666667);
              } else {
                var _9o = $k[--$j];
                $k[$j++] = $f(_9o + 1.3333334);
              }
            }
            var _9p = $k[--$j];
            $1[$k[--$j]] = _9p;
            $k[$j++] = "xc";
            $k[$j++] = $1.xc;
            $1.isX();
            if ($k[--$j]) {
              var _9t = $k[--$j];
              $k[$j++] = $f(_9t + 0.6666667);
            } else {
              $1.isEA();
              if ($k[--$j]) {
                var _9v = $k[--$j];
                $k[$j++] = $f(_9v + 4.3333334);
              } else {
                var _9w = $k[--$j];
                $k[$j++] = $f(_9w + 3.3333334);
              }
            }
            var _9x = $k[--$j];
            $1[$k[--$j]] = _9x;
            $k[$j++] = "bc";
            $k[$j++] = $1.bc;
            $1.isFN();
            if ($k[--$j]) {
              var _A1 = $k[--$j];
              $k[$j++] = $f(_A1 + 3);
            } else {
              var _A2 = $k[--$j];
              $k[$j++] = $f(_A2 + 1);
            }
            var _A3 = $k[--$j];
            $1[$k[--$j]] = _A3;
            if ($1.k >= 3) {
              var _AA = $a([$1.ac, $1.cc, $1.tc, $1.xc]);
              $k[$j++] = true;
              for (var _AB = 0, _AC = _AA.length; _AB < _AC; _AB++) {
                var _AF = $k[--$j];
                $k[$j++] = _AF && $1.bc + 1 <= Math.ceil($get(_AA, _AB));
              }
              if ($k[--$j]) {
                $k[$j++] = $1.B;
                break;
              }
              var _AM = $a([$1.cc, $1.tc, $1.xc, $1.bc]);
              $k[$j++] = true;
              for (var _AN = 0, _AO = _AM.length; _AN < _AO; _AN++) {
                var _AR = $k[--$j];
                $k[$j++] = _AR && $1.ac + 1 <= Math.ceil($get(_AM, _AN));
              }
              if ($k[--$j]) {
                $k[$j++] = $1.A;
                break;
              }
              var _AY = $a([$1.ac, $1.cc, $1.xc, $1.bc]);
              $k[$j++] = true;
              for (var _AZ = 0, _Aa = _AY.length; _AZ < _Aa; _AZ++) {
                var _Ad = $k[--$j];
                $k[$j++] = _Ad && Math.ceil($1.tc) + 1 <= Math.ceil($get(_AY, _AZ));
              }
              if ($k[--$j]) {
                $k[$j++] = $1.T;
                break;
              }
              var _Ai = $a([$1.ac, $1.tc]);
              $k[$j++] = true;
              for (var _Aj = 0, _Ak = _Ai.length; _Aj < _Ak; _Aj++) {
                var _An = $k[--$j];
                $k[$j++] = _An && Math.ceil($1.cc) + 1 <= Math.ceil($get(_Ai, _Aj));
              }
              if ($k[--$j]) {
                if (Math.ceil($1.cc) < Math.ceil($1.xc)) {
                  $k[$j++] = $1.C;
                  break;
                }
                if ($1.cc == $1.xc) {
                  $k[$j++] = $1.i + $1.k + 1;
                  $1.XtermFirst();
                  if ($k[--$j]) {
                    $k[$j++] = $1.X;
                    break;
                  } else {
                    $k[$j++] = $1.C;
                    break;
                  }
                }
              }
              var _B3 = $a([$1.ac, $1.cc, $1.tc, $1.bc]);
              $k[$j++] = true;
              for (var _B4 = 0, _B5 = _B3.length; _B4 < _B5; _B4++) {
                var _B8 = $k[--$j];
                $k[$j++] = _B8 && Math.ceil($1.xc) + 1 <= Math.ceil($get(_B3, _B4));
              }
              if ($k[--$j]) {
                $k[$j++] = $1.X;
                break;
              }
            }
            $1.k = $1.k + 1;
          }
        }
      };
      $1.addtocws = function() {
        var _BC = $k[--$j];
        $k[$j++] = _BC;
        if (_BC.length + $1.j > 1480) {
          $j--;
          $k[$j++] = "bwipp.codeoneTooLong#23128";
          $k[$j++] = "Maximum length exceeded";
          bwipp_raiseerror();
        }
        var _BE = $k[--$j];
        $puti($1.cws, $1.j, _BE);
        $1.j = _BE.length + $1.j;
      };
      $1.tobin = function() {
        var _BJ = $s($k[--$j]);
        $k[$j++] = _BJ;
        for (var _BL = 0, _BK = _BJ.length - 1; _BL <= _BK; _BL += 1) {
          var _BM = $k[--$j];
          $put(_BM, _BL, 48);
          $k[$j++] = _BM;
        }
        var _BN = $k[--$j];
        var _BQ = $cvrs($s(_BN.length), $k[--$j], 2);
        $puti(_BN, _BN.length - _BQ.length, _BQ);
        $k[$j++] = _BN;
        $k[$j++] = Infinity;
        var _BR = $k[--$j];
        var _BS = $k[--$j];
        $k[$j++] = _BR;
        $forall(_BS, function() {
          var _BT = $k[--$j];
          $k[$j++] = $f(_BT - 48);
        });
        var _BU = $a();
        $k[$j++] = _BU;
      };
      $1.encA = function() {
        for (var _BV = 0, _BW = 1; _BV < _BW; _BV++) {
          if ($get($1.numD, $1.i) >= 21) {
            $1.Dbits = $a([1, 1, 1, 1]);
            $1.mode = $1.D;
            break;
          }
          var _Be = $get($1.numD, $1.i);
          if (_Be >= 13 && $f(_Be + $1.i) == $1.msglen) {
            $1.Dbits = $a([1, 1, 1, 1]);
            $1.mode = $1.D;
            break;
          }
          if ($get($1.numD, $1.i) >= 2) {
            var _Bm = $s(2);
            $put(_Bm, 0, $get($1.msg, $1.i));
            $put(_Bm, 1, $get($1.msg, $1.i + 1));
            $k[$j++] = $get($1.Avals, _Bm);
            $1.addtocws();
            $1.i = $1.i + 2;
            break;
          }
          if ($get($1.msg, $1.i) == $1.fnc1) {
            if ($get($1.numD, $1.i + 1) >= 15) {
              $k[$j++] = $get($1.Avals, $1.fnc1lD);
              $1.addtocws();
              $1.i = $1.i + 1;
              $1.Dbits = $a([]);
              $1.mode = $1.D;
              break;
            }
            var _CB = $get($1.numD, $1.i + 1);
            if (_CB >= 7 && $f($f(_CB + $1.i) + 1) == $1.msglen) {
              $k[$j++] = $get($1.Avals, $1.fnc1lD);
              $1.addtocws();
              $1.i = $1.i + 1;
              $1.Dbits = $a([]);
              $1.mode = $1.D;
              break;
            }
          }
          $k[$j++] = "newmode";
          $1.lookup();
          var _CK = $k[--$j];
          $1[$k[--$j]] = _CK;
          if ($1.newmode != $1.mode) {
            $k[$j++] = $get($1.Avals, $get($a([-1, $1.lC, $1.lT, $1.lX, $1.lD, $1.lB]), $1.newmode));
            $1.addtocws();
            $1.mode = $1.newmode;
            break;
          }
          $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
          $1.addtocws();
          $1.i = $1.i + 1;
          break;
        }
      };
      $1.CTXvalstocws = function() {
        $1.in = $k[--$j];
        $k[$j++] = Infinity;
        for (var _Ci = 0, _Ch = $1.in.length - 1; _Ci <= _Ch; _Ci += 3) {
          var _Ck = $geti($1.in, _Ci, 3);
          $k[$j++] = 0;
          for (var _Cl = 0, _Cm = _Ck.length; _Cl < _Cm; _Cl++) {
            var _Co = $k[--$j];
            $k[$j++] = $f(_Co + $get(_Ck, _Cl)) * 40;
          }
          var _Cq = ~~($k[--$j] / 40) + 1;
          $k[$j++] = ~~(_Cq / 256);
          $k[$j++] = _Cq % 256;
        }
        $astore($a($counttomark()));
        var _Ct = $k[--$j];
        var _Cu = $k[--$j];
        $k[$j++] = _Ct;
        $k[$j++] = _Cu;
        $j--;
      };
      $1.encCTX = function() {
        $1.p = 0;
        $1.ctxvals = $a(2220);
        for (; ; ) {
          if ($1.i == $1.msglen) {
            break;
          }
          if ($1.p % 3 == 0) {
            if ($get($1.numD, $1.i) >= 12) {
              $k[$j++] = $geti($1.ctxvals, 0, $1.p);
              $1.CTXvalstocws();
              $1.addtocws();
              $k[$j++] = $a([$1.unlcw]);
              $1.addtocws();
              $1.mode = $1.A;
              break;
            }
            var _DA = $get($1.numD, $1.i);
            if (_DA >= 8 && $f(_DA + $1.i) == $1.msglen) {
              $k[$j++] = $geti($1.ctxvals, 0, $1.p);
              $1.CTXvalstocws();
              $1.addtocws();
              $k[$j++] = $a([$1.unlcw]);
              $1.addtocws();
              $1.mode = $1.A;
              break;
            }
            if ($1.mode == $1.X) {
              var _DP = $get($1.Xvals, $get($1.msg, $1.i)) !== void 0;
              if (!_DP) {
                $k[$j++] = $geti($1.ctxvals, 0, $1.p);
                $1.CTXvalstocws();
                $1.addtocws();
                if ($get($1.numremcws, $1.j) != 1 || $get($1.msg, $1.i) > 127) {
                  $k[$j++] = $a([$1.unlcw]);
                  $1.addtocws();
                }
                $1.mode = $1.A;
                break;
              }
              if ($1.i + 1 < $1.msglen) {
                var _Di = $get($1.Xvals, $get($1.msg, $1.i + 1)) !== void 0;
                if (!_Di) {
                  break;
                }
                if ($1.i + 2 < $1.msglen) {
                  var _Dp = $get($1.Xvals, $get($1.msg, $1.i + 2)) !== void 0;
                  if (!_Dp) {
                    break;
                  }
                }
              }
            } else {
              $1.lookup();
              if ($k[--$j] != $1.mode) {
                $k[$j++] = $geti($1.ctxvals, 0, $1.p);
                $1.CTXvalstocws();
                $1.addtocws();
                $k[$j++] = $a([$1.unlcw]);
                $1.addtocws();
                $1.mode = $1.A;
                break;
              }
            }
            if ($1.msglen - $1.i <= 3) {
              $1.remcws = $get($1.numremcws, $1.j + ~~($1.p / 3) * 2);
              $k[$j++] = Infinity;
              var _E8 = $geti($1.msg, $1.i, $1.msglen - $1.i);
              for (var _E9 = 0, _EA = _E8.length; _E9 < _EA; _E9++) {
                var _EB = $get(_E8, _E9);
                var _EF = $get($get($1.encvals, $1.mode), _EB) !== void 0;
                $k[$j++] = _EB;
                if (_EF) {
                  $aload($get($get($1.encvals, $1.mode), $k[--$j]));
                } else {
                  $j--;
                  $k[$j++] = -1;
                  $k[$j++] = -1;
                  $k[$j++] = -1;
                  $k[$j++] = -1;
                }
              }
              $1.remvals = $a();
              if ($1.remcws == 2 && $1.remvals.length == 3) {
                $k[$j++] = Infinity;
                $aload($geti($1.ctxvals, 0, $1.p));
                $aload($1.remvals);
                var _ES = $a();
                $k[$j++] = _ES;
                $1.CTXvalstocws();
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                break;
              }
              if ($1.remcws == 2 && $1.remvals.length == 2 && $1.mode != $1.X) {
                $k[$j++] = Infinity;
                $aload($geti($1.ctxvals, 0, $1.p));
                $aload($1.remvals);
                $aload($get($get($1.encvals, $1.mode), $1.sft1));
                var _Ei = $a();
                $k[$j++] = _Ei;
                $1.CTXvalstocws();
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                break;
              }
              if ($1.remcws == 2 && $1.remvals.length == 1) {
                $k[$j++] = $geti($1.ctxvals, 0, $1.p);
                $1.CTXvalstocws();
                $1.addtocws();
                $k[$j++] = $a([$1.unlcw]);
                $1.addtocws();
                $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                break;
              }
              if ($1.remcws == 1 && $1.remvals.length == 1) {
                $k[$j++] = $geti($1.ctxvals, 0, $1.p);
                $1.CTXvalstocws();
                $1.addtocws();
                $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
                $1.addtocws();
                $1.mode = $1.A;
                $1.i = $1.msglen;
                break;
              }
            }
          }
          var _FH = $get($get($1.encvals, $1.mode), $get($1.msg, $1.i));
          $puti($1.ctxvals, $1.p, _FH);
          $1.p = _FH.length + $1.p;
          $1.i = $1.i + 1;
        }
        if ($1.mode != $1.A) {
          for (; ; ) {
            if ($1.p % 3 == 0) {
              break;
            }
            $1.i = $1.i - 1;
            $1.p = $1.p - $get($get($1.encvals, $1.mode), $get($1.msg, $1.i)).length;
          }
          $k[$j++] = Infinity;
          $aload($geti($1.ctxvals, 0, $1.p));
          var _Fb = $a();
          $k[$j++] = _Fb;
          $1.CTXvalstocws();
          $1.addtocws();
          $k[$j++] = $a([$1.unlcw]);
          $1.addtocws();
          $1.mode = $1.A;
          if ($1.i != $1.msglen) {
            if ($get($1.numD, $1.i) >= 2) {
              var _Fk = $s(2);
              $put(_Fk, 0, $get($1.msg, $1.i));
              $put(_Fk, 1, $get($1.msg, $1.i + 1));
              $k[$j++] = $get($1.Avals, _Fk);
              $1.addtocws();
              $1.i = $1.i + 2;
            } else {
              $k[$j++] = $get($1.Avals, $get($1.msg, $1.i));
              $1.addtocws();
              $1.i = $1.i + 1;
            }
          }
        }
      };
      $1.encD = function() {
        for (; ; ) {
          if ($get($1.numD, $1.i) < 3) {
            $1.Drem = (8 - $1.Dbits.length % 8) % 8;
            $1.remcws = $get($1.numremcws, $1.j + ~~($1.Dbits.length / 8));
            if (($f($get($1.numremcws, $1.j + ~~($1.Dbits.length / 8) - 1) - 1) == 0 && $1.Drem == 0 || $1.remcws == 1 && $1.Drem != 0) && $1.i == $1.msglen) {
              if ($1.Drem == 4 || $1.Drem == 6) {
                $k[$j++] = Infinity;
                $aload($1.Dbits);
                $k[$j++] = 1;
                $k[$j++] = 1;
                $k[$j++] = 1;
                $k[$j++] = 1;
                $1.Dbits = $a();
              }
              if ($1.Drem == 2 || $1.Drem == 6) {
                $k[$j++] = Infinity;
                $aload($1.Dbits);
                $k[$j++] = 0;
                $k[$j++] = 1;
                $1.Dbits = $a();
              }
              break;
            }
            if (($1.i == $1.msglen - 1 && $get($1.numD, $1.i) == 1 || $1.i == $1.msglen - 2 && $get($1.numD, $1.i) == 2) && $1.remcws == 1 && $1.Drem == 0) {
              break;
            }
            if (!($1.i == $1.msglen - 1 && $get($1.numD, $1.i) == 1 && $1.remcws == 1 && ($1.Drem == 4 || $1.Drem == 6))) {
              $k[$j++] = Infinity;
              $aload($1.Dbits);
              $k[$j++] = 1;
              $k[$j++] = 1;
              $k[$j++] = 1;
              $k[$j++] = 1;
              $k[$j++] = 1;
              $k[$j++] = 1;
              $1.Dbits = $a();
              $1.Drem = (8 - $1.Dbits.length % 8) % 8;
            }
            if ($1.Drem == 4 || $1.Drem == 6) {
              if ($get($1.numD, $1.i) >= 1) {
                $k[$j++] = Infinity;
                $aload($1.Dbits);
                $k[$j++] = $f($f($get($1.msg, $1.i) - 48) + 1);
                $k[$j++] = 4;
                $1.tobin();
                $aload($k[--$j]);
                $1.Dbits = $a();
                $1.i = $1.i + 1;
              } else {
                $k[$j++] = Infinity;
                $aload($1.Dbits);
                $k[$j++] = 1;
                $k[$j++] = 1;
                $k[$j++] = 1;
                $k[$j++] = 1;
                $1.Dbits = $a();
              }
              $1.Drem = $1.Drem - 4;
            }
            if ($1.Drem == 2) {
              $k[$j++] = Infinity;
              $aload($1.Dbits);
              $k[$j++] = 0;
              $k[$j++] = 1;
              $1.Dbits = $a();
              $1.Drem = 0;
            }
            break;
          }
          $k[$j++] = Infinity;
          $aload($1.Dbits);
          var _H7 = $geti($1.msg, $1.i, 3);
          $k[$j++] = 0;
          for (var _H8 = 0, _H9 = _H7.length; _H8 < _H9; _H8++) {
            var _HB = $k[--$j];
            $k[$j++] = $f(_HB + $f($get(_H7, _H8) - 48)) * 10;
          }
          var _HC = $k[--$j];
          $k[$j++] = ~~(_HC / 10) + 1;
          $k[$j++] = 10;
          $1.tobin();
          $aload($k[--$j]);
          $1.Dbits = $a();
          $1.i = $1.i + 3;
        }
        $k[$j++] = Infinity;
        for (var _HI = 0, _HH = $1.Dbits.length - 1; _HI <= _HH; _HI += 8) {
          var _HK = $geti($1.Dbits, _HI, 8);
          $k[$j++] = 0;
          for (var _HL = 0, _HM = _HK.length; _HL < _HM; _HL++) {
            var _HO = $k[--$j];
            $k[$j++] = $f(_HO + $get(_HK, _HL)) * 2;
          }
          var _HP = $k[--$j];
          $k[$j++] = ~~(_HP / 2);
        }
        $astore($a($counttomark()));
        var _HS = $k[--$j];
        var _HT = $k[--$j];
        $k[$j++] = _HS;
        $k[$j++] = _HT;
        $j--;
        $1.addtocws();
        $1.mode = $1.A;
      };
      $1.encB = function() {
        $1.p = 0;
        $1.bvals = $a(1480);
        for (; ; ) {
          if ($1.i == $1.msglen) {
            break;
          }
          if ($get($1.msg, $1.i) < 0) {
            break;
          }
          $1.lookup();
          if ($k[--$j] != $1.mode) {
            break;
          }
          $put($1.bvals, $1.p, $get($1.msg, $1.i));
          $1.p = $1.p + 1;
          $1.i = $1.i + 1;
        }
        $1.remcws = $f($get($1.numremcws, $1.j + $1.p) - 1);
        $k[$j++] = Infinity;
        if ($1.remcws == 0 && $1.i == $1.msglen) {
          $k[$j++] = 0;
        } else {
          if ($1.p < 250) {
            $k[$j++] = $1.p;
          } else {
            $k[$j++] = ~~($1.p / 250) + 249;
            $k[$j++] = $1.p % 250;
          }
        }
        $aload($geti($1.bvals, 0, $1.p));
        $1.bvals = $a();
        $k[$j++] = $1.bvals;
        $1.addtocws();
        $1.mode = $1.A;
      };
      $1.cws = $a(1480);
      $1.mode = $1.A;
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i >= $1.msglen) {
          break;
        }
        if ($1[$get($a(["encA", "encCTX", "encCTX", "encCTX", "encD", "encB"]), $1.mode)]() === true) {
          break;
        }
      }
      $1.cws = $geti($1.cws, 0, $1.j);
    }
    var _IC = $1.metrics;
    for (var _ID = 0, _IE = _IC.length; _ID < _IE; _ID++) {
      $1.m = $get(_IC, _ID);
      $1.vers = $get($1.m, 0);
      $1.rows = $get($1.m, 1);
      $1.cols = $get($1.m, 2);
      $1.dcol = $get($1.m, 3);
      $1.dcws = $get($1.m, 4);
      $1.rscw = $get($1.m, 5);
      $1.rsbl = $get($1.m, 6);
      $1.riso = $get($1.m, 7);
      $1.risi = $get($1.m, 8);
      $1.risl = $get($1.m, 9);
      $1.dcpb = ~~($1.dcws / $1.rsbl);
      $1.ecpb = ~~($1.rscw / $1.rsbl);
      $1.okay = true;
      if ($ne($1.version, "unset") && $ne($1.version, $1.vers)) {
        $1.okay = false;
      }
      if ($1.cws.length > $1.dcws) {
        $1.okay = false;
      }
      if ($1.okay) {
        break;
      }
    }
    if (!$1.okay) {
      $k[$j++] = "bwipp.codeoneNoValidSymbol#23444";
      $k[$j++] = "Maximum length exceeded";
      bwipp_raiseerror();
    }
    if (!$1.stype) {
      $k[$j++] = Infinity;
      $aload($1.cws);
      for (var _Ip = 0, _Iq = $f($1.dcws - $1.cws.length); _Ip < _Iq; _Ip++) {
        $k[$j++] = 129;
      }
      $1.cws = $a();
    } else {
      $k[$j++] = Infinity;
      for (var _Iu = 0, _Iv = $f($1.dcws - $1.cws.length); _Iu < _Iv; _Iu++) {
        $k[$j++] = 0;
      }
      $aload($1.cws);
      $1.cws = $a();
    }
    var _Iz = $get($1.options, "debugcws") !== void 0;
    if (_Iz) {
      $k[$j++] = "bwipp.debugcws#23454";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    $1.cwbs = $a($1.rsbl);
    $1.ecbs = $a($1.rsbl);
    for (var _J7 = 0, _J6 = $f($1.rsbl - 1); _J7 <= _J6; _J7 += 1) {
      $1.i = _J7;
      $1.cwb = $a($1.dcpb);
      for (var _JC = 0, _JB = $1.dcpb - 1; _JC <= _JB; _JC += 1) {
        $1.j = _JC;
        $put($1.cwb, $1.j, $get($1.cws, $f($1.j * $1.rsbl + $1.i)));
      }
      $put($1.cwbs, $1.i, $1.cwb);
    }
    var _JO = $1.stype ? 32 : 256;
    $1.gf = _JO;
    $1["gf-1"] = $1.gf - 1;
    var _JR = $1.stype ? 37 : 301;
    $1.pm = _JR;
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _JT = 0, _JU = $1["gf-1"]; _JT < _JU; _JT++) {
      var _JV = $k[--$j];
      var _JW = _JV * 2;
      $k[$j++] = _JV;
      $k[$j++] = _JW;
      if (_JW >= $1.gf) {
        var _JZ = $k[--$j];
        $k[$j++] = _JZ ^ $1.pm;
      }
    }
    $1.rsalog = $a();
    $1.rslog = $a($1.gf);
    for (var _Jf = 1, _Je = $1["gf-1"]; _Jf <= _Je; _Jf += 1) {
      $put($1.rslog, $get($1.rsalog, _Jf), _Jf);
    }
    $1.rsprod = function() {
      var _Jj = $k[--$j];
      var _Jk = $k[--$j];
      $k[$j++] = _Jk;
      $k[$j++] = _Jj;
      if (_Jj != 0 && _Jk != 0) {
        var _Jn = $get($1.rslog, $k[--$j]);
        var _Jt = $get($1.rsalog, $f(_Jn + $get($1.rslog, $k[--$j])) % $1["gf-1"]);
        $k[$j++] = _Jt;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _Jv = 0, _Jw = $1.ecpb; _Jv < _Jw; _Jv++) {
      $k[$j++] = 0;
    }
    $1.coeffs = $a();
    for (var _K0 = 0, _Jz = $1.ecpb - 1; _K0 <= _Jz; _K0 += 1) {
      $1.i = _K0;
      $put($1.coeffs, $1.i + 1, $get($1.coeffs, $1.i));
      for (var _K7 = $1.i; _K7 >= 1; _K7 -= 1) {
        $1.j = _K7;
        $k[$j++] = $1.coeffs;
        $k[$j++] = $1.j;
        $k[$j++] = $get($1.coeffs, $1.j - 1);
        $k[$j++] = $get($1.coeffs, $1.j);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _KJ = $k[--$j];
        var _KK = $k[--$j];
        var _KL = $k[--$j];
        $put($k[--$j], _KL, $xo(_KK, _KJ));
      }
      $k[$j++] = $1.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($1.coeffs, 0);
      $k[$j++] = $get($1.rsalog, $1.i);
      $1.rsprod();
      var _KT = $k[--$j];
      var _KU = $k[--$j];
      $put($k[--$j], _KU, _KT);
    }
    $1.coeffs = $geti($1.coeffs, 0, $1.coeffs.length - 1);
    for (var _Kb = 0, _Ka = $1.cwbs.length - 1; _Kb <= _Ka; _Kb += 1) {
      $1.i = _Kb;
      $k[$j++] = Infinity;
      $aload($get($1.cwbs, $1.i));
      for (var _Kg = 0, _Kh = $1.ecpb; _Kg < _Kh; _Kg++) {
        $k[$j++] = 0;
      }
      $1.rscws = $a();
      for (var _Kl = 0, _Kk = $1.dcpb - 1; _Kl <= _Kk; _Kl += 1) {
        $1.m = _Kl;
        $1.k = $get($1.rscws, $1.m);
        for (var _Kr = 0, _Kq = $1.ecpb - 1; _Kr <= _Kq; _Kr += 1) {
          $1.j = _Kr;
          $k[$j++] = $1.rscws;
          $k[$j++] = $1.m + $1.j + 1;
          $k[$j++] = $get($1.coeffs, $1.ecpb - $1.j - 1);
          $k[$j++] = $1.k;
          $1.rsprod();
          var _L4 = $k[--$j];
          var _L5 = $k[--$j];
          $put($k[--$j], _L5, $xo(_L4, $get($1.rscws, $1.m + $1.j + 1)));
        }
      }
      $put($1.ecbs, $1.i, $geti($1.rscws, $1.dcpb, $1.ecpb));
    }
    $k[$j++] = Infinity;
    $aload($1.cws);
    for (var _LF = 0, _LG = $1.rscw; _LF < _LG; _LF++) {
      $k[$j++] = 0;
    }
    $1.cws = $a();
    for (var _LK = 0, _LJ = $f($1.rscw - 1); _LK <= _LJ; _LK += 1) {
      $1.i = _LK;
      $put($1.cws, $f($1.dcws + $1.i), $get($get($1.ecbs, $1.i % $1.rsbl), ~~($1.i / $1.rsbl)));
    }
    var _LY = $1.stype ? 5 : 8;
    $1.mmat = $a($f($1.dcws + $1.rscw) * _LY);
    $1.r = 0;
    $1.c = 0;
    var _Lb = $1.stype ? 2 : 1;
    for (var _Le = 0, _Lf = _Lb, _Ld = $1.cws.length - 1; _Lf < 0 ? _Le >= _Ld : _Le <= _Ld; _Le += _Lf) {
      $1.i = _Le;
      if (!$1.stype) {
        var _Li = $strcpy($s(8), "00000000");
        var _Ln = $cvrs($s(8), $get($1.cws, $1.i), 2);
        $puti(_Li, 8 - _Ln.length, _Ln);
        $k[$j++] = _Li;
        $k[$j++] = Infinity;
        var _Lo = $k[--$j];
        var _Lp = $k[--$j];
        $k[$j++] = _Lo;
        $forall(_Lp, function() {
          var _Lq = $k[--$j];
          $k[$j++] = $f(_Lq - 48);
        });
        var _Lr = $a();
        $1.top = $geti(_Lr, 0, 4);
        $1.bot = $geti(_Lr, 4, 4);
      } else {
        var _Lv = $strcpy($s(5), "00000");
        var _M0 = $cvrs($s(5), $get($1.cws, $1.i), 2);
        $puti(_Lv, 5 - _M0.length, _M0);
        $k[$j++] = _Lv;
        $k[$j++] = Infinity;
        var _M1 = $k[--$j];
        var _M2 = $k[--$j];
        $k[$j++] = _M1;
        $forall(_M2, function() {
          var _M3 = $k[--$j];
          $k[$j++] = $f(_M3 - 48);
        });
        $1.c1 = $a();
        var _M6 = $strcpy($s(5), "00000");
        var _MB = $cvrs($s(5), $get($1.cws, $1.i + 1), 2);
        $puti(_M6, 5 - _MB.length, _MB);
        $k[$j++] = _M6;
        $k[$j++] = Infinity;
        var _MC = $k[--$j];
        var _MD = $k[--$j];
        $k[$j++] = _MC;
        $forall(_MD, function() {
          var _ME = $k[--$j];
          $k[$j++] = $f(_ME - 48);
        });
        $1.c2 = $a();
        $k[$j++] = Infinity;
        $aload($geti($1.c1, 0, 3));
        $aload($geti($1.c2, 0, 2));
        $1.top = $a();
        $k[$j++] = Infinity;
        $aload($geti($1.c1, 3, 2));
        $aload($geti($1.c2, 2, 3));
        $1.bot = $a();
      }
      $puti($1.mmat, $f($1.r * $1.dcol + $1.c), $1.top);
      $puti($1.mmat, $f(($1.r + 1) * $1.dcol + $1.c), $1.bot);
      $1.c = $1.c + $1.top.length;
      if ($1.c == $1.dcol) {
        $1.c = 0;
        $1.r = $1.r + 2;
      }
    }
    $1.mmv = function() {
      var _Mg = $k[--$j];
      var _Mh = $k[--$j];
      $k[$j++] = $f(_Mh + _Mg * $1.cols);
    };
    $k[$j++] = Infinity;
    for (var _Mk = 0, _Ml = $1.rows * $1.cols; _Mk < _Ml; _Mk++) {
      $k[$j++] = -1;
    }
    $1.pixs = $a();
    var _NH = $a([function() {
      for (var _Mo = 0, _Mp = $1.cols; _Mo < _Mp; _Mo++) {
        $k[$j++] = 0;
      }
    }, function() {
      for (var _Mr = 0, _Ms = $1.cols; _Mr < _Ms; _Mr++) {
        $k[$j++] = 1;
      }
    }, function() {
      $k[$j++] = 0;
      for (var _Mu = 0, _Mv = $f($1.cols - 2); _Mu < _Mv; _Mu++) {
        $k[$j++] = 1;
      }
      $k[$j++] = 0;
    }, function() {
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _Mx = 0, _My = $f($1.cols - 4); _Mx < _My; _Mx++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
    }, function() {
      for (var _N0 = 0, _N1 = ~~($f($1.cols - 1) / 2); _N0 < _N1; _N0++) {
        $k[$j++] = -1;
      }
      $k[$j++] = 1;
      for (var _N3 = 0, _N4 = ~~($f($1.cols - 1) / 2); _N3 < _N4; _N3++) {
        $k[$j++] = -1;
      }
    }, function() {
      for (var _N6 = 0, _N7 = ~~($f($1.cols - 1) / 2); _N6 < _N7; _N6++) {
        $k[$j++] = -1;
      }
      $k[$j++] = 0;
      for (var _N9 = 0, _NA = ~~($f($1.cols - 1) / 2); _N9 < _NA; _N9++) {
        $k[$j++] = -1;
      }
    }, function() {
      $k[$j++] = 1;
      for (var _NC = 0, _ND = $f($1.cols - 2); _NC < _ND; _NC++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
    }, function() {
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _NF = 0, _NG = $f($1.cols - 4); _NF < _NG; _NF++) {
        $k[$j++] = 1;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
    }]);
    $1.artifact = _NH;
    if (!bwipp_codeone.__23573__) {
      (function() {
        var $ctx = Object.create($1);
        var _NI = /* @__PURE__ */ new Map([
          ["A", "121343"],
          ["B", "12134343"],
          ["C", "12121343"],
          ["D", "1213434343"],
          ["E", "1212134343"],
          ["F", "1212121343"],
          ["G", "121213434343"],
          ["H", "121212134343"],
          ["S", "56661278"],
          ["T", "5666666666127878"]
        ]);
        $ctx.cpatmap = _NI;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_codeone.$ctx[id] = $ctx[id]);
        bwipp_codeone.__23573__ = 1;
      })();
    }
    $1.cpat = $get($1.cpatmap, $geti($1.vers, 0, 1));
    $k[$j++] = $1.pixs;
    $k[$j++] = 0;
    $k[$j++] = ~~($f($1.rows - $1.cpat.length) / 2);
    $1.mmv();
    $k[$j++] = Infinity;
    $forall($1.cpat, function() {
      if ($get($1.artifact, $f($k[--$j] - 49))() === true) {
        return true;
      }
    });
    var _NV = $a();
    var _NW = $k[--$j];
    $puti($k[--$j], _NW, _NV);
    for (var _Na = 0, _NZ = $f($1.risl - 1); _Na <= _NZ; _Na += 1) {
      $1.i = _Na;
      for (var _Nf = $1.riso, _Ng = $1.risi, _Ne = $f($1.cols - 1); _Ng < 0 ? _Nf >= _Ne : _Nf <= _Ne; _Nf += _Ng) {
        $1.j = _Nf;
        var _Ni = $1.i % 12 == 0 ? 1 : 0;
        var _Nj = $a([1, _Ni]);
        $k[$j++] = _Nj;
        $k[$j++] = _Nj;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.j;
        $k[$j++] = $1.i;
        $1.mmv();
        var _Nn = $k[--$j];
        var _No = $k[--$j];
        $puti(_No, _Nn, $k[--$j]);
        if ($1.i != $f($1.risl - 1)) {
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($f($1.cols - $1.j) - 2);
          $k[$j++] = $f($f($1.rows - $1.i) - 1);
          $1.mmv();
          var _Nx = $k[--$j];
          var _Ny = $k[--$j];
          $puti(_Ny, _Nx, $k[--$j]);
        } else {
          $j--;
        }
      }
    }
    if (!bwipp_codeone.__23611__) {
      (function() {
        var $ctx = Object.create($1);
        var _Od = /* @__PURE__ */ new Map([
          ["A", $a([$a([12, 5])])],
          ["B", $a([$a([16, 7])])],
          ["C", $a([$a([26, 12])])],
          ["D", $a([])],
          ["E", $a([$a([26, 23])])],
          ["F", $a([$a([26, 32]), $a([70, 32]), $a([26, 34]), $a([70, 34])])],
          ["G", $a([$a([27, 48]), $a([69, 48])])],
          ["H", $a([$a([26, 70]), $a([66, 70]), $a([106, 70]), $a([26, 72]), $a([66, 72]), $a([106, 72])])],
          ["S-10", $a([])],
          ["S-20", $a([$a([10, 4])])],
          ["S-30", $a([$a([15, 4]), $a([15, 6])])],
          ["T-16", $a([$a([8, 10])])],
          ["T-32", $a([$a([16, 10]), $a([16, 12])])],
          ["T-48", $a([$a([24, 10]), $a([24, 12]), $a([24, 14])])]
        ]);
        $ctx.blackdotmap = _Od;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_codeone.$ctx[id] = $ctx[id]);
        bwipp_codeone.__23611__ = 1;
      })();
    }
    $forall($get($1.blackdotmap, $1.vers), function() {
      var _Oj = $k[--$j];
      $k[$j++] = $1.pixs;
      $aload(_Oj);
      $1.mmv();
      var _Ok = $k[--$j];
      $put($k[--$j], _Ok, 1);
    });
    $1.j = 0;
    for (var _Oo = 0, _On = $1.pixs.length - 1; _Oo <= _On; _Oo += 1) {
      $1.i = _Oo;
      if ($get($1.pixs, $1.i) == -1) {
        $put($1.pixs, $1.i, $get($1.mmat, $1.j));
        $1.j = $1.j + 1;
      }
    }
    var _P4 = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.cols],
      ["pixy", $1.rows],
      ["height", $1.rows / 72 * 2],
      ["width", $1.cols / 72 * 2],
      ["opt", $1.options]
    ]);
    $k[$j++] = _P4;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_hanxin() {
    var $1 = Object.create(bwipp_hanxin.$ctx || (bwipp_hanxin.$ctx = {}));
    $1.dontdraw = false;
    $1.version = "unset";
    $1.eclevel = "L2";
    $1.parse = false;
    $1.parsefnc = false;
    $1.mask = -1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($eq($1.barcode, "")) {
      $k[$j++] = "bwipp.hanxinEmptyData#23684";
      $k[$j++] = "The data must not be empty";
      bwipp_raiseerror();
    }
    if ($ne($1.version, "unset")) {
      var _5 = $1.version.length;
      var _6 = _5 >= 1 && _5 <= 2;
      $k[$j++] = _6;
      if (_6) {
        $j--;
        var _7 = $1.version;
        $k[$j++] = true;
        for (var _8 = 0, _9 = _7.length; _8 < _9; _8++) {
          var _A = $get(_7, _8);
          if (_A < 48 || _A > 57) {
            $j--;
            $k[$j++] = false;
          }
        }
        var _B = $k[--$j];
        $k[$j++] = _B;
        if (_B) {
          $j--;
          var _D = $cvi($1.version);
          $k[$j++] = _D >= 1 && _D <= 84;
        }
      }
      if ($nt($k[--$j])) {
        $k[$j++] = "bwipp.hanxinInvalidVersion#23695";
        $k[$j++] = "Valid versions are 1 to 84";
        bwipp_raiseerror();
      }
    }
    var _G = $1.eclevel.length == 2;
    $k[$j++] = _G;
    if (_G) {
      $j--;
      $k[$j++] = $geti($1.eclevel, 0, 1);
      if ($eq("L", "L")) {
        $j--;
        var _L = $get($1.eclevel, 1) - 48;
        $k[$j++] = _L >= 1 && _L <= 4;
      }
    }
    if ($nt($k[--$j])) {
      $k[$j++] = "bwipp.hanxinInvalidErrorCorrectionLevel#23705";
      $k[$j++] = "Valid error correction levels are L1 to L4";
      bwipp_raiseerror();
    }
    if ($1.mask != -1) {
      if ($1.mask < 1 || $1.mask > 4) {
        $k[$j++] = "bwipp.hanxinInvalidErrorCorrectionLevel#23710";
        $k[$j++] = "The valid masks are 1 to 4";
        bwipp_raiseerror();
      }
    }
    var _S = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc]
    ]);
    $1.fncvals = _S;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _V = $k[--$j];
    $1[$k[--$j]] = _V;
    $1.msglen = $1.msg.length;
    $1.tobin = function() {
      var _Z = $s($k[--$j]);
      $k[$j++] = _Z;
      for (var _b = 0, _a = _Z.length - 1; _b <= _a; _b += 1) {
        var _c = $k[--$j];
        $put(_c, _b, 48);
        $k[$j++] = _c;
      }
      var _d = $k[--$j];
      var _g = $cvrs($s(_d.length), $k[--$j], 2);
      $puti(_d, _d.length - _g.length, _g);
      $k[$j++] = _d;
    };
    $1.bits = $s(4 + 13 + $1.msglen * 8);
    $puti($1.bits, 0, "0011");
    $k[$j++] = $1.bits;
    $k[$j++] = 4;
    $k[$j++] = $1.msglen;
    $k[$j++] = 13;
    $1.tobin();
    var _m = $k[--$j];
    var _n = $k[--$j];
    $puti($k[--$j], _n, _m);
    for (var _r = 0, _q = $1.msglen - 1; _r <= _q; _r += 1) {
      $1.i = _r;
      $k[$j++] = $1.bits;
      $k[$j++] = 17 + $1.i * 8;
      $k[$j++] = $get($1.msg, $1.i);
      $k[$j++] = 8;
      $1.tobin();
      var _x = $k[--$j];
      var _y = $k[--$j];
      $puti($k[--$j], _y, _x);
    }
    if (!bwipp_hanxin.__24081__) {
      (function() {
        var $ctx = Object.create($1);
        var _24 = $a([0, -1, -1]);
        $ctx.metrics = $a([$a(["1", 23, -1, 0, 205, $a([1, 21, 4]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 17, 8]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 13, 12]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 9, 16]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["2", 25, -1, 0, 301, $a([1, 31, 6]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 25, 12]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 19, 18]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 15, 22]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["3", 27, -1, 0, 405, $a([1, 42, 8]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 34, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 26, 24]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 20, 30]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["4", 29, 14, 1, 439, $a([1, 46, 8]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 38, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 30, 24]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 22, 32]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["5", 31, 16, 1, 555, $a([1, 57, 12]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 49, 20]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 37, 32]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 14, 20]), $a([1, 13, 22]), $a([0, -1, -1])]), $a(["6", 33, 16, 1, 675, $a([1, 70, 14]), _24, $a([0, -1, -1]), $a([1, 58, 26]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 24, 20]), $a([1, 22, 18]), $a([0, -1, -1]), $a([1, 16, 24]), $a([1, 18, 26]), $a([0, -1, -1])]), $a(["7", 35, 17, 1, 805, $a([1, 84, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 70, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 26, 22]), $a([1, 28, 24]), $a([0, -1, -1]), $a([2, 14, 20]), $a([1, 12, 20]), $a([0, -1, -1])]), $a(["8", 37, 18, 1, 943, $a([1, 99, 18]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 40, 18]), $a([1, 41, 18]), $a([0, -1, -1]), $a([1, 31, 26]), $a([1, 32, 28]), $a([0, -1, -1]), $a([2, 16, 24]), $a([1, 15, 22]), $a([0, -1, -1])]), $a(["9", 39, 19, 1, 1089, $a([1, 114, 22]), $a([0, -1, -1]), $a([0, -1, -1]), $a([2, 48, 20]), $a([0, -1, -1]), $a([0, -1, -1]), $a([2, 24, 20]), $a([1, 26, 22]), $a([0, -1, -1]), $a([2, 18, 28]), $a([1, 18, 26]), $a([0, -1, -1])]), $a(["10", 41, 20, 1, 1243, $a([1, 131, 24]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 52, 22]), $a([1, 57, 24]), $a([0, -1, -1]), $a([2, 27, 24]), $a([1, 29, 24]), $a([0, -1, -1]), $a([2, 21, 32]), $a([1, 19, 30]), $a([0, -1, -1])]), $a(["11", 43, 14, 2, 1289, $a([1, 135, 26]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 56, 24]), $a([1, 57, 24]), $a([0, -1, -1]), $a([2, 28, 24]), $a([1, 31, 26]), $a([0, -1, -1]), $a([2, 22, 32]), $a([1, 21, 32]), $a([0, -1, -1])]), $a(["12", 45, 15, 2, 1455, $a([1, 153, 28]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 62, 26]), $a([1, 65, 28]), $a([0, -1, -1]), $a([2, 32, 28]), $a([1, 33, 28]), $a([0, -1, -1]), $a([3, 17, 26]), $a([1, 22, 30]), $a([0, -1, -1])]), $a(["13", 47, 16, 2, 1629, $a([1, 86, 16]), $a([1, 85, 16]), $a([0, -1, -1]), $a([1, 71, 30]), $a([1, 72, 30]), $a([0, -1, -1]), $a([2, 37, 32]), $a([1, 35, 30]), $a([0, -1, -1]), $a([3, 20, 30]), $a([1, 21, 32]), $a([0, -1, -1])]), $a(["14", 49, 16, 2, 1805, $a([1, 94, 18]), $a([1, 95, 18]), $a([0, -1, -1]), $a([2, 51, 22]), $a([1, 55, 24]), $a([0, -1, -1]), $a([3, 30, 26]), $a([1, 31, 26]), $a([0, -1, -1]), $a([4, 18, 28]), $a([1, 17, 24]), $a([0, -1, -1])]), $a(["15", 51, 17, 2, 1995, $a([1, 104, 20]), $a([1, 105, 20]), $a([0, -1, -1]), $a([2, 57, 24]), $a([1, 61, 26]), $a([0, -1, -1]), $a([3, 33, 28]), $a([1, 36, 30]), $a([0, -1, -1]), $a([4, 20, 30]), $a([1, 19, 30]), $a([0, -1, -1])]), $a(["16", 53, 17, 2, 2187, $a([1, 115, 22]), $a([1, 114, 22]), $a([0, -1, -1]), $a([2, 65, 28]), $a([1, 61, 26]), $a([0, -1, -1]), $a([3, 38, 32]), $a([1, 33, 30]), $a([0, -1, -1]), $a([5, 19, 28]), $a([1, 14, 24]), $a([0, -1, -1])]), $a(["17", 55, 18, 2, 2393, $a([1, 126, 24]), $a([1, 125, 24]), $a([0, -1, -1]), $a([2, 70, 30]), $a([1, 69, 30]), $a([0, -1, -1]), $a([4, 33, 28]), $a([1, 29, 26]), $a([0, -1, -1]), $a([5, 20, 30]), $a([1, 19, 30]), $a([0, -1, -1])]), $a(["18", 57, 19, 2, 2607, $a([1, 136, 26]), $a([1, 137, 26]), $a([0, -1, -1]), $a([3, 56, 24]), $a([1, 59, 26]), $a([0, -1, -1]), $a([5, 35, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([6, 18, 28]), $a([1, 21, 28]), $a([0, -1, -1])]), $a(["19", 59, 20, 2, 2829, $a([1, 148, 28]), $a([1, 149, 28]), $a([0, -1, -1]), $a([3, 61, 26]), $a([1, 64, 28]), $a([0, -1, -1]), $a([7, 24, 20]), $a([1, 23, 22]), $a([0, -1, -1]), $a([6, 20, 30]), $a([1, 21, 32]), $a([0, -1, -1])]), $a(["20", 61, 20, 2, 3053, $a([3, 107, 20]), $a([0, -1, -1]), $a([0, -1, -1]), $a([3, 65, 28]), $a([1, 72, 30]), $a([0, -1, -1]), $a([7, 26, 22]), $a([1, 23, 22]), $a([0, -1, -1]), $a([7, 19, 28]), $a([1, 20, 32]), $a([0, -1, -1])]), $a(["21", 63, 21, 2, 3291, $a([3, 115, 22]), $a([0, -1, -1]), $a([0, -1, -1]), $a([4, 56, 24]), $a([1, 63, 28]), $a([0, -1, -1]), $a([7, 28, 24]), $a([1, 25, 22]), $a([0, -1, -1]), $a([8, 18, 28]), $a([1, 21, 22]), $a([0, -1, -1])]), $a(["22", 65, 16, 3, 3383, $a([2, 116, 22]), $a([1, 122, 24]), $a([0, -1, -1]), $a([4, 56, 24]), $a([1, 72, 30]), $a([0, -1, -1]), $a([7, 28, 24]), $a([1, 32, 26]), $a([0, -1, -1]), $a([8, 18, 28]), $a([1, 24, 30]), $a([0, -1, -1])]), $a(["23", 67, 17, 3, 3631, $a([3, 127, 24]), $a([0, -1, -1]), $a([0, -1, -1]), $a([5, 51, 22]), $a([1, 62, 26]), $a([0, -1, -1]), $a([7, 30, 26]), $a([1, 35, 26]), $a([0, -1, -1]), $a([8, 20, 30]), $a([1, 21, 32]), $a([0, -1, -1])]), $a(["24", 69, 17, 3, 3887, $a([2, 135, 26]), $a([1, 137, 26]), $a([0, -1, -1]), $a([5, 56, 24]), $a([1, 59, 26]), $a([0, -1, -1]), $a([7, 33, 28]), $a([1, 30, 28]), $a([0, -1, -1]), $a([11, 16, 24]), $a([1, 19, 26]), $a([0, -1, -1])]), $a(["25", 71, 18, 3, 4151, $a([3, 105, 20]), $a([1, 121, 22]), $a([0, -1, -1]), $a([5, 61, 26]), $a([1, 57, 26]), $a([0, -1, -1]), $a([9, 28, 24]), $a([1, 28, 22]), $a([0, -1, -1]), $a([10, 19, 28]), $a([1, 18, 30]), $a([0, -1, -1])]), $a(["26", 73, 18, 3, 4423, $a([2, 157, 30]), $a([1, 150, 28]), $a([0, -1, -1]), $a([5, 65, 28]), $a([1, 61, 26]), $a([0, -1, -1]), $a([8, 33, 28]), $a([1, 34, 30]), $a([0, -1, -1]), $a([10, 19, 28]), $a([2, 15, 26]), $a([0, -1, -1])]), $a(["27", 75, 19, 3, 4703, $a([3, 126, 24]), $a([1, 115, 22]), $a([0, -1, -1]), $a([7, 51, 22]), $a([1, 54, 22]), $a([0, -1, -1]), $a([8, 35, 30]), $a([1, 37, 30]), $a([0, -1, -1]), $a([15, 15, 22]), $a([1, 10, 22]), $a([0, -1, -1])]), $a(["28", 77, 19, 3, 4991, $a([4, 105, 20]), $a([1, 103, 20]), $a([0, -1, -1]), $a([7, 56, 24]), $a([1, 45, 18]), $a([0, -1, -1]), $a([10, 31, 26]), $a([1, 27, 26]), $a([0, -1, -1]), $a([10, 17, 26]), $a([3, 20, 28]), $a([1, 21, 28])]), $a(["29", 79, 20, 3, 5287, $a([3, 139, 26]), $a([1, 137, 28]), $a([0, -1, -1]), $a([6, 66, 28]), $a([1, 66, 30]), $a([0, -1, -1]), $a([9, 36, 30]), $a([1, 34, 32]), $a([0, -1, -1]), $a([13, 19, 28]), $a([1, 17, 32]), $a([0, -1, -1])]), $a(["30", 81, 20, 3, 5591, $a([6, 84, 16]), $a([1, 82, 16]), $a([0, -1, -1]), $a([6, 70, 30]), $a([1, 68, 30]), $a([0, -1, -1]), $a([7, 35, 30]), $a([3, 33, 28]), $a([1, 32, 28]), $a([13, 20, 30]), $a([1, 20, 28]), $a([0, -1, -1])]), $a(["31", 83, 21, 3, 5903, $a([5, 105, 20]), $a([1, 94, 18]), $a([0, -1, -1]), $a([6, 74, 32]), $a([1, 71, 30]), $a([0, -1, -1]), $a([11, 33, 28]), $a([1, 34, 32]), $a([0, -1, -1]), $a([13, 19, 28]), $a([3, 16, 26]), $a([0, -1, -1])]), $a(["32", 85, 17, 4, 6033, $a([4, 127, 24]), $a([1, 126, 24]), $a([0, -1, -1]), $a([7, 66, 28]), $a([1, 66, 30]), $a([0, -1, -1]), $a([12, 30, 24]), $a([1, 24, 28]), $a([1, 24, 30]), $a([15, 19, 28]), $a([1, 17, 32]), $a([0, -1, -1])]), $a(["33", 87, 17, 4, 6353, $a([7, 84, 16]), $a([1, 78, 16]), $a([0, -1, -1]), $a([7, 70, 30]), $a([1, 66, 28]), $a([0, -1, -1]), $a([12, 33, 28]), $a([1, 32, 30]), $a([0, -1, -1]), $a([14, 21, 32]), $a([1, 24, 28]), $a([0, -1, -1])]), $a(["34", 89, 18, 4, 6689, $a([5, 117, 22]), $a([1, 117, 24]), $a([0, -1, -1]), $a([8, 66, 28]), $a([1, 58, 26]), $a([0, -1, -1]), $a([11, 38, 32]), $a([1, 34, 32]), $a([0, -1, -1]), $a([15, 20, 30]), $a([2, 17, 26]), $a([0, -1, -1])]), $a(["35", 91, 18, 4, 7025, $a([4, 148, 28]), $a([1, 146, 28]), $a([0, -1, -1]), $a([8, 68, 30]), $a([1, 70, 24]), $a([0, -1, -1]), $a([10, 36, 32]), $a([3, 38, 28]), $a([0, -1, -1]), $a([16, 19, 28]), $a([3, 16, 26]), $a([0, -1, -1])]), $a(["36", 93, 19, 4, 7377, $a([4, 126, 24]), $a([2, 135, 26]), $a([0, -1, -1]), $a([8, 70, 28]), $a([2, 43, 26]), $a([0, -1, -1]), $a([13, 32, 28]), $a([2, 41, 30]), $a([0, -1, -1]), $a([17, 19, 28]), $a([3, 15, 26]), $a([0, -1, -1])]), $a(["37", 95, 19, 4, 7729, $a([5, 136, 26]), $a([1, 132, 24]), $a([0, -1, -1]), $a([5, 67, 30]), $a([4, 68, 28]), $a([1, 69, 28]), $a([14, 35, 30]), $a([1, 32, 24]), $a([0, -1, -1]), $a([18, 18, 26]), $a([3, 16, 28]), $a([1, 14, 28])]), $a(["38", 97, 19, 4, 8089, $a([3, 142, 26]), $a([3, 141, 28]), $a([0, -1, -1]), $a([8, 70, 30]), $a([1, 73, 32]), $a([1, 74, 32]), $a([12, 34, 30]), $a([3, 34, 26]), $a([1, 35, 28]), $a([18, 21, 32]), $a([1, 27, 30]), $a([0, -1, -1])]), $a(["39", 99, 20, 4, 8465, $a([5, 116, 22]), $a([2, 103, 20]), $a([1, 102, 20]), $a([9, 74, 32]), $a([1, 74, 30]), $a([0, -1, -1]), $a([14, 34, 28]), $a([2, 32, 32]), $a([1, 32, 30]), $a([19, 21, 32]), $a([1, 25, 26]), $a([0, -1, -1])]), $a(["40", 101, 20, 4, 8841, $a([7, 116, 22]), $a([1, 117, 22]), $a([0, -1, -1]), $a([11, 65, 28]), $a([1, 58, 24]), $a([0, -1, -1]), $a([15, 38, 32]), $a([1, 27, 28]), $a([0, -1, -1]), $a([20, 20, 30]), $a([1, 20, 32]), $a([1, 21, 32])]), $a(["41", 103, 17, 5, 9009, $a([6, 136, 26]), $a([1, 130, 24]), $a([0, -1, -1]), $a([11, 66, 28]), $a([1, 62, 30]), $a([0, -1, -1]), $a([14, 34, 28]), $a([3, 34, 32]), $a([1, 30, 30]), $a([18, 20, 30]), $a([3, 20, 28]), $a([2, 15, 26])]), $a(["42", 105, 17, 5, 9401, $a([5, 105, 20]), $a([2, 115, 22]), $a([2, 116, 22]), $a([10, 75, 32]), $a([1, 73, 32]), $a([0, -1, -1]), $a([16, 38, 32]), $a([1, 27, 28]), $a([0, -1, -1]), $a([22, 19, 28]), $a([2, 16, 30]), $a([1, 19, 30])]), $a(["43", 107, 18, 5, 9799, $a([6, 147, 28]), $a([1, 146, 28]), $a([0, -1, -1]), $a([11, 66, 28]), $a([2, 65, 30]), $a([0, -1, -1]), $a([18, 33, 28]), $a([2, 33, 30]), $a([0, -1, -1]), $a([22, 21, 32]), $a([1, 28, 30]), $a([0, -1, -1])]), $a(["44", 109, 18, 5, 10207, $a([6, 116, 22]), $a([3, 125, 24]), $a([0, -1, -1]), $a([11, 75, 32]), $a([1, 68, 30]), $a([0, -1, -1]), $a([13, 35, 28]), $a([6, 34, 32]), $a([1, 30, 30]), $a([23, 21, 32]), $a([1, 26, 30]), $a([0, -1, -1])]), $a(["45", 111, 18, 5, 10623, $a([7, 105, 20]), $a([4, 95, 18]), $a([0, -1, -1]), $a([12, 67, 28]), $a([1, 63, 30]), $a([1, 62, 32]), $a([21, 31, 26]), $a([2, 33, 32]), $a([0, -1, -1]), $a([23, 21, 32]), $a([2, 24, 30]), $a([0, -1, -1])]), $a(["46", 113, 19, 5, 11045, $a([10, 116, 22]), $a([0, -1, -1]), $a([0, -1, -1]), $a([12, 74, 32]), $a([1, 78, 30]), $a([0, -1, -1]), $a([18, 37, 32]), $a([1, 39, 30]), $a([1, 41, 28]), $a([25, 21, 32]), $a([1, 27, 28]), $a([0, -1, -1])]), $a(["47", 115, 19, 5, 11477, $a([5, 126, 24]), $a([4, 115, 22]), $a([1, 114, 22]), $a([12, 67, 28]), $a([2, 66, 32]), $a([1, 68, 30]), $a([21, 35, 30]), $a([1, 39, 30]), $a([0, -1, -1]), $a([26, 21, 32]), $a([1, 28, 28]), $a([0, -1, -1])]), $a(["48", 117, 19, 5, 11917, $a([9, 126, 24]), $a([1, 117, 22]), $a([0, -1, -1]), $a([13, 75, 32]), $a([1, 68, 30]), $a([0, -1, -1]), $a([20, 35, 30]), $a([3, 35, 28]), $a([0, -1, -1]), $a([27, 21, 32]), $a([1, 28, 30]), $a([0, -1, -1])]), $a(["49", 119, 17, 6, 12111, $a([9, 126, 24]), $a([1, 137, 26]), $a([0, -1, -1]), $a([13, 71, 30]), $a([2, 68, 32]), $a([0, -1, -1]), $a([20, 37, 32]), $a([1, 39, 28]), $a([1, 38, 28]), $a([24, 20, 32]), $a([5, 25, 28]), $a([0, -1, -1])]), $a(["50", 121, 17, 6, 12559, $a([8, 147, 28]), $a([1, 141, 28]), $a([0, -1, -1]), $a([10, 73, 32]), $a([4, 74, 30]), $a([1, 73, 30]), $a([16, 36, 32]), $a([6, 39, 30]), $a([1, 37, 30]), $a([27, 21, 32]), $a([3, 20, 26]), $a([0, -1, -1])]), $a(["51", 123, 18, 6, 13025, $a([9, 137, 26]), $a([1, 135, 26]), $a([0, -1, -1]), $a([12, 70, 30]), $a([4, 75, 32]), $a([0, -1, -1]), $a([24, 35, 30]), $a([1, 40, 28]), $a([0, -1, -1]), $a([23, 20, 32]), $a([8, 24, 30]), $a([0, -1, -1])]), $a(["52", 125, 18, 6, 13489, $a([14, 95, 18]), $a([1, 86, 18]), $a([0, -1, -1]), $a([13, 73, 32]), $a([3, 77, 30]), $a([0, -1, -1]), $a([24, 35, 30]), $a([2, 35, 28]), $a([0, -1, -1]), $a([26, 21, 32]), $a([5, 21, 30]), $a([1, 23, 30])]), $a(["53", 127, 18, 6, 13961, $a([9, 147, 28]), $a([1, 142, 28]), $a([0, -1, -1]), $a([10, 73, 30]), $a([6, 70, 32]), $a([1, 71, 32]), $a([25, 35, 30]), $a([2, 34, 26]), $a([0, -1, -1]), $a([29, 21, 32]), $a([4, 22, 30]), $a([0, -1, -1])]), $a(["54", 129, 18, 6, 14441, $a([11, 126, 24]), $a([1, 131, 24]), $a([0, -1, -1]), $a([16, 74, 32]), $a([1, 79, 30]), $a([0, -1, -1]), $a([25, 38, 32]), $a([1, 25, 30]), $a([0, -1, -1]), $a([33, 21, 32]), $a([1, 28, 28]), $a([0, -1, -1])]), $a(["55", 131, 19, 6, 14939, $a([14, 105, 20]), $a([1, 99, 18]), $a([0, -1, -1]), $a([19, 65, 28]), $a([1, 72, 28]), $a([0, -1, -1]), $a([24, 37, 32]), $a([2, 40, 30]), $a([1, 41, 30]), $a([31, 21, 32]), $a([4, 24, 32]), $a([0, -1, -1])]), $a(["56", 133, 19, 6, 15435, $a([10, 147, 28]), $a([1, 151, 28]), $a([0, -1, -1]), $a([15, 71, 30]), $a([3, 71, 32]), $a([1, 73, 32]), $a([24, 37, 32]), $a([3, 38, 30]), $a([1, 39, 30]), $a([36, 19, 30]), $a([3, 29, 26]), $a([0, -1, -1])]), $a(["57", 135, 19, 6, 15939, $a([15, 105, 20]), $a([1, 99, 18]), $a([0, -1, -1]), $a([19, 70, 30]), $a([1, 64, 28]), $a([0, -1, -1]), $a([27, 38, 32]), $a([2, 25, 26]), $a([0, -1, -1]), $a([38, 20, 30]), $a([2, 18, 28]), $a([0, -1, -1])]), $a(["58", 137, 17, 7, 16171, $a([14, 105, 20]), $a([1, 113, 22]), $a([1, 114, 22]), $a([17, 67, 30]), $a([3, 92, 32]), $a([0, -1, -1]), $a([30, 35, 30]), $a([1, 41, 30]), $a([0, -1, -1]), $a([36, 21, 32]), $a([1, 26, 30]), $a([1, 27, 30])]), $a(["59", 139, 17, 7, 16691, $a([11, 146, 28]), $a([1, 146, 26]), $a([0, -1, -1]), $a([20, 70, 30]), $a([1, 60, 26]), $a([0, -1, -1]), $a([29, 38, 32]), $a([1, 24, 32]), $a([0, -1, -1]), $a([40, 20, 30]), $a([2, 17, 26]), $a([0, -1, -1])]), $a(["60", 141, 18, 7, 17215, $a([3, 137, 26]), $a([1, 136, 26]), $a([10, 126, 24]), $a([22, 65, 28]), $a([1, 75, 30]), $a([0, -1, -1]), $a([30, 37, 32]), $a([1, 51, 30]), $a([0, -1, -1]), $a([42, 20, 30]), $a([1, 21, 30]), $a([0, -1, -1])]), $a(["61", 143, 18, 7, 17751, $a([12, 126, 24]), $a([2, 118, 22]), $a([1, 116, 22]), $a([19, 74, 32]), $a([1, 74, 30]), $a([1, 72, 28]), $a([30, 38, 32]), $a([2, 29, 30]), $a([0, -1, -1]), $a([39, 20, 32]), $a([2, 37, 26]), $a([1, 38, 26])]), $a(["62", 145, 18, 7, 18295, $a([12, 126, 24]), $a([3, 136, 26]), $a([0, -1, -1]), $a([21, 70, 30]), $a([2, 65, 28]), $a([0, -1, -1]), $a([34, 35, 30]), $a([1, 44, 32]), $a([0, -1, -1]), $a([42, 20, 30]), $a([2, 19, 28]), $a([2, 18, 28])]), $a(["63", 147, 18, 7, 18847, $a([12, 126, 24]), $a([3, 117, 22]), $a([1, 116, 22]), $a([25, 61, 26]), $a([2, 62, 28]), $a([0, -1, -1]), $a([34, 35, 30]), $a([1, 40, 32]), $a([1, 41, 32]), $a([45, 20, 30]), $a([1, 20, 32]), $a([1, 21, 32])]), $a(["64", 149, 19, 7, 19403, $a([15, 105, 20]), $a([2, 115, 22]), $a([2, 116, 22]), $a([25, 65, 28]), $a([1, 72, 28]), $a([0, -1, -1]), $a([18, 35, 30]), $a([17, 37, 32]), $a([1, 50, 32]), $a([42, 20, 30]), $a([6, 19, 28]), $a([1, 15, 28])]), $a(["65", 151, 19, 7, 19971, $a([19, 105, 20]), $a([1, 101, 20]), $a([0, -1, -1]), $a([33, 51, 22]), $a([1, 65, 22]), $a([0, -1, -1]), $a([40, 33, 28]), $a([1, 28, 28]), $a([0, -1, -1]), $a([49, 20, 30]), $a([1, 18, 28]), $a([0, -1, -1])]), $a(["66", 153, 17, 8, 20229, $a([18, 105, 20]), $a([2, 117, 22]), $a([0, -1, -1]), $a([26, 65, 28]), $a([1, 80, 30]), $a([0, -1, -1]), $a([35, 35, 30]), $a([3, 35, 28]), $a([1, 36, 28]), $a([52, 18, 28]), $a([2, 38, 30]), $a([0, -1, -1])]), $a(["67", 155, 17, 8, 20805, $a([26, 84, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([26, 70, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([45, 31, 26]), $a([1, 9, 26]), $a([0, -1, -1]), $a([52, 20, 30]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["68", 157, 17, 8, 21389, $a([16, 126, 24]), $a([1, 114, 22]), $a([1, 115, 22]), $a([23, 70, 30]), $a([3, 65, 28]), $a([1, 66, 28]), $a([40, 35, 30]), $a([1, 43, 30]), $a([0, -1, -1]), $a([46, 20, 30]), $a([7, 19, 28]), $a([1, 16, 28])]), $a(["69", 159, 18, 8, 21993, $a([19, 116, 22]), $a([1, 105, 22]), $a([0, -1, -1]), $a([20, 70, 30]), $a([7, 66, 28]), $a([1, 63, 28]), $a([40, 35, 30]), $a([1, 42, 32]), $a([1, 43, 32]), $a([54, 20, 30]), $a([1, 19, 30]), $a([0, -1, -1])]), $a(["70", 161, 18, 8, 22593, $a([17, 126, 24]), $a([2, 115, 22]), $a([0, -1, -1]), $a([24, 70, 30]), $a([4, 74, 32]), $a([0, -1, -1]), $a([48, 31, 26]), $a([2, 18, 26]), $a([0, -1, -1]), $a([54, 19, 28]), $a([6, 15, 26]), $a([1, 14, 26])]), $a(["71", 163, 18, 8, 23201, $a([29, 84, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([29, 70, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([6, 34, 30]), $a([3, 36, 30]), $a([38, 33, 28]), $a([58, 20, 30]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["72", 165, 18, 8, 23817, $a([16, 147, 28]), $a([1, 149, 28]), $a([0, -1, -1]), $a([31, 66, 28]), $a([1, 37, 26]), $a([0, -1, -1]), $a([48, 33, 28]), $a([1, 23, 26]), $a([0, -1, -1]), $a([53, 20, 30]), $a([6, 19, 28]), $a([1, 17, 28])]), $a(["73", 167, 19, 8, 24453, $a([20, 115, 22]), $a([2, 134, 24]), $a([0, -1, -1]), $a([29, 66, 28]), $a([2, 56, 26]), $a([2, 57, 26]), $a([45, 36, 30]), $a([2, 15, 28]), $a([0, -1, -1]), $a([59, 20, 30]), $a([2, 21, 32]), $a([0, -1, -1])]), $a(["74", 169, 19, 8, 25085, $a([17, 147, 28]), $a([1, 134, 26]), $a([0, -1, -1]), $a([26, 70, 30]), $a([5, 75, 32]), $a([0, -1, -1]), $a([47, 35, 30]), $a([1, 48, 32]), $a([0, -1, -1]), $a([64, 18, 28]), $a([2, 33, 30]), $a([1, 35, 30])]), $a(["75", 171, 17, 9, 25373, $a([22, 115, 22]), $a([1, 133, 24]), $a([0, -1, -1]), $a([33, 65, 28]), $a([1, 74, 28]), $a([0, -1, -1]), $a([43, 36, 30]), $a([5, 27, 28]), $a([1, 30, 28]), $a([57, 20, 30]), $a([5, 21, 32]), $a([1, 24, 32])]), $a(["76", 173, 17, 9, 26021, $a([18, 136, 26]), $a([2, 142, 26]), $a([0, -1, -1]), $a([33, 66, 28]), $a([2, 49, 26]), $a([0, -1, -1]), $a([48, 35, 30]), $a([2, 38, 28]), $a([0, -1, -1]), $a([64, 20, 30]), $a([1, 20, 32]), $a([0, -1, -1])]), $a(["77", 175, 17, 9, 26677, $a([19, 126, 24]), $a([2, 135, 26]), $a([1, 136, 26]), $a([32, 66, 28]), $a([2, 55, 26]), $a([2, 56, 26]), $a([49, 36, 30]), $a([2, 18, 32]), $a([0, -1, -1]), $a([65, 18, 28]), $a([5, 27, 30]), $a([1, 29, 30])]), $a(["78", 177, 18, 9, 27335, $a([20, 137, 26]), $a([1, 130, 26]), $a([0, -1, -1]), $a([30, 75, 32]), $a([2, 71, 32]), $a([0, -1, -1]), $a([46, 35, 30]), $a([6, 39, 32]), $a([0, -1, -1]), $a([3, 12, 30]), $a([70, 19, 28]), $a([0, -1, -1])]), $a(["79", 179, 18, 9, 28007, $a([20, 147, 28]), $a([0, -1, -1]), $a([0, -1, -1]), $a([35, 70, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([49, 35, 30]), $a([5, 35, 28]), $a([0, -1, -1]), $a([70, 20, 30]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["80", 181, 18, 9, 28687, $a([21, 136, 26]), $a([1, 155, 28]), $a([0, -1, -1]), $a([34, 70, 30]), $a([1, 64, 28]), $a([1, 65, 28]), $a([54, 35, 30]), $a([1, 45, 30]), $a([0, -1, -1]), $a([68, 20, 30]), $a([3, 18, 28]), $a([1, 19, 28])]), $a(["81", 183, 18, 9, 29375, $a([19, 126, 24]), $a([5, 115, 22]), $a([1, 114, 22]), $a([33, 70, 30]), $a([3, 65, 28]), $a([1, 64, 28]), $a([52, 35, 30]), $a([3, 41, 32]), $a([1, 40, 32]), $a([67, 20, 30]), $a([5, 21, 32]), $a([1, 24, 32])]), $a(["82", 185, 18, 9, 30071, $a([2, 150, 28]), $a([21, 136, 26]), $a([0, -1, -1]), $a([32, 70, 30]), $a([6, 65, 28]), $a([0, -1, -1]), $a([52, 38, 32]), $a([2, 27, 32]), $a([0, -1, -1]), $a([73, 20, 30]), $a([2, 22, 32]), $a([0, -1, -1])]), $a(["83", 187, 17, 10, 30387, $a([21, 126, 24]), $a([4, 136, 26]), $a([0, -1, -1]), $a([30, 74, 32]), $a([6, 73, 30]), $a([0, -1, -1]), $a([54, 35, 30]), $a([4, 40, 32]), $a([0, -1, -1]), $a([75, 20, 30]), $a([1, 20, 28]), $a([0, -1, -1])]), $a(["84", 189, 17, 10, 31091, $a([30, 105, 20]), $a([1, 114, 22]), $a([0, -1, -1]), $a([3, 45, 22]), $a([55, 47, 20]), $a([0, -1, -1]), $a([2, 26, 26]), $a([62, 33, 28]), $a([0, -1, -1]), $a([79, 18, 28]), $a([4, 33, 30]), $a([0, -1, -1])])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hanxin.$ctx[id] = $ctx[id]);
        bwipp_hanxin.__24081__ = 1;
      })();
    }
    $1.eclval = $get($1.eclevel, 1) - 49;
    var _Ig = $1.metrics;
    for (var _Ih = 0, _Ii = _Ig.length; _Ih < _Ii; _Ih++) {
      $1.m = $get(_Ig, _Ih);
      $1.vers = $get($1.m, 0);
      $1.size = $get($1.m, 1);
      $1.alnk = $get($1.m, 2);
      $1.alnn = $get($1.m, 3);
      $1.alnr = $f($1.size - $1.alnk * $1.alnn);
      $1.nmod = $get($1.m, 4);
      $1.ncws = ~~($1.nmod / 8);
      $1.rbit = $1.nmod % 8;
      $1.ecbs = $geti($1.m, 5 + $1.eclval * 3, 3);
      var _J2 = $1.ecbs;
      $k[$j++] = "ecws";
      $k[$j++] = 0;
      for (var _J3 = 0, _J4 = _J2.length; _J3 < _J4; _J3++) {
        var _J5 = $get(_J2, _J3);
        var _J8 = $k[--$j];
        $k[$j++] = $f(_J8 + $get(_J5, 0) * $get(_J5, 2));
      }
      var _J9 = $k[--$j];
      $1[$k[--$j]] = _J9;
      $1.dcws = $f($1.ncws - $1.ecws);
      $1.dmod = $1.dcws * 8;
      $1.okay = true;
      if ($ne($1.version, "unset") && $ne($1.version, $1.vers)) {
        $1.okay = false;
      }
      if ($1.bits.length > $1.dmod) {
        $1.okay = false;
      }
      if ($1.okay) {
        break;
      }
    }
    if (!$1.okay) {
      $k[$j++] = "bwipp.hanxinNoValidSymbol#24105";
      $k[$j++] = "Maximum length exceeded or invalid content";
      bwipp_raiseerror();
    }
    $1.version = $1.vers;
    $1.msgbits = $1.bits;
    $1.e1nb = $get($get($1.ecbs, 0), 0);
    $1.e2nb = $get($get($1.ecbs, 1), 0);
    $1.e3nb = $get($get($1.ecbs, 2), 0);
    $1.e1dcws = $get($get($1.ecbs, 0), 1);
    $1.e2dcws = $get($get($1.ecbs, 1), 1);
    $1.e3dcws = $get($get($1.ecbs, 2), 1);
    $1.e1ecws = $get($get($1.ecbs, 0), 2);
    $1.e2ecws = $get($get($1.ecbs, 1), 2);
    $1.e3ecws = $get($get($1.ecbs, 2), 2);
    $1.pad = $s($1.dmod);
    for (var _Js = 0, _Jr = $1.pad.length - 1; _Js <= _Jr; _Js += 1) {
      $put($1.pad, _Js, 48);
    }
    $puti($1.pad, 0, $1.msgbits);
    $1.cws = $a($1.dcws);
    for (var _K0 = 0, _Jz = $1.cws.length - 1; _K0 <= _Jz; _K0 += 1) {
      $1.c = _K0;
      $1.cwb = $geti($1.pad, $1.c * 8, 8);
      $1.cw = 0;
      for (var _K4 = 0; _K4 <= 7; _K4 += 1) {
        $1.i = _K4;
        $1.cw = $f($1.cw + ~~Math.pow(2, 8 - $1.i - 1) * $f($get($1.cwb, $1.i) - 48));
      }
      $put($1.cws, $1.c, $1.cw);
    }
    $1.rscodes = function() {
      $1.rspm = $k[--$j];
      $1.rsgf = $k[--$j];
      $1.rsnc = $k[--$j];
      $1.rscws = $k[--$j];
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      for (var _KI = 0, _KJ = $f($1.rsgf - 1); _KI < _KJ; _KI++) {
        var _KK = $k[--$j];
        var _KL = _KK * 2;
        $k[$j++] = _KK;
        $k[$j++] = _KL;
        if (_KL >= $1.rsgf) {
          var _KO = $k[--$j];
          $k[$j++] = $xo(_KO, $1.rspm);
        }
      }
      $1.rsalog = $a();
      $1.rslog = $a($1.rsgf);
      for (var _KU = 1, _KT = $f($1.rsgf - 1); _KU <= _KT; _KU += 1) {
        $put($1.rslog, $get($1.rsalog, _KU), _KU);
      }
      $1.rsprod = function() {
        var _KY = $k[--$j];
        var _KZ = $k[--$j];
        $k[$j++] = _KZ;
        $k[$j++] = _KY;
        if (_KY != 0 && _KZ != 0) {
          var _Kc = $get($1.rslog, $k[--$j]);
          var _Ki = $get($1.rsalog, $f(_Kc + $get($1.rslog, $k[--$j])) % $f($1.rsgf - 1));
          $k[$j++] = _Ki;
        } else {
          $j -= 2;
          $k[$j++] = 0;
        }
      };
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      for (var _Kk = 0, _Kl = $1.rsnc; _Kk < _Kl; _Kk++) {
        $k[$j++] = 0;
      }
      $1.coeffs = $a();
      for (var _Kp = 1, _Ko = $1.rsnc; _Kp <= _Ko; _Kp += 1) {
        $1.i = _Kp;
        $put($1.coeffs, $1.i, $get($1.coeffs, $1.i - 1));
        for (var _Kw = $1.i - 1; _Kw >= 1; _Kw -= 1) {
          $1.j = _Kw;
          $k[$j++] = $1.coeffs;
          $k[$j++] = $1.j;
          $k[$j++] = $get($1.coeffs, $1.j - 1);
          $k[$j++] = $get($1.coeffs, $1.j);
          $k[$j++] = $get($1.rsalog, $1.i);
          $1.rsprod();
          var _L8 = $k[--$j];
          var _L9 = $k[--$j];
          var _LA = $k[--$j];
          $put($k[--$j], _LA, $xo(_L9, _L8));
        }
        $k[$j++] = $1.coeffs;
        $k[$j++] = 0;
        $k[$j++] = $get($1.coeffs, 0);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _LI = $k[--$j];
        var _LJ = $k[--$j];
        $put($k[--$j], _LJ, _LI);
      }
      $1.nd = $1.rscws.length;
      $k[$j++] = Infinity;
      $forall($1.rscws);
      for (var _LO = 0, _LP = $1.rsnc; _LO < _LP; _LO++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $1.rscws = $a();
      for (var _LT = 0, _LS = $1.nd - 1; _LT <= _LS; _LT += 1) {
        $1.k = $xo($get($1.rscws, _LT), $get($1.rscws, $1.nd));
        for (var _Lb = 0, _La = $f($1.rsnc - 1); _Lb <= _La; _Lb += 1) {
          $1.j = _Lb;
          $k[$j++] = $1.rscws;
          $k[$j++] = $1.nd + $1.j;
          $k[$j++] = $get($1.rscws, $1.nd + $1.j + 1);
          $k[$j++] = $1.k;
          $k[$j++] = $get($1.coeffs, $f($f($1.rsnc - $1.j) - 1));
          $1.rsprod();
          var _Lo = $k[--$j];
          var _Lp = $k[--$j];
          var _Lq = $k[--$j];
          $put($k[--$j], _Lq, $xo(_Lp, _Lo));
        }
      }
      $k[$j++] = $geti($1.rscws, 0, $1.rscws.length - 1);
    };
    $1.dcwsb = $a($f($f($1.e1nb + $1.e2nb) + $1.e3nb));
    $1.ecwsb = $a($1.dcwsb.length);
    $1.in = 0;
    $1.out = 0;
    for (var _M2 = 0, _M3 = $1.e1nb; _M2 < _M3; _M2++) {
      $k[$j++] = $geti($1.cws, $1.in, $1.e1dcws);
      $k[$j++] = $1.e1ecws;
      $k[$j++] = 256;
      $k[$j++] = 355;
      $1.rscodes();
      var _M9 = $k[--$j];
      $put($1.dcwsb, $1.out, $geti(_M9, 0, $1.e1dcws));
      $put($1.ecwsb, $1.out, $geti(_M9, $1.e1dcws, $1.e1ecws));
      $1.in = $f($1.in + $1.e1dcws);
      $1.out = $1.out + 1;
    }
    for (var _MN = 0, _MO = $1.e2nb; _MN < _MO; _MN++) {
      $k[$j++] = $geti($1.cws, $1.in, $1.e2dcws);
      $k[$j++] = $1.e2ecws;
      $k[$j++] = 256;
      $k[$j++] = 355;
      $1.rscodes();
      var _MU = $k[--$j];
      $put($1.dcwsb, $1.out, $geti(_MU, 0, $1.e2dcws));
      $put($1.ecwsb, $1.out, $geti(_MU, $1.e2dcws, $1.e2ecws));
      $1.in = $f($1.in + $1.e2dcws);
      $1.out = $1.out + 1;
    }
    for (var _Mi = 0, _Mj = $1.e3nb; _Mi < _Mj; _Mi++) {
      $k[$j++] = $geti($1.cws, $1.in, $1.e3dcws);
      $k[$j++] = $1.e3ecws;
      $k[$j++] = 256;
      $k[$j++] = 355;
      $1.rscodes();
      var _Mp = $k[--$j];
      $put($1.dcwsb, $1.out, $geti(_Mp, 0, $1.e3dcws));
      $put($1.ecwsb, $1.out, $geti(_Mp, $1.e3dcws, $1.e3ecws));
      $1.in = $f($1.in + $1.e3dcws);
      $1.out = $1.out + 1;
    }
    $1.cws = $a($1.ncws);
    $1.cw = 0;
    for (var _N6 = 0, _N5 = $1.dcwsb.length - 1; _N6 <= _N5; _N6 += 1) {
      $1.i = _N6;
      var _N9 = $get($1.dcwsb, $1.i);
      $puti($1.cws, $1.cw, _N9);
      $1.cw = _N9.length + $1.cw;
      var _NF = $get($1.ecwsb, $1.i);
      $puti($1.cws, $1.cw, _NF);
      $1.cw = _NF.length + $1.cw;
    }
    $k[$j++] = Infinity;
    var _NJ = $1.ncws;
    var _NK = 12;
    var _NL = _NJ - 1;
    if (_NJ - 1 > 12) {
      var _ = _NK;
      _NK = _NL;
      _NL = _;
    }
    for (var _NN = 0, _NM = _NL; _NN <= _NM; _NN += 1) {
      for (var _NQ = _NN, _NP = $1.ncws - 1; _NQ <= _NP; _NQ += 13) {
        $k[$j++] = _NQ;
        if (_NQ < $1.ncws) {
          var _NU = $get($1.cws, $k[--$j]);
          $k[$j++] = _NU;
        } else {
          $j--;
        }
      }
    }
    $1.cws = $a();
    if ($1.rbit > 0) {
      $1.pad = $a($1.cws.length + 1);
      $puti($1.pad, 0, $1.cws);
      $put($1.pad, $1.pad.length - 1, 0);
      $1.cws = $1.pad;
    }
    $k[$j++] = Infinity;
    for (var _Ng = 0, _Nh = $1.size * $1.size; _Ng < _Nh; _Ng++) {
      $k[$j++] = -1;
    }
    $1.pixs = $a();
    $1.qmv = function() {
      var _Nk = $k[--$j];
      var _Nl = $k[--$j];
      $k[$j++] = $f(_Nl + _Nk * $1.size);
    };
    if ($1.alnn != 0) {
      $1.trmv = function() {
        var _No = $k[--$j];
        var _Nq = $k[--$j];
        $k[$j++] = $f($f($f(_No * $1.size + $1.size) - 1) - _Nq);
      };
      $1.aplot = function() {
        var _Nr = $k[--$j];
        var _Ns = $k[--$j];
        var _Nt = $k[--$j];
        $k[$j++] = _Nr;
        $k[$j++] = _Nt;
        $k[$j++] = _Ns;
        $k[$j++] = _Nr;
        $k[$j++] = _Ns;
        $k[$j++] = _Nt;
        $1.trmv();
        var _Nv = $k[--$j];
        $put($1.pixs, _Nv, $k[--$j]);
        $1.trmv();
        var _Ny = $k[--$j];
        $put($1.pixs, _Ny, $k[--$j]);
      };
      $1.i = 0;
      $1.stag = 0;
      for (; ; ) {
        if ($1.i >= $1.size) {
          break;
        }
        for (var _O4 = 0, _O3 = $f($1.size - 1); _O4 <= _O3; _O4 += 1) {
          $1.j = _O4;
          if ($f($1.j + $1.alnr) < $1.size) {
            $k[$j++] = (~~($1.j / $1.alnk) + $1.stag) % 2 == 0 && !($1.i == 0 && $1.j < $1.alnk) || $1.j % $1.alnk == 0;
          } else {
            $k[$j++] = $f($1.alnn + $1.stag) % 2 == 0;
          }
          if ($k[--$j]) {
            $k[$j++] = $1.j;
            $k[$j++] = $1.i;
            $k[$j++] = 1;
            $1.aplot();
            var _OL = $1.j;
            var _OM = $1.i;
            $k[$j++] = _OL + 1;
            $k[$j++] = _OM + 1;
            if (_OM + 1 < $1.size && _OL + 1 < $1.size) {
              $k[$j++] = 0;
              $1.aplot();
            } else {
              $j -= 2;
            }
          }
        }
        if ($f($1.i + $1.alnr) == $1.size) {
          $1.i = $f($f($1.i + $1.alnr) - 1);
        } else {
          $1.i = $f($1.i + $1.alnk);
        }
        $1.stag = 1 - $1.stag;
      }
      for (var _Ob = $1.alnk, _Oc = $1.alnk, _Oa = $f($1.size - 2); _Oc < 0 ? _Ob >= _Oa : _Ob <= _Oa; _Ob += _Oc) {
        $1.i = _Ob;
        if (~~($1.i / $1.alnk) % 2 != 0) {
          $k[$j++] = $1.pixs;
          $k[$j++] = 0;
          $k[$j++] = $1.i - 1;
          $1.trmv();
          var _Oh = $k[--$j];
          $put($k[--$j], _Oh, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = 0;
          $k[$j++] = $1.i + 1;
          $1.trmv();
          var _Ol = $k[--$j];
          $put($k[--$j], _Ol, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = 1;
          $k[$j++] = $1.i - 1;
          $1.trmv();
          var _Op = $k[--$j];
          $put($k[--$j], _Op, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = 1;
          $k[$j++] = $1.i;
          $1.trmv();
          var _Ot = $k[--$j];
          $put($k[--$j], _Ot, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = 1;
          $k[$j++] = $1.i + 1;
          $1.trmv();
          var _Ox = $k[--$j];
          $put($k[--$j], _Ox, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i - 1;
          $k[$j++] = 0;
          $1.trmv();
          var _P1 = $k[--$j];
          $put($k[--$j], _P1, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i + 1;
          $k[$j++] = 0;
          $1.trmv();
          var _P5 = $k[--$j];
          $put($k[--$j], _P5, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i - 1;
          $k[$j++] = 1;
          $1.trmv();
          var _P9 = $k[--$j];
          $put($k[--$j], _P9, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i;
          $k[$j++] = 1;
          $1.trmv();
          var _PD = $k[--$j];
          $put($k[--$j], _PD, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i + 1;
          $k[$j++] = 1;
          $1.trmv();
          var _PH = $k[--$j];
          $put($k[--$j], _PH, 0);
        }
        $k[$j++] = $1.pixs;
        $k[$j++] = $f($1.size - 1);
        $k[$j++] = $1.i - 1;
        $1.trmv();
        var _PM = $k[--$j];
        if ($get($k[--$j], _PM) != 1) {
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($1.size - 1);
          $k[$j++] = $1.i - 1;
          $1.trmv();
          var _PS = $k[--$j];
          $put($k[--$j], _PS, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($1.size - 2);
          $k[$j++] = $1.i - 1;
          $1.trmv();
          var _PX = $k[--$j];
          $put($k[--$j], _PX, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($1.size - 2);
          $k[$j++] = $1.i;
          $1.trmv();
          var _Pc = $k[--$j];
          $put($k[--$j], _Pc, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($1.size - 2);
          $k[$j++] = $1.i + 1;
          $1.trmv();
          var _Ph = $k[--$j];
          $put($k[--$j], _Ph, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($1.size - 1);
          $k[$j++] = $1.i + 1;
          $1.trmv();
          var _Pm = $k[--$j];
          $put($k[--$j], _Pm, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i - 1;
          $k[$j++] = $f($1.size - 1);
          $1.trmv();
          var _Pr = $k[--$j];
          $put($k[--$j], _Pr, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i - 1;
          $k[$j++] = $f($1.size - 2);
          $1.trmv();
          var _Pw = $k[--$j];
          $put($k[--$j], _Pw, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i;
          $k[$j++] = $f($1.size - 2);
          $1.trmv();
          var _Q1 = $k[--$j];
          $put($k[--$j], _Q1, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i + 1;
          $k[$j++] = $f($1.size - 2);
          $1.trmv();
          var _Q6 = $k[--$j];
          $put($k[--$j], _Q6, 0);
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i + 1;
          $k[$j++] = $f($1.size - 1);
          $1.trmv();
          var _QB = $k[--$j];
          $put($k[--$j], _QB, 0);
        }
      }
    }
    if (!bwipp_hanxin.__24313__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.fpat = $a([$a([1, 1, 1, 1, 1, 1, 1, 0]), $a([1, 0, 0, 0, 0, 0, 0, 0]), $a([1, 0, 1, 1, 1, 1, 1, 0]), $a([1, 0, 1, 0, 0, 0, 0, 0]), $a([1, 0, 1, 0, 1, 1, 1, 0]), $a([1, 0, 1, 0, 1, 1, 1, 0]), $a([1, 0, 1, 0, 1, 1, 1, 0]), $a([0, 0, 0, 0, 0, 0, 0, 0])]);
        $ctx.fpat2 = $a([$a([1, 1, 1, 0, 1, 0, 1, 0]), $a([1, 1, 1, 0, 1, 0, 1, 0]), $a([1, 1, 1, 0, 1, 0, 1, 0]), $a([0, 0, 0, 0, 1, 0, 1, 0]), $a([1, 1, 1, 1, 1, 0, 1, 0]), $a([0, 0, 0, 0, 0, 0, 1, 0]), $a([1, 1, 1, 1, 1, 1, 1, 0]), $a([0, 0, 0, 0, 0, 0, 0, 0])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hanxin.$ctx[id] = $ctx[id]);
        bwipp_hanxin.__24313__ = 1;
      })();
    }
    for (var _QY = 0, _QX = $1.fpat.length - 1; _QY <= _QX; _QY += 1) {
      $1.y = _QY;
      for (var _Qc = 0, _Qb = $get($1.fpat, 0).length - 1; _Qc <= _Qb; _Qc += 1) {
        $1.x = _Qc;
        $1.fpb = $get($get($1.fpat, $1.y), $1.x);
        $1.fpb2 = $get($get($1.fpat2, $1.y), $1.x);
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $1.qmv();
        var _Qr = $k[--$j];
        $put($k[--$j], _Qr, $1.fpb);
        $k[$j++] = $1.pixs;
        $k[$j++] = $f($f($1.size - $1.x) - 1);
        $k[$j++] = $1.y;
        $1.qmv();
        var _Qy = $k[--$j];
        $put($k[--$j], _Qy, $1.fpb);
        $k[$j++] = $1.pixs;
        $k[$j++] = $f($f($1.size - $1.x) - 1);
        $k[$j++] = $f($f($1.size - $1.y) - 1);
        $1.qmv();
        var _R6 = $k[--$j];
        $put($k[--$j], _R6, $1.fpb);
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.x;
        $k[$j++] = $f($f($1.size - $1.y) - 1);
        $1.qmv();
        var _RD = $k[--$j];
        $put($k[--$j], _RD, $1.fpb2);
      }
    }
    $1.functionmap = $a([$a([$a([0, 8]), $a([$f($1.size - 1), $f($1.size - 9)])]), $a([$a([1, 8]), $a([$f($1.size - 2), $f($1.size - 9)])]), $a([$a([2, 8]), $a([$f($1.size - 3), $f($1.size - 9)])]), $a([$a([3, 8]), $a([$f($1.size - 4), $f($1.size - 9)])]), $a([$a([4, 8]), $a([$f($1.size - 5), $f($1.size - 9)])]), $a([$a([5, 8]), $a([$f($1.size - 6), $f($1.size - 9)])]), $a([$a([6, 8]), $a([$f($1.size - 7), $f($1.size - 9)])]), $a([$a([7, 8]), $a([$f($1.size - 8), $f($1.size - 9)])]), $a([$a([8, 8]), $a([$f($1.size - 9), $f($1.size - 9)])]), $a([$a([8, 7]), $a([$f($1.size - 9), $f($1.size - 8)])]), $a([$a([8, 6]), $a([$f($1.size - 9), $f($1.size - 7)])]), $a([$a([8, 5]), $a([$f($1.size - 9), $f($1.size - 6)])]), $a([$a([8, 4]), $a([$f($1.size - 9), $f($1.size - 5)])]), $a([$a([8, 3]), $a([$f($1.size - 9), $f($1.size - 4)])]), $a([$a([8, 2]), $a([$f($1.size - 9), $f($1.size - 3)])]), $a([$a([8, 1]), $a([$f($1.size - 9), $f($1.size - 2)])]), $a([$a([8, 0]), $a([$f($1.size - 9), $f($1.size - 1)])]), $a([$a([$f($1.size - 9), 0]), $a([8, $f($1.size - 1)])]), $a([$a([$f($1.size - 9), 1]), $a([8, $f($1.size - 2)])]), $a([$a([$f($1.size - 9), 2]), $a([8, $f($1.size - 3)])]), $a([$a([$f($1.size - 9), 3]), $a([8, $f($1.size - 4)])]), $a([$a([$f($1.size - 9), 4]), $a([8, $f($1.size - 5)])]), $a([$a([$f($1.size - 9), 5]), $a([8, $f($1.size - 6)])]), $a([$a([$f($1.size - 9), 6]), $a([8, $f($1.size - 7)])]), $a([$a([$f($1.size - 9), 7]), $a([8, $f($1.size - 8)])]), $a([$a([$f($1.size - 9), 8]), $a([8, $f($1.size - 9)])]), $a([$a([$f($1.size - 8), 8]), $a([7, $f($1.size - 9)])]), $a([$a([$f($1.size - 7), 8]), $a([6, $f($1.size - 9)])]), $a([$a([$f($1.size - 6), 8]), $a([5, $f($1.size - 9)])]), $a([$a([$f($1.size - 5), 8]), $a([4, $f($1.size - 9)])]), $a([$a([$f($1.size - 4), 8]), $a([3, $f($1.size - 9)])]), $a([$a([$f($1.size - 3), 8]), $a([2, $f($1.size - 9)])]), $a([$a([$f($1.size - 2), 8]), $a([1, $f($1.size - 9)])]), $a([$a([$f($1.size - 1), 8]), $a([0, $f($1.size - 9)])])]);
    var _U0 = $1.functionmap;
    for (var _U1 = 0, _U2 = _U0.length; _U1 < _U2; _U1++) {
      $forall($get(_U0, _U1), function() {
        $forall($k[--$j]);
        $1.qmv();
        $put($1.pixs, $k[--$j], 0);
      });
    }
    var _UD = $a([function() {
      $j -= 2;
      $k[$j++] = 1;
    }, function() {
      var _U7 = $k[--$j];
      var _U8 = $k[--$j];
      $k[$j++] = $f(_U8 + _U7) % 2;
    }, function() {
      var _U9 = $k[--$j];
      var _UA = $k[--$j];
      $k[$j++] = $f($f(_U9 + _UA) % 3 + _UA % 3) % 2;
    }, function() {
      var _UB = $k[--$j];
      var _UC = $k[--$j];
      $k[$j++] = $f(_UC % _UB + $f(_UB % _UC + $f(_UB % 3 + _UC % 3))) % 2;
    }]);
    $1.maskfuncs = _UD;
    if ($1.mask != -1) {
      $1.maskfuncs = $a([$get($1.maskfuncs, $1.mask - 1)]);
      $1.bestmaskval = $1.mask - 1;
    }
    $1.masks = $a($1.maskfuncs.length);
    for (var _UO = 0, _UN = $1.masks.length - 1; _UO <= _UN; _UO += 1) {
      $1.m = _UO;
      $1.mask = $a($1.size * $1.size);
      for (var _UU = 0, _UT = $f($1.size - 1); _UU <= _UT; _UU += 1) {
        $1.j = _UU;
        for (var _UX = 0, _UW = $f($1.size - 1); _UX <= _UW; _UX += 1) {
          $1.i = _UX;
          $k[$j++] = $1.i + 1;
          $k[$j++] = $1.j + 1;
          if ($get($1.maskfuncs, $1.m)() === true) {
            break;
          }
          var _Ud = $k[--$j];
          $k[$j++] = _Ud == 0;
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.qmv();
          var _Uh = $k[--$j];
          var _Uj = $get($k[--$j], _Uh);
          var _Uk = $k[--$j];
          var _Ul = _Uk && _Uj == -1 ? 1 : 0;
          $k[$j++] = _Ul;
          $k[$j++] = $1.mask;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.qmv();
          var _Up = $k[--$j];
          var _Uq = $k[--$j];
          $put(_Uq, _Up, $k[--$j]);
        }
      }
      $put($1.masks, $1.m, $1.mask);
    }
    $1.posx = 0;
    $1.posy = 0;
    $1.num = 0;
    for (; ; ) {
      if ($1.posy == $1.size) {
        break;
      }
      $k[$j++] = $1.pixs;
      $k[$j++] = $1.posx;
      $k[$j++] = $1.posy;
      $1.qmv();
      var _V0 = $k[--$j];
      if ($get($k[--$j], _V0) == -1) {
        var _V5 = $get($1.cws, ~~($1.num / 8));
        var _V7 = -(7 - $1.num % 8);
        $k[$j++] = (_V7 < 0 ? _V5 >>> -_V7 : _V5 << _V7) & 1;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.posx;
        $k[$j++] = $1.posy;
        $1.qmv();
        var _VB = $k[--$j];
        var _VC = $k[--$j];
        $put(_VC, _VB, $k[--$j]);
        $1.num = $1.num + 1;
      }
      $1.posx = $1.posx + 1;
      if ($1.posx == $1.size) {
        $1.posx = 0;
        $1.posy = $1.posy + 1;
      }
    }
    $1.evalfulln1n3 = function() {
      $1.scrle = $k[--$j];
      $k[$j++] = "scr1";
      $k[$j++] = 0;
      $forall($1.scrle, function() {
        var _VL = $k[--$j];
        $k[$j++] = _VL;
        if (_VL >= 3) {
          var _VM = $k[--$j];
          var _VO = $f($k[--$j] + _VM * 4);
          $k[$j++] = _VO;
          $k[$j++] = _VO;
        }
        $j--;
      });
      var _VP = $k[--$j];
      $1[$k[--$j]] = _VP;
      $1.scr3 = 0;
      for (var _VT = 5, _VS = $1.scrle.length - 1; _VT <= _VS; _VT += 2) {
        $1.j = _VT;
        if ($get($1.scrle, $1.j) % 3 == 0) {
          $1.fact = ~~($get($1.scrle, $1.j) / 3);
          var _Vc = $geti($1.scrle, $1.j - 4, 4);
          for (var _Vd = 0, _Ve = _Vc.length; _Vd < _Ve; _Vd++) {
            $k[$j++] = $get(_Vc, _Vd) == $1.fact;
          }
          var _Vh = $k[--$j];
          var _Vi = $k[--$j];
          var _Vj = $k[--$j];
          var _Vk = $k[--$j];
          if (_Vk && (_Vj && (_Vi && _Vh))) {
            if ($1.j == 5 || $1.j + 2 >= $1.scrle.length) {
              $1.scr3 = $1.scr3 + 50;
            } else {
              if ($get($1.scrle, $1.j - 5) >= 3 || $get($1.scrle, $1.j + 1) >= 3) {
                $1.scr3 = $1.scr3 + 50;
              }
            }
          }
        }
      }
      for (var _Vy = 1, _Vx = $1.scrle.length - 5; _Vy <= _Vx; _Vy += 2) {
        $1.j = _Vy;
        if ($get($1.scrle, $1.j) % 3 == 0) {
          $1.fact = ~~($get($1.scrle, $1.j) / 3);
          var _W7 = $geti($1.scrle, $1.j + 1, 4);
          for (var _W8 = 0, _W9 = _W7.length; _W8 < _W9; _W8++) {
            $k[$j++] = $get(_W7, _W8) == $1.fact;
          }
          var _WC = $k[--$j];
          var _WD = $k[--$j];
          var _WE = $k[--$j];
          var _WF = $k[--$j];
          if (_WF && (_WE && (_WD && _WC))) {
            if ($1.j == 1 || $1.j + 6 >= $1.scrle.length) {
              $1.scr3 = $1.scr3 + 50;
            } else {
              if ($get($1.scrle, $1.j - 1) >= 3 || $get($1.scrle, $1.j + 5) >= 3) {
                $1.scr3 = $1.scr3 + 50;
              }
            }
          }
        }
      }
      $k[$j++] = $1.scr1;
      $k[$j++] = $1.scr3;
    };
    $1.evalfull = function() {
      $1.sym = $k[--$j];
      $1.n1 = 0;
      $1.n3 = 0;
      $1.rle = $a($f($1.size + 1));
      $1.lastpairs = $a($1.size);
      $1.thispairs = $a($1.size);
      $1.sizeadd1 = $f($1.size + 1);
      for (var _Wd = 0, _Wc = $f($1.size - 1); _Wd <= _Wc; _Wd += 1) {
        $1.i = _Wd;
        $k[$j++] = Infinity;
        var _Wf = $1.size;
        $k[$j++] = 0;
        $k[$j++] = 0;
        for (var _Wh = $1.i, _Wi = _Wf, _Wg = $f(_Wf * _Wf - 1); _Wi < 0 ? _Wh >= _Wg : _Wh <= _Wg; _Wh += _Wi) {
          var _Wk = $get($1.sym, _Wh);
          var _Wl = $k[--$j];
          $k[$j++] = _Wk;
          if ($eq(_Wl, _Wk)) {
            var _Wm = $k[--$j];
            var _Wn = $k[--$j];
            $k[$j++] = $f(_Wn + 1);
            $k[$j++] = _Wm;
          } else {
            var _Wo = $k[--$j];
            $k[$j++] = 1;
            $k[$j++] = _Wo;
          }
        }
        $j--;
        var _Wq = $counttomark() + 2;
        $astore($geti($1.rle, 0, _Wq - 2));
        $1.evalfulln1n3();
        $1.n3 = $f($k[--$j] + $1.n3);
        $1.n1 = $f($k[--$j] + $1.n1);
        $j--;
        $1.symrow = $geti($1.sym, $1.i * $1.size, $1.size);
        $k[$j++] = Infinity;
        var _X1 = $1.symrow;
        $k[$j++] = 0;
        $k[$j++] = 0;
        for (var _X2 = 0, _X3 = _X1.length; _X2 < _X3; _X2++) {
          var _X4 = $get(_X1, _X2);
          var _X5 = $k[--$j];
          $k[$j++] = _X4;
          if ($eq(_X5, _X4)) {
            var _X6 = $k[--$j];
            var _X7 = $k[--$j];
            $k[$j++] = $f(_X7 + 1);
            $k[$j++] = _X6;
          } else {
            var _X8 = $k[--$j];
            $k[$j++] = 1;
            $k[$j++] = _X8;
          }
        }
        $j--;
        var _XA = $counttomark() + 2;
        $astore($geti($1.rle, 0, _XA - 2));
        $1.evalfulln1n3();
        $1.n3 = $f($k[--$j] + $1.n3);
        $1.n1 = $f($k[--$j] + $1.n1);
        $j--;
      }
      $k[$j++] = $f($1.n1 + $1.n3);
    };
    $1.bestscore = 999999999;
    for (var _XK = 0, _XJ = $1.masks.length - 1; _XK <= _XJ; _XK += 1) {
      $1.m = _XK;
      $1.masksym = $a($1.size * $1.size);
      for (var _XR = 0, _XQ = $f($1.size * $1.size - 1); _XR <= _XQ; _XR += 1) {
        $1.i = _XR;
        $put($1.masksym, $1.i, $xo($get($1.pixs, $1.i), $get($get($1.masks, $1.m), $1.i)));
      }
      if ($1.masks.length != 1) {
        $k[$j++] = $1.masksym;
        $1.evalfull();
        $1.score = $k[--$j];
        if ($1.score < $1.bestscore) {
          $1.bestsym = $1.masksym;
          $1.bestmaskval = $1.m;
          $1.bestscore = $1.score;
        }
      } else {
        $1.bestsym = $1.masksym;
      }
    }
    $1.pixs = $1.bestsym;
    $1.funval = ((~~($f($1.size - 21) / 2) + 20) * 4 + $1.eclval) * 4 + $1.bestmaskval;
    $k[$j++] = $a([($1.funval & 3840) >>> 8, ($1.funval & 240) >>> 4, $1.funval & 15]);
    $k[$j++] = 4;
    $k[$j++] = 16;
    $k[$j++] = 19;
    $1.rscodes();
    $1.funvals = $k[--$j];
    $k[$j++] = Infinity;
    $forall($1.funvals, function() {
      $k[$j++] = 4;
      $1.tobin();
      $forall($k[--$j], function() {
        var _Xw = $k[--$j];
        $k[$j++] = $f(_Xw - 48);
      });
    });
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $1.funbits = $a();
    for (var _Y0 = 0, _Xz = $1.functionmap.length - 1; _Y0 <= _Xz; _Y0 += 1) {
      $1.i = _Y0;
      $forall($get($1.functionmap, $1.i), function() {
        var _Y5 = $k[--$j];
        $k[$j++] = $1.pixs;
        $aload(_Y5);
        $1.qmv();
        var _Y9 = $k[--$j];
        $put($k[--$j], _Y9, $get($1.funbits, $1.i));
      });
    }
    var _YH = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.size],
      ["pixy", $1.size],
      ["height", $1.size * 2 / 72],
      ["width", $1.size * 2 / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _YH;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_dotcode() {
    var $1 = Object.create(bwipp_dotcode.$ctx || (bwipp_dotcode.$ctx = {}));
    $1.dontdraw = false;
    $1.rows = -1;
    $1.columns = -1;
    $1.ratio = -1;
    $1.parse = false;
    $1.parsefnc = false;
    $1.raw = false;
    $1.fast = false;
    $1.mask = -1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.rows != -1) {
      if ($1.rows < 5) {
        $k[$j++] = "bwipp.dotcodeBadRows#24578";
        $k[$j++] = "There must be at least 5 rows";
        bwipp_raiseerror();
      }
    }
    if ($1.columns != -1) {
      if ($1.columns < 5) {
        $k[$j++] = "bwipp.dotcodeBadColumns#24584";
        $k[$j++] = "There must be at least 5 columns";
        bwipp_raiseerror();
      }
    }
    if ($1.rows != -1 && $1.columns != -1 && ($1.rows + $1.columns) % 2 != 1) {
      $k[$j++] = "bwipp.dotcodeRowsColumnsBadParity#24589";
      $k[$j++] = "Sum of rows and columns must be odd";
      bwipp_raiseerror();
    }
    if ($1.ratio == -1 && $1.rows == -1 && $1.columns == -1) {
      $1.ratio = 3 / 2;
    }
    if ($1.ratio != -1) {
      if ($1.ratio <= 0) {
        $k[$j++] = "bwipp.dotcodeRatio#24598";
        $k[$j++] = "The ratio must be greater than 0";
        bwipp_raiseerror();
      }
    }
    if ($1.mask != -1) {
      if ($1.mask < 0 || $1.mask > 3) {
        $k[$j++] = "bwipp.dotcodeBadMask#24604";
        $k[$j++] = "Valid mask values are 0 to 3";
        bwipp_raiseerror();
      }
    }
    if (!bwipp_dotcode.__24621__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.laa = -1;
        $ctx.lab = -2;
        $ctx.lac = -3;
        $ctx.bin = -4;
        $ctx.sfa = -5;
        $ctx.sfb = -6;
        $ctx.sb2 = -7;
        $ctx.sb3 = -8;
        $ctx.sb4 = -9;
        $ctx.sb5 = -10;
        $ctx.sb6 = -11;
        $ctx.sfc = -12;
        $ctx.sc2 = -13;
        $ctx.sc3 = -14;
        $ctx.sc4 = -15;
        $ctx.sc5 = -16;
        $ctx.sc6 = -17;
        $ctx.sc7 = -18;
        $ctx.bsa = -19;
        $ctx.bsb = -20;
        $ctx.tma = -21;
        $ctx.tmb = -22;
        $ctx.tmc = -23;
        $ctx.tms = -24;
        $ctx.fn1 = -25;
        $ctx.fn2 = -26;
        $ctx.fn3 = -27;
        $ctx.crl = -28;
        $ctx.aim = -29;
        $ctx.m05 = -30;
        $ctx.m06 = -31;
        $ctx.m12 = -32;
        $ctx.mac = -33;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_dotcode.$ctx[id] = $ctx[id]);
        bwipp_dotcode.__24621__ = 1;
      })();
    }
    var _N = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["eci", true],
      ["FNC1", $1.fn1],
      ["FNC3", $1.fn3]
    ]);
    $1.fncvals = _N;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _Q = $k[--$j];
    $1[$k[--$j]] = _Q;
    $1.msglen = $1.msg.length;
    var _T = $1.msg;
    $k[$j++] = "numecis";
    $k[$j++] = 0;
    for (var _U = 0, _V = _T.length; _U < _V; _U++) {
      if ($get(_T, _U) <= -1e6) {
        var _X = $k[--$j];
        $k[$j++] = $f(_X + 1);
      }
    }
    var _Y = $k[--$j];
    $1[$k[--$j]] = _Y;
    $1.msgtmp = $a($f($1.msg.length + $1.numecis * 6));
    $1.j = 0;
    for (var _f = 0, _e = $1.msg.length - 1; _f <= _e; _f += 1) {
      var _h = $get($1.msg, _f);
      $k[$j++] = _h;
      if (_h <= -1e6) {
        var _l = $geti($cvrs($s(7), -$k[--$j], 10), 1, 6);
        for (var _m = 0, _n = _l.length; _m < _n; _m++) {
          $k[$j++] = $get(_l, _m);
        }
        $astore($a(6));
        $puti($1.msgtmp, $1.j + 1, $k[--$j]);
        $put($1.msgtmp, $1.j, $1.fn2);
        $1.j = $1.j + 7;
      } else {
        $put($1.msgtmp, $1.j, $k[--$j]);
        $1.j = $1.j + 1;
      }
    }
    $1.msg = $1.msgtmp;
    $1.msglen = $1.msg.length;
    if (!bwipp_dotcode.__24720__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.charmaps = $a([$a([32, 32, "00"]), $a(["!", "!", "01"]), $a(['"', '"', "02"]), $a(["#", "#", "03"]), $a(["$", "$", "04"]), $a(["%", "%", "05"]), $a(["&", "&", "06"]), $a(["'", "'", "07"]), $a([40, 40, "08"]), $a([41, 41, "09"]), $a(["*", "*", "10"]), $a(["+", "+", "11"]), $a([",", ",", "12"]), $a(["-", "-", "13"]), $a([".", ".", "14"]), $a(["/", "/", "15"]), $a(["0", "0", "16"]), $a(["1", "1", "17"]), $a(["2", "2", "18"]), $a(["3", "3", "19"]), $a(["4", "4", "20"]), $a(["5", "5", "21"]), $a(["6", "6", "22"]), $a(["7", "7", "23"]), $a(["8", "8", "24"]), $a(["9", "9", "25"]), $a([":", ":", "26"]), $a([";", ";", "27"]), $a(["<", "<", "28"]), $a(["=", "=", "29"]), $a([">", ">", "30"]), $a(["?", "?", "31"]), $a(["@", "@", "32"]), $a(["A", "A", "33"]), $a(["B", "B", "34"]), $a(["C", "C", "35"]), $a(["D", "D", "36"]), $a(["E", "E", "37"]), $a(["F", "F", "38"]), $a(["G", "G", "39"]), $a(["H", "H", "40"]), $a(["I", "I", "41"]), $a(["J", "J", "42"]), $a(["K", "K", "43"]), $a(["L", "L", "44"]), $a(["M", "M", "45"]), $a(["N", "N", "46"]), $a(["O", "O", "47"]), $a(["P", "P", "48"]), $a(["Q", "Q", "49"]), $a(["R", "R", "50"]), $a(["S", "S", "51"]), $a(["T", "T", "52"]), $a(["U", "U", "53"]), $a(["V", "V", "54"]), $a(["W", "W", "55"]), $a(["X", "X", "56"]), $a(["Y", "Y", "57"]), $a(["Z", "Z", "58"]), $a(["[", "[", "59"]), $a([92, 92, "60"]), $a(["]", "]", "61"]), $a(["^", "^", "62"]), $a(["_", "_", "63"]), $a([0, "`", "64"]), $a([1, "a", "65"]), $a([2, "b", "66"]), $a([3, "c", "67"]), $a([4, "d", "68"]), $a([5, "e", "69"]), $a([6, "f", "70"]), $a([7, "g", "71"]), $a([8, "h", "72"]), $a([9, "i", "73"]), $a([10, "j", "74"]), $a([11, "k", "75"]), $a([12, "l", "76"]), $a([13, "m", "77"]), $a([14, "n", "78"]), $a([15, "o", "79"]), $a([16, "p", "80"]), $a([17, "q", "81"]), $a([18, "r", "82"]), $a([19, "s", "83"]), $a([20, "t", "84"]), $a([21, "u", "85"]), $a([22, "v", "86"]), $a([23, "w", "87"]), $a([24, "x", "88"]), $a([25, "y", "89"]), $a([26, "z", "90"]), $a([27, "{", "91"]), $a([28, "|", "92"]), $a([29, "}", "93"]), $a([30, "~", "94"]), $a([31, 127, "95"]), $a([$ctx.sfb, $ctx.crl, "96"]), $a([$ctx.sb2, 9, "97"]), $a([$ctx.sb3, 28, "98"]), $a([$ctx.sb4, 29, "99"]), $a([$ctx.sb5, 30, $ctx.aim]), $a([$ctx.sb6, $ctx.sfa, $ctx.laa]), $a([$ctx.lab, $ctx.laa, $ctx.sfb]), $a([$ctx.sc2, $ctx.sc2, $ctx.sb2]), $a([$ctx.sc3, $ctx.sc3, $ctx.sb3]), $a([$ctx.sc4, $ctx.sc4, $ctx.sb4]), $a([$ctx.lac, $ctx.lac, $ctx.lab]), $a([$ctx.fn1, $ctx.fn1, $ctx.fn1]), $a([$ctx.fn2, $ctx.fn2, $ctx.fn2]), $a([$ctx.fn3, $ctx.fn3, $ctx.fn3]), $a([$ctx.bsa, $ctx.bsa, $ctx.bsa]), $a([$ctx.bsb, $ctx.bsb, $ctx.bsb]), $a([$ctx.bin, $ctx.bin, $ctx.bin])]);
        $ctx.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
        for (var _3d = 0, _3c = $ctx.charmaps.length - 1; _3d <= _3c; _3d += 1) {
          $ctx.i = _3d;
          $ctx.encs = $get($ctx.charmaps, $ctx.i);
          for (var _3h = 0; _3h <= 2; _3h += 1) {
            $ctx.j = _3h;
            var _3k = $get($ctx.encs, $ctx.j);
            $k[$j++] = _3k;
            if ($eq($type(_3k), "stringtype")) {
              var _3n = $get($k[--$j], 0);
              $k[$j++] = _3n;
            }
            $put($get($ctx.charvals, $ctx.j), $k[--$j], $ctx.i);
          }
        }
        $ctx.Avals = $get($ctx.charvals, 0);
        $ctx.Bvals = $get($ctx.charvals, 1);
        $put($ctx.Bvals, $ctx.m05, 97);
        $put($ctx.Bvals, $ctx.m06, 98);
        $put($ctx.Bvals, $ctx.m12, 99);
        $put($ctx.Bvals, $ctx.mac, 100);
        $ctx.Cvals = $get($ctx.charvals, 2);
        $k[$j++] = Infinity;
        var _4H = $a([$ctx.sc2, $ctx.sc3, $ctx.sc4, $ctx.sc5, $ctx.sc6, $ctx.sc7, $ctx.tma, $ctx.tmb, $ctx.tmc, $ctx.tms]);
        $k[$j++] = 102;
        for (var _4I = 0, _4J = _4H.length; _4I < _4J; _4I++) {
          var _4M = $f($k[--$j] + 1);
          $k[$j++] = $get(_4H, _4I);
          $k[$j++] = _4M;
          $k[$j++] = _4M;
        }
        $j--;
        $ctx.BINvals = $d();
        $ctx.A = 0;
        $ctx.B = 1;
        $ctx.C = 2;
        $ctx.BIN = 3;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_dotcode.$ctx[id] = $ctx[id]);
        bwipp_dotcode.__24720__ = 1;
      })();
    }
    $k[$j++] = Infinity;
    for (var _4Q = 0, _4R = $1.msglen + 1; _4Q < _4R; _4Q++) {
      $k[$j++] = 0;
    }
    $1.nDigits = $a();
    $k[$j++] = Infinity;
    for (var _4U = 0, _4V = $1.msglen + 1; _4U < _4V; _4U++) {
      $k[$j++] = false;
    }
    $1.SeventeenTen = $a();
    $k[$j++] = Infinity;
    for (var _4Y = 0, _4Z = $1.msglen + 1; _4Y < _4Z; _4Y++) {
      $k[$j++] = false;
    }
    $1.ECI = $a();
    $k[$j++] = Infinity;
    for (var _4c = 0, _4d = $1.msglen + 1; _4c < _4d; _4c++) {
      $k[$j++] = false;
    }
    $1.DatumA = $a();
    $k[$j++] = Infinity;
    for (var _4g = 0, _4h = $1.msglen + 1; _4g < _4h; _4g++) {
      $k[$j++] = false;
    }
    $1.DatumB = $a();
    $k[$j++] = Infinity;
    for (var _4k = 0, _4l = $1.msglen + 1; _4k < _4l; _4k++) {
      $k[$j++] = false;
    }
    $1.DatumC = $a();
    $k[$j++] = Infinity;
    for (var _4o = 0, _4p = $1.msglen + 8; _4o < _4p; _4o++) {
      $k[$j++] = false;
    }
    $1.Binary = $a();
    $k[$j++] = Infinity;
    for (var _4s = 0, _4t = $1.msglen + 1; _4s < _4t; _4s++) {
      $k[$j++] = 0;
    }
    $1.AheadC = $a();
    $k[$j++] = Infinity;
    for (var _4w = 0, _4x = $1.msglen + 1; _4w < _4x; _4w++) {
      $k[$j++] = 0;
    }
    $1.TryC = $a();
    $k[$j++] = Infinity;
    for (var _50 = 0, _51 = $1.msglen + 1; _50 < _51; _50++) {
      $k[$j++] = 0;
    }
    $1.AheadA = $a();
    $k[$j++] = Infinity;
    for (var _54 = 0, _55 = $1.msglen + 1; _54 < _55; _54++) {
      $k[$j++] = 0;
    }
    $1.AheadB = $a();
    $k[$j++] = Infinity;
    for (var _58 = 0, _59 = $1.msglen + 1; _58 < _59; _58++) {
      $k[$j++] = 0;
    }
    $1.UntilEndSeg = $a();
    for (var _5C = $1.msglen - 1; _5C >= 0; _5C -= 1) {
      $1.i = _5C;
      $1.barchar = $get($1.msg, $1.i);
      if ($1.barchar >= 48 && $1.barchar <= 57) {
        $put($1.nDigits, $1.i, $f($get($1.nDigits, $1.i + 1) + 1));
      }
      var _5P = $get($1.Avals, $1.barchar) !== void 0;
      if (_5P) {
        $put($1.DatumA, $1.i, true);
      }
      var _5U = $get($1.Bvals, $1.barchar) !== void 0;
      if (_5U) {
        $put($1.DatumB, $1.i, true);
      }
      $1.CRLF = false;
      if ($1.barchar == 13 && $1.i < $1.msglen - 1) {
        if ($get($1.msg, $1.i + 1) == 10) {
          $1.CRLF = true;
        }
      }
      if ($1.CRLF) {
        $put($1.DatumB, $1.i, true);
      }
      if ($get($1.nDigits, $1.i) >= 2) {
        $put($1.DatumC, $1.i, true);
      }
      if ($1.barchar < 0) {
        $put($1.DatumC, $1.i, true);
      }
      if ($1.barchar >= 128) {
        $put($1.Binary, $1.i, true);
      }
      if ($get($1.nDigits, $1.i) >= 10) {
        $k[$j++] = Infinity;
        $aload($geti($1.msg, $1.i, 10));
        for (var _5x = 0, _5y = 1; _5x < _5y; _5x++) {
          if ($k[--$j] != 48) {
            $k[$j++] = false;
            break;
          }
          if ($k[--$j] != 49) {
            $k[$j++] = false;
            break;
          }
          $j -= 6;
          if ($k[--$j] != 55) {
            $k[$j++] = false;
            break;
          }
          if ($k[--$j] != 49) {
            $k[$j++] = false;
            break;
          }
          $k[$j++] = true;
        }
        $put($1.SeventeenTen, $1.i, $k[--$j]);
        $cleartomark();
      }
      if ($get($1.nDigits, $1.i + 1) >= 6 && $get($1.msg, $1.i) == $1.fn2) {
        $put($1.ECI, $1.i, true);
      }
      if ($1.barchar < 0 && $1.barchar != $1.fn3) {
        $put($1.AheadC, $1.i, $f($get($1.AheadC, $1.i + 1) + 1));
      } else {
        if ($get($1.nDigits, $1.i) <= 1) {
          $put($1.AheadC, $1.i, 0);
        } else {
          $put($1.AheadC, $1.i, $f($get($1.AheadC, $1.i + 2) + 1));
        }
      }
      if ($get($1.nDigits, $1.i) > 0 && $gt($get($1.AheadC, $1.i), $get($1.AheadC, $1.i + 1))) {
        $put($1.TryC, $1.i, $get($1.AheadC, $1.i));
      }
      if ($get($1.DatumA, $1.i) && $get($1.TryC, $1.i) < 2 && $1.barchar != $1.fn3) {
        $put($1.AheadA, $1.i, $f($get($1.AheadA, $1.i + 1) + 1));
      }
      if ($get($1.DatumB, $1.i) && $get($1.TryC, $1.i) < 2 && $1.barchar != $1.fn3) {
        $k[$j++] = $1.AheadB;
        $k[$j++] = $1.i;
        $k[$j++] = $1.AheadB;
        $k[$j++] = $1.i + 1;
        if ($1.CRLF) {
          var _7B = $k[--$j];
          $k[$j++] = $f(_7B + 1);
        }
        var _7C = $k[--$j];
        var _7E = $get($k[--$j], _7C);
        var _7F = $k[--$j];
        $put($k[--$j], _7F, $f(_7E + 1));
      }
      if ($1.barchar != $1.fn3) {
        $put($1.UntilEndSeg, $1.i, $f($get($1.UntilEndSeg, $1.i + 1) + 1));
      }
    }
    $1.addtocws = function() {
      var _7O = $k[--$j];
      $puti($1.cws, $1.j, _7O);
      $1.j = _7O.length + $1.j;
    };
    $1.base259to103 = function() {
      $1.in = $k[--$j];
      $1.inlen = $1.in.length;
      $k[$j++] = Infinity;
      for (var _7V = 0, _7W = 5 - $1.inlen; _7V < _7W; _7V++) {
        $k[$j++] = 0;
      }
      $aload($1.in);
      $1.in = $a();
      $1.out = $a(6);
      $k[$j++] = Infinity;
      $aload($geti($1.in, 0, 2));
      $1.msbs = $a();
      $k[$j++] = Infinity;
      $aload($1.msbs);
      var _7e = $k[--$j];
      var _7f = $k[--$j];
      $k[$j++] = $f(_7e + _7f * 259);
      for (var _7g = 0, _7h = 2; _7g < _7h; _7g++) {
        var _7i = $k[--$j];
        $k[$j++] = _7i % 103;
        $k[$j++] = ~~(_7i / 103);
      }
      $1.mscs = $a();
      $k[$j++] = Infinity;
      $aload($geti($1.in, 2, 3));
      $1.lsbs = $a();
      $k[$j++] = Infinity;
      $aload($1.lsbs);
      var _7o = $k[--$j];
      var _7p = $k[--$j];
      var _7q = $k[--$j];
      $k[$j++] = $f($f(_7o + _7p * 259) + _7q * 67081);
      for (var _7r = 0, _7s = 3; _7r < _7s; _7r++) {
        var _7t = $k[--$j];
        $k[$j++] = _7t % 103;
        $k[$j++] = ~~(_7t / 103);
      }
      $1.lscs = $a();
      var _7w = $get($1.lscs, 0);
      var _7y = $get($1.mscs, 0);
      $put($1.out, 5, $f(_7w + _7y * 42) % 103);
      var _81 = $get($1.lscs, 1);
      var _83 = $get($1.mscs, 0);
      var _85 = $get($1.mscs, 1);
      $put($1.out, 4, $f($f($f(~~($f(_7w + _7y * 42) / 103) + _81) + _83 * 68) + _85 * 42) % 103);
      var _88 = $get($1.lscs, 2);
      var _8A = $get($1.mscs, 0);
      var _8C = $get($1.mscs, 1);
      var _8E = $get($1.mscs, 2);
      $put($1.out, 3, $f($f($f($f(~~($f($f($f(~~($f(_7w + _7y * 42) / 103) + _81) + _83 * 68) + _85 * 42) / 103) + _88) + _8A * 92) + _8C * 68) + _8E * 42) % 103);
      var _8H = $get($1.lscs, 3);
      var _8J = $get($1.mscs, 0);
      var _8L = $get($1.mscs, 1);
      var _8N = $get($1.mscs, 2);
      $put($1.out, 2, $f($f($f($f(~~($f($f($f($f(~~($f($f($f(~~($f(_7w + _7y * 42) / 103) + _81) + _83 * 68) + _85 * 42) / 103) + _88) + _8A * 92) + _8C * 68) + _8E * 42) / 103) + _8H) + _8J * 15) + _8L * 92) + _8N * 68) % 103);
      var _8Q = $get($1.mscs, 1);
      var _8S = $get($1.mscs, 2);
      $put($1.out, 1, $f($f(~~($f($f($f($f(~~($f($f($f($f(~~($f($f($f(~~($f(_7w + _7y * 42) / 103) + _81) + _83 * 68) + _85 * 42) / 103) + _88) + _8A * 92) + _8C * 68) + _8E * 42) / 103) + _8H) + _8J * 15) + _8L * 92) + _8N * 68) / 103) + _8Q * 15) + _8S * 92) % 103);
      $put($1.out, 0, $f(~~($f($f(~~($f($f($f($f(~~($f($f($f($f(~~($f($f($f(~~($f(_7w + _7y * 42) / 103) + _81) + _83 * 68) + _85 * 42) / 103) + _88) + _8A * 92) + _8C * 68) + _8E * 42) / 103) + _8H) + _8J * 15) + _8L * 92) + _8N * 68) / 103) + _8Q * 15) + _8S * 92) / 103) + $get($1.mscs, 2) * 15) % 103);
      $k[$j++] = $geti($1.out, 6 - $1.inlen - 1, $1.inlen + 1);
    };
    $1.finaliseBIN = function() {
      if ($1.bpos != 0) {
        $k[$j++] = $geti($1.bvals, 0, $1.bpos);
        $1.base259to103();
        $aload($k[--$j]);
        $1.bpos = 0;
      }
    };
    $1.addtobin = function() {
      $put($1.bvals, $1.bpos, $k[--$j]);
      $1.bpos = $1.bpos + 1;
      if ($1.bpos == 5) {
        $1.finaliseBIN();
      }
    };
    $1.ECIabc = function() {
      var _8n = $geti($1.msg, $1.i + 1, 6);
      $k[$j++] = 0;
      for (var _8o = 0, _8p = _8n.length; _8o < _8p; _8o++) {
        var _8r = $k[--$j];
        $k[$j++] = $f(_8r + $f($get(_8n, _8o) - 48)) * 10;
      }
      var _8t = ~~($k[--$j] / 10);
      $k[$j++] = _8t;
      if (_8t >= 40) {
        var _8v = $f($k[--$j] - 40);
        var _8w = _8v % 12769;
        $k[$j++] = ~~(_8v / 12769) + 40;
        $k[$j++] = ~~(_8w / 113);
        $k[$j++] = _8w % 113;
      }
    };
    $1.ECIbin = function() {
      $k[$j++] = Infinity;
      var _8z = $geti($1.msg, $1.i + 1, 6);
      $k[$j++] = 0;
      for (var _90 = 0, _91 = _8z.length; _90 < _91; _90++) {
        var _93 = $k[--$j];
        $k[$j++] = $f(_93 + $f($get(_8z, _90) - 48)) * 10;
      }
      var _95 = ~~($k[--$j] / 10);
      $k[$j++] = _95;
      if (_95 >= 65536) {
        var _96 = $k[--$j];
        var _97 = _96 % 65536;
        $k[$j++] = 258;
        $k[$j++] = ~~(_96 / 65536);
        $k[$j++] = ~~(_97 / 256);
        $k[$j++] = _97 % 256;
      } else {
        var _98 = $k[--$j];
        $k[$j++] = _98;
        if (_98 >= 256) {
          var _99 = $k[--$j];
          $k[$j++] = 257;
          $k[$j++] = ~~(_99 / 256);
          $k[$j++] = _99 % 256;
        } else {
          var _9A = $k[--$j];
          $k[$j++] = 256;
          $k[$j++] = _9A;
        }
      }
      var _9B = $a();
      for (var _9C = 0, _9D = _9B.length; _9C < _9D; _9C++) {
        $k[$j++] = $get(_9B, _9C);
        $1.addtobin();
      }
    };
    $1.encC = function() {
      for (var _9F = 0, _9G = 1; _9F < _9G; _9F++) {
        if ($1.i == $1.segstart) {
          for (var _9J = 0, _9K = 1; _9J < _9K; _9J++) {
            if ($1.i > $f($1.segend - 7)) {
              $k[$j++] = 0;
              break;
            }
            if ($get($1.msg, $1.segstart) != 91) {
              $k[$j++] = 0;
              break;
            }
            if ($get($1.msg, $1.segstart + 1) != 41) {
              $k[$j++] = 0;
              break;
            }
            if ($get($1.msg, $1.segstart + 2) != 62) {
              $k[$j++] = 0;
              break;
            }
            if ($get($1.msg, $1.segstart + 3) != 30) {
              $k[$j++] = 0;
              break;
            }
            var _9b = $get($1.msg, $1.segstart + 4);
            if (_9b < 48 || _9b > 57) {
              $k[$j++] = 0;
              break;
            }
            var _9e = $get($1.msg, $1.segstart + 5);
            if (_9e < 48 || _9e > 57) {
              $k[$j++] = 0;
              break;
            }
            if ($get($1.msg, $f($1.segend - 1)) != 4) {
              $k[$j++] = 0;
              break;
            }
            var _9o = $f($f($get($1.msg, $1.segstart + 4) - 48) * 10 + $f($get($1.msg, $1.segstart + 5) - 48));
            $k[$j++] = _9o;
            if (_9o != 5 && (_9o != 6 && _9o != 12)) {
              $j--;
              $k[$j++] = $1.mac;
              break;
            }
            if ($get($1.msg, $1.segstart + 6) != 29) {
              $j--;
              $k[$j++] = 0;
              break;
            }
            if ($get($1.msg, $f($1.segend - 2)) != 30) {
              $j--;
              $k[$j++] = 0;
              break;
            }
            var _9w = $k[--$j];
            $k[$j++] = _9w;
            if (_9w == 5) {
              $j--;
              $k[$j++] = $1.m05;
              break;
            }
            if ($k[--$j] == 6) {
              $k[$j++] = $1.m06;
              break;
            }
            $k[$j++] = $1.m12;
            break;
          }
          $1.inmac = $k[--$j];
          if ($1.inmac != 0) {
            $k[$j++] = $a([$get($1.Cvals, $1.lab)]);
            $1.addtocws();
            $1.mode = $1.B;
            $k[$j++] = $a([$get($1.Bvals, $1.inmac)]);
            $1.addtocws();
            if ($1.inmac == $1.mac) {
              $k[$j++] = $a([$get($1.Bvals, $get($1.msg, $1.segstart + 4))]);
              $1.addtocws();
              $k[$j++] = $a([$get($1.Bvals, $get($1.msg, $1.segstart + 5))]);
              $1.addtocws();
              $1.i = $1.i + 6;
            } else {
              $1.i = $1.i + 7;
            }
            break;
          }
        }
        if ($1.i == $1.segstart) {
          if ($get($1.nDigits, $1.i) >= 2) {
            $k[$j++] = $a([$get($1.Cvals, $1.fn1)]);
            $1.addtocws();
          }
          if ($get($1.msg, $1.i) == $1.fn1 && $get($1.nDigits, $1.i + 1) >= 2) {
            $1.i = $1.i + 1;
          }
        }
        if ($get($1.SeventeenTen, $1.i)) {
          $k[$j++] = $a([$get($1.Cvals, $1.aim), $f($f($get($1.msg, $1.i + 2) - 48) * 10 + $f($get($1.msg, $1.i + 3) - 48)), $f($f($get($1.msg, $1.i + 4) - 48) * 10 + $f($get($1.msg, $1.i + 5) - 48)), $f($f($get($1.msg, $1.i + 6) - 48) * 10 + $f($get($1.msg, $1.i + 7) - 48))]);
          $1.addtocws();
          $1.i = $1.i + 10;
          break;
        }
        if ($get($1.DatumC, $1.i)) {
          var _BE = $get($1.msg, $1.i);
          if (_BE == $1.fn1 || (_BE == $1.fn2 || _BE == $1.fn3)) {
            $k[$j++] = $a([$get($1.Cvals, $get($1.msg, $1.i))]);
            $1.addtocws();
            if ($get($1.ECI, $1.i)) {
              $k[$j++] = Infinity;
              $1.ECIabc();
              var _BR = $a();
              $k[$j++] = _BR;
              $1.addtocws();
              $1.i = $1.i + 7;
              break;
            }
            if ($get($1.msg, $1.i) == $1.fn3 && $1.segstart != $1.i) {
              $1.i = $1.i + 1;
              $1.inmac = 0;
              $1.segstart = $1.i;
              $1.segend = $f($1.i + $get($1.UntilEndSeg, $1.i));
              break;
            }
            $1.i = $1.i + 1;
            break;
          }
          $k[$j++] = $a([$f($f($get($1.msg, $1.i) - 48) * 10 + $f($get($1.msg, $1.i + 1) - 48))]);
          $1.addtocws();
          $1.i = $1.i + 2;
          break;
        }
        if ($get($1.Binary, $1.i)) {
          if ($get($1.nDigits, $1.i + 1) > 0) {
            if ($get($1.msg, $1.i) < 160) {
              $k[$j++] = $a([$get($1.Cvals, $1.bsa), $get($1.Avals, $f($get($1.msg, $1.i) - 128))]);
              $1.addtocws();
            } else {
              $k[$j++] = $a([$get($1.Cvals, $1.bsb), $get($1.Bvals, $f($get($1.msg, $1.i) - 128))]);
              $1.addtocws();
            }
            $1.i = $1.i + 1;
            break;
          }
          $k[$j++] = $a([$get($1.Cvals, $1.bin)]);
          $1.addtocws();
          $1.mode = $1.BIN;
          break;
        }
        $1.m = $get($1.AheadA, $1.i);
        $1.n = $get($1.AheadB, $1.i);
        if ($gt($1.m, $1.n)) {
          $k[$j++] = $a([$get($1.Cvals, $1.laa)]);
          $1.addtocws();
          $1.mode = $1.A;
          break;
        }
        if ($1.i == $1.segstart) {
          var _Cc = $get($1.msg, $1.i);
          if (_Cc == 9 || (_Cc == 28 || (_Cc == 29 || _Cc == 30))) {
            $k[$j++] = $a([$get($1.Cvals, $1.laa)]);
            $1.addtocws();
            $1.mode = $1.A;
            break;
          }
        }
        if ($1.n > 4) {
          $k[$j++] = $a([$get($1.Cvals, $1.lab)]);
          $1.addtocws();
          $1.mode = $1.B;
          break;
        }
        $k[$j++] = $a([$get($1.Cvals, $get($a([$1.sfb, $1.sb2, $1.sb3, $1.sb4]), $f($1.n - 1)))]);
        $1.addtocws();
        for (var _Cz = 0, _D0 = $1.n; _Cz < _D0; _Cz++) {
          if ($get($1.msg, $1.i) == 13) {
            $k[$j++] = $a([$get($1.Bvals, $1.crl)]);
            $1.addtocws();
            $1.i = $1.i + 2;
          } else {
            $k[$j++] = $a([$get($1.Bvals, $get($1.msg, $1.i))]);
            $1.addtocws();
            $1.i = $1.i + 1;
          }
        }
        break;
      }
    };
    $1.encB = function() {
      for (var _DG = 0, _DH = 1; _DG < _DH; _DG++) {
        $1.n = $get($1.TryC, $1.i);
        if ($1.n >= 2) {
          if ($1.n > 4) {
            $k[$j++] = $a([$get($1.Bvals, $1.lac)]);
            $1.addtocws();
            $1.mode = $1.C;
            break;
          }
          $k[$j++] = $a([$get($1.Bvals, $get($a([$1.sfc, $1.sc2, $1.sc3, $1.sc4]), $f($1.n - 1)))]);
          $1.addtocws();
          for (var _Dd = 0, _De = $1.n; _Dd < _De; _Dd++) {
            if ($get($1.msg, $1.i) < 0) {
              $k[$j++] = $a([$get($1.Cvals, $get($1.msg, $1.i))]);
              $1.addtocws();
              $1.i = $1.i + 1;
            } else {
              $k[$j++] = $a([$f($f($get($1.msg, $1.i) - 48) * 10 + $f($get($1.msg, $1.i + 1) - 48))]);
              $1.addtocws();
              $1.i = $1.i + 2;
            }
          }
          break;
        }
        if ($get($1.DatumB, $1.i)) {
          var _E2 = $get($1.msg, $1.i);
          if (_E2 == $1.fn1 || (_E2 == $1.fn2 || _E2 == $1.fn3)) {
            $k[$j++] = $a([$get($1.Bvals, $get($1.msg, $1.i))]);
            $1.addtocws();
            if ($get($1.ECI, $1.i)) {
              $k[$j++] = Infinity;
              $1.ECIabc();
              var _EF = $a();
              $k[$j++] = _EF;
              $1.addtocws();
              $1.i = $1.i + 7;
              break;
            }
            if ($get($1.msg, $1.i) == $1.fn3 && $1.i != $1.segstart) {
              $1.i = $1.i + 1;
              $1.mode = $1.C;
              $1.inmac = 0;
              $1.segstart = $1.i;
              $1.segend = $f($1.i + $get($1.UntilEndSeg, $1.i));
              break;
            }
            $1.i = $1.i + 1;
            break;
          }
          if ($get($1.msg, $1.i) == 13 && $1.i < $1.msglen - 1) {
            if ($get($1.msg, $1.i + 1) == 10) {
              $k[$j++] = $a([$get($1.Bvals, $1.crl)]);
              $1.addtocws();
              $1.i = $1.i + 2;
              break;
            }
          }
          $k[$j++] = $a([$get($1.Bvals, $get($1.msg, $1.i))]);
          $1.addtocws();
          $1.i = $1.i + 1;
          break;
        }
        if ($get($1.Binary, $1.i)) {
          if ($get($1.DatumB, $1.i + 1)) {
            if ($get($1.msg, $1.i) < 160) {
              $k[$j++] = $a([$get($1.Bvals, $1.bsa), $get($1.Avals, $f($get($1.msg, $1.i) - 128))]);
              $1.addtocws();
            } else {
              $k[$j++] = $a([$get($1.Bvals, $1.bsb), $get($1.Bvals, $f($get($1.msg, $1.i) - 128))]);
              $1.addtocws();
            }
            $1.i = $1.i + 1;
            break;
          }
          $k[$j++] = $a([$get($1.Bvals, $1.bin)]);
          $1.addtocws();
          $1.mode = $1.BIN;
          break;
        }
        if ($get($1.AheadA, $1.i) == 1) {
          $k[$j++] = $a([$get($1.Bvals, $1.sfa), $get($1.Avals, $get($1.msg, $1.i))]);
          $1.addtocws();
          $1.i = $1.i + 1;
          break;
        }
        $k[$j++] = $a([$get($1.Bvals, $1.laa)]);
        $1.addtocws();
        $1.mode = $1.A;
        break;
      }
    };
    $1.encA = function() {
      for (var _Fe = 0, _Ff = 1; _Fe < _Ff; _Fe++) {
        $1.n = $get($1.TryC, $1.i);
        if ($1.n >= 2) {
          if ($1.n > 4) {
            $k[$j++] = $a([$get($1.Avals, $1.lac)]);
            $1.addtocws();
            $1.mode = $1.C;
            break;
          }
          $k[$j++] = $a([$get($1.Avals, $get($a([$1.sfc, $1.sc2, $1.sc3, $1.sc4]), $f($1.n - 1)))]);
          $1.addtocws();
          for (var _G1 = 0, _G2 = $1.n; _G1 < _G2; _G1++) {
            if ($get($1.msg, $1.i) < 0) {
              $k[$j++] = $a([$get($1.Cvals, $get($1.msg, $1.i))]);
              $1.addtocws();
              $1.i = $1.i + 1;
            } else {
              $k[$j++] = $a([$f($f($get($1.msg, $1.i) - 48) * 10 + $f($get($1.msg, $1.i + 1) - 48))]);
              $1.addtocws();
              $1.i = $1.i + 2;
            }
          }
          break;
        }
        if ($get($1.DatumA, $1.i)) {
          var _GQ = $get($1.msg, $1.i);
          if (_GQ == $1.fn1 || (_GQ == $1.fn2 || _GQ == $1.fn3)) {
            $k[$j++] = $a([$get($1.Avals, $get($1.msg, $1.i))]);
            $1.addtocws();
            if ($get($1.ECI, $1.i)) {
              $k[$j++] = Infinity;
              $1.ECIabc();
              var _Gd = $a();
              $k[$j++] = _Gd;
              $1.addtocws();
              $1.i = $1.i + 7;
              break;
            }
            if ($get($1.msg, $1.i) == $1.fn3 && $1.i != $1.segstart) {
              $1.i = $1.i + 1;
              $1.mode = $1.C;
              $1.inmac = 0;
              $1.segstart = $1.i;
              $1.segend = $f($1.i + $get($1.UntilEndSeg, $1.i));
              break;
            }
            $1.i = $1.i + 1;
            break;
          }
          $k[$j++] = $a([$get($1.Avals, $get($1.msg, $1.i))]);
          $1.addtocws();
          $1.i = $1.i + 1;
          break;
        }
        if ($get($1.Binary, $1.i)) {
          if ($get($1.DatumA, $1.i + 1)) {
            if ($get($1.msg, $1.i) < 160) {
              $k[$j++] = $a([$get($1.Avals, $1.bsa), $get($1.Avals, $f($get($1.msg, $1.i) - 128))]);
              $1.addtocws();
            } else {
              $k[$j++] = $a([$get($1.Avals, $1.bsb), $get($1.Bvals, $f($get($1.msg, $1.i) - 128))]);
              $1.addtocws();
            }
            $1.i = $1.i + 1;
            break;
          }
          $k[$j++] = $a([$get($1.Avals, $1.bin)]);
          $1.addtocws();
          $1.mode = $1.BIN;
          break;
        }
        $1.n = $get($1.AheadB, $1.i);
        if ($1.n > 6) {
          $k[$j++] = $a([$get($1.Avals, $1.lab)]);
          $1.addtocws();
          $1.mode = $1.B;
          break;
        }
        $k[$j++] = $a([$get($1.Avals, $get($a([$1.sfb, $1.sb2, $1.sb3, $1.sb4, $1.sb5, $1.sb6]), $f($1.n - 1)))]);
        $1.addtocws();
        for (var _Ht = 0, _Hu = $1.n; _Ht < _Hu; _Ht++) {
          if ($get($1.msg, $1.i) == 13) {
            $k[$j++] = $a([$get($1.Bvals, $1.crl)]);
            $1.addtocws();
            $1.i = $1.i + 2;
          } else {
            $k[$j++] = $a([$get($1.Bvals, $get($1.msg, $1.i))]);
            $1.addtocws();
            $1.i = $1.i + 1;
          }
        }
        break;
      }
    };
    $1.encBIN = function() {
      for (var _IA = 0, _IB = 1; _IA < _IB; _IA++) {
        $1.n = $get($1.TryC, $1.i);
        if ($1.n >= 2) {
          $k[$j++] = Infinity;
          $1.finaliseBIN();
          var _IG = $a();
          $k[$j++] = _IG;
          $1.addtocws();
          if ($1.n > 7) {
            $k[$j++] = $a([$get($1.BINvals, $1.tmc)]);
            $1.addtocws();
            $1.mode = $1.C;
            break;
          }
          $k[$j++] = $a([$get($1.BINvals, $get($a([$1.sc2, $1.sc3, $1.sc4, $1.sc5, $1.sc6, $1.sc7]), $f($1.n - 2)))]);
          $1.addtocws();
          for (var _Ia = 0, _Ib = $1.n; _Ia < _Ib; _Ia++) {
            if ($get($1.msg, $1.i) < 0) {
              $k[$j++] = $a([$get($1.Cvals, $get($1.msg, $1.i))]);
              $1.addtocws();
              $1.i = $1.i + 1;
            } else {
              $k[$j++] = $a([$f($f($get($1.msg, $1.i) - 48) * 10 + $f($get($1.msg, $1.i + 1) - 48))]);
              $1.addtocws();
              $1.i = $1.i + 2;
            }
          }
          break;
        }
        if ($get($1.ECI, $1.i) && $get($1.Binary, $1.i + 7)) {
          $k[$j++] = Infinity;
          $1.ECIbin();
          var _J0 = $a();
          $k[$j++] = _J0;
          $1.addtocws();
          $1.i = $1.i + 7;
          if ($1.i == $1.msglen) {
            $k[$j++] = Infinity;
            $1.finaliseBIN();
            var _J4 = $a();
            $k[$j++] = _J4;
            $1.addtocws();
          }
          break;
        }
        if ($get($1.msg, $1.i) >= 0) {
          if ($get($1.Binary, $1.i) || $get($1.Binary, $1.i + 1) || $get($1.Binary, $1.i + 2) || $get($1.Binary, $1.i + 3) || $get($1.ECI, $1.i + 1) && $get($1.Binary, $1.i + 8)) {
            $k[$j++] = Infinity;
            $k[$j++] = $get($1.msg, $1.i);
            $1.addtobin();
            var _JT = $a();
            $k[$j++] = _JT;
            $1.addtocws();
            $1.i = $1.i + 1;
            if ($1.i == $1.msglen) {
              $k[$j++] = Infinity;
              $1.finaliseBIN();
              var _JX = $a();
              $k[$j++] = _JX;
              $1.addtocws();
            }
            break;
          }
        }
        $k[$j++] = Infinity;
        $1.finaliseBIN();
        var _JY = $a();
        $k[$j++] = _JY;
        $1.addtocws();
        if ($1.i != $1.msglen - 1) {
          if ($get($1.msg, $1.i) == $1.fn3 && $1.i != $1.segstart) {
            $k[$j++] = $a([$get($1.BINvals, $1.tms)]);
            $1.addtocws();
            $1.i = $1.i + 1;
            $1.mode = $1.C;
            $1.inmac = 0;
            $1.segstart = $1.i;
            $1.segend = $f($1.i + $get($1.UntilEndSeg, $1.i));
            break;
          }
          if ($gt($get($1.AheadA, $1.i), $get($1.AheadB, $1.i))) {
            $k[$j++] = $a([$get($1.BINvals, $1.tma)]);
            $1.addtocws();
            $1.mode = $1.A;
          } else {
            $k[$j++] = $a([$get($1.BINvals, $1.tmb)]);
            $1.addtocws();
            $1.mode = $1.B;
          }
          break;
        }
        break;
      }
    };
    $1.cws = $a($1.msglen * 2 + 1);
    $1.mode = $1.C;
    $1.bvals = $a(5);
    $1.bpos = 0;
    $1.inmac = 0;
    $1.segstart = 0;
    $1.segend = $get($1.UntilEndSeg, 0);
    $1.i = 0;
    $1.j = 0;
    for (; ; ) {
      if ($1.i >= $1.msglen) {
        break;
      }
      if ($1.inmac != 0) {
        if ($1.inmac != $1.mac && $1.i == $f($1.segend - 2)) {
          $1.i = $1.i + 2;
          if ($1.i >= $1.msglen) {
            break;
          }
        }
        if ($1.inmac == $1.mac && $1.i == $f($1.segend - 1)) {
          $1.i = $1.i + 1;
          if ($1.i >= $1.msglen) {
            break;
          }
        }
      }
      if ($1[$get($a(["encA", "encB", "encC", "encBIN"]), $1.mode)]() === true) {
        break;
      }
    }
    $1.cws = $geti($1.cws, 0, $1.j);
    $1.nd = $1.cws.length;
    $1.minarea = (($1.nd + 3 + ~~($1.nd / 2)) * 9 + 2) * 2;
    if ($1.ratio != -1) {
      $1.hgt = Math.sqrt($1.minarea / $1.ratio);
      $1.wid = Math.sqrt($1.minarea * $1.ratio);
      $1.h = ~~$1.hgt;
      $1.w = ~~$1.wid;
      if (($1.h + $1.w) % 2 == 1) {
        if ($1.h * $1.w < $1.minarea) {
          $1.h = $1.h + 1;
          $1.w = $1.w + 1;
        }
      } else {
        if ($1.hgt * $1.w < $1.wid * $1.h) {
          $1.w = $1.w + 1;
          if ($1.h * $1.w < $1.minarea) {
            $1.w = $1.w - 1;
            $1.h = $1.h + 1;
            if ($1.h * $1.w < $1.minarea) {
              $1.w = $1.w + 2;
            }
          }
        } else {
          $1.h = $1.h + 1;
          if ($1.h * $1.w < $1.minarea) {
            $1.h = $1.h - 1;
            $1.w = $1.w + 1;
            if ($1.h * $1.w < $1.minarea) {
              $1.h = $1.h + 2;
            }
          }
        }
      }
      $1.rows = $1.h;
      $1.columns = $1.w;
    } else {
      if ($1.columns == -1) {
        var _LN = ~~(($1.minarea + $1.rows - 1) / $1.rows);
        $k[$j++] = "columns";
        $k[$j++] = _LN;
        if ((_LN + $1.rows) % 2 == 0) {
          var _LP = $k[--$j];
          $k[$j++] = $f(_LP + 1);
        }
        var _LQ = $k[--$j];
        $1[$k[--$j]] = _LQ;
      }
      if ($1.rows == -1) {
        var _LW = ~~(($1.minarea + $1.columns - 1) / $1.columns);
        $k[$j++] = "rows";
        $k[$j++] = _LW;
        if ((_LW + $1.columns) % 2 == 0) {
          var _LY = $k[--$j];
          $k[$j++] = $f(_LY + 1);
        }
        var _LZ = $k[--$j];
        $1[$k[--$j]] = _LZ;
      }
    }
    $1.ndots = ~~($1.rows * $1.columns / 2);
    for (; ; ) {
      var _Le = $1.nd + 1;
      if ((_Le + (~~(_Le / 2) + 3)) * 9 + 2 > $1.ndots) {
        break;
      }
      $1.nd = $1.nd + 1;
    }
    $1.nc = ~~($1.nd / 2) + 3;
    $1.nw = $1.nd + $1.nc;
    $1.rembits = $1.ndots - ($1.nw * 9 + 2);
    if ($1.nd > $1.cws.length) {
      $k[$j++] = Infinity;
      $aload($1.cws);
      var _Lr = $1.mode == $1.BIN ? 109 : 106;
      $k[$j++] = _Lr;
      for (var _Lu = 0, _Lv = $1.nd - $1.cws.length - 1; _Lu < _Lv; _Lu++) {
        $k[$j++] = 106;
      }
      $1.cws = $a();
    }
    var _Ly = $get($1.options, "debugcws") !== void 0;
    if (_Ly) {
      $k[$j++] = "bwipp.debugcws#25277";
      $k[$j++] = $1.cws;
      bwipp_raiseerror();
    }
    if ($1.nw * 9 > $1.ndots - 2) {
      $k[$j++] = "bwipp.dotcodeTooLong#25281";
      $k[$j++] = "Maximum length exceeded";
      bwipp_raiseerror();
    }
    if (!bwipp_dotcode.__25311__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.encs = $a(["101010101", "010101011", "010101101", "010110101", "011010101", "101010110", "101011010", "101101010", "110101010", "010101110", "010110110", "010111010", "011010110", "011011010", "011101010", "100101011", "100101101", "100110101", "101001011", "101001101", "101010011", "101011001", "101100101", "101101001", "110010101", "110100101", "110101001", "001010111", "001011011", "001011101", "001101011", "001101101", "001110101", "010010111", "010011011", "010011101", "010100111", "010110011", "010111001", "011001011", "011001101", "011010011", "011011001", "011100101", "011101001", "100101110", "100110110", "100111010", "101001110", "101011100", "101100110", "101101100", "101110010", "101110100", "110010110", "110011010", "110100110", "110101100", "110110010", "110110100", "111001010", "111010010", "111010100", "001011110", "001101110", "001110110", "001111010", "010011110", "010111100", "011001110", "011011100", "011100110", "011101100", "011110010", "011110100", "100010111", "100011011", "100011101", "100100111", "100110011", "100111001", "101000111", "101100011", "101110001", "110001011", "110001101", "110010011", "110011001", "110100011", "110110001", "111000101", "111001001", "111010001", "000101111", "000110111", "000111011", "000111101", "001001111", "001100111", "001110011", "001111001", "010001111", "011000111", "011100011", "011110001", "100011110", "100111100", "101111000", "110001110", "110011100", "110111000", "111000110", "111001100"]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_dotcode.$ctx[id] = $ctx[id]);
        bwipp_dotcode.__25311__ = 1;
      })();
    }
    if ($1.rows % 2 == 0) {
      $1.sixedges = $a([$a([$1.columns - 1, $1.rows - 2]), $a([0, $1.rows - 2]), $a([$1.columns - 2, $1.rows - 1]), $a([1, $1.rows - 1]), $a([$1.columns - 1, 0]), $a([0, 0])]);
    } else {
      $1.sixedges = $a([$a([$1.columns - 2, 0]), $a([$1.columns - 2, $1.rows - 1]), $a([$1.columns - 1, 1]), $a([$1.columns - 1, $1.rows - 2]), $a([0, 0]), $a([0, $1.rows - 1])]);
    }
    $1.dmv = function() {
      var _MY = $k[--$j];
      var _MZ = $k[--$j];
      $k[$j++] = $f(_MZ + _MY * $1.columns);
    };
    $1.outline = $a($1.rows * $1.columns);
    for (var _Mf = 0, _Me = $1.rows - 1; _Mf <= _Me; _Mf += 1) {
      $1.y = _Mf;
      for (var _Mi = 0, _Mh = $1.columns - 1; _Mi <= _Mh; _Mi += 1) {
        $1.x = _Mi;
        $k[$j++] = $1.outline;
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $1.dmv();
        var _Mo = $k[--$j];
        $put($k[--$j], _Mo, ($1.x + $1.y) % 2 - 1);
      }
    }
    var _Mq = $1.sixedges;
    for (var _Mr = 0, _Ms = _Mq.length; _Mr < _Ms; _Mr++) {
      $k[$j++] = $1.outline;
      $aload($get(_Mq, _Mr));
      $1.dmv();
      var _Mv = $k[--$j];
      $put($k[--$j], _Mv, 1);
    }
    $1.clearcol = function() {
      $1.x = $k[--$j];
      $k[$j++] = true;
      for (var _N1 = $1.x & 1, _N0 = $1.rows - 1; _N1 <= _N0; _N1 += 2) {
        $k[$j++] = $1.x;
        $k[$j++] = _N1;
        $1.dmv();
        if ($get($1.sym, $k[--$j]) == 1) {
          $j--;
          $k[$j++] = false;
          break;
        }
      }
    };
    $1.clearrow = function() {
      $1.y = $k[--$j];
      $k[$j++] = true;
      for (var _NA = $1.y & 1, _N9 = $1.columns - 1; _NA <= _N9; _NA += 2) {
        $k[$j++] = _NA;
        $k[$j++] = $1.y;
        $1.dmv();
        if ($get($1.sym, $k[--$j]) == 1) {
          $j--;
          $k[$j++] = false;
          break;
        }
      }
    };
    $1.evalsymbol = function() {
      $1.sym = $k[--$j];
      $1.worst = 9999999;
      var _NK = $a([$a(["x", 0]), $a(["x", 1]), $a(["y", 0]), $a(["y", 1])]);
      for (var _NL = 0, _NM = _NK.length; _NL < _NM; _NL++) {
        $aload($get(_NK, _NL));
        $1.fl = $k[--$j];
        $1.dir = $k[--$j];
        $1.sum = 0;
        $1.first = -1;
        $1.last = -1;
        var _NR = $eq($1.dir, "x") ? $1.columns : $1.rows;
        for (var _NT = 0, _NS = _NR - 1; _NT <= _NS; _NT += 1) {
          $1[$1.dir] = _NT;
          var _NV = $1.sym;
          var _NX = $1[$1.dir];
          var _NZ = $eq($1.dir, "x") ? $1.rows : $1.columns;
          var _Nc = (_NZ - 1) * $1.fl;
          if ($eq($1.dir, "y")) {
            var _ = _Nc;
            _Nc = _NX;
            _NX = _;
          }
          $k[$j++] = _NV;
          $k[$j++] = _NX;
          $k[$j++] = _Nc;
          $1.dmv();
          var _Nd = $k[--$j];
          if ($get($k[--$j], _Nd) == 1) {
            if ($1.first == -1) {
              $1.first = $1[$1.dir];
            }
            $1.last = $1[$1.dir];
            $1.sum = $1.sum + 1;
          }
        }
        var _Nq = $eq($1.dir, "x") ? $1.rows : $1.columns;
        var _Nr = $f($f($1.sum + $1.last) - $1.first) * _Nq;
        $k[$j++] = _Nr;
        if (_Nr < $1.worst) {
          $1.worst = $k[--$j];
        } else {
          $j--;
        }
      }
      $1.pen = 0;
      if ($1.rows % 2 == 1 || $1.rows <= 12) {
        $1.sum = 0;
        $1.p = 0;
        for (var _Ny = 1, _Nx = $1.columns - 2; _Ny <= _Nx; _Ny += 1) {
          $k[$j++] = _Ny;
          $1.clearcol();
          if ($k[--$j]) {
            $1.sum = $1.sum + 1;
            $k[$j++] = "p";
            if ($1.sum == 1) {
              $k[$j++] = $1.rows;
            } else {
              $k[$j++] = $1.p * $1.rows;
            }
            var _O5 = $k[--$j];
            $1[$k[--$j]] = _O5;
          } else {
            $1.sum = 0;
            $1.pen = $1.pen + $1.p;
            $1.p = 0;
          }
        }
        $1.pen = $1.pen + $1.p;
      }
      if ($1.rows % 2 == 0 || $1.columns <= 12) {
        $1.sum = 0;
        $1.p = 0;
        for (var _OF = 1, _OE = $1.rows - 2; _OF <= _OE; _OF += 1) {
          $k[$j++] = _OF;
          $1.clearrow();
          if ($k[--$j]) {
            $1.sum = $1.sum + 1;
            $k[$j++] = "p";
            if ($1.sum == 1) {
              $k[$j++] = $1.columns;
            } else {
              $k[$j++] = $1.p * $1.columns;
            }
            var _OM = $k[--$j];
            $1[$k[--$j]] = _OM;
          } else {
            $1.sum = 0;
            $1.pen = $1.pen + $1.p;
            $1.p = 0;
          }
        }
        $1.pen = $1.pen + $1.p;
      }
      $k[$j++] = Infinity;
      for (var _OT = 0, _OU = ($1.columns + 4) * 2; _OT < _OU; _OT++) {
        $k[$j++] = 0;
      }
      for (var _OY = 0, _OZ = $1.columns, _OX = $1.sym.length - 1; _OZ < 0 ? _OY >= _OX : _OY <= _OX; _OY += _OZ) {
        $k[$j++] = 0;
        $k[$j++] = 0;
        $aload($geti($1.sym, _OY, $1.columns));
        $k[$j++] = 0;
        $k[$j++] = 0;
      }
      for (var _Oe = 0, _Of = ($1.columns + 4) * 2; _Oe < _Of; _Oe++) {
        $k[$j++] = 0;
      }
      $1.symp = $a();
      $1.columns = $1.columns + 4;
      $1.rows = $1.rows + 4;
      $1.sum = 0;
      for (var _Ol = 2, _Ok = $1.rows - 3; _Ol <= _Ok; _Ol += 1) {
        $1.y = _Ol;
        for (var _Op = ($1.y & 1) + 2, _Oo = $1.columns - 3; _Op <= _Oo; _Op += 2) {
          $1.x = _Op;
          for (var _Oq = 0, _Or = 1; _Oq < _Or; _Oq++) {
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x - 1;
            $k[$j++] = $1.y - 1;
            $1.dmv();
            var _Ov = $k[--$j];
            if ($get($k[--$j], _Ov) == 1) {
              break;
            }
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x + 1;
            $k[$j++] = $1.y - 1;
            $1.dmv();
            var _P1 = $k[--$j];
            if ($get($k[--$j], _P1) == 1) {
              break;
            }
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x - 1;
            $k[$j++] = $1.y + 1;
            $1.dmv();
            var _P7 = $k[--$j];
            if ($get($k[--$j], _P7) == 1) {
              break;
            }
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x + 1;
            $k[$j++] = $1.y + 1;
            $1.dmv();
            var _PD = $k[--$j];
            if ($get($k[--$j], _PD) == 1) {
              break;
            }
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x;
            $k[$j++] = $1.y;
            $1.dmv();
            var _PJ = $k[--$j];
            if ($get($k[--$j], _PJ) == 0) {
              $1.sum = $1.sum + 1;
              break;
            }
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x - 2;
            $k[$j++] = $1.y;
            $1.dmv();
            var _PQ = $k[--$j];
            if ($get($k[--$j], _PQ) == 1) {
              break;
            }
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x;
            $k[$j++] = $1.y - 2;
            $1.dmv();
            var _PW = $k[--$j];
            if ($get($k[--$j], _PW) == 1) {
              break;
            }
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x + 2;
            $k[$j++] = $1.y;
            $1.dmv();
            var _Pc = $k[--$j];
            if ($get($k[--$j], _Pc) == 1) {
              break;
            }
            $k[$j++] = $1.symp;
            $k[$j++] = $1.x;
            $k[$j++] = $1.y + 2;
            $1.dmv();
            var _Pi = $k[--$j];
            if ($get($k[--$j], _Pi) == 1) {
              break;
            }
            $1.sum = $1.sum + 1;
          }
        }
      }
      $1.columns = $1.columns - 4;
      $1.rows = $1.rows - 4;
      if ($1.worst == 0) {
        $k[$j++] = -99999;
      } else {
        $k[$j++] = $f($f($1.worst - $1.sum * $1.sum) - $1.pen);
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _Pt = 0, _Pu = 112; _Pt < _Pu; _Pt++) {
      var _Pv = $k[--$j];
      $k[$j++] = _Pv;
      $k[$j++] = _Pv * 3 % 113;
    }
    $1.rsalog = $a();
    $1.step = ~~($1.nw / 112) + 1;
    $1.offset = function() {
      var _Pz = $k[--$j];
      $k[$j++] = $f(_Pz * $1.step + $1.start);
    };
    $1.bestscore = -99999999;
    $k[$j++] = "masks";
    if ($1.mask != -1) {
      $k[$j++] = $a([$1.mask]);
    } else {
      if ($1.fast) {
        $k[$j++] = $a([3, 2, 1, 0]);
      } else {
        $k[$j++] = $a([0, 1, 2, 3]);
      }
    }
    var _Q7 = $k[--$j];
    $1[$k[--$j]] = _Q7;
    $1.litmasks = $a(4);
    $forall($1.masks, function() {
      $1.mask = $k[--$j];
      $k[$j++] = Infinity;
      var _QG = $1.cws;
      $k[$j++] = $1.mask;
      $k[$j++] = $get($a([0, 3, 7, 17]), $1.mask);
      $k[$j++] = 0;
      for (var _QH = 0, _QI = _QG.length; _QH < _QI; _QH++) {
        var _QK = $k[--$j];
        var _QL = $k[--$j];
        $k[$j++] = $f($get(_QG, _QH) + _QK) % 113;
        $k[$j++] = _QL;
        $k[$j++] = $f(_QK + _QL);
      }
      $j -= 2;
      for (var _QN = 0, _QO = $1.nc; _QN < _QO; _QN++) {
        $k[$j++] = 0;
      }
      $1.rscws = $a();
      for (var _QS = 0, _QR = $1.step - 1; _QS <= _QR; _QS += 1) {
        $1.start = _QS;
        $1.ND = ~~(($1.nd + 1 - $1.start + $1.step - 1) / $1.step);
        $1.NW = ~~(($1.nw + 1 - $1.start + $1.step - 1) / $1.step);
        $1.NC = $1.NW - $1.ND;
        $k[$j++] = Infinity;
        $k[$j++] = 1;
        for (var _Qe = 0, _Qf = $1.NC; _Qe < _Qf; _Qe++) {
          $k[$j++] = 0;
        }
        $1.coeffs = $a();
        for (var _Qj = 1, _Qi = $1.NC; _Qj <= _Qi; _Qj += 1) {
          $1.i = _Qj;
          for (var _Ql = $1.NC; _Ql >= 1; _Ql -= 1) {
            $1.j = _Ql;
            $put($1.coeffs, $1.j, $f($f($get($1.coeffs, $1.j) + 113) - $get($1.rsalog, $1.i) * $get($1.coeffs, $1.j - 1) % 113) % 113);
          }
        }
        for (var _Qz = 0, _Qy = $1.ND - 1; _Qz <= _Qy; _Qz += 1) {
          $k[$j++] = "t";
          $k[$j++] = $1.rscws;
          $k[$j++] = _Qz;
          $1.offset();
          var _R1 = $k[--$j];
          var _R3 = $get($k[--$j], _R1);
          $k[$j++] = _R3;
          $k[$j++] = $1.rscws;
          $k[$j++] = $1.ND;
          $1.offset();
          var _R6 = $k[--$j];
          var _R8 = $get($k[--$j], _R6);
          var _R9 = $k[--$j];
          $1[$k[--$j]] = $f(_R9 + _R8) % 113;
          for (var _RD = 0, _RC = $1.NC - 2; _RD <= _RC; _RD += 1) {
            $1.j = _RD;
            $k[$j++] = $1.rscws;
            $k[$j++] = $1.ND + $1.j;
            $1.offset();
            $k[$j++] = $1.rscws;
            $k[$j++] = $1.ND + $1.j + 1;
            $1.offset();
            var _RK = $k[--$j];
            var _RM = $get($k[--$j], _RK);
            var _RR = $k[--$j];
            $put($k[--$j], _RR, $f($f(_RM + 113) - $1.t * $get($1.coeffs, $1.j + 1) % 113) % 113);
          }
          $k[$j++] = $1.rscws;
          $k[$j++] = $1.ND + $1.NC - 1;
          $1.offset();
          var _Ra = $k[--$j];
          $put($k[--$j], _Ra, $f(113 - $1.t * $get($1.coeffs, $1.NC) % 113) % 113);
        }
        for (var _Rf = $1.ND, _Re = $1.NW - 1; _Rf <= _Re; _Rf += 1) {
          $k[$j++] = _Rf;
          $k[$j++] = $1.rscws;
          $k[$j++] = _Rf;
          $1.offset();
          var _Ri = $k[--$j];
          var _Rj = $k[--$j];
          var _Rk = $k[--$j];
          $k[$j++] = _Rj;
          $k[$j++] = _Ri;
          $k[$j++] = 113;
          $k[$j++] = $1.rscws;
          $k[$j++] = _Rk;
          $1.offset();
          var _Rl = $k[--$j];
          var _Rn = $get($k[--$j], _Rl);
          var _Ro = $k[--$j];
          var _Rp = $k[--$j];
          $put($k[--$j], _Rp, $f(_Ro - _Rn) % 113);
        }
      }
      $1.bits = $s($1.ndots);
      $puti($1.bits, 0, $get($a(["00", "01", "10", "11"]), $1.mask));
      for (var _Rz = 1, _Ry = $1.nw; _Rz <= _Ry; _Rz += 1) {
        $1.i = _Rz;
        $puti($1.bits, ($1.i - 1) * 9 + 2, $get($1.encs, $get($1.rscws, $1.i)));
      }
      if ($1.rembits > 0) {
        $puti($1.bits, $1.nw * 9 + 2, $geti("11111111111111111", 0, $1.rembits));
      }
      var _SC = $1.outline;
      $1.pixs = $arrcpy($a(_SC.length), _SC);
      $1.posx = 0;
      $k[$j++] = "posy";
      if ($1.rows % 2 == 0) {
        $k[$j++] = 0;
      } else {
        $k[$j++] = $1.rows - 1;
      }
      var _SH = $k[--$j];
      $1[$k[--$j]] = _SH;
      var _SL = $geti($1.bits, 0, $1.bits.length - 6);
      for (var _SM = 0, _SN = _SL.length; _SM < _SN; _SM++) {
        $k[$j++] = $get(_SL, _SM);
        for (; ; ) {
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.posx;
          $k[$j++] = $1.posy;
          $1.dmv();
          var _SS = $k[--$j];
          if ($get($k[--$j], _SS) == -1) {
            break;
          }
          if ($1.rows % 2 == 0) {
            $1.posy = $1.posy + 1;
            if ($1.posy == $1.rows) {
              $1.posy = 0;
              $1.posx = $1.posx + 1;
            }
          } else {
            $1.posx = $1.posx + 1;
            if ($1.posx == $1.columns) {
              $1.posx = 0;
              $1.posy = $1.posy - 1;
            }
          }
        }
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.posx;
        $k[$j++] = $1.posy;
        $1.dmv();
        var _Sh = $k[--$j];
        var _Si = $k[--$j];
        $put(_Si, _Sh, $f($k[--$j] - 48));
      }
      for (var _Sk = 0; _Sk <= 5; _Sk += 1) {
        $1.i = _Sk;
        $k[$j++] = $1.pixs;
        $aload($get($1.sixedges, $1.i));
        $1.dmv();
        var _St = $k[--$j];
        $put($k[--$j], _St, $get($1.bits, $1.bits.length - 6 + $1.i) - 48);
      }
      $k[$j++] = "score";
      $k[$j++] = $1.pixs;
      $1.evalsymbol();
      var _Sw = $k[--$j];
      $1[$k[--$j]] = _Sw;
      if ($1.score > $1.bestscore) {
        $1.bestsym = $1.pixs;
        $1.bestscore = $1.score;
        if ($1.fast && $1.bestscore > ~~($1.rows * $1.columns / 2)) {
          return true;
        }
      }
      var _T6 = $1.pixs;
      $1.litmask = $arrcpy($a(_T6.length), _T6);
      for (var _T9 = 0; _T9 <= 5; _T9 += 1) {
        $1.i = _T9;
        $k[$j++] = $1.litmask;
        $aload($get($1.sixedges, $1.i));
        $1.dmv();
        var _TE = $k[--$j];
        $put($k[--$j], _TE, 1);
      }
      $put($1.litmasks, $1.mask, $1.litmask);
      if ($1.fast) {
        $k[$j++] = "score";
        $k[$j++] = $1.litmask;
        $1.evalsymbol();
        var _TL = $k[--$j];
        $1[$k[--$j]] = _TL;
        if ($gt($1.score, $1.bestscore)) {
          $1.bestsym = $1.litmask;
          $1.bestscore = $1.score;
          if ($1.bestscore > ~~($1.rows * $1.columns / 2)) {
            return true;
          }
        }
      }
    });
    $1.pixs = $1.bestsym;
    if (!$1.fast && $1.bestscore <= ~~($1.rows * $1.columns / 2)) {
      $1.bestscore = -99999999;
      $forall($1.masks, function() {
        $1.litmask = $get($1.litmasks, $k[--$j]);
        $k[$j++] = "score";
        $k[$j++] = $1.litmask;
        $1.evalsymbol();
        var _Te = $k[--$j];
        $1[$k[--$j]] = _Te;
        if ($1.score > $1.bestscore) {
          $1.bestsym = $1.litmask;
          $1.bestscore = $1.score;
        }
      });
      $1.pixs = $1.bestsym;
    }
    var _Tr = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["dotty", true],
      ["pixs", $1.pixs],
      ["pixx", $1.columns],
      ["pixy", $1.rows],
      ["height", $1.rows * 2 / 72],
      ["width", $1.columns * 2 / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _Tr;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_ultracode() {
    var $1 = Object.create(bwipp_ultracode.$ctx || (bwipp_ultracode.$ctx = {}));
    $1.dontdraw = false;
    $1.eclevel = "EC2";
    $1.parse = false;
    $1.parsefnc = false;
    $1.start = 257;
    $1.link1 = 0;
    $1.raw = false;
    $1.rev = 2;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _2 = $1.rev;
    if (_2 != 1 && _2 != 2) {
      $k[$j++] = "bwipp.ultracodeInvalidRevision#25672";
      $k[$j++] = "Valid revisions are 1 and 2";
      bwipp_raiseerror();
    }
    var _4 = $1.eclevel.length == 3;
    $k[$j++] = _4;
    if (_4) {
      $j--;
      $k[$j++] = $geti($1.eclevel, 0, 2);
      if ($eq("EC", "EC")) {
        $j--;
        var _9 = $get($1.eclevel, 2) - 48;
        var _B = $1.rev == 2 ? 1 : 0;
        $k[$j++] = _9 >= _B && _9 <= 5;
      }
    }
    if ($nt($k[--$j])) {
      $k[$j++] = "bwipp.ultracodeInvalidErrorCorrectionLevel#25681";
      $k[$j++] = "Valid error correction levels are EC1 to EC5, and EC0 for legacy revision 1";
      bwipp_raiseerror();
    }
    if ($1.raw) {
      $1.dcws = $a($1.barcode.length);
      $1.i = 0;
      $1.j = 0;
      for (; ; ) {
        if ($1.i == $1.barcode.length) {
          break;
        }
        $1.cw = $cvi($geti($1.barcode, $1.i + 1, 3));
        $put($1.dcws, $1.j, $1.cw);
        $1.i = $1.i + 4;
        $1.j = $1.j + 1;
      }
      $1.dcws = $geti($1.dcws, 0, $1.j);
    } else {
      $1.fn1 = -1;
      $1.fn3 = -2;
      var _X = /* @__PURE__ */ new Map([
        ["parse", $1.parse],
        ["parsefnc", $1.parsefnc],
        ["FNC1", $1.fn1],
        ["FNC3", $1.fn3]
      ]);
      $1.fncvals = _X;
      $k[$j++] = "msg";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.fncvals;
      bwipp_parseinput();
      var _a = $k[--$j];
      $1[$k[--$j]] = _a;
      $1.msglen = $1.msg.length;
      $1.scr = $a([]);
      $1.scp = $a([]);
      $k[$j++] = Infinity;
      $aload($1.scr);
      $aload($1.scp);
      $forall($1.msg, function() {
        var _i = $k[--$j];
        $k[$j++] = _i;
        if (_i == $1.fn1) {
          $j--;
          $k[$j++] = 268;
        }
        var _k = $k[--$j];
        $k[$j++] = _k;
        if (_k == $1.fn3) {
          $j--;
          $k[$j++] = 269;
        }
      });
      $1.dcws = $a();
    }
    var _o = $get($1.options, "debugcws") !== void 0;
    if (_o) {
      $k[$j++] = "bwipp.debugcws#25725";
      $k[$j++] = $1.dcws;
      bwipp_raiseerror();
    }
    $1.mcc = $1.dcws.length + 3;
    $1.eclval = $get($1.eclevel, 2) - 48;
    if ($1.eclval != 0) {
      $k[$j++] = "qcc";
      $k[$j++] = $get($a([0, 1, 2, 4, 6, 8]), $1.eclval);
      $k[$j++] = ~~($1.mcc / 25);
      if ($1.mcc % 25 != 0) {
        var _z = $k[--$j];
        $k[$j++] = $f(_z + 1);
      }
      var _10 = $k[--$j];
      var _11 = $k[--$j];
      $1[$k[--$j]] = $f(_11 * _10 + 5);
    } else {
      $1.qcc = 3;
    }
    $1.acc = $1.qcc - 3 + 78 * $1.link1;
    $1.tcc = $1.mcc + $1.qcc;
    if (!bwipp_ultracode.__25747__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.metrics = $a([$a([2, 7, 37, 5]), $a([3, 36, 84, 13]), $a([4, 85, 161, 22]), $a([5, 142, 282, 29])]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_ultracode.$ctx[id] = $ctx[id]);
        bwipp_ultracode.__25747__ = 1;
      })();
    }
    var _1D = $1.metrics;
    for (var _1E = 0, _1F = _1D.length; _1E < _1F; _1E++) {
      $1.m = $get(_1D, _1E);
      $1.rows = $get($1.m, 0);
      $1.minc = $get($1.m, 1);
      $1.maxc = $get($1.m, 2);
      $1.mcol = $get($1.m, 3);
      $1.okay = true;
      if ($1.tcc < $1.minc || $1.tcc > $1.maxc) {
        $1.okay = false;
      }
      if ($1.okay) {
        break;
      }
    }
    if (!$1.okay) {
      $k[$j++] = "bwipp.ultracodeNoValidSymbol#25761";
      $k[$j++] = "Maximum length exceeded or invalid content";
      bwipp_raiseerror();
    }
    for (var _1W = $1.mcol; _1W <= 61; _1W += 1) {
      $1.columns = _1W;
      $k[$j++] = $1.columns;
      if ($1.columns >= 15) {
        var _1Z = $k[--$j];
        $k[$j++] = $f(_1Z - 1);
      }
      if ($1.columns >= 31) {
        var _1b = $k[--$j];
        $k[$j++] = $f(_1b - 1);
      }
      if ($1.columns >= 47) {
        var _1d = $k[--$j];
        $k[$j++] = $f(_1d - 1);
      }
      var _1h = $f($f($k[--$j] * $1.rows - 3) - $1.tcc);
      $k[$j++] = _1h;
      if (_1h >= 0) {
        $1.pads = $k[--$j];
        break;
      }
      $j--;
    }
    $1.dcc = $f($1.columns - $1.mcol);
    $k[$j++] = Infinity;
    $k[$j++] = $1.start;
    $k[$j++] = $1.mcc;
    $k[$j++] = $1.acc;
    $aload($1.dcws);
    for (var _1q = 0, _1r = $1.qcc; _1q < _1r; _1q++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.rsseq = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _1t = 0, _1u = 282; _1t < _1u; _1t++) {
      var _1v = $k[--$j];
      $k[$j++] = _1v;
      $k[$j++] = _1v * 3 % 283;
    }
    $1.rsalog = $a();
    $1.rslog = $a(283);
    for (var _1y = 1; _1y <= 282; _1y += 1) {
      $put($1.rslog, $get($1.rsalog, _1y), _1y);
    }
    $1.rsprod = function() {
      var _22 = $k[--$j];
      var _23 = $k[--$j];
      $k[$j++] = _23;
      $k[$j++] = _22;
      if (_22 != 0 && _23 != 0) {
        var _26 = $get($1.rslog, $k[--$j]);
        var _2B = $get($1.rsalog, $f(_26 + $get($1.rslog, $k[--$j])) % 282);
        $k[$j++] = _2B;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $1.n = $1.mcc;
    $1.k = $1.qcc;
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _2F = 0, _2G = $1.k; _2F < _2G; _2F++) {
      $k[$j++] = 0;
    }
    $1.coeffs = $a();
    for (var _2K = 1, _2J = $1.k; _2K <= _2J; _2K += 1) {
      $1.i = _2K;
      $put($1.coeffs, $1.i, $get($1.coeffs, $1.i - 1));
      for (var _2R = $1.i - 1; _2R >= 1; _2R -= 1) {
        $1.j = _2R;
        $k[$j++] = $1.coeffs;
        $k[$j++] = $1.j;
        $k[$j++] = $get($1.coeffs, $1.j - 1);
        $k[$j++] = $get($1.coeffs, $1.j);
        $k[$j++] = $get($1.rsalog, $1.i);
        $1.rsprod();
        var _2d = $k[--$j];
        var _2e = $k[--$j];
        var _2f = $k[--$j];
        $put($k[--$j], _2f, $f(_2e + _2d) % 283);
      }
      $k[$j++] = $1.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($1.coeffs, 0);
      $k[$j++] = $get($1.rsalog, $1.i);
      $1.rsprod();
      var _2n = $k[--$j];
      var _2o = $k[--$j];
      $put($k[--$j], _2o, _2n);
    }
    $1.coeffs = $geti($1.coeffs, 0, $1.coeffs.length - 1);
    for (var _2u = $1.coeffs.length - 1; _2u >= 0; _2u -= 2) {
      var _2v = $1.coeffs;
      $put(_2v, _2u, $f(283 - $get(_2v, _2u)));
    }
    for (var _2z = 0, _2y = $1.n - 1; _2z <= _2y; _2z += 1) {
      $1.t = $f($get($1.rsseq, _2z) + $get($1.rsseq, $1.n)) % 283;
      for (var _37 = 0, _36 = $1.k - 1; _37 <= _36; _37 += 1) {
        $1.j = _37;
        $put($1.rsseq, $1.n + $1.j, $f($get($1.rsseq, $1.n + $1.j + 1) + $f(283 - $1.t * $get($1.coeffs, $1.k - $1.j - 1) % 283)) % 283);
      }
    }
    for (var _3O = $1.n, _3N = $1.n + $1.k; _3O <= _3N; _3O += 1) {
      $put($1.rsseq, _3O, $f(283 - $get($1.rsseq, _3O)) % 283);
    }
    $1.ecws = $geti($1.rsseq, $1.n, $1.k);
    var _3X = $get($1.options, "debugecc") !== void 0;
    if (_3X) {
      $k[$j++] = "bwipp.debugecc#25829";
      $k[$j++] = $1.ecws;
      bwipp_raiseerror();
    }
    if (!bwipp_ultracode.__25888__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.tiles = $a([13135, 13136, 13153, 13156, 13163, 13165, 13513, 13515, 13516, 13531, 13535, 13536, 13561, 13563, 13565, 13613, 13615, 13616, 13631, 13635, 13636, 13651, 13653, 13656, 15135, 15136, 15153, 15163, 15165, 15313, 15315, 15316, 15351, 15353, 15356, 15361, 15363, 15365, 15613, 15615, 15616, 15631, 15635, 15636, 15651, 15653, 15656, 16135, 16136, 16153, 16156, 16165, 16313, 16315, 16316, 16351, 16353, 16356, 16361, 16363, 16365, 16513, 16515, 16516, 16531, 16535, 16536, 16561, 16563, 16565, 31315, 31316, 31351, 31356, 31361, 31365, 31513, 31515, 31516, 31531, 31535, 31536, 31561, 31563, 31565, 31613, 31615, 31631, 31635, 31636, 31651, 31653, 31656, 35131, 35135, 35136, 35151, 35153, 35156, 35161, 35163, 35165, 35315, 35316, 35351, 35356, 35361, 35365, 35613, 35615, 35616, 35631, 35635, 35636, 35651, 35653, 35656, 36131, 36135, 36136, 36151, 36153, 36156, 36163, 36165, 36315, 36316, 36351, 36356, 36361, 36365, 36513, 36515, 36516, 36531, 36535, 36536, 36561, 36563, 36565, 51313, 51315, 51316, 51351, 51353, 51356, 51361, 51363, 51365, 51513, 51516, 51531, 51536, 51561, 51563, 51613, 51615, 51616, 51631, 51635, 51636, 51651, 51653, 51656, 53131, 53135, 53136, 53151, 53153, 53156, 53161, 53163, 53165, 53513, 53516, 53531, 53536, 53561, 53563, 53613, 53615, 53616, 53631, 53635, 53636, 53651, 53653, 53656, 56131, 56135, 56136, 56151, 56153, 56156, 56161, 56163, 56165, 56313, 56315, 56316, 56351, 56353, 56356, 56361, 56363, 56365, 56513, 56516, 56531, 56536, 56561, 56563, 61313, 61315, 61316, 61351, 61353, 61356, 61361, 61363, 61365, 61513, 61515, 61516, 61531, 61535, 61536, 61561, 61563, 61565, 61615, 61631, 61635, 61651, 61653, 63131, 63135, 63136, 63151, 63153, 63156, 63161, 63163, 63165, 63513, 63515, 63516, 63531, 63535, 63536, 63561, 63563, 63565, 63613, 63615, 63631, 63635, 63651, 63653, 65131, 65135, 65136, 65151, 65153, 65156, 65161, 65163, 65165, 65313, 65315, 65316, 65351, 65353, 65356, 65361, 65363, 65365, 65613, 65615, 65631, 65635, 65651, 65653, 56565, 51515]);
        $ctx.dccurev1 = $a([51363, 51563, 51653, 53153, 53163, 53513, 53563, 53613, 53653, 56153, 56163, 56313, 56353, 56363, 56513, 56563, 51316, 51356, 51536, 51616, 53156, 53516, 53536, 53616, 53636, 53656, 56136, 56156, 56316, 56356, 56516, 56536]);
        $ctx.dcclrev1 = $a([61351, 61361, 61531, 61561, 61631, 61651, 63131, 63151, 63161, 63531, 63561, 63631, 65131, 65161, 65351, 65631, 31351, 31361, 31531, 31561, 31631, 31651, 35131, 35151, 35161, 35361, 35631, 35651, 36131, 36151, 36351, 36531]);
        $ctx.dccurev2 = $a([15316, 16316, 13516, 16516, 13616, 15616, 13136, 15136, 16136, 13536, 16536, 13636, 13156, 16156, 15356, 13656, 15313, 16313, 13513, 16513, 13613, 15613, 13153, 15153, 16153, 16353, 13653, 15653, 13163, 15163, 15363, 13563]);
        $ctx.dcclrev2 = $a([36315, 36515, 35615, 35135, 36135, 31535, 36535, 31635, 35635, 35165, 36165, 31365, 35365, 36365, 31565, 36565, 61315, 65315, 63515, 61615, 65135, 61535, 63535, 61635, 63635, 65635, 63165, 65165, 61365, 65365, 61565, 63565]);
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_ultracode.$ctx[id] = $ctx[id]);
        bwipp_ultracode.__25888__ = 1;
      })();
    }
    $k[$j++] = "dccu";
    if ($1.rev == 1) {
      $k[$j++] = $1.dccurev1;
    } else {
      $k[$j++] = $1.dccurev2;
    }
    var _3i = $k[--$j];
    $1[$k[--$j]] = _3i;
    $k[$j++] = "dccl";
    if ($1.rev == 1) {
      $k[$j++] = $1.dcclrev1;
    } else {
      $k[$j++] = $1.dcclrev2;
    }
    var _3n = $k[--$j];
    $1[$k[--$j]] = _3n;
    $1.rows = $f($1.rows * 6 + 1);
    $1.columns = $1.columns + 6;
    $k[$j++] = Infinity;
    for (var _3t = 0, _3u = $1.rows * $1.columns; _3t < _3u; _3t++) {
      $k[$j++] = -1;
    }
    $1.pixs = $a();
    $1.qmv = function() {
      var _3x = $k[--$j];
      var _3y = $k[--$j];
      $k[$j++] = $f(_3y + _3x * $1.columns);
    };
    for (var _41 = 0, _40 = $1.columns - 1; _41 <= _40; _41 += 1) {
      $1.i = _41;
      for (var _44 = 0, _43 = $f($1.rows - 1); _44 <= _43; _44 += 6) {
        $1.j = _44;
        if ($1.i >= 5) {
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.qmv();
          var _4A = $k[--$j];
          $put($k[--$j], _4A, $1.i % 2 * 9);
        }
      }
      $k[$j++] = $1.pixs;
      $k[$j++] = $1.i;
      $k[$j++] = 0;
      $1.qmv();
      var _4E = $k[--$j];
      $put($k[--$j], _4E, 9);
      $k[$j++] = $1.pixs;
      $k[$j++] = $1.i;
      $k[$j++] = $f($1.rows - 1);
      $1.qmv();
      var _4J = $k[--$j];
      $put($k[--$j], _4J, 9);
    }
    for (var _4N = 1, _4M = $f($1.rows - 2); _4N <= _4M; _4N += 1) {
      $1.i = _4N;
      for (var _4Q = 3, _4P = $1.columns - 1; _4Q <= _4P; _4Q += 16) {
        $1.j = _4Q;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.j;
        $k[$j++] = $1.i;
        $1.qmv();
        var _4V = $k[--$j];
        $put($k[--$j], _4V, (1 - $1.i % 2) * 9);
      }
      $k[$j++] = $1.pixs;
      $k[$j++] = 0;
      $k[$j++] = $1.i;
      $1.qmv();
      var _4Z = $k[--$j];
      $put($k[--$j], _4Z, 9);
      $k[$j++] = $1.pixs;
      $k[$j++] = 1;
      $k[$j++] = $1.i;
      $1.qmv();
      var _4e = $k[--$j];
      $put($k[--$j], _4e, (1 - $1.i % 2) * 9);
      $k[$j++] = $1.pixs;
      $k[$j++] = 2;
      $k[$j++] = $1.i;
      $1.qmv();
      var _4i = $k[--$j];
      $put($k[--$j], _4i, 0);
      $k[$j++] = $1.pixs;
      $k[$j++] = 3;
      $k[$j++] = $1.i;
      $1.qmv();
      var _4m = $k[--$j];
      $put($k[--$j], _4m, 9);
      $k[$j++] = $1.pixs;
      $k[$j++] = 4;
      $k[$j++] = $1.i;
      $1.qmv();
      var _4q = $k[--$j];
      $put($k[--$j], _4q, 0);
      $k[$j++] = $1.pixs;
      $k[$j++] = $1.columns - 1;
      $k[$j++] = $1.i;
      $1.qmv();
      var _4v = $k[--$j];
      $put($k[--$j], _4v, 9);
    }
    $1.i = ~~($1.rows / 2) - 5;
    $k[$j++] = Infinity;
    var _52 = $cvrs($s(5), $get($1.dccu, $1.dcc), 10);
    for (var _53 = 0, _54 = _52.length; _53 < _54; _53++) {
      $k[$j++] = $get(_52, _53) - 48;
    }
    var _5A = $cvrs($s(5), $get($1.dccl, $1.dcc), 10);
    $k[$j++] = 0;
    for (var _5B = 0, _5C = _5A.length; _5B < _5C; _5B++) {
      $k[$j++] = $get(_5A, _5B) - 48;
    }
    var _5E = $a();
    for (var _5F = 0, _5G = _5E.length; _5F < _5G; _5F++) {
      $k[$j++] = $get(_5E, _5F);
      $k[$j++] = $1.pixs;
      $k[$j++] = 2;
      $k[$j++] = $1.i;
      $1.qmv();
      var _5K = $k[--$j];
      var _5L = $k[--$j];
      $put(_5L, _5K, $k[--$j]);
      $1.i = $1.i + 1;
    }
    $k[$j++] = Infinity;
    $k[$j++] = $1.start;
    $k[$j++] = $1.mcc;
    $aload($1.ecws);
    $k[$j++] = $1.tcc;
    $k[$j++] = 283;
    $k[$j++] = $1.acc;
    $aload($1.dcws);
    for (var _5V = 0, _5W = $1.pads; _5V < _5W; _5V++) {
      $k[$j++] = 284;
    }
    $k[$j++] = $1.qcc;
    $1.tileseq = $a();
    $1.x = 5;
    $1.y = 1;
    var _5Z = $1.tileseq;
    for (var _5a = 0, _5b = _5Z.length; _5a < _5b; _5a++) {
      var _5g = $cvrs($s(5), $get($1.tiles, $get(_5Z, _5a)), 10);
      for (var _5h = 0, _5i = _5g.length; _5h < _5i; _5h++) {
        $k[$j++] = $get(_5g, _5h);
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $1.qmv();
        var _5n = $k[--$j];
        var _5o = $k[--$j];
        $put(_5o, _5n, $f($k[--$j] - 48));
        $1.y = $1.y + 1;
      }
      if ($1.y != $f($1.rows - 1)) {
        $1.y = $1.y + 1;
      } else {
        $1.x = $1.x + 1;
        $1.y = 1;
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $1.qmv();
        var _5y = $k[--$j];
        if ($get($k[--$j], _5y) != -1) {
          $1.x = $1.x + 1;
        }
      }
    }
    if (!bwipp_ultracode.__25970__) {
      (function() {
        var $ctx = Object.create($1);
        var _62 = /* @__PURE__ */ new Map([
          [0, "FFFFFF"],
          [9, "000000"],
          [1, "00FFFF"],
          [3, "FF00FF"],
          [5, "FFFF00"],
          [6, "00FF00"]
        ]);
        $ctx.colormap = _62;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_ultracode.$ctx[id] = $ctx[id]);
        bwipp_ultracode.__25970__ = 1;
      })();
    }
    var _6B = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.columns],
      ["pixy", $1.rows],
      ["height", $1.rows / 72 * 2],
      ["width", $1.columns / 72 * 2],
      ["colormap", $1.colormap],
      ["opt", $1.options]
    ]);
    $k[$j++] = _6B;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_jabcode() {
    var $1 = Object.create(bwipp_jabcode.$ctx || (bwipp_jabcode.$ctx = {}));
    $1.dontdraw = false;
    $1.rows = -1;
    $1.columns = -1;
    $1.slave = false;
    $1.colors = 16;
    $1.eclevel = 6;
    $1.raw = false;
    $1.parse = false;
    $1.parsefnc = false;
    $1.mask = -1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $1.databpm = ~~Math.round(Math.log($1.colors) / Math.log(2));
    var _3 = $1.colors;
    $k[$j++] = "metabpm";
    $k[$j++] = _3;
    if (_3 > 8) {
      $j--;
      $k[$j++] = 8;
    }
    var _4 = $k[--$j];
    $1[$k[--$j]] = ~~Math.round(Math.log(_4) / Math.log(2));
    $1.fn1 = -1;
    var _9 = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parsefnc", $1.parsefnc],
      ["FNC1", $1.fn1]
    ]);
    $1.fncvals = _9;
    $k[$j++] = "msg";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _C = $k[--$j];
    $1[$k[--$j]] = _C;
    $1.msglen = $1.msg.length;
    $1.addtobits = function() {
      var _F = $k[--$j];
      $puti($1.bits, $1.j, _F);
      $1.j = _F.length + $1.j;
    };
    $1.tofixedbits = function() {
      var _K = $strcpy($s(13), "0000000000000");
      var _L = $k[--$j];
      var _O = $cvrs($s(13), $k[--$j], 2);
      $puti(_K, $f(_L - _O.length), _O);
      $k[$j++] = $geti(_K, 0, _L);
    };
    var _R = $1.msglen <= 15 ? 4 : 17;
    $1.bits = $s(7 + _R + $1.msglen * 8 + 12);
    $1.j = 0;
    $k[$j++] = 31;
    $k[$j++] = 5;
    $1.tofixedbits();
    $1.addtobits();
    $k[$j++] = "00";
    $1.addtobits();
    if ($1.msglen <= 15) {
      $k[$j++] = $1.msglen;
      $k[$j++] = 4;
      $1.tofixedbits();
      $1.addtobits();
    } else {
      $k[$j++] = "0000";
      $1.addtobits();
      $k[$j++] = $1.msglen - 16;
      $k[$j++] = 13;
      $1.tofixedbits();
      $1.addtobits();
    }
    for (var _Z = 0, _Y = $1.msglen - 1; _Z <= _Y; _Z += 1) {
      $k[$j++] = $get($1.msg, _Z);
      $k[$j++] = 8;
      $1.tofixedbits();
      $1.addtobits();
    }
    $k[$j++] = 28;
    $k[$j++] = 5;
    $1.tofixedbits();
    $1.addtobits();
    $k[$j++] = 31;
    $k[$j++] = 5;
    $1.tofixedbits();
    $1.addtobits();
    $k[$j++] = "11";
    $1.addtobits();
    $1.diffside = 21;
    $1.sameshape = false;
    $1.sameecc = false;
    $1.hasslaves = false;
    $1.metrics = function() {
      $1.mc = $k[--$j];
      $1.mr = $k[--$j];
      var _e = $1.mc;
      var _f = $1.mr;
      var _g = $1.mc;
      var _h = $1.mr;
      var _i = $1.colors;
      var _j = 64;
      if (64 > _i) {
        var _2 = _i;
        _i = _j;
        _j = _2;
      }
      var _l = $1.slave ? 7 : 17;
      $k[$j++] = _e * _f;
      $k[$j++] = ((~~($f(_g - 25) / 16) + 2) * (~~($f(_h - 25) / 16) + 2) - 4) * 7;
      $k[$j++] = _j * 2;
      $k[$j++] = _l * 4;
      if (!$1.slave) {
        var _p = $eq($1.mr, $1.mc) ? 0 : 1;
        $1.metass = _p;
        var _q = $1.mr;
        var _r = $1.mc;
        if ($lt(_q, _r)) {
          var _2 = _r;
          _r = _q;
          _q = _2;
        }
        $1.metavf = $get($a([0, 1, 2, 2, 3, 3, 3, 3]), ~~($f(_q - 21) / 16));
        $k[$j++] = "metavlen";
        if ($1.metass == 0) {
          $k[$j++] = $a([2, 2, 3, 4]);
        } else {
          $k[$j++] = $a([4, 6, 8, 10]);
        }
        var _z = $get($k[--$j], $1.metavf);
        $1[$k[--$j]] = _z;
        $1.metaelen = $f($1.metavf * 2 + 10);
        $k[$j++] = $f($f(7 + $1.metavlen) + $1.metaelen);
        if ($1.hasslaves) {
          var _15 = $k[--$j];
          $k[$j++] = $f(_15 + 4);
        }
        var _18 = ~~Math.ceil($k[--$j] * 2 / $1.metabpm);
        $1.nummetabits = $f(_18 * $1.metabpm + 6);
        $k[$j++] = _18 + 6;
      } else {
        $k[$j++] = 3;
        if (!$1.sameshape) {
          var _1B = $k[--$j];
          $k[$j++] = $f(_1B + 5);
        }
        if ($1.hasslaves) {
          var _1D = $k[--$j];
          $k[$j++] = $f(_1D + 3);
        }
        if (!$1.sameecc) {
          var _1F = $1.mr;
          var _1G = $1.mc;
          if ($lt(_1F, _1G)) {
            var _2 = _1G;
            _1G = _1F;
            _1F = _2;
          }
          var _1J = $k[--$j];
          $k[$j++] = $f(_1J + $get($a([10, 12, 14, 14, 16, 16, 16, 16]), ~~($f(_1F - 21) / 16)));
        }
        var _1M = ~~Math.ceil($k[--$j] * 2 / $1.metabpm);
        $1.nummetabits = _1M * $1.metabpm;
        $k[$j++] = _1M;
      }
      var _1O = $k[--$j];
      $1.nummetamodules = _1O;
      var _1P = $k[--$j];
      var _1Q = $k[--$j];
      var _1R = $k[--$j];
      $1.numdatamodules = $f($k[--$j] - $f(_1R + $f(_1Q + $f(_1P + _1O))));
      $1.numdatabits = $1.numdatamodules * $1.databpm;
    };
    $1.coderate = $get($a([0.67, 0.63, 0.57, 0.55, 0.5, 0.43, 0.34, 0.25, 0.2, 0.17, 0.14]), $1.eclevel);
    $1.grosslen = ~~Math.ceil($1.bits.length / $1.coderate);
    $1.snapsize = function() {
      var _1b = ~~Math.ceil($k[--$j]) - 18;
      $k[$j++] = _1b;
      if (_1b < 0) {
        $j--;
        $k[$j++] = 0;
      }
      var _1c = $k[--$j];
      $k[$j++] = ~~(_1c / 4) * 4 + 21;
    };
    if ($1.rows == -1 && $1.columns == -1) {
      $k[$j++] = "size";
      $k[$j++] = Math.sqrt($1.grosslen);
      $1.snapsize();
      var _1g = $k[--$j];
      $1[$k[--$j]] = _1g;
      for (; ; ) {
        $k[$j++] = $1.size;
        $k[$j++] = $1.size;
        $1.metrics();
        if ($1.grosslen <= $1.numdatabits) {
          break;
        }
        $1.size = $f($1.size + 4);
      }
      $1.rows = $1.size;
      $1.columns = $1.size;
    } else {
      if ($1.columns == -1 && $1.rows != -1) {
        $k[$j++] = "columns";
        $k[$j++] = $1.grosslen / $1.rows;
        $1.snapsize();
        var _1t = $k[--$j];
        $1[$k[--$j]] = _1t;
        for (; ; ) {
          $k[$j++] = $1.rows;
          $k[$j++] = $1.columns;
          $1.metrics();
          if ($1.grosslen <= $1.numdatabits) {
            break;
          }
          $1.columns = $f($1.columns + 4);
        }
      }
      if ($1.rows == -1 && $1.columns != -1) {
        $k[$j++] = "rows";
        $k[$j++] = $1.grosslen / $1.columns;
        $1.snapsize();
        var _24 = $k[--$j];
        $1[$k[--$j]] = _24;
        for (; ; ) {
          $k[$j++] = $1.rows;
          $k[$j++] = $1.columns;
          $1.metrics();
          if ($1.grosslen <= $1.numdatabits) {
            break;
          }
          $1.rows = $f($1.rows + 4);
        }
      }
      if ($1.rows != -1 && $1.columns != -1) {
        $k[$j++] = $1.rows;
        $k[$j++] = $1.columns;
        $1.metrics();
      }
    }
    $1.C = $1.numdatabits;
    $1.cols = $1.columns;
    if ($1.rows > 145 || $1.cols > 145) {
      $k[$j++] = "bwipp.jabcodeNoValidSymbol#26182";
      $k[$j++] = "Maximum length exceeded or invalid content";
      bwipp_raiseerror();
    }
    $1.min = $1.C;
    for (var _2K = 3; _2K <= 8; _2K += 1) {
      $1.i = _2K;
      for (var _2M = $1.i + 1; _2M <= 9; _2M += 1) {
        $1.j = _2M;
        $1.dist = ~~($1.C / $1.j) * $1.j - ~~($1.C / $1.j) * $1.i - $1.bits.length;
        if ($1.dist < $1.min && $1.dist >= 0) {
          $1.datawc = $1.i;
          $1.datawr = $1.j;
          $1.min = $1.dist;
        }
      }
    }
    $1.tmpbits = $s(~~($1.C / $1.datawr) * $1.datawr - ~~($1.C / $1.datawr) * $1.datawc);
    $puti($1.tmpbits, 0, $1.bits);
    for (var _2m = $1.bits.length, _2l = $1.tmpbits.length - 1; _2m <= _2l; _2m += 1) {
      var _2o = $get($1.tmpbits, _2m - 1);
      $k[$j++] = _2m;
      $k[$j++] = _2o;
      if (_2o % 2 == 0) {
        var _2p = $k[--$j];
        $k[$j++] = $f(_2p + 1);
      } else {
        var _2q = $k[--$j];
        $k[$j++] = $f(_2q - 1);
      }
      var _2s = $k[--$j];
      $put($1.tmpbits, $k[--$j], _2s);
    }
    $1.bits = $1.tmpbits;
    $1.m0 = 22609 + 1;
    $1.m1 = 62509 - 65536;
    $1.m2 = 19605;
    $1.m3 = 32557;
    $1.lcg64_temper = function() {
      $1.p00 = $1.m0 * $1.s0;
      $1.p01 = $1.m0 * $1.s1;
      $1.p02 = $1.m0 * $1.s2;
      $1.p03 = $1.m0 * $1.s3;
      $1.p10 = $1.m1 * $1.s0;
      $1.p11 = $1.m1 * $1.s1;
      $1.p12 = $1.m1 * $1.s2;
      $1.p13 = $1.m1 * $1.s3;
      $1.p20 = $1.m2 * $1.s0;
      $1.p21 = $1.m2 * $1.s1;
      $1.p22 = $1.m2 * $1.s2;
      $1.p23 = $1.m2 * $1.s3;
      $1.p30 = $1.m3 * $1.s0;
      $1.p31 = $1.m3 * $1.s1;
      $1.p32 = $1.m3 * $1.s2;
      $1.p33 = $1.m3 * $1.s3;
      $1.s3 = $1.p33 % 65536 + 1;
      $1.s2 = $1.p32 % 65536 + ~~($1.p33 / 65536) + $1.p23 % 65536;
      $1.s1 = $1.p31 % 65536 + ~~($1.p32 / 65536) + ($1.p22 % 65536 + ~~($1.p23 / 65536)) + $1.p13 % 65536;
      $1.s0 = $1.p30 % 65536 + ~~($1.p31 / 65536) + ($1.p21 % 65536 + ~~($1.p22 / 65536)) + ($1.p12 % 65536 + ~~($1.p13 / 65536)) + $1.p03 % 65536;
      $1.s3 = $1.s3 + 65536;
      $1.s2 = $1.s2 + 65535;
      $1.s1 = $1.s1 + 65535;
      $1.s0 = $1.s0 + 65535;
      $1.s2 = ~~($1.s3 / 65536) + $1.s2;
      $1.s3 = $1.s3 % 65536;
      $1.s1 = ~~($1.s2 / 65536) + $1.s1;
      $1.s2 = $1.s2 % 65536;
      $1.s0 = ~~($1.s1 / 65536) + $1.s0;
      $1.s1 = $1.s1 % 65536;
      $1.s0 = $1.s0 % 65536;
      var _3x = (($1.s0 - 32768) * 65536 + $1.s1 ^ 2147483648) & 4294967295;
      var _3y = _3x ^ _3x >>> 11;
      var _3z = _3y ^ _3y << 7 & -1658038656;
      var _40 = (_3z ^ _3z << 15 & -272236544) & 4294967295;
      $k[$j++] = _40 ^ _40 >>> 18;
    };
    $1.createMatrixA = function() {
      $k[$j++] = "nb_pcb";
      if ($1.wr < 4) {
        $k[$j++] = ~~($1.Pg_sub_block / 2);
      } else {
        $k[$j++] = ~~($1.Pg_sub_block / $1.wr) * $1.wc;
      }
      var _46 = $k[--$j];
      $1[$k[--$j]] = _46;
      $1.offset = ~~Math.ceil($1.Pg_sub_block / 32);
      $1.effwidth = $1.offset * 32;
      $1.matrixA = $a($1.offset * $1.nb_pcb);
      for (var _4G = 0, _4F = $1.offset * $1.nb_pcb - 1; _4G <= _4F; _4G += 1) {
        $put($1.matrixA, _4G, 0);
      }
      $1.permutation = $a($1.Pg_sub_block);
      for (var _4M = 0, _4L = $1.Pg_sub_block - 1; _4M <= _4L; _4M += 1) {
        $put($1.permutation, _4M, _4M);
      }
      for (var _4R = 0, _4Q = ~~($1.Pg_sub_block / $1.wr) - 1; _4R <= _4Q; _4R += 1) {
        $1.i = _4R;
        for (var _4U = 0, _4T = $f($1.wr - 1); _4U <= _4T; _4U += 1) {
          $1.j = _4U;
          var _4V = $1.matrixA;
          var _4W = $1.i;
          var _4X = $1.effwidth;
          var _4Y = $1.wr;
          var _4Z = $1.j;
          var _4f = $f(31 - $f($1.i * $f($1.effwidth + $1.wr) + $1.j) % 32);
          $put(_4V, ~~($f(_4W * $f(_4X + _4Y) + _4Z) / 32), $get(_4V, ~~($f(_4W * $f(_4X + _4Y) + _4Z) / 32)) | (_4f < 0 ? 1 >>> -_4f : 1 << _4f));
        }
      }
      $1.s0 = 0;
      $1.s1 = 0;
      $1.s2 = 11;
      $1.s3 = 64569;
      for (var _4i = 1, _4h = $f($1.wc - 1); _4i <= _4h; _4i += 1) {
        $1.i = _4i;
        $1.off_index = ~~($1.Pg_sub_block / $1.wr) * $1.i;
        for (var _4o = 0, _4n = $1.Pg_sub_block - 1; _4o <= _4n; _4o += 1) {
          $1.j = _4o;
          $1.lcg64_temper();
          var _4p = $k[--$j];
          $k[$j++] = _4p;
          if (_4p < 0) {
            var _4q = $k[--$j];
            $k[$j++] = $f((_4q ^ 2147483648) + 2147483648);
          }
          $1.pos = ~~($k[--$j] / 4294967296 * ($1.Pg_sub_block - $1.j));
          for (var _4x = 0, _4w = ~~($1.Pg_sub_block / $1.wr) - 1; _4x <= _4w; _4x += 1) {
            $1.k = _4x;
            var _4y = $1.matrixA;
            var _4z = $1.off_index;
            var _50 = $1.k;
            var _51 = $1.offset;
            var _52 = $1.j;
            var _5A = $get($1.matrixA, ~~($get($1.permutation, $1.pos) / 32) + $1.k * $1.offset);
            var _5E = -$f(31 - $get($1.permutation, $1.pos) % 32);
            var _5G = 31 - $1.j % 32;
            $put(_4y, (_4z + _50) * _51 + ~~(_52 / 32), $get(_4y, (_4z + _50) * _51 + ~~(_52 / 32)) | (_5G < 0 ? ((_5E < 0 ? _5A >>> -_5E : _5A << _5E) & 1) >>> -_5G : ((_5E < 0 ? _5A >>> -_5E : _5A << _5E) & 1) << _5G));
          }
          var _5J = $1.permutation;
          var _5K = $1.Pg_sub_block;
          var _5L = $1.j;
          $put(_5J, _5K - 1 - _5L, $get($1.permutation, $1.pos));
          $put($1.permutation, $1.pos, $get(_5J, _5K - 1 - _5L));
        }
      }
    };
    $1.createMetadataMatrixA = function() {
      $1.nb_pcb = ~~($1.Pg_sub_block / 2);
      $1.offset = ~~Math.ceil($1.Pg_sub_block / 32);
      $1.matrixA = $a($1.offset * $1.nb_pcb);
      for (var _5Y = 0, _5X = $1.offset * $1.nb_pcb - 1; _5Y <= _5X; _5Y += 1) {
        $put($1.matrixA, _5Y, 0);
      }
      $1.permutation = $a($1.Pg_sub_block);
      for (var _5e = 0, _5d = $1.Pg_sub_block - 1; _5e <= _5d; _5e += 1) {
        $put($1.permutation, _5e, _5e);
      }
      $1.s0 = 0;
      $1.s1 = 0;
      $1.s2 = 0;
      $1.s3 = 38545;
      $1.nb_once = ~~(~~$f($1.nb_pcb / $1.wc * $1.Pg_sub_block + 3) / $1.nb_pcb);
      for (var _5m = 0, _5l = $1.nb_pcb - 1; _5m <= _5l; _5m += 1) {
        $1.i = _5m;
        for (var _5p = 0, _5o = $1.nb_once - 1; _5p <= _5o; _5p += 1) {
          $1.j = _5p;
          $1.lcg64_temper();
          var _5q = $k[--$j];
          $k[$j++] = _5q;
          if (_5q < 0) {
            var _5r = $k[--$j];
            $k[$j++] = $f((_5r ^ 2147483648) + 2147483648);
          }
          $1.pos = ~~($k[--$j] / 4294967296 * ($1.Pg_sub_block - $1.j));
          var _5v = $1.matrixA;
          var _5w = $1.i;
          var _5x = $1.offset;
          var _60 = $get($1.permutation, $1.pos);
          var _65 = $f(31 - $get($1.permutation, $1.pos) % 32);
          $put(_5v, _5w * _5x + ~~(_60 / 32), $get(_5v, _5w * _5x + ~~(_60 / 32)) | (_65 < 0 ? 1 >>> -_65 : 1 << _65));
          var _68 = $1.permutation;
          var _69 = $1.Pg_sub_block;
          var _6A = $1.j;
          $put(_68, _69 - 1 - _6A, $get($1.permutation, $1.pos));
          $put($1.permutation, $1.pos, $get(_68, _69 - 1 - _6A));
        }
      }
    };
    $1.GaussJordan = function() {
      $k[$j++] = "nb_pcb";
      if ($1.wr < 4) {
        $k[$j++] = ~~($1.Pg_sub_block / 2);
      } else {
        $k[$j++] = ~~($1.Pg_sub_block / $1.wr) * $1.wc;
      }
      var _6K = $k[--$j];
      $1[$k[--$j]] = _6K;
      $1.offset = ~~Math.ceil($1.Pg_sub_block / 32);
      var _6N = $1.matrixA;
      $1.matrixH = $arrcpy($a(_6N.length), _6N);
      $k[$j++] = Infinity;
      for (var _6R = 0, _6S = $1.Pg_sub_block; _6R < _6S; _6R++) {
        $k[$j++] = 0;
      }
      $1.column_arrangement = $a();
      $k[$j++] = Infinity;
      for (var _6V = 0, _6W = $1.Pg_sub_block; _6V < _6W; _6V++) {
        $k[$j++] = false;
      }
      $1.processed_column = $a();
      $k[$j++] = Infinity;
      for (var _6Z = 0, _6a = $1.nb_pcb; _6Z < _6a; _6Z++) {
        $k[$j++] = 0;
      }
      $1.zero_lines_nb = $a();
      $k[$j++] = Infinity;
      for (var _6d = 0, _6e = $1.Pg_sub_block * 2; _6d < _6e; _6d++) {
        $k[$j++] = 0;
      }
      $1.swap_col = $a();
      $1.zero_lines = 0;
      $1.loop0 = 0;
      for (var _6i = 0, _6h = $1.nb_pcb - 1; _6i <= _6h; _6i += 1) {
        $1.i = _6i;
        $1.pivot_column = $1.Pg_sub_block + 1;
        for (var _6m = 0, _6l = $1.Pg_sub_block - 1; _6m <= _6l; _6m += 1) {
          $1.j = _6m;
          var _6r = $get($1.matrixH, ~~(($1.offset * 32 * $1.i + $1.j) / 32));
          var _6v = -(31 - ($1.offset * 32 * $1.i + $1.j) % 32);
          if (((_6v < 0 ? _6r >>> -_6v : _6r << _6v) & 1) == 1) {
            $1.pivot_column = $1.j;
            break;
          }
        }
        if ($1.pivot_column < $1.Pg_sub_block) {
          $put($1.processed_column, $1.pivot_column, true);
          $put($1.column_arrangement, $1.pivot_column, $1.i);
          if ($1.pivot_column >= $1.nb_pcb) {
            $put($1.swap_col, $1.loop0 * 2, $1.pivot_column);
            $1.loop0 = $1.loop0 + 1;
          }
          $1.off_index = ~~($1.pivot_column / 32);
          $1.off_index1 = $1.pivot_column % 32;
          for (var _7E = 0, _7D = $1.nb_pcb - 1; _7E <= _7D; _7E += 1) {
            $1.j = _7E;
            if ($1.i != $1.j) {
              var _7L = $get($1.matrixH, $1.off_index + $1.j * $1.offset);
              var _7N = -(31 - $1.off_index1);
              if (((_7N < 0 ? _7L >>> -_7N : _7L << _7N) & 1) == 1) {
                for (var _7Q = 0, _7P = $1.offset - 1; _7Q <= _7P; _7Q += 1) {
                  $1.k = _7Q;
                  var _7R = $1.matrixH;
                  var _7S = $1.offset;
                  var _7T = $1.j;
                  var _7U = $1.k;
                  $put(_7R, _7S * _7T + _7U, $xo($get(_7R, _7S * _7T + _7U), $get($1.matrixH, $1.offset * $1.i + $1.k)));
                }
              }
            }
          }
        } else {
          $put($1.zero_lines_nb, $1.zero_lines, $1.i);
          $1.zero_lines = $1.zero_lines + 1;
        }
      }
      $1.matrix_rank = $1.nb_pcb - $1.zero_lines;
      $1.loop2 = 0;
      for (var _7k = $1.matrix_rank, _7j = $1.nb_pcb - 1; _7k <= _7j; _7k += 1) {
        $1.i = _7k;
        if ($get($1.column_arrangement, $1.i) > 0) {
          for (var _7q = 0, _7p = $1.nb_pcb - 1; _7q <= _7p; _7q += 1) {
            $1.j = _7q;
            if ($nt($get($1.processed_column, $1.j))) {
              $put($1.column_arrangement, $1.j, $get($1.column_arrangement, $1.i));
              $put($1.column_arrangement, $1.i, 0);
              $put($1.processed_column, $1.j, true);
              $put($1.processed_column, $1.i, false);
              $put($1.swap_col, $1.loop0 * 2, $1.i);
              $put($1.swap_col, $1.loop0 * 2 + 1, $1.j);
              $put($1.column_arrangement, $1.i, $1.j);
              $1.loop0 = $1.loop0 + 1;
              $1.loop2 = $1.loop2 + 1;
              break;
            }
          }
        }
      }
      $1.loop1 = 0;
      for (var _8I = 0, _8H = $1.nb_pcb - 1; _8I <= _8H; _8I += 1) {
        $1.kl = _8I;
        if ($nt($get($1.processed_column, $1.kl)) && $1.loop1 < $1.loop0 - $1.loop2) {
          $put($1.column_arrangement, $1.kl, $get($1.column_arrangement, $get($1.swap_col, $1.loop1 * 2)));
          $put($1.processed_column, $1.kl, true);
          $put($1.swap_col, $1.loop1 * 2 + 1, $1.kl);
          $1.loop1 = $1.loop1 + 1;
        }
      }
      $1.loop1 = 0;
      for (var _8e = 0, _8d = $1.nb_pcb - 1; _8e <= _8d; _8e += 1) {
        $1.kl = _8e;
        if ($nt($get($1.processed_column, $1.kl))) {
          $put($1.column_arrangement, $1.kl, $get($1.zero_lines_nb, $1.loop1));
          $1.loop1 = $1.loop1 + 1;
        }
      }
      for (var _8q = 0, _8p = $1.nb_pcb - 1; _8q <= _8p; _8q += 1) {
        $1.i = _8q;
        for (var _8t = 0, _8s = $1.offset - 1; _8t <= _8s; _8t += 1) {
          $1.j = _8t;
          $put($1.matrixA, $1.i * $1.offset + $1.j, $get($1.matrixH, $f($get($1.column_arrangement, $1.i) * $1.offset + $1.j)));
        }
      }
      $1.tmp = 0;
      for (var _97 = 0, _96 = $1.loop0 - 1; _97 <= _96; _97 += 1) {
        $1.i = _97;
        for (var _9A = 0, _99 = $1.nb_pcb - 1; _9A <= _99; _9A += 1) {
          $1.j = _9A;
          var _9H = $get($1.matrixA, ~~($get($1.swap_col, $1.i * 2) / 32) + $1.j * $1.offset);
          var _9L = -$f(31 - $get($1.swap_col, $1.i * 2) % 32);
          $1.tmp = (-((_9L < 0 ? _9H >>> -_9L : _9H << _9L) & 1) ^ $1.tmp) & 1 ^ $1.tmp;
          var _9O = $1.matrixA;
          var _9R = $get($1.swap_col, $1.i * 2);
          var _9S = $1.j;
          var _9T = $1.offset;
          var _9b = $get($1.matrixA, ~~($get($1.swap_col, $1.i * 2 + 1) / 32) + $1.j * $1.offset);
          var _9f = -$f(31 - $get($1.swap_col, $1.i * 2 + 1) % 32);
          var _9q = $f(31 - $get($1.swap_col, $1.i * 2) % 32);
          $put(_9O, ~~(_9R / 32) + _9S * _9T, $get(_9O, ~~(_9R / 32) + _9S * _9T) ^ (-((_9f < 0 ? _9b >>> -_9f : _9b << _9f) & 1) ^ $get($1.matrixA, ~~($get($1.swap_col, $1.i * 2) / 32) + $1.j * $1.offset)) & (_9q < 0 ? 1 >>> -_9q : 1 << _9q));
          var _9r = $1.matrixA;
          var _9u = $get($1.swap_col, $1.i * 2 + 1);
          var _9v = $1.j;
          var _9w = $1.offset;
          var _A9 = $f(31 - $get($1.swap_col, $1.i * 2 + 1) % 32);
          $put(_9r, ~~(_9u / 32) + _9v * _9w, $get(_9r, ~~(_9u / 32) + _9v * _9w) ^ (-($1.tmp & 1) ^ $get($1.matrixA, ~~($get($1.swap_col, $1.i * 2 + 1) / 32) + $1.j * $1.offset)) & (_A9 < 0 ? 1 >>> -_A9 : 1 << _A9));
        }
      }
    };
    $1.createGeneratorMatrix = function() {
      $1.pn = $1.Pg_sub_block - $1.matrix_rank;
      $1.offset = ~~Math.ceil($1.pn / 32);
      $1.effwidth = $1.offset * 32;
      $1.offset_cap = ~~Math.ceil($1.Pg_sub_block / 32);
      $1.G = $a($1.offset * $1.Pg_sub_block);
      for (var _AL = 0, _AK = $1.offset * $1.Pg_sub_block - 1; _AL <= _AK; _AL += 1) {
        $put($1.G, _AL, 0);
      }
      for (var _AP = 0, _AO = $1.pn - 1; _AP <= _AO; _AP += 1) {
        $1.i = _AP;
        var _AQ = $1.G;
        var _AR = $1.Pg_sub_block;
        var _AS = $1.pn;
        var _AT = $1.i;
        var _AU = $1.offset;
        var _AV = $1.i;
        var _AY = 31 - $1.i % 32;
        $put(_AQ, (_AR - _AS + _AT) * _AU + ~~(_AV / 32), $get(_AQ, (_AR - _AS + _AT) * _AU + ~~(_AV / 32)) | (_AY < 0 ? 1 >>> -_AY : 1 << _AY));
      }
      $1.matrix_index = $1.Pg_sub_block - $1.pn;
      $1.loop0 = 0;
      for (var _Af = 0, _Ae = ($1.Pg_sub_block - $1.pn) * $1.effwidth - 1; _Af <= _Ae; _Af += 1) {
        $1.i = _Af;
        if ($1.matrix_index >= $1.Pg_sub_block) {
          $1.loop0 = $1.loop0 + 1;
          $1.matrix_index = $1.Pg_sub_block - $1.pn;
        }
        if ($1.i % $1.effwidth < $1.pn) {
          var _Ao = $1.G;
          var _Ap = $1.i;
          var _Av = $get($1.matrixA, ~~($1.matrix_index / 32) + $1.offset_cap * $1.loop0);
          var _Ax = -(31 - $1.matrix_index % 32);
          var _B2 = 31 - $1.i % 32;
          $put(_Ao, ~~(_Ap / 32), $get(_Ao, ~~(_Ap / 32)) ^ (-((_Ax < 0 ? _Av >>> -_Ax : _Av << _Ax) & 1) ^ $get($1.G, ~~($1.i / 32))) & (_B2 < 0 ? 1 >>> -_B2 : 1 << _B2));
          $1.matrix_index = $1.matrix_index + 1;
        }
      }
    };
    $1.ldpc = function() {
      $1.wr = $k[--$j];
      $1.wc = $k[--$j];
      $k[$j++] = Infinity;
      var _B6 = $k[--$j];
      var _B7 = $k[--$j];
      $k[$j++] = _B6;
      $forall(_B7, function() {
        var _B8 = $k[--$j];
        $k[$j++] = $f(_B8 - 48);
      });
      $1.data = $a();
      $1.Pn = $1.data.length;
      if ($1.wr != -1) {
        $1.Pg = ~~(Math.ceil(Math.ceil($1.Pn * $1.wr / $f($1.wr - $1.wc)) / $1.wr) * $1.wr);
        $1.nb_sub_blocks = ~~($1.Pg / 2700) + 1;
        $1.Pg_sub_block = ~~(~~($1.Pg / $1.nb_sub_blocks) / $1.wr) * $1.wr;
        $1.Pn_sub_block = ~~($1.Pg_sub_block * $f($1.wr - $1.wc) / $1.wr);
        $1.nb_sub_blocks = ~~($1.Pg / $1.Pg_sub_block);
        $k[$j++] = "encoding_iterations";
        $k[$j++] = ~~($1.Pg / $1.Pg_sub_block);
        if ($1.Pn_sub_block * $1.nb_sub_blocks < $1.Pn) {
          var _BY = $k[--$j];
          $k[$j++] = $f(_BY - 1);
        }
        var _BZ = $k[--$j];
        $1[$k[--$j]] = _BZ;
        $1.createMatrixA();
      } else {
        $1.Pg = $1.Pn * 2;
        $1.nb_sub_blocks = 1;
        $1.Pg_sub_block = $1.Pg;
        $1.Pn_sub_block = $1.Pn;
        $1.encoding_iterations = 1;
        $1.createMetadataMatrixA();
      }
      $1.GaussJordan();
      $1.createGeneratorMatrix();
      $1.ecc_encoded_data = $a($1.Pg);
      $1.offset = ~~Math.ceil(($1.Pg_sub_block - $1.matrix_rank) / 32);
      for (var _Bk = 0, _Bj = $1.encoding_iterations - 1; _Bk <= _Bj; _Bk += 1) {
        $1.iter = _Bk;
        for (var _Bn = 0, _Bm = $1.Pg_sub_block - 1; _Bn <= _Bm; _Bn += 1) {
          $1.i = _Bn;
          $1.temp = 0;
          $1.loop0 = 0;
          $1.offset_index = $1.offset * $1.i;
          for (var _Bv = $1.iter * $1.Pn_sub_block, _Bu = ($1.iter + 1) * $1.Pn_sub_block - 1; _Bv <= _Bu; _Bv += 1) {
            var _C1 = $get($1.G, $1.offset_index + ~~($1.loop0 / 32));
            var _C3 = -(31 - $1.loop0 % 32);
            $1.temp = $get($1.data, _Bv) & ((_C3 < 0 ? _C1 >>> -_C3 : _C1 << _C3) & 1) ^ $1.temp;
            $1.loop0 = $1.loop0 + 1;
          }
          $put($1.ecc_encoded_data, $1.i + $1.iter * $1.Pg_sub_block, $1.temp);
        }
      }
      if ($1.encoding_iterations != $1.nb_sub_blocks) {
        $1.start = $1.encoding_iterations * $1.Pn_sub_block;
        $1.last_index = $1.encoding_iterations * $1.Pg_sub_block;
        $1.Pg_sub_block = $1.Pg - $1.encoding_iterations * $1.Pg_sub_block;
        $1.Pn_sub_block = ~~($1.Pg_sub_block * $f($1.wr - $1.wc) / $1.wr);
        $1.createMatrixA();
        $1.GaussJordan();
        $1.createGeneratorMatrix();
        $1.offset = ~~Math.ceil(($1.Pg_sub_block - $1.matrix_rank) / 32);
        for (var _CS = 0, _CR = $1.Pg_sub_block - 1; _CS <= _CR; _CS += 1) {
          $1.i = _CS;
          $1.temp = 0;
          $1.loop0 = 0;
          $1.offset_index = $1.offset * $1.i;
          for (var _CY = $1.start, _CX = $1.Pn - 1; _CY <= _CX; _CY += 1) {
            var _Ce = $get($1.G, $1.offset_index + ~~($1.loop0 / 32));
            var _Cg = -(31 - $1.loop0 % 32);
            $1.temp = $get($1.data, _CY) & ((_Cg < 0 ? _Ce >>> -_Cg : _Ce << _Cg) & 1) ^ $1.temp;
            $1.loop0 = $1.loop0 + 1;
          }
          $put($1.ecc_encoded_data, $1.i + $1.last_index, $1.temp);
        }
      }
      $1.out = $s($1.Pg);
      for (var _Cr = 0, _Cq = $1.Pg - 1; _Cr <= _Cq; _Cr += 1) {
        $put($1.out, _Cr, $f($get($1.ecc_encoded_data, _Cr) + 48));
      }
      $k[$j++] = $1.out;
    };
    $k[$j++] = "bits";
    $k[$j++] = $1.bits;
    $k[$j++] = $1.datawc;
    $k[$j++] = $1.datawr;
    $1.ldpc();
    var _Cz = $k[--$j];
    $1[$k[--$j]] = _Cz;
    $1.s0 = 0;
    $1.s1 = 0;
    $1.s2 = 3;
    $1.s3 = 30151;
    for (var _D2 = $1.bits.length - 1; _D2 >= 1; _D2 -= 1) {
      $1.l = _D2;
      $1.lcg64_temper();
      var _D3 = $k[--$j];
      $k[$j++] = _D3;
      if (_D3 < 0) {
        var _D4 = $k[--$j];
        $k[$j++] = $f((_D4 ^ 2147483648) + 2147483648);
      }
      $1.r = ~~($k[--$j] / 4294967296 * ($1.l + 1));
      $put($1.bits, $1.l, $get($1.bits, $1.r));
      $put($1.bits, $1.r, $get($1.bits, $1.l));
    }
    $1.tmpbits = $s($1.C);
    $puti($1.tmpbits, 0, $1.bits);
    $1.j = $1.bits.length;
    for (var _DO = 0, _DP = ~~($f($f($1.C - $1.j) + 1) / 2); _DO < _DP; _DO++) {
      $put($1.tmpbits, $1.j, 48);
      if ($1.j + 1 < $1.C) {
        $put($1.tmpbits, $1.j + 1, 49);
      }
      $1.j = $1.j + 2;
    }
    $1.bits = $1.tmpbits;
    if ($1.colors == 4) {
      $1.bi = 0;
      $1.gi = 1;
      $1.mi = 2;
      $1.yi = 3;
      $1.ki = 4;
      $1.wi = 5;
      $k[$j++] = Infinity;
      $k[$j++] = $1.bi;
      $k[$j++] = "0000FF";
      $k[$j++] = $1.gi;
      $k[$j++] = "00FF00";
      $k[$j++] = $1.mi;
      $k[$j++] = "FF00FF";
      $k[$j++] = $1.yi;
      $k[$j++] = "FFFF00";
      $k[$j++] = $1.ki;
      $k[$j++] = "000000";
      $k[$j++] = $1.wi;
      $k[$j++] = "FFFFFF";
      $1.palette = $d();
      $1.metacolorindex = $a([$1.bi, $1.gi, $1.mi, $1.yi]);
      $1.palettelayout = $a([$1.bi, $1.gi, $1.mi, $1.yi]);
    } else {
      var _Dw = /* @__PURE__ */ new Map([
        [8, $a([2, 2, 2])],
        [16, $a([4, 2, 2])],
        [32, $a([4, 4, 2])],
        [64, $a([4, 4, 4])],
        [128, $a([8, 4, 4])],
        [256, $a([8, 8, 4])]
      ]);
      $1.rgbres = $get(_Dw, $1.colors);
      $k[$j++] = "rvals";
      $k[$j++] = $get($1.rgbres, 0);
      $k[$j++] = Infinity;
      var _E1 = $k[--$j];
      var _E3 = $f($k[--$j] - 1);
      $k[$j++] = _E1;
      $k[$j++] = _E3;
      for (var _E5 = 0, _E4 = _E3; _E5 <= _E4; _E5 += 1) {
        var _E6 = $k[--$j];
        $k[$j++] = ~~Math.round(_E5 * (255 / _E6));
        $k[$j++] = _E6;
      }
      $j--;
      var _E7 = $a();
      $1[$k[--$j]] = _E7;
      $k[$j++] = "gvals";
      $k[$j++] = $get($1.rgbres, 1);
      $k[$j++] = Infinity;
      var _EB = $k[--$j];
      var _ED = $f($k[--$j] - 1);
      $k[$j++] = _EB;
      $k[$j++] = _ED;
      for (var _EF = 0, _EE = _ED; _EF <= _EE; _EF += 1) {
        var _EG = $k[--$j];
        $k[$j++] = ~~Math.round(_EF * (255 / _EG));
        $k[$j++] = _EG;
      }
      $j--;
      var _EH = $a();
      $1[$k[--$j]] = _EH;
      $k[$j++] = "bvals";
      $k[$j++] = $get($1.rgbres, 2);
      $k[$j++] = Infinity;
      var _EL = $k[--$j];
      var _EN = $f($k[--$j] - 1);
      $k[$j++] = _EL;
      $k[$j++] = _EN;
      for (var _EP = 0, _EO = _EN; _EP <= _EO; _EP += 1) {
        var _EQ = $k[--$j];
        $k[$j++] = ~~Math.round(_EP * (255 / _EQ));
        $k[$j++] = _EQ;
      }
      $j--;
      var _ER = $a();
      $1[$k[--$j]] = _ER;
      var _ET = $1.colors;
      $1.palette = /* @__PURE__ */ new Map();
      var _EU = $1.colors;
      var _EV = 64;
      if (64 > _EU) {
        var _ = _EU;
        _EU = _EV;
        _EV = _;
      }
      $1.palettelayout = $a(_EV);
      $1.i = 0;
      $1.j = 8;
      $forall($1.rvals, function() {
        $1.r = $k[--$j];
        $forall($1.gvals, function() {
          $1.g = $k[--$j];
          $forall($1.bvals, function() {
            $1.b = $k[--$j];
            var _Eh = $strcpy($s(6), "000000");
            var _Ej = $cvrs($s(6), $1.r << 16 | $1.g << 8 | $1.b, 16);
            $puti(_Eh, 6 - _Ej.length, _Ej);
            $k[$j++] = _Eh;
            $k[$j++] = false;
            if ($eq(_Eh, "000000")) {
              $1.ki = $1.i;
              $j--;
              $k[$j++] = true;
            }
            var _El = $k[--$j];
            var _Em = $k[--$j];
            $k[$j++] = _Em;
            $k[$j++] = _El;
            if ($eq(_Em, "0000FF")) {
              $1.bi = $1.i;
              $j--;
              $k[$j++] = true;
            }
            var _Eo = $k[--$j];
            var _Ep = $k[--$j];
            $k[$j++] = _Ep;
            $k[$j++] = _Eo;
            if ($eq(_Ep, "00FF00")) {
              $1.gi = $1.i;
              $j--;
              $k[$j++] = true;
            }
            var _Er = $k[--$j];
            var _Es = $k[--$j];
            $k[$j++] = _Es;
            $k[$j++] = _Er;
            if ($eq(_Es, "00FFFF")) {
              $1.ci = $1.i;
              $j--;
              $k[$j++] = true;
            }
            var _Eu = $k[--$j];
            var _Ev = $k[--$j];
            $k[$j++] = _Ev;
            $k[$j++] = _Eu;
            if ($eq(_Ev, "FF0000")) {
              $1.ri = $1.i;
              $j--;
              $k[$j++] = true;
            }
            var _Ex = $k[--$j];
            var _Ey = $k[--$j];
            $k[$j++] = _Ey;
            $k[$j++] = _Ex;
            if ($eq(_Ey, "FF00FF")) {
              $1.mi = $1.i;
              $j--;
              $k[$j++] = true;
            }
            var _F0 = $k[--$j];
            var _F1 = $k[--$j];
            $k[$j++] = _F1;
            $k[$j++] = _F0;
            if ($eq(_F1, "FFFF00")) {
              $1.yi = $1.i;
              $j--;
              $k[$j++] = true;
            }
            var _F3 = $k[--$j];
            var _F4 = $k[--$j];
            $k[$j++] = _F4;
            $k[$j++] = _F3;
            if ($eq(_F4, "FFFFFF")) {
              $1.wi = $1.i;
              $j--;
              $k[$j++] = true;
            }
            if ($nt($k[--$j])) {
              if ($1.colors <= 64 || ($1.colors == 128 && ($1.r == 0 || $1.r == 73 || $1.r == 182 || $1.r == 255) || $1.colors == 256 && ($1.r == 0 || $1.r == 73 || $1.r == 182 || $1.r == 255) && ($1.g == 0 || $1.g == 73 || $1.g == 182 || $1.g == 255))) {
                $put($1.palettelayout, $1.j, $1.i);
                $1.j = $1.j + 1;
              }
            }
            $put($1.palette, $1.i, $k[--$j]);
            $1.i = $1.i + 1;
          });
        });
      });
      $puti($1.palettelayout, 0, $a([$1.ki, $1.bi, $1.gi, $1.ci, $1.ri, $1.mi, $1.yi, $1.wi]));
      $1.metacolorindex = $a([$1.ki, $1.bi, $1.gi, $1.ci, $1.ri, $1.mi, $1.yi, $1.wi]);
    }
    $k[$j++] = Infinity;
    for (var _Fp = 0, _Fq = $1.rows * $1.cols; _Fp < _Fq; _Fp++) {
      $k[$j++] = -1;
    }
    $1.pixs = $a();
    $1.jmv = function() {
      var _Ft = $k[--$j];
      var _Fu = $k[--$j];
      $k[$j++] = $f(_Fu + _Ft * $1.cols);
    };
    if (!$1.slave) {
      $1.fpat = $a([$a([1, 1, 1, 0, 0]), $a([1, 2, 2, 0, 0]), $a([1, 2, 1, 2, 1]), $a([0, 0, 2, 2, 1]), $a([0, 0, 1, 1, 1])]);
      $1.fmap = $a([$a([-1, $1.bi, $1.yi]), $a([-1, $1.yi, $1.bi]), $a([-1, $1.gi, $1.mi]), $a([-1, $1.mi, $1.gi])]);
    } else {
      $1.fpat = $a([$a([0, 0, 0, 0, 0]), $a([0, 2, 2, 0, 0]), $a([0, 2, 1, 2, 0]), $a([0, 0, 2, 2, 0]), $a([0, 0, 0, 0, 0])]);
      $1.fmap = $a([$a([-1, $1.ki, $1.wi]), $a([-1, $1.ki, $1.wi]), $a([-1, $1.ki, $1.wi]), $a([-1, $1.ki, $1.wi])]);
    }
    for (var _GY = 0; _GY <= 4; _GY += 1) {
      $1.y = _GY;
      for (var _GZ = 0; _GZ <= 4; _GZ += 1) {
        $1.x = _GZ;
        $1.fpb = $get($get($1.fpat, $1.y), $1.x);
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.x + 1;
        $k[$j++] = $1.y + 1;
        $1.jmv();
        var _Gm = $k[--$j];
        $put($k[--$j], _Gm, $get($get($1.fmap, 0), $1.fpb));
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.x + 1;
        $k[$j++] = $f($f($1.rows - $1.y) - 2);
        $1.jmv();
        var _Gw = $k[--$j];
        $put($k[--$j], _Gw, $get($get($1.fmap, 1), $1.fpb));
        $k[$j++] = $1.pixs;
        $k[$j++] = $f($f($1.x + $1.cols) - 6);
        $k[$j++] = $1.y + 1;
        $1.jmv();
        var _H6 = $k[--$j];
        $put($k[--$j], _H6, $get($get($1.fmap, 2), $1.fpb));
        $k[$j++] = $1.pixs;
        $k[$j++] = $f($f($1.x + $1.cols) - 6);
        $k[$j++] = $f($f($1.rows - $1.y) - 2);
        $1.jmv();
        var _HH = $k[--$j];
        $put($k[--$j], _HH, $get($get($1.fmap, 3), $1.fpb));
      }
    }
    $1.algnpat0 = $a([$a([$1.ki, $1.ki, -1]), $a([$1.ki, $1.wi, $1.ki]), $a([-1, $1.ki, $1.ki])]);
    $1.algnpat1 = $a([$a([-1, $1.ki, $1.ki]), $a([$1.ki, $1.wi, $1.ki]), $a([$1.ki, $1.ki, -1])]);
    $1.num = ~~Math.round($1.cols / 16) - 1;
    $1.algnrpos = $a([3, 17]);
    if ($1.num > 0) {
      $k[$j++] = Infinity;
      for (var _Hk = 0, _Hj = $1.num; _Hk <= _Hj; _Hk += 1) {
        $k[$j++] = ~~(_Hk * ($f($1.cols - 7) / $1.num)) + 3;
      }
      $1.algnrpos = $a();
    }
    $1.num = ~~Math.round($1.rows / 16) - 1;
    $1.algncpos = $a([3, 17]);
    if ($1.num > 0) {
      $k[$j++] = Infinity;
      for (var _Ht = 0, _Hs = $1.num; _Ht <= _Hs; _Ht += 1) {
        $k[$j++] = ~~(_Ht * ($f($1.rows - 7) / $1.num)) + 3;
      }
      $1.algncpos = $a();
    }
    $1.putalgnpat = function() {
      $1.pp = $k[--$j];
      $1.py = $k[--$j];
      $1.px = $k[--$j];
      for (var _I0 = 0; _I0 <= 2; _I0 += 1) {
        $1.pb = _I0;
        for (var _I1 = 0; _I1 <= 2; _I1 += 1) {
          $1.pa = _I1;
          $k[$j++] = $1.pixs;
          $k[$j++] = $f($1.px + $1.pa);
          $k[$j++] = $f($1.py + $1.pb);
          $1.jmv();
          var _IC = $k[--$j];
          $put($k[--$j], _IC, $get($get($1.pp, $1.pb), $1.pa));
        }
      }
    };
    for (var _IG = 0, _IF = $1.algncpos.length - 1; _IG <= _IF; _IG += 1) {
      $1.j = _IG;
      $1.y = $get($1.algncpos, $1.j);
      for (var _IM = 0, _IL = $1.algnrpos.length - 1; _IM <= _IL; _IM += 1) {
        $1.i = _IM;
        $1.x = $get($1.algnrpos, $1.i);
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.x;
        $k[$j++] = $1.y;
        $1.jmv();
        var _IT = $k[--$j];
        if ($get($k[--$j], _IT) == -1) {
          $k[$j++] = $f($1.x - 1);
          $k[$j++] = $f($1.y - 1);
          if (($1.i + $1.j) % 2 == 0) {
            $k[$j++] = $1.algnpat0;
          } else {
            $k[$j++] = $1.algnpat1;
          }
          $1.putalgnpat();
        }
      }
    }
    if (!$1.slave) {
      var _JL = $a([$a([6, 1]), $a([6, 2]), $a([6, 3]), $a([6, 4]), $a([6, 5]), $a([6, 6]), $a([5, 6]), $a([4, 6]), $a([3, 6]), $a([2, 6]), $a([1, 6]), $a([7, 1]), $a([7, 2]), $a([7, 3]), $a([7, 4]), $a([7, 5]), $a([7, 6]), $a([7, 7]), $a([6, 7]), $a([5, 7]), $a([4, 7]), $a([3, 7]), $a([2, 7]), $a([1, 7]), $a([8, 1]), $a([8, 2]), $a([8, 3]), $a([8, 4]), $a([8, 5]), $a([8, 6]), $a([8, 7]), $a([8, 8]), $a([7, 8]), $a([6, 8]), $a([5, 8]), $a([4, 8]), $a([3, 8]), $a([2, 8]), $a([1, 8]), $a([9, 1]), $a([9, 2]), $a([9, 3]), $a([9, 4]), $a([9, 5])]);
      for (var _JM = 0, _JN = _JL.length; _JM < _JN; _JM++) {
        $aload($get(_JL, _JM));
        $1.y = $k[--$j];
        $1.x = $k[--$j];
        $k[$j++] = $a([$1.x, $1.y]);
        $k[$j++] = $a([-$1.x, $1.y]);
        $k[$j++] = $a([-$1.x, -$1.y]);
        $k[$j++] = $a([$1.x, -$1.y]);
      }
      $astore($a(176));
      $1.metadatamap = $k[--$j];
      $1.palettemap1 = $a([$a([4, 1]), $a([4, 2]), $a([5, 1]), $a([5, 2]), $a([2, 4]), $a([2, 5]), $a([1, 4]), $a([1, 5]), $a([-2, 1]), $a([-2, 2]), $a([-1, 1]), $a([-1, 2]), $a([-4, 4]), $a([-4, 5]), $a([-5, 4]), $a([-5, 5])]);
      $1.palettemap2 = $a([$a([-4, -5]), $a([-4, -4]), $a([-5, -5]), $a([-5, -4]), $a([-2, -2]), $a([-2, -1]), $a([-1, -2]), $a([-1, -1]), $a([2, -5]), $a([2, -4]), $a([1, -5]), $a([1, -4]), $a([4, -2]), $a([4, -1]), $a([5, -2]), $a([5, -1])]);
    } else {
      $k[$j++] = Infinity;
      for (var _KD = 1; _KD <= 19; _KD += 1) {
        $1.i = _KD;
        $k[$j++] = $a([0, $1.i]);
        $k[$j++] = $a([1, $1.i]);
      }
      for (var _KI = 5; _KI <= 12; _KI += 1) {
        $1.i = _KI;
        $k[$j++] = $a([2, $1.i]);
        $k[$j++] = $a([3, $1.i]);
      }
      $1.metadatamap = $a();
      $k[$j++] = Infinity;
      for (var _KO = 5; _KO <= 12; _KO += 1) {
        $k[$j++] = _KO;
        $k[$j++] = Infinity;
        var _KP = $k[--$j];
        var _KQ = $k[--$j];
        $k[$j++] = _KP;
        $k[$j++] = 4;
        $k[$j++] = _KQ;
        var _KR = $a();
        $k[$j++] = _KR;
      }
      for (var _KS = 12; _KS >= 5; _KS -= 1) {
        $k[$j++] = _KS;
        $k[$j++] = Infinity;
        var _KT = $k[--$j];
        var _KU = $k[--$j];
        $k[$j++] = _KT;
        $k[$j++] = 5;
        $k[$j++] = _KU;
        var _KV = $a();
        $k[$j++] = _KV;
      }
      for (var _KW = 5; _KW <= 12; _KW += 1) {
        $k[$j++] = _KW;
        $k[$j++] = Infinity;
        var _KX = $k[--$j];
        var _KY = $k[--$j];
        $k[$j++] = _KX;
        $k[$j++] = 6;
        $k[$j++] = _KY;
        var _KZ = $a();
        $k[$j++] = _KZ;
      }
      for (var _Ka = 12; _Ka >= 5; _Ka -= 1) {
        $k[$j++] = _Ka;
        $k[$j++] = Infinity;
        var _Kb = $k[--$j];
        var _Kc = $k[--$j];
        $k[$j++] = _Kb;
        $k[$j++] = 7;
        $k[$j++] = _Kc;
        var _Kd = $a();
        $k[$j++] = _Kd;
      }
      $1.palettemap1 = $a();
      $k[$j++] = Infinity;
      var _Kf = $1.palettemap1;
      for (var _Kg = 0, _Kh = _Kf.length; _Kg < _Kh; _Kg++) {
        $k[$j++] = $get(_Kf, _Kg);
        $k[$j++] = Infinity;
        var _Kj = $k[--$j];
        var _Kk = $k[--$j];
        $k[$j++] = _Kj;
        $aload(_Kk);
        var _Kl = $k[--$j];
        var _Km = $k[--$j];
        $k[$j++] = -_Km;
        $k[$j++] = -_Kl;
        var _Kn = $a();
        $k[$j++] = _Kn;
      }
      $1.palettemap2 = $a();
    }
    var _Kp = $1.metadatamap;
    for (var _Kq = 0, _Kr = _Kp.length; _Kq < _Kr; _Kq++) {
      var _Ks = $get(_Kp, _Kq);
      var _Kt = $get(_Ks, 0);
      $k[$j++] = _Ks;
      $k[$j++] = _Kt;
      if (_Kt < 0) {
        var _Kv = $k[--$j];
        var _Kw = $k[--$j];
        $put(_Kw, 0, $f($f(_Kv + $1.cols) - 1));
        $k[$j++] = _Kw;
      } else {
        $j--;
      }
      var _Kx = $k[--$j];
      var _Ky = $get(_Kx, 1);
      $k[$j++] = _Kx;
      $k[$j++] = _Ky;
      if (_Ky < 0) {
        var _L0 = $k[--$j];
        var _L1 = $k[--$j];
        $put(_L1, 1, $f($f(_L0 + $1.rows) - 1));
        $k[$j++] = _L1;
      } else {
        $j--;
      }
      $j--;
    }
    var _L2 = $1.palettemap1;
    for (var _L3 = 0, _L4 = _L2.length; _L3 < _L4; _L3++) {
      var _L5 = $get(_L2, _L3);
      var _L6 = $get(_L5, 0);
      $k[$j++] = _L5;
      $k[$j++] = _L6;
      if (_L6 < 0) {
        var _L8 = $k[--$j];
        var _L9 = $k[--$j];
        $put(_L9, 0, $f($f(_L8 + $1.cols) - 1));
        $k[$j++] = _L9;
      } else {
        $j--;
      }
      var _LA = $k[--$j];
      var _LB = $get(_LA, 1);
      $k[$j++] = _LA;
      $k[$j++] = _LB;
      if (_LB < 0) {
        var _LD = $k[--$j];
        var _LE = $k[--$j];
        $put(_LE, 1, $f($f(_LD + $1.rows) - 1));
        $k[$j++] = _LE;
      } else {
        $j--;
      }
      $j--;
    }
    var _LF = $1.palettemap2;
    for (var _LG = 0, _LH = _LF.length; _LG < _LH; _LG++) {
      var _LI = $get(_LF, _LG);
      var _LJ = $get(_LI, 0);
      $k[$j++] = _LI;
      $k[$j++] = _LJ;
      if (_LJ < 0) {
        var _LL = $k[--$j];
        var _LM = $k[--$j];
        $put(_LM, 0, $f($f(_LL + $1.cols) - 1));
        $k[$j++] = _LM;
      } else {
        $j--;
      }
      var _LN = $k[--$j];
      var _LO = $get(_LN, 1);
      $k[$j++] = _LN;
      $k[$j++] = _LO;
      if (_LO < 0) {
        var _LQ = $k[--$j];
        var _LR = $k[--$j];
        $put(_LR, 1, $f($f(_LQ + $1.rows) - 1));
        $k[$j++] = _LR;
      } else {
        $j--;
      }
      $j--;
    }
    for (var _LU = 0, _LT = $f($1.nummetamodules - 1); _LU <= _LT; _LU += 1) {
      $k[$j++] = $1.pixs;
      $aload($get($1.metadatamap, _LU));
      $1.jmv();
      var _LY = $k[--$j];
      $put($k[--$j], _LY, 0);
    }
    if (!$1.slave) {
      var _Lb = $1.colors;
      var _Lc = 16;
      if (16 > _Lb) {
        var _ = _Lb;
        _Lb = _Lc;
        _Lc = _;
      }
      for (var _Le = 0, _Ld = _Lc - 1; _Le <= _Ld; _Le += 1) {
        $1.i = _Le;
        var _Lh = $get($1.palettelayout, $1.i);
        $k[$j++] = _Lh;
        $k[$j++] = $1.pixs;
        $k[$j++] = _Lh;
        $aload($get($1.palettemap1, $1.i));
        $1.jmv();
        var _Lm = $k[--$j];
        var _Ln = $k[--$j];
        $put($k[--$j], _Lm, _Ln);
        var _Lq = $k[--$j];
        $k[$j++] = $1.pixs;
        $k[$j++] = _Lq;
        $aload($get($1.palettemap2, $1.i));
        $1.jmv();
        var _Lu = $k[--$j];
        var _Lv = $k[--$j];
        $put($k[--$j], _Lu, _Lv);
      }
      $1.i = 16;
    } else {
      $1.i = 0;
    }
    $1.j = $1.nummetamodules;
    for (var _M1 = $1.i, _M0 = $1.palettelayout.length - 1; _M1 <= _M0; _M1 += 2) {
      $1.i = _M1;
      var _M4 = $get($1.palettelayout, $1.i);
      $k[$j++] = _M4;
      $k[$j++] = $1.pixs;
      $k[$j++] = _M4;
      $aload($get($1.metadatamap, $1.j));
      $1.jmv();
      var _M9 = $k[--$j];
      var _MA = $k[--$j];
      $put($k[--$j], _M9, _MA);
      var _MD = $k[--$j];
      $k[$j++] = $1.pixs;
      $k[$j++] = _MD;
      $aload($get($1.metadatamap, $f($1.j + 2)));
      $1.jmv();
      var _MH = $k[--$j];
      var _MI = $k[--$j];
      $put($k[--$j], _MH, _MI);
      var _MM = $get($1.palettelayout, $1.i + 1);
      $k[$j++] = _MM;
      $k[$j++] = $1.pixs;
      $k[$j++] = _MM;
      $aload($get($1.metadatamap, $f($1.j + 1)));
      $1.jmv();
      var _MR = $k[--$j];
      var _MS = $k[--$j];
      $put($k[--$j], _MR, _MS);
      var _MV = $k[--$j];
      $k[$j++] = $1.pixs;
      $k[$j++] = _MV;
      $aload($get($1.metadatamap, $f($1.j + 3)));
      $1.jmv();
      var _MZ = $k[--$j];
      var _Ma = $k[--$j];
      $put($k[--$j], _MZ, _Ma);
      $1.j = $f($1.j + 4);
    }
    var _N2 = $a([function() {
      var _Md = $k[--$j];
      var _Me = $k[--$j];
      $k[$j++] = $f(_Me + _Md) % $1.colors;
    }, function() {
      $j--;
      var _Mh = $k[--$j];
      $k[$j++] = _Mh % $1.colors;
    }, function() {
      var _Mi = $k[--$j];
      var _Mj = $k[--$j];
      $k[$j++] = _Mi;
      $k[$j++] = _Mj;
      $j--;
      var _Ml = $k[--$j];
      $k[$j++] = _Ml % $1.colors;
    }, function() {
      var _Mm = $k[--$j];
      var _Mn = $k[--$j];
      $k[$j++] = (~~(_Mm / 3) + ~~(_Mn / 2)) % $1.colors;
    }, function() {
      var _Mp = $k[--$j];
      var _Mq = $k[--$j];
      $k[$j++] = (~~(_Mp / 2) + ~~(_Mq / 3)) % $1.colors;
    }, function() {
      var _Ms = $k[--$j];
      var _Mu = $f($k[--$j] + _Ms);
      $k[$j++] = (~~(_Mu / 2) + ~~(_Mu / 3)) % $1.colors;
    }, function() {
      var _Mw = $k[--$j];
      var _Mx = $k[--$j];
      $k[$j++] = $f(_Mw * (_Mx * _Mx) % 7 + $f(_Mw + _Mx * _Mx) * 2 % 19) % $1.colors;
    }, function() {
      var _Mz = $k[--$j];
      var _N0 = $k[--$j];
      $k[$j++] = $f(_N0 * (_Mz * _Mz) % 5 + $f(_Mz * _Mz + _N0 * 2) % 13) % $1.colors;
    }]);
    $1.maskfuncs = _N2;
    if ($1.mask != -1) {
      $1.maskfuncs = $a([$get($1.maskfuncs, $1.mask)]);
      $1.bestmaskval = $1.mask;
    }
    $1.masks = $a($1.maskfuncs.length);
    for (var _ND = 0, _NC = $1.masks.length - 1; _ND <= _NC; _ND += 1) {
      $1.m = _ND;
      $1.mask = $a($1.rows * $1.cols);
      for (var _NJ = 0, _NI = $f($1.rows - 1); _NJ <= _NI; _NJ += 1) {
        $1.j = _NJ;
        for (var _NM = 0, _NL = $f($1.cols - 1); _NM <= _NL; _NM += 1) {
          $1.i = _NM;
          $k[$j++] = $1.pixs;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.jmv();
          var _NQ = $k[--$j];
          if ($get($k[--$j], _NQ) == -1) {
            $k[$j++] = $1.i;
            $k[$j++] = $1.j;
            if ($get($1.maskfuncs, $1.m)() === true) {
              break;
            }
          } else {
            $k[$j++] = 0;
          }
          $k[$j++] = $1.mask;
          $k[$j++] = $1.i;
          $k[$j++] = $1.j;
          $1.jmv();
          var _Nb = $k[--$j];
          var _Nc = $k[--$j];
          $put(_Nc, _Nb, $k[--$j]);
        }
      }
      $put($1.masks, $1.m, $1.mask);
    }
    $1.posx = 0;
    $1.posy = 0;
    $1.i = 0;
    for (; ; ) {
      if ($1.posx == $1.cols) {
        break;
      }
      $k[$j++] = $1.pixs;
      $k[$j++] = $1.posx;
      $k[$j++] = $1.posy;
      $1.jmv();
      var _Nm = $k[--$j];
      if ($get($k[--$j], _Nm) == -1) {
        var _Ns = $geti($1.bits, $1.i, $1.databpm);
        $k[$j++] = 0;
        for (var _Nt = 0, _Nu = _Ns.length; _Nt < _Nu; _Nt++) {
          var _Nw = $k[--$j];
          $k[$j++] = $f(_Nw + $f($get(_Ns, _Nt) - 48)) * 2;
        }
        var _Nx = $k[--$j];
        $k[$j++] = ~~(_Nx / 2);
        $k[$j++] = $1.pixs;
        $k[$j++] = $1.posx;
        $k[$j++] = $1.posy;
        $1.jmv();
        var _O1 = $k[--$j];
        var _O2 = $k[--$j];
        $put(_O2, _O1, $k[--$j]);
        $1.i = $1.i + $1.databpm;
      }
      $1.posy = $1.posy + 1;
      if ($1.posy == $1.rows) {
        $1.posy = 0;
        $1.posx = $1.posx + 1;
      }
    }
    $1.evalrle = function() {
      $1.scrle = $k[--$j];
      $1.scr1 = 0;
      $1.scr3 = 0;
      for (var _OD = 0, _OC = $1.scrle.length - 2; _OD <= _OC; _OD += 2) {
        $1.j = _OD;
        if ($get($1.scrle, $1.j + 1) != -1) {
          var _OJ = $get($1.scrle, $1.j);
          $k[$j++] = _OJ;
          if (_OJ >= 5) {
            $1.scr1 = $f($f($k[--$j] - 2) + $1.scr1);
          } else {
            $j--;
          }
          if ($1.j >= 4 && $1.j <= $1.scrle.length - 5) {
            var _OR = $geti($1.scrle, $1.j - 4, 10);
            $k[$j++] = _OR;
            for (var _OS = 0, _OT = _OR.length; _OS < _OT; _OS++) {
              $k[$j++] = $get(_OR, _OS) == 1;
            }
            $j--;
            for (var _OV = 0, _OW = 4; _OV < _OW; _OV++) {
              var _OX = $k[--$j];
              var _OY = $k[--$j];
              $k[$j++] = _OX;
              $k[$j++] = _OY;
              $j--;
              var _OZ = $k[--$j];
              var _Oa = $k[--$j];
              $k[$j++] = $an(_Oa, _OZ);
            }
            if ($k[--$j]) {
              $k[$j++] = Infinity;
              var _Oc = $k[--$j];
              var _Od = $k[--$j];
              $k[$j++] = _Oc;
              $aload(_Od);
              var _Oe = $k[--$j];
              var _Of = $k[--$j];
              var _Og = $k[--$j];
              var _Oh = $k[--$j];
              var _Oi = $k[--$j];
              var _Oj = $k[--$j];
              var _Ok = $k[--$j];
              var _Ol = $k[--$j];
              var _Om = $k[--$j];
              $k[$j++] = _Om;
              $k[$j++] = _Ol;
              $k[$j++] = _Ok;
              $k[$j++] = _Oj;
              $k[$j++] = _Oi;
              $k[$j++] = _Oh;
              $k[$j++] = _Og;
              $k[$j++] = _Of;
              $k[$j++] = _Oe;
              if ($eq(_Om, _Oi) && $eq(_Om, _Oe) && $eq(_Ok, _Og)) {
                var _On = $k[--$j];
                var _Oo = $k[--$j];
                var _Op = $k[--$j];
                $1.c4 = _Op;
                $1.c5 = _On;
                $k[$j++] = _Op;
                $k[$j++] = _Oo;
                if ($1.c4 == $1.bi && $1.c5 == $1.yi || ($1.c4 == $1.yi && $1.c5 == $1.bi || ($1.c4 == $1.gi && $1.c5 == $1.mi || $1.c4 == $1.mi && $1.c5 == $1.gi))) {
                  $1.scr3 = $1.scr3 + 100;
                }
              }
              $cleartomark();
            } else {
              $j--;
            }
          }
        }
      }
      $k[$j++] = $1.scr1;
      $k[$j++] = $1.scr3;
    };
    $1.evalmask = function() {
      $1.sym = $k[--$j];
      $1.n1 = 0;
      $1.n2 = 0;
      $1.n3 = 0;
      var _PA = $1.rows;
      var _PB = $1.cols;
      if (_PA < _PB) {
        var _2 = _PB;
        _PB = _PA;
        _PA = _2;
      }
      $1.rle = $a($f(_PA * 2 + 2));
      $1.lastpairs = $a($1.cols);
      $1.thispairs = $a($1.cols);
      for (var _PJ = 0, _PI = $f($1.cols - 1); _PJ <= _PI; _PJ += 1) {
        $1.i = _PJ;
        $k[$j++] = Infinity;
        $k[$j++] = 0;
        $k[$j++] = -1;
        for (var _PP = $1.i, _PQ = $1.cols, _PO = $f($1.rows * $1.cols - 1); _PQ < 0 ? _PP >= _PO : _PP <= _PO; _PP += _PQ) {
          var _PS = $get($1.sym, _PP);
          var _PT = $k[--$j];
          $k[$j++] = _PT;
          $k[$j++] = _PS;
          if ($eq(_PT, _PS)) {
            $j--;
            var _PU = $k[--$j];
            var _PV = $k[--$j];
            $k[$j++] = $f(_PV + 1);
            $k[$j++] = _PU;
          } else {
            var _PW = $k[--$j];
            $k[$j++] = 1;
            $k[$j++] = _PW;
          }
        }
        var _PY = $counttomark() + 2;
        $astore($geti($1.rle, 0, _PY - 2));
        $1.evalrle();
        $1.n3 = $f($k[--$j] + $1.n3);
        $1.n1 = $f($k[--$j] + $1.n1);
        $j--;
      }
      for (var _Pg = 0, _Pf = $f($1.rows - 1); _Pg <= _Pf; _Pg += 1) {
        $1.i = _Pg;
        $1.symrow = $geti($1.sym, $1.i * $1.cols, $1.cols);
        $k[$j++] = Infinity;
        var _Pm = $1.symrow;
        $k[$j++] = 0;
        $k[$j++] = -1;
        for (var _Pn = 0, _Po = _Pm.length; _Pn < _Po; _Pn++) {
          var _Pp = $get(_Pm, _Pn);
          var _Pq = $k[--$j];
          $k[$j++] = _Pq;
          $k[$j++] = _Pp;
          if ($eq(_Pq, _Pp)) {
            $j--;
            var _Pr = $k[--$j];
            var _Ps = $k[--$j];
            $k[$j++] = $f(_Ps + 1);
            $k[$j++] = _Pr;
          } else {
            var _Pt = $k[--$j];
            $k[$j++] = 1;
            $k[$j++] = _Pt;
          }
        }
        var _Pv = $counttomark() + 2;
        $astore($geti($1.rle, 0, _Pv - 2));
        $1.evalrle();
        $1.n3 = $f($k[--$j] + $1.n3);
        $1.n1 = $f($k[--$j] + $1.n1);
        $j--;
        var _Q1 = $1.thispairs;
        $1.thispairs = $1.lastpairs;
        $1.lastpairs = _Q1;
        var _Q3 = $1.symrow;
        $k[$j++] = -1;
        for (var _Q4 = 0, _Q5 = _Q3.length; _Q4 < _Q5; _Q4++) {
          var _Q6 = $get(_Q3, _Q4);
          var _Q7 = $k[--$j];
          $k[$j++] = _Q6;
          $k[$j++] = _Q7;
          if ($ne(_Q6, _Q7)) {
            $j--;
            var _Q8 = $k[--$j];
            $k[$j++] = -1;
            $k[$j++] = _Q8;
          }
        }
        $j--;
        $astore($1.thispairs);
        $j--;
        if ($1.i > 0) {
          $k[$j++] = Infinity;
          $aload($1.lastpairs);
          $aload($1.thispairs);
          $k[$j++] = $1.n2;
          for (var _QF = 0, _QG = $1.cols; _QF < _QG; _QF++) {
            var _QH = $k[--$j];
            var _QI = $k[--$j];
            $k[$j++] = _QH;
            $k[$j++] = _QI;
            if (_QI != -1) {
              var _QK = $k[$j - 1 - $f($1.cols + 1)];
              if ($eq($k[--$j], _QK)) {
                var _QM = $k[--$j];
                $k[$j++] = $f(_QM + 3);
              }
            } else {
              $j--;
            }
          }
          $1.n2 = $k[--$j];
          $cleartomark();
        }
      }
      $k[$j++] = $f($f($1.n1 + $1.n2) + $1.n3);
    };
    $1.bestscore = 999999999;
    for (var _QT = 0, _QS = $1.masks.length - 1; _QT <= _QS; _QT += 1) {
      $1.m = _QT;
      $1.masksym = $a($1.rows * $1.cols);
      for (var _Qa = 0, _QZ = $f($1.rows * $1.cols - 1); _Qa <= _QZ; _Qa += 1) {
        $1.i = _Qa;
        $put($1.masksym, $1.i, $xo($get($1.pixs, $1.i), $get($get($1.masks, $1.m), $1.i)));
      }
      if ($1.masks.length != 1) {
        $k[$j++] = $1.masksym;
        $1.evalmask();
        $1.score = $k[--$j];
        if ($1.score < $1.bestscore) {
          $1.bestsym = $1.masksym;
          $1.bestmaskval = $1.m;
          $1.bestscore = $1.score;
        }
      } else {
        $1.bestsym = $1.masksym;
      }
    }
    $1.pixs = $1.bestsym;
    $1.metamask = $1.bestmaskval;
    $1.addtometapart = function() {
      var _Qw = $k[--$j];
      $puti($1.metapart, $1.p, _Qw);
      $1.p = _Qw.length + $1.p;
    };
    $1.addtometabits = function() {
      var _R0 = $k[--$j];
      $puti($1.metabits, $1.q, _R0);
      $1.q = _R0.length + $1.q;
    };
    $1.metapart = $s(40);
    $1.metabits = $s($1.nummetabits);
    $1.p = 0;
    $1.q = 0;
    if (!$1.slave) {
      $k[$j++] = ~~Math.round(Math.log($1.colors) / Math.log(2)) - 1;
      $k[$j++] = 3;
      $1.tofixedbits();
      $1.addtometapart();
      $k[$j++] = $geti($1.metapart, 0, $1.p);
      $k[$j++] = 2;
      $k[$j++] = -1;
      $1.ldpc();
      $1.addtometabits();
      $1.p = 0;
      $k[$j++] = $1.metass;
      $k[$j++] = 1;
      $1.tofixedbits();
      $1.addtometapart();
      $k[$j++] = $1.metavf;
      $k[$j++] = 2;
      $1.tofixedbits();
      $1.addtometapart();
      $k[$j++] = $1.metamask;
      $k[$j++] = 3;
      $1.tofixedbits();
      $1.addtometapart();
      if ($1.hasslaves) {
        $k[$j++] = "1";
      } else {
        $k[$j++] = "0";
      }
      $1.addtometapart();
      $k[$j++] = $geti($1.metapart, 0, $1.p);
      $k[$j++] = 2;
      $k[$j++] = -1;
      $1.ldpc();
      $1.addtometabits();
      $1.p = 0;
      if ($1.metass == 0) {
        $k[$j++] = $f($f(~~($f($1.cols - 17) / 4) - $get($a([0, 4, 8, 16]), $1.metavf)) - 1);
        $k[$j++] = $1.metavlen;
        $1.tofixedbits();
        $1.addtometapart();
      } else {
        $k[$j++] = ~~($f($1.cols - 17) / 4) - 1;
        $k[$j++] = ~~($1.metavlen / 2);
        $1.tofixedbits();
        $1.addtometapart();
        $k[$j++] = ~~($f($1.rows - 17) / 4) - 1;
        $k[$j++] = ~~($1.metavlen / 2);
        $1.tofixedbits();
        $1.addtometapart();
      }
      $k[$j++] = $1.datawc - 3;
      $k[$j++] = ~~($1.metaelen / 2);
      $1.tofixedbits();
      $1.addtometapart();
      $k[$j++] = $1.datawr - 4;
      $k[$j++] = ~~($1.metaelen / 2);
      $1.tofixedbits();
      $1.addtometapart();
      if ($1.hasslaves) {
        $k[$j++] = 0;
        $k[$j++] = 4;
        $1.tofixedbits();
        $1.addtometapart();
      }
      $k[$j++] = $geti($1.metapart, 0, $1.p);
      $k[$j++] = 2;
      $k[$j++] = -1;
      $1.ldpc();
      $1.addtometabits();
      $1.p = 0;
    } else {
      var _Rc = $1.sameshape ? 0 : 1;
      $k[$j++] = _Rc;
      $k[$j++] = 1;
      $1.tofixedbits();
      $1.addtometapart();
      var _Re = $1.sameecc ? 0 : 1;
      $k[$j++] = _Re;
      $k[$j++] = 1;
      $1.tofixedbits();
      $1.addtometapart();
      var _Rg = $1.hasslaves ? 1 : 0;
      $k[$j++] = _Rg;
      $k[$j++] = 1;
      $1.tofixedbits();
      $1.addtometapart();
      $k[$j++] = $geti($1.metapart, 0, $1.p);
      $k[$j++] = 2;
      $k[$j++] = -1;
      $1.ldpc();
      $1.addtometabits();
      $1.p = 0;
      if (!$1.sameshape) {
        $k[$j++] = ~~(($1.diffside - 17) / 4) - 1;
        $k[$j++] = 5;
        $1.tofixedbits();
        $1.addtometapart();
      }
      if ($1.hasslaves) {
        $k[$j++] = 0;
        $k[$j++] = 3;
        $1.tofixedbits();
        $1.addtometapart();
      }
      $k[$j++] = $geti($1.metapart, 0, $1.p);
      $k[$j++] = 2;
      $k[$j++] = -1;
      $1.ldpc();
      $1.addtometabits();
      $1.p = 0;
      if (!$1.sameecc) {
        $k[$j++] = $1.datawc - 3;
        $k[$j++] = ~~($1.metaelen / 2);
        $1.tofixedbits();
        $1.addtometapart();
        $k[$j++] = $1.datawr - 4;
        $k[$j++] = ~~($1.metaelen / 2);
        $1.tofixedbits();
        $1.addtometapart();
      }
      $k[$j++] = $geti($1.metapart, 0, $1.p);
      $k[$j++] = 2;
      $k[$j++] = -1;
      $1.ldpc();
      $1.addtometabits();
      $1.p = 0;
    }
    for (var _S1 = $1.q, _S0 = $f($1.nummetabits - 1); _S1 <= _S0; _S1 += 1) {
      $put($1.metabits, _S1, 48);
    }
    $1.i = 0;
    $1.j = 0;
    if (!$1.slave) {
      var _S6 = $geti($1.metabits, $1.i, 6);
      for (var _S7 = 0, _S8 = _S6.length; _S7 < _S8; _S7++) {
        $k[$j++] = $get(_S6, _S7);
        if ($1.colors == 4) {
          $k[$j++] = $a([$1.bi, $1.yi]);
        } else {
          $k[$j++] = $a([$1.ki, $1.wi]);
        }
        var _SH = $k[--$j];
        var _SJ = $get(_SH, $f($k[--$j] - 48));
        $k[$j++] = _SJ;
        $k[$j++] = $1.pixs;
        $aload($get($1.metadatamap, $1.j));
        $1.jmv();
        var _SO = $k[--$j];
        var _SP = $k[--$j];
        $put(_SP, _SO, $k[--$j]);
        $1.j = $1.j + 1;
      }
      $1.i = $1.i + 6;
    }
    for (var _SW = 0, _SX = ~~($f($1.nummetabits - $1.i) / $1.metabpm); _SW < _SX; _SW++) {
      var _Sb = $geti($1.metabits, $1.i, $1.metabpm);
      $k[$j++] = 0;
      for (var _Sc = 0, _Sd = _Sb.length; _Sc < _Sd; _Sc++) {
        var _Sf = $k[--$j];
        $k[$j++] = $f(_Sf + $f($get(_Sb, _Sc) - 48)) * 2;
      }
      var _Si = $get($1.metacolorindex, ~~($k[--$j] / 2));
      $k[$j++] = _Si;
      $k[$j++] = $1.pixs;
      $aload($get($1.metadatamap, $1.j));
      $1.jmv();
      var _Sn = $k[--$j];
      var _So = $k[--$j];
      $put(_So, _Sn, $k[--$j]);
      $1.i = $f($1.i + $1.metabpm);
      $1.j = $1.j + 1;
    }
    var _T0 = /* @__PURE__ */ new Map([
      ["ren", bwipp_renmatrix],
      ["pixs", $1.pixs],
      ["pixx", $1.cols],
      ["pixy", $1.rows],
      ["colormap", $1.palette],
      ["height", $1.rows * 2 / 72],
      ["width", $1.cols * 2 / 72],
      ["opt", $1.options]
    ]);
    $k[$j++] = _T0;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_gs1_cc() {
    var $1 = Object.create(bwipp_gs1_cc.$ctx || (bwipp_gs1_cc.$ctx = {}));
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = false;
    $1.dontdraw = false;
    $1.ccversion = "a";
    $1.cccolumns = -1;
    $1.lintype = "";
    $1.linwidth = -1;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($ne($1.ccversion, "a") && $ne($1.ccversion, "b") && $ne($1.ccversion, "c")) {
      $k[$j++] = "bwipp.gs1ccBadCCversion#27168";
      $k[$j++] = "ccversion must be a, b or c";
      bwipp_raiseerror();
    }
    if ($1.cccolumns > 30) {
      $k[$j++] = "bwipp.gs1ccColumnsTooBig#27172";
      $k[$j++] = "The maximum number of composite component columns is 30";
      bwipp_raiseerror();
    }
    if (!bwipp_gs1_cc.__27190__) {
      (function() {
        var $ctx = Object.create($1);
        var _6 = /* @__PURE__ */ new Map([
          ["ean13", 4],
          ["upca", 4],
          ["ean8", 3],
          ["upce", 2],
          ["gs1-128", 4],
          ["databaromni", 4],
          ["databarstacked", 2],
          ["databarstackedomni", 2],
          ["databartruncated", 4],
          ["databarlimited", 3],
          ["databarexpanded", 4],
          ["databarexpandedstacked", 4]
        ]);
        $ctx.lintypecccolumns = _6;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1_cc.$ctx[id] = $ctx[id]);
        bwipp_gs1_cc.__27190__ = 1;
      })();
    }
    if ($ne($1.lintype, "")) {
      var _B = $get($1.lintypecccolumns, $1.lintype) !== void 0;
      if (!_B) {
        $k[$j++] = "bwipp.gs1ccBadLinType#27194";
        $k[$j++] = "The lintype is not recognised";
        bwipp_raiseerror();
      }
    }
    if ($1.cccolumns == -1) {
      if ($eq($1.lintype, "gs1-128") && $eq($1.ccversion, "c")) {
        if ($1.linwidth < 0) {
          $k[$j++] = "bwipp.gs1ccMissingLinWidth#27202";
          $k[$j++] = "linwidth must be set for a GS1-128 with a CC-C composite component";
          bwipp_raiseerror();
        }
        $k[$j++] = ~~(($1.linwidth - 52) / 17);
      } else {
        $k[$j++] = $get($1.lintypecccolumns, $1.lintype);
      }
      $1.cccolumns = $k[--$j];
    }
    $k[$j++] = $1.barcode;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $1.fncs = $k[--$j];
    $1.vals = $k[--$j];
    $1.ais = $k[--$j];
    $1.isupper = function() {
      var _P = $k[--$j];
      $k[$j++] = _P >= 65 && _P <= 90;
    };
    $1.isnum0 = function() {
      var _Q = $k[--$j];
      $k[$j++] = _Q >= 48 && _Q <= 57;
    };
    $1.isnum1 = function() {
      var _R = $k[--$j];
      $k[$j++] = _R >= 49 && _R <= 57;
    };
    for (; ; ) {
      if ($1.ais.length >= 1) {
        if ($eq($get($1.ais, 0), "10") || $eq($get($1.ais, 0), "11") || $eq($get($1.ais, 0), "17")) {
          $k[$j++] = -1;
          $k[$j++] = "10";
          break;
        }
      }
      if ($1.ais.length >= 1) {
        if ($eq($get($1.ais, 0), "90")) {
          $1.v = $get($1.vals, 0);
          if ($1.v.length >= 1) {
            $k[$j++] = $get($1.v, 0);
            $1.isupper();
            if ($k[--$j]) {
              $k[$j++] = 0;
              $k[$j++] = "11";
              break;
            }
          }
          if ($1.v.length >= 2) {
            $k[$j++] = $get($1.v, 0);
            $1.isnum1();
            $k[$j++] = $get($1.v, 1);
            $1.isupper();
            var _n = $k[--$j];
            var _o = $k[--$j];
            if (_o && _n) {
              $k[$j++] = 1;
              $k[$j++] = "11";
              break;
            }
          }
          if ($1.v.length >= 3) {
            $k[$j++] = $get($1.v, 0);
            $1.isnum1();
            $k[$j++] = $get($1.v, 1);
            $1.isnum0();
            var _u = $k[--$j];
            var _v = $k[--$j];
            $k[$j++] = $an(_v, _u);
            $k[$j++] = $get($1.v, 2);
            $1.isupper();
            var _y = $k[--$j];
            var _z = $k[--$j];
            if (_z && _y) {
              $k[$j++] = 2;
              $k[$j++] = "11";
              break;
            }
          }
          if ($1.v.length >= 4) {
            $k[$j++] = $get($1.v, 0);
            $1.isnum1();
            $k[$j++] = $get($1.v, 1);
            $1.isnum0();
            var _15 = $k[--$j];
            var _16 = $k[--$j];
            $k[$j++] = $an(_16, _15);
            $k[$j++] = $get($1.v, 2);
            $1.isnum0();
            var _19 = $k[--$j];
            var _1A = $k[--$j];
            $k[$j++] = $an(_1A, _19);
            $k[$j++] = $get($1.v, 3);
            $1.isupper();
            var _1D = $k[--$j];
            var _1E = $k[--$j];
            if (_1E && _1D) {
              $k[$j++] = 3;
              $k[$j++] = "11";
              break;
            }
          }
        }
      }
      $k[$j++] = -1;
      $k[$j++] = "0";
      break;
    }
    $1.method = $k[--$j];
    $1.npre = $k[--$j];
    $1.tobin = function() {
      var _1I = $s($k[--$j]);
      $k[$j++] = _1I;
      for (var _1K = 0, _1J = _1I.length - 1; _1K <= _1J; _1K += 1) {
        var _1L = $k[--$j];
        $put(_1L, _1K, 48);
        $k[$j++] = _1L;
      }
      var _1M = $k[--$j];
      var _1P = $cvrs($s(_1M.length), $k[--$j], 2);
      $puti(_1M, _1M.length - _1P.length, _1P);
      $k[$j++] = _1M;
    };
    if (!bwipp_gs1_cc.__27322__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.fnc1 = -1;
        $ctx.lnumeric = -2;
        $ctx.lalphanumeric = -3;
        $ctx.liso646 = -4;
        $k[$j++] = Infinity;
        for (var _1Q = 65; _1Q <= 90; _1Q += 1) {
          $k[$j++] = _1Q;
          $k[$j++] = _1Q - 65;
          $k[$j++] = 5;
          $ctx.tobin();
        }
        for (var _1R = 48; _1R <= 57; _1R += 1) {
          $k[$j++] = _1R;
          $k[$j++] = _1R + 4;
          $k[$j++] = 6;
          $ctx.tobin();
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = "11111";
        $ctx.alpha = $d();
        $k[$j++] = Infinity;
        for (var _1U = 0; _1U <= 119; _1U += 1) {
          var _1W = $strcpy($s(2), "00");
          var _1Y = $cvrs($s(2), _1U, 11);
          $puti(_1W, 2 - _1Y.length, _1Y);
          $k[$j++] = _1U;
          $k[$j++] = _1W;
          if ($get(_1W, 0) == 65) {
            var _1a = $k[--$j];
            $put(_1a, 0, 94);
            $k[$j++] = _1a;
          }
          var _1b = $k[--$j];
          $k[$j++] = _1b;
          if ($get(_1b, 1) == 65) {
            var _1d = $k[--$j];
            $put(_1d, 1, 94);
            $k[$j++] = _1d;
          }
          var _1e = $k[--$j];
          var _1h = $strcpy($s(7), "0000000");
          var _1j = $cvrs($s(7), $f($k[--$j] + 8), 2);
          $puti(_1h, 7 - _1j.length, _1j);
          $k[$j++] = _1e;
          $k[$j++] = _1h;
        }
        $k[$j++] = $ctx.lalphanumeric;
        $k[$j++] = "0000";
        $ctx.numeric = $d();
        $k[$j++] = Infinity;
        for (var _1m = 48; _1m <= 57; _1m += 1) {
          $k[$j++] = _1m;
          $k[$j++] = _1m - 43;
          $k[$j++] = 5;
          $ctx.tobin();
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = "01111";
        for (var _1o = 65; _1o <= 90; _1o += 1) {
          $k[$j++] = _1o;
          $k[$j++] = _1o - 33;
          $k[$j++] = 6;
          $ctx.tobin();
        }
        $k[$j++] = 42;
        $k[$j++] = "111010";
        for (var _1p = 44; _1p <= 47; _1p += 1) {
          $k[$j++] = _1p;
          $k[$j++] = _1p + 15;
          $k[$j++] = 6;
          $ctx.tobin();
        }
        $k[$j++] = $ctx.lnumeric;
        $k[$j++] = "000";
        $k[$j++] = $ctx.liso646;
        $k[$j++] = "00100";
        $ctx.alphanumeric = $d();
        $k[$j++] = Infinity;
        for (var _1t = 48; _1t <= 57; _1t += 1) {
          $k[$j++] = _1t;
          $k[$j++] = _1t - 43;
          $k[$j++] = 5;
          $ctx.tobin();
        }
        $k[$j++] = $ctx.fnc1;
        $k[$j++] = "01111";
        for (var _1v = 65; _1v <= 90; _1v += 1) {
          $k[$j++] = _1v;
          $k[$j++] = _1v - 1;
          $k[$j++] = 7;
          $ctx.tobin();
        }
        for (var _1w = 97; _1w <= 122; _1w += 1) {
          $k[$j++] = _1w;
          $k[$j++] = _1w - 7;
          $k[$j++] = 7;
          $ctx.tobin();
        }
        $k[$j++] = 33;
        $k[$j++] = "11101000";
        $k[$j++] = 34;
        $k[$j++] = "11101001";
        for (var _1x = 37; _1x <= 47; _1x += 1) {
          $k[$j++] = _1x;
          $k[$j++] = _1x + 197;
          $k[$j++] = 8;
          $ctx.tobin();
        }
        for (var _1y = 58; _1y <= 63; _1y += 1) {
          $k[$j++] = _1y;
          $k[$j++] = _1y + 187;
          $k[$j++] = 8;
          $ctx.tobin();
        }
        $k[$j++] = 95;
        $k[$j++] = "11111011";
        $k[$j++] = 32;
        $k[$j++] = "11111100";
        $k[$j++] = $ctx.lnumeric;
        $k[$j++] = "000";
        $k[$j++] = $ctx.lalphanumeric;
        $k[$j++] = "00100";
        $ctx.iso646 = $d();
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1_cc.$ctx[id] = $ctx[id]);
        bwipp_gs1_cc.__27322__ = 1;
      })();
    }
    if ($eq($1.method, "10")) {
      if ($eq($get($1.ais, 0), "11") || $eq($get($1.ais, 0), "17")) {
        var _29 = $get($1.vals, 0);
        var _2E = $strcpy($s(16), "0000000000000000");
        var _2G = $cvrs($s(16), $cvi($geti(_29, 0, 2)) * 384 + (($cvi($geti(_29, 2, 2)) - 1) * 32 + $cvi($geti(_29, 4, 2))), 2);
        $puti(_2E, 16 - _2G.length, _2G);
        $k[$j++] = _2E;
        $k[$j++] = Infinity;
        var _2H = $k[--$j];
        var _2I = $k[--$j];
        $k[$j++] = _2H;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $forall(_2I, function() {
          var _2J = $k[--$j];
          $k[$j++] = $f(_2J - 48);
        });
        var _2M = $eq($get($1.ais, 0), "11") ? 0 : 1;
        $k[$j++] = _2M;
        $1.cdf = $a();
        $1.ais = $geti($1.ais, 1, $1.ais.length - 1);
        $1.vals = $geti($1.vals, 1, $1.vals.length - 1);
        $1.fncs = $geti($1.fncs, 1, $1.fncs.length - 1);
      } else {
        $1.cdf = $a([1, 0, 1, 1]);
      }
      if ($1.ais.length != 0) {
        if ($eq($get($1.ais, 0), "10")) {
          $k[$j++] = Infinity;
          $forall($get($1.vals, 0));
          $1.gpf = $a();
          if ($1.ais.length > 1) {
            $k[$j++] = Infinity;
            $aload($1.gpf);
            $k[$j++] = $1.fnc1;
            $1.gpf = $a();
          }
          $1.ais = $geti($1.ais, 1, $1.ais.length - 1);
          $1.vals = $geti($1.vals, 1, $1.vals.length - 1);
          $1.fncs = $geti($1.fncs, 1, $1.fncs.length - 1);
        } else {
          $1.gpf = $a([$1.fnc1]);
        }
      } else {
        $k[$j++] = Infinity;
        $aload($1.cdf);
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $1.cdf = $a();
        $1.gpf = $a([]);
      }
      $1.mode = "numeric";
    }
    if ($eq($1.method, "11")) {
      $1.cdf = $a([1, 1]);
      $1.ai90 = $get($1.vals, 0);
      if ($f($1.npre + 1) != $1.ai90.length) {
        $k[$j++] = $geti($1.ai90, $f($1.npre + 1), $f($f($1.ai90.length - $1.npre) - 1));
      } else {
        $k[$j++] = "";
      }
      $1.ai90rem = $k[--$j];
      $k[$j++] = "nalpha";
      $k[$j++] = 0;
      $forall($1.ai90rem, function() {
        var _39 = $k[--$j];
        if (_39 >= 65 && _39 <= 90) {
          var _3A = $k[--$j];
          $k[$j++] = $f(_3A + 1);
        }
      });
      var _3B = $k[--$j];
      $1[$k[--$j]] = _3B;
      $k[$j++] = "nnums";
      $k[$j++] = 0;
      $forall($1.ai90rem, function() {
        var _3E = $k[--$j];
        if (_3E >= 48 && _3E <= 57) {
          var _3F = $k[--$j];
          $k[$j++] = $f(_3F + 1);
        }
      });
      var _3G = $k[--$j];
      $1[$k[--$j]] = _3G;
      $k[$j++] = "mode";
      if ($gt($1.nalpha, $1.nnums)) {
        $k[$j++] = "alpha";
      } else {
        if ($1.nalpha == 0) {
          $k[$j++] = "numeric";
        } else {
          $k[$j++] = "alphanumeric";
        }
      }
      var _3L = $k[--$j];
      $1[$k[--$j]] = _3L;
      if ($f($1.nalpha + $1.nnums) != $1.ai90rem.length) {
        $1.mode = "alphanumeric";
      }
      $k[$j++] = Infinity;
      $aload($1.cdf);
      if ($eq($1.mode, "alphanumeric")) {
        $k[$j++] = 0;
      }
      if ($eq($1.mode, "numeric")) {
        $k[$j++] = 1;
        $k[$j++] = 0;
      }
      if ($eq($1.mode, "alpha")) {
        $k[$j++] = 1;
        $k[$j++] = 1;
      }
      $1.cdf = $a();
      $k[$j++] = "ais1";
      if ($1.ais.length > 1) {
        $k[$j++] = $get($1.ais, 1);
      } else {
        $k[$j++] = -1;
      }
      var _3Y = $k[--$j];
      $1[$k[--$j]] = _3Y;
      $k[$j++] = "vals1";
      if ($1.vals.length > 1) {
        $k[$j++] = $get($1.vals, 1);
      } else {
        $k[$j++] = -1;
      }
      var _3d = $k[--$j];
      $1[$k[--$j]] = _3d;
      if ($eq($1.ais1, "21") || $eq($1.ais1, "8004")) {
        $k[$j++] = Infinity;
        $aload($1.cdf);
        if ($eq($1.ais1, "21")) {
          $k[$j++] = 1;
          $k[$j++] = 0;
        } else {
          $k[$j++] = 1;
          $k[$j++] = 1;
        }
        $1.cdf = $a();
      } else {
        $k[$j++] = Infinity;
        $aload($1.cdf);
        $k[$j++] = 0;
        $1.cdf = $a();
      }
      $k[$j++] = "nval";
      if ($1.npre != 0) {
        $k[$j++] = $cvi($geti($1.ai90, 0, $1.npre));
      } else {
        $k[$j++] = 0;
      }
      var _3q = $k[--$j];
      $1[$k[--$j]] = _3q;
      $search("BDHIJKLNPQRSTVXZ", $geti($1.ai90, $1.npre, 1));
      if ($k[--$j]) {
        var _3w = $k[--$j];
        var _3x = $k[--$j];
        $k[$j++] = _3w.length;
        $k[$j++] = _3x;
        $j--;
        var _3y = $k[--$j];
        var _3z = $k[--$j];
        $k[$j++] = _3y;
        $k[$j++] = _3z;
        $j--;
        $1.aval = $k[--$j];
      } else {
        $j--;
        $1.aval = -1;
      }
      if ($1.nval < 31 && $1.aval != -1) {
        var _44 = $strcpy($s(5), "00000");
        var _47 = $cvrs($s(5), $1.nval, 2);
        $puti(_44, 5 - _47.length, _47);
        $k[$j++] = _44;
        $k[$j++] = Infinity;
        var _48 = $k[--$j];
        var _49 = $k[--$j];
        $k[$j++] = _48;
        $forall(_49, function() {
          var _4A = $k[--$j];
          $k[$j++] = $f(_4A - 48);
        });
        $1.nbits = $a();
        var _4D = $strcpy($s(4), "0000");
        var _4G = $cvrs($s(4), $1.aval, 2);
        $puti(_4D, 4 - _4G.length, _4G);
        $k[$j++] = _4D;
        $k[$j++] = Infinity;
        var _4H = $k[--$j];
        var _4I = $k[--$j];
        $k[$j++] = _4H;
        $forall(_4I, function() {
          var _4J = $k[--$j];
          $k[$j++] = $f(_4J - 48);
        });
        $1.abits = $a();
        $k[$j++] = Infinity;
        $aload($1.cdf);
        $aload($1.nbits);
        $aload($1.abits);
        $1.cdf = $a();
      } else {
        var _4Q = $strcpy($s(10), "0000000000");
        var _4T = $cvrs($s(10), $1.nval, 2);
        $puti(_4Q, 10 - _4T.length, _4T);
        $k[$j++] = _4Q;
        $k[$j++] = Infinity;
        var _4U = $k[--$j];
        var _4V = $k[--$j];
        $k[$j++] = _4U;
        $forall(_4V, function() {
          var _4W = $k[--$j];
          $k[$j++] = $f(_4W - 48);
        });
        $1.nbits = $a();
        var _4Z = $strcpy($s(5), "00000");
        var _4e = $cvrs($s(5), $f($get($1.ai90, $1.npre) - 65), 2);
        $puti(_4Z, 5 - _4e.length, _4e);
        $k[$j++] = _4Z;
        $k[$j++] = Infinity;
        var _4f = $k[--$j];
        var _4g = $k[--$j];
        $k[$j++] = _4f;
        $forall(_4g, function() {
          var _4h = $k[--$j];
          $k[$j++] = $f(_4h - 48);
        });
        $1.abits = $a();
        $k[$j++] = Infinity;
        $aload($1.cdf);
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $aload($1.nbits);
        $aload($1.abits);
        $1.cdf = $a();
      }
      if ($ne($1.mode, "alpha")) {
        $k[$j++] = Infinity;
        $forall($1.ai90rem);
        if ($1.ais.length > 1) {
          $k[$j++] = $1.fnc1;
        }
        $1.gpf = $a();
      } else {
        $k[$j++] = Infinity;
        $forall($1.ai90rem);
        if ($1.ais.length > 1) {
          $k[$j++] = $1.fnc1;
        }
        $1.in = $a();
        $1.out = $a($1.in.length * 6);
        $1.j = 0;
        for (var _50 = 0, _4z = $1.in.length - 1; _50 <= _4z; _50 += 1) {
          var _54 = $get($1.alpha, $get($1.in, _50));
          $k[$j++] = _54;
          $k[$j++] = _54;
          $k[$j++] = Infinity;
          var _55 = $k[--$j];
          var _56 = $k[--$j];
          $k[$j++] = _55;
          $forall(_56, function() {
            var _57 = $k[--$j];
            $k[$j++] = $f(_57 - 48);
          });
          $puti($1.out, $1.j, $a());
          $1.j = $k[--$j].length + $1.j;
        }
        $k[$j++] = Infinity;
        $aload($1.cdf);
        $aload($geti($1.out, 0, $1.j));
        $1.cdf = $a();
        $1.gpf = $a([]);
        if ($1.ais.length > 1) {
          $1.mode = "numeric";
        }
      }
      $1.ais = $geti($1.ais, 1, $1.ais.length - 1);
      $1.vals = $geti($1.vals, 1, $1.vals.length - 1);
      $1.fncs = $geti($1.fncs, 1, $1.fncs.length - 1);
      if ($1.ais.length != 0) {
        if ($eq($1.ais1, "21") || $eq($1.ais1, "8004")) {
          $k[$j++] = Infinity;
          $aload($1.gpf);
          $forall($1.vals1);
          $1.gpf = $a();
          $1.ais = $geti($1.ais, 1, $1.ais.length - 1);
          $1.vals = $geti($1.vals, 1, $1.vals.length - 1);
          $1.fncs = $geti($1.fncs, 1, $1.fncs.length - 1);
          if ($1.ais.length != 0) {
            $k[$j++] = Infinity;
            $aload($1.gpf);
            $k[$j++] = $1.fnc1;
            $1.gpf = $a();
          }
        }
      }
    }
    if ($eq($1.method, "0")) {
      $1.cdf = $a([0]);
      $1.gpf = $a([]);
      $1.mode = "numeric";
    }
    for (var _5r = 0, _5q = $1.ais.length - 1; _5r <= _5q; _5r += 1) {
      $1.i = _5r;
      $1.ai = $get($1.ais, $1.i);
      $1.val = $get($1.vals, $1.i);
      var _61 = $a($1.gpf.length + $1.ai.length + $1.val.length);
      $puti(_61, 0, $1.gpf);
      $k[$j++] = _61;
      $k[$j++] = _61;
      $k[$j++] = $1.gpf.length;
      $k[$j++] = $1.ai;
      $k[$j++] = Infinity;
      var _65 = $k[--$j];
      var _66 = $k[--$j];
      $k[$j++] = _65;
      $forall(_66);
      var _67 = $a();
      var _68 = $k[--$j];
      $puti($k[--$j], _68, _67);
      var _6A = $k[--$j];
      $k[$j++] = _6A;
      $k[$j++] = _6A;
      $k[$j++] = $1.gpf.length + $1.ai.length;
      $k[$j++] = $1.val;
      $k[$j++] = Infinity;
      var _6E = $k[--$j];
      var _6F = $k[--$j];
      $k[$j++] = _6E;
      $forall(_6F);
      var _6G = $a();
      var _6H = $k[--$j];
      $puti($k[--$j], _6H, _6G);
      $1.gpf = $k[--$j];
      if ($1.i != $1.ais.length - 1 && $get($1.fncs, $1.i)) {
        var _6Q = $a($1.gpf.length + 1);
        $puti(_6Q, 0, $1.gpf);
        $put(_6Q, $1.gpf.length, $1.fnc1);
        $1.gpf = _6Q;
      }
    }
    if (!bwipp_gs1_cc.__27491__) {
      (function() {
        var $ctx = Object.create($1);
        var _6c = /* @__PURE__ */ new Map([
          ["a", $a([$a([167, 138, 118, 108, 88, 78, 59]), $a([167, 138, 118, 98, 78]), $a([197, 167, 138, 108, 78])])],
          ["b", $a([$a([336, 296, 256, 208, 160, 104, 56]), $a([768, 648, 536, 416, 304, 208, 152, 112, 72, 32]), $a([1184, 1016, 840, 672, 496, 352, 264, 208, 152, 96, 56])])]
        ]);
        $ctx.bitcapsmaps = _6c;
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1_cc.$ctx[id] = $ctx[id]);
        bwipp_gs1_cc.__27491__ = 1;
      })();
    }
    $1.rembits = function() {
      $1.used = $k[--$j];
      if ($ne($1.ccversion, "c")) {
        $1.bitcaps = $get($get($1.bitcapsmaps, $1.ccversion), $f($1.cccolumns - 2));
        $k[$j++] = -1;
        $forall($1.bitcaps, function() {
          var _6m = $k[--$j];
          $k[$j++] = _6m;
          if ($ge(_6m, $1.used)) {
            var _6o = $k[--$j];
            var _6p = $k[--$j];
            $k[$j++] = _6o;
            $k[$j++] = _6p;
          }
          $j--;
        });
        var _6q = $k[--$j];
        $k[$j++] = _6q;
        if (_6q != -1) {
          var _6s = $k[--$j];
          $k[$j++] = $f(_6s - $1.used);
        }
      } else {
        var _6t = /* @__PURE__ */ new Map([
          ["c", -1]
        ]);
        var _6v = $get(_6t, $1.ccversion);
        var _6x = ~~Math.ceil($1.used / 8);
        $1.m = ~~(_6x / 6) * 5 + _6x % 6;
        if ($1.m <= 40) {
          $k[$j++] = 8;
        }
        if ($1.m >= 41 && $1.m <= 160) {
          $k[$j++] = 16;
        }
        if ($1.m >= 161 && $1.m <= 320) {
          $k[$j++] = 32;
        }
        if ($1.m >= 321 && $1.m <= 833) {
          $k[$j++] = 64;
        }
        if ($1.m >= 834) {
          $k[$j++] = 32;
        }
        $1.eccws = $k[--$j];
        $1.m = $f($f($1.m + $1.eccws) + 3);
        if ($1.cccolumns > 30) {
          $1.cccolumns = 30;
        }
        for (; ; ) {
          if (~~Math.ceil($1.m / $1.cccolumns) <= 30 || $1.cccolumns >= 30) {
            break;
          }
          $1.cccolumns = $1.cccolumns + 1;
        }
        $1.r = ~~Math.ceil($1.m / $1.cccolumns);
        if ($1.r < 3) {
          $1.r = 3;
        }
        var _7K = $f($f($1.cccolumns * $1.r - $1.eccws) - 3);
        $1.tgt = $f(~~(_7K / 5) * 6 + _7K % 5) * 8;
        if ($1.used <= 8304) {
          $k[$j++] = $f($1.tgt - $1.used);
        } else {
          $k[$j++] = -1;
        }
      }
      var _7O = $k[--$j];
      $k[$j++] = _7O;
      if (_7O == -1) {
        $j--;
        if ($eq($1.ccversion, "a")) {
          $1.ccversion = "b";
        } else {
          if ($eq($1.ccversion, "b") && $eq($1.lintype, "gs1-128")) {
            $1.ccversion = "c";
            $1.cccolumns = ~~(($1.linwidth - 52) / 17);
          } else {
            $1.ccversion = -1;
          }
        }
        $k[$j++] = $1.used;
        $1.rembits();
      }
    };
    $1.encode = function() {
      var _7U = $k[--$j];
      $k[$j++] = _7U;
      if ($ne(_7U, "raw")) {
        var _7V = $k[--$j];
        var _7X = $get(_7V, $k[--$j]);
        $k[$j++] = _7X;
      } else {
        $j--;
      }
      $k[$j++] = Infinity;
      var _7Y = $k[--$j];
      var _7Z = $k[--$j];
      $k[$j++] = _7Y;
      $forall(_7Z, function() {
        var _7a = $k[--$j];
        $k[$j++] = $f(_7a - 48);
      });
      var _7b = $a();
      $puti($1.gpfenc, $1.j, _7b);
      $1.j = _7b.length + $1.j;
    };
    $k[$j++] = Infinity;
    for (var _7g = 0, _7h = $1.gpf.length; _7g < _7h; _7g++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $k[$j++] = -1;
    $1.numericruns = $a();
    $k[$j++] = Infinity;
    for (var _7k = 0, _7l = $1.gpf.length; _7k < _7l; _7k++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $1.alphanumericruns = $a();
    $k[$j++] = Infinity;
    for (var _7o = 0, _7p = $1.gpf.length; _7o < _7p; _7o++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $1.nextiso646only = $a();
    for (var _7s = $1.gpf.length - 1; _7s >= 0; _7s -= 1) {
      $1.i = _7s;
      var _7x = $strcpy($s(2), "00");
      var _80 = $get($1.gpf, $1.i);
      $k[$j++] = $get($1.gpf, $1.i);
      $k[$j++] = _7x;
      $k[$j++] = _7x;
      $k[$j++] = 0;
      $k[$j++] = _80;
      if (_80 == $1.fnc1) {
        $j--;
        $k[$j++] = 94;
      }
      var _82 = $k[--$j];
      var _83 = $k[--$j];
      $put($k[--$j], _83, _82);
      if ($1.i < $1.gpf.length - 1) {
        var _87 = $k[--$j];
        var _8A = $get($1.gpf, $1.i + 1);
        $k[$j++] = _87;
        $k[$j++] = _87;
        $k[$j++] = 1;
        $k[$j++] = _8A;
        if (_8A == $1.fnc1) {
          $j--;
          $k[$j++] = 94;
        }
        var _8C = $k[--$j];
        var _8D = $k[--$j];
        $put($k[--$j], _8D, _8C);
      }
      var _8H = $get($1.numeric, $k[--$j]) !== void 0;
      if (_8H) {
        $put($1.numericruns, $1.i, $f($get($1.numericruns, $1.i + 2) + 2));
      } else {
        $put($1.numericruns, $1.i, 0);
      }
      var _8P = $k[--$j];
      var _8R = $get($1.alphanumeric, _8P) !== void 0;
      $k[$j++] = _8P;
      if (_8R) {
        $put($1.alphanumericruns, $1.i, $f($get($1.alphanumericruns, $1.i + 1) + 1));
      } else {
        $put($1.alphanumericruns, $1.i, 0);
      }
      var _8Z = $k[--$j];
      var _8b = $get($1.iso646, _8Z) !== void 0;
      var _8d = $get($1.alphanumeric, _8Z) !== void 0;
      if (_8b && !_8d) {
        $put($1.nextiso646only, $1.i, 0);
      } else {
        $put($1.nextiso646only, $1.i, $f($get($1.nextiso646only, $1.i + 1) + 1));
      }
    }
    $1.gpfenc = $a(8304);
    $1.i = 0;
    $1.j = 0;
    for (; ; ) {
      if ($1.i == $1.gpf.length) {
        break;
      }
      for (; ; ) {
        if ($eq($1.mode, "numeric")) {
          if ($1.i <= $1.gpf.length - 2) {
            var _8r = $s(2);
            var _8u = $get($1.gpf, $1.i);
            $k[$j++] = _8r;
            $k[$j++] = _8r;
            $k[$j++] = 0;
            $k[$j++] = _8u;
            if (_8u == $1.fnc1) {
              $j--;
              $k[$j++] = 94;
            }
            var _8w = $k[--$j];
            var _8x = $k[--$j];
            $put($k[--$j], _8x, _8w);
            var _8z = $k[--$j];
            var _92 = $get($1.gpf, $1.i + 1);
            $k[$j++] = _8z;
            $k[$j++] = _8z;
            $k[$j++] = 1;
            $k[$j++] = _92;
            if (_92 == $1.fnc1) {
              $j--;
              $k[$j++] = 94;
            }
            var _94 = $k[--$j];
            var _95 = $k[--$j];
            $put($k[--$j], _95, _94);
            var _97 = $k[--$j];
            var _99 = $get($1.numeric, _97) !== void 0;
            $k[$j++] = _97;
            if (_99) {
              $k[$j++] = $1.numeric;
              $1.encode();
              $1.i = $1.i + 2;
              break;
            }
            $j--;
            $k[$j++] = $1.lalphanumeric;
            $k[$j++] = $1.numeric;
            $1.encode();
            $1.mode = "alphanumeric";
            break;
          } else {
            var _9G = $get($1.gpf, $1.i);
            if (_9G < 48 || _9G > 57) {
              $k[$j++] = $1.lalphanumeric;
              $k[$j++] = $1.numeric;
              $1.encode();
              $1.mode = "alphanumeric";
              break;
            }
            $k[$j++] = "rem";
            $k[$j++] = $1.cdf.length + $1.j;
            $1.rembits();
            var _9L = $k[--$j];
            $1[$k[--$j]] = _9L;
            if ($1.rem >= 4 && $1.rem <= 6) {
              var _9S = $geti($strcpy($s(6), "000000"), 0, $1.rem);
              var _9X = $cvrs($s(4), $f($get($1.gpf, $1.i) - 47), 2);
              $puti(_9S, 4 - _9X.length, _9X);
              $k[$j++] = _9S;
              $k[$j++] = "raw";
              $1.encode();
              $1.i = $1.i + 1;
              break;
            } else {
              var _9Z = $s(2);
              $put(_9Z, 0, $get($1.gpf, $1.i));
              $put(_9Z, 1, 94);
              $k[$j++] = _9Z;
              $k[$j++] = $1.numeric;
              $1.encode();
              $1.i = $1.i + 1;
              break;
            }
          }
        }
        if ($eq($1.mode, "alphanumeric")) {
          if ($get($1.gpf, $1.i) == $1.fnc1) {
            $k[$j++] = $1.fnc1;
            $k[$j++] = $1.alphanumeric;
            $1.encode();
            $1.mode = "numeric";
            $1.i = $1.i + 1;
            break;
          }
          var _9p = $get($1.gpf, $1.i);
          var _9r = $get($1.iso646, _9p) !== void 0;
          var _9t = $get($1.alphanumeric, _9p) !== void 0;
          if (_9r && !_9t) {
            $k[$j++] = $1.liso646;
            $k[$j++] = $1.alphanumeric;
            $1.encode();
            $1.mode = "iso646";
            break;
          }
          if ($get($1.numericruns, $1.i) >= 6) {
            $k[$j++] = $1.lnumeric;
            $k[$j++] = $1.alphanumeric;
            $1.encode();
            $1.mode = "numeric";
            break;
          }
          var _A3 = $get($1.numericruns, $1.i);
          if (_A3 >= 4 && $f(_A3 + $1.i) == $1.gpf.length) {
            $k[$j++] = $1.lnumeric;
            $k[$j++] = $1.alphanumeric;
            $1.encode();
            $1.mode = "numeric";
            break;
          }
          $k[$j++] = $get($1.gpf, $1.i);
          $k[$j++] = $1.alphanumeric;
          $1.encode();
          $1.i = $1.i + 1;
          break;
        }
        if ($eq($1.mode, "iso646")) {
          if ($get($1.gpf, $1.i) == $1.fnc1) {
            $k[$j++] = $1.fnc1;
            $k[$j++] = $1.iso646;
            $1.encode();
            $1.mode = "numeric";
            $1.i = $1.i + 1;
            break;
          }
          if ($get($1.numericruns, $1.i) >= 4 && $get($1.nextiso646only, $1.i) >= 10) {
            $k[$j++] = $1.lnumeric;
            $k[$j++] = $1.iso646;
            $1.encode();
            $1.mode = "numeric";
            break;
          }
          if ($get($1.alphanumericruns, $1.i) >= 5 && $get($1.nextiso646only, $1.i) >= 10) {
            $k[$j++] = $1.lalphanumeric;
            $k[$j++] = $1.iso646;
            $1.encode();
            $1.mode = "alphanumeric";
            break;
          }
          $k[$j++] = $get($1.gpf, $1.i);
          $k[$j++] = $1.iso646;
          $1.encode();
          $1.i = $1.i + 1;
          break;
        }
      }
    }
    $1.gpf = $geti($1.gpfenc, 0, $1.j);
    $k[$j++] = "pad";
    $k[$j++] = $1.cdf.length + $1.gpf.length;
    $1.rembits();
    var _Am = $a($k[--$j]);
    $1[$k[--$j]] = _Am;
    if ($1.pad.length > 0) {
      for (var _Ar = 0, _Aq = $1.pad.length - 1; _Ar <= _Aq; _Ar += 5) {
        $1.i = _Ar;
        var _As = $1.pad;
        var _At = $1.i;
        var _Au = $a([0, 0, 1, 0, 0]);
        var _Av = $1.pad;
        var _Aw = $1.i;
        var _Ax = 5;
        var _Ay = _Av.length - _Aw;
        if (_Av.length - _Aw > 5) {
          var _ = _Ax;
          _Ax = _Ay;
          _Ay = _;
        }
        $puti(_As, _At, $geti(_Au, 0, _Ay));
      }
      if ($eq($1.mode, "numeric")) {
        $k[$j++] = Infinity;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $aload($1.pad);
        $1.pad = $geti($a(), 0, $1.pad.length);
      }
      if ($eq($1.mode, "alpha")) {
        $k[$j++] = Infinity;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 1;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $aload($1.pad);
        $1.pad = $geti($a(), 0, $1.pad.length);
      }
    }
    $k[$j++] = Infinity;
    $aload($1.cdf);
    $aload($1.gpf);
    $aload($1.pad);
    $1.bits = $a();
    if (!bwipp_gs1_cc.__27702__) {
      (function() {
        var $ctx = Object.create($1);
        $k[$j++] = Infinity;
        $k[$j++] = $a([0, 0, 0, 0, 0, 0, 1]);
        for (var _BF = 0, _BG = 68; _BF < _BG; _BF++) {
          $k[$j++] = $a(7);
        }
        $ctx.pwr928 = $a();
        for (var _BJ = 1; _BJ <= 68; _BJ += 1) {
          $ctx.j = _BJ;
          $ctx.v = 0;
          for (var _BK = 6; _BK >= 1; _BK -= 1) {
            $ctx.i = _BK;
            $ctx.v = $f($get($get($ctx.pwr928, $ctx.j - 1), $ctx.i) * 2 + ~~($ctx.v / 928));
            $put($get($ctx.pwr928, $ctx.j), $ctx.i, $ctx.v % 928);
          }
          $put($get($ctx.pwr928, $ctx.j), 0, $f($get($get($ctx.pwr928, $ctx.j - 1), 0) * 2 + ~~($ctx.v / 928)));
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_gs1_cc.$ctx[id] = $ctx[id]);
        bwipp_gs1_cc.__27702__ = 1;
      })();
    }
    if ($1.ccversion == "a") {
      $k[$j++] = Infinity;
      for (var _Bg = 0, _Bh = 28; _Bg < _Bh; _Bg++) {
        $k[$j++] = 0;
      }
      $1.cws = $a();
      $1.b = 0;
      $1.c = 0;
      for (; ; ) {
        if ($1.b == $1.bits.length) {
          break;
        }
        var _Bl = $1.bits;
        var _Bm = $1.b;
        var _Bn = $1.bits;
        var _Bo = $1.b;
        var _Bp = _Bn.length - _Bo;
        var _Bq = 69;
        if (69 > _Bn.length - _Bo) {
          var _ = _Bp;
          _Bp = _Bq;
          _Bq = _;
        }
        $1.bs = $geti(_Bl, _Bm, _Bq);
        $1.bsl = $1.bs.length;
        $1.cs = $geti($1.cws, $1.c, ~~($1.bsl / 10) + 1);
        $1.csl = $1.cs.length;
        for (var _C0 = 0, _Bz = $1.bsl - 1; _C0 <= _Bz; _C0 += 1) {
          $1.i = _C0;
          for (var _C3 = 0, _C2 = $1.csl - 1; _C3 <= _C2; _C3 += 1) {
            $1.j = _C3;
            var _C4 = $1.cs;
            var _C5 = $1.j;
            $put(_C4, _C5, $f($get(_C4, _C5) + $get($get($1.pwr928, $1.i), $1.j + 7 - $1.csl) * $get($1.bs, $1.bsl - $1.i - 1)));
          }
        }
        for (var _CI = $1.csl - 1; _CI >= 1; _CI -= 1) {
          $1.i = _CI;
          var _CJ = $1.cs;
          var _CK = $1.i;
          $put(_CJ, _CK - 1, $f($get(_CJ, _CK - 1) + ~~($get($1.cs, $1.i) / 928)));
          var _CP = $1.cs;
          var _CQ = $1.i;
          $put(_CP, _CQ, $get(_CP, _CQ) % 928);
        }
        $1.b = $1.b + $1.bsl;
        $1.c = $1.c + $1.csl;
      }
      $1.cws = $geti($1.cws, 0, $1.c);
      $1.barcode = $s($1.cws.length * 4);
      for (var _Cd = 0, _Cc = $1.cws.length - 1; _Cd <= _Cc; _Cd += 1) {
        $1.i = _Cd;
        var _Cf = $strcpy($s(4), "^000");
        var _Ck = $cvrs($s(4), $get($1.cws, $1.i), 10);
        $puti(_Cf, 4 - _Ck.length, _Ck);
        $puti($1.barcode, $1.i * 4, _Cf);
      }
      delete $1.options["parse"];
      $put($1.options, "dontdraw", true);
      $put($1.options, "cca", true);
      $put($1.options, "columns", $1.cccolumns);
      $k[$j++] = "args";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.options;
      bwipp_micropdf417();
      var _Cu = $k[--$j];
      $1[$k[--$j]] = _Cu;
    }
    if ($1.ccversion == "b") {
      $1.barcode = $s(~~($1.bits.length / 8));
      for (var _D1 = 0, _D0 = $1.barcode.length - 1; _D1 <= _D0; _D1 += 1) {
        $1.i = _D1;
        var _D4 = $geti($1.bits, $1.i * 8, 8);
        $k[$j++] = 0;
        for (var _D5 = 0, _D6 = _D4.length; _D5 < _D6; _D5++) {
          var _D8 = $k[--$j];
          $k[$j++] = $f(_D8 + $get(_D4, _D5)) * 2;
        }
        $put($1.barcode, $1.i, ~~($k[--$j] / 2));
      }
      delete $1.options["parse"];
      $put($1.options, "dontdraw", true);
      $put($1.options, "ccb", true);
      $put($1.options, "columns", $1.cccolumns);
      $k[$j++] = "args";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.options;
      bwipp_micropdf417();
      var _DJ = $k[--$j];
      $1[$k[--$j]] = _DJ;
    }
    if ($1.ccversion == "c") {
      $1.barcode = $s(~~($1.bits.length / 8));
      for (var _DQ = 0, _DP = $1.barcode.length - 1; _DQ <= _DP; _DQ += 1) {
        $1.i = _DQ;
        var _DT = $geti($1.bits, $1.i * 8, 8);
        $k[$j++] = 0;
        for (var _DU = 0, _DV = _DT.length; _DU < _DV; _DU++) {
          var _DX = $k[--$j];
          $k[$j++] = $f(_DX + $get(_DT, _DU)) * 2;
        }
        $put($1.barcode, $1.i, ~~($k[--$j] / 2));
      }
      delete $1.options["parse"];
      $put($1.options, "dontdraw", true);
      $put($1.options, "ccc", true);
      $put($1.options, "columns", $1.cccolumns);
      $put($1.options, "eclevel", ~~(Math.log($1.eccws) / Math.log(2)) - 1);
      $k[$j++] = "args";
      $k[$j++] = $1.barcode;
      $k[$j++] = $1.options;
      bwipp_pdf417();
      var _Dk = $k[--$j];
      $1[$k[--$j]] = _Dk;
    }
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_ean13composite() {
    var $1 = Object.create(bwipp_ean13composite.$ctx || (bwipp_ean13composite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#27832";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    $put($1.options, "lintype", "ean13");
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _C = $s($1.comp.length + 18);
    $puti(_C, 0, "(01)00000000000000");
    $puti(_C, 18, $1.comp);
    $k[$j++] = _C;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_ean13();
    if (!$1.usematrix) {
      $$.save();
      bwipp_renlinear();
      $$.rmoveto(-1, 72);
      $k[$j++] = Infinity;
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _H = 0, _I = 93; _H < _I; _H++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _J = 0, _K = 93; _J < _K; _J++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _L = 0, _M = 93; _L < _M; _L++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      var _N = $a();
      $k[$j++] = "ren";
      $k[$j++] = bwipp_renmatrix;
      $k[$j++] = "pixs";
      $k[$j++] = _N;
      $k[$j++] = "pixx";
      $k[$j++] = 97;
      $k[$j++] = "pixy";
      $k[$j++] = 3;
      $k[$j++] = "height";
      $k[$j++] = 6 / 72;
      $k[$j++] = "width";
      $k[$j++] = 97 / 72;
      $k[$j++] = "opt";
      $k[$j++] = $1.options;
      var _P = $d();
      $k[$j++] = _P;
      bwipp_renmatrix();
      $$.rmoveto(-2, 6);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $1.linsym = $k[--$j];
      $1.sbs = $get($1.linsym, "sbs");
      $1.bhs = $get($1.linsym, "bhs");
      $1.bbs = $get($1.linsym, "bbs");
      $k[$j++] = "linwidth";
      $k[$j++] = 0;
      $forall($1.sbs, function() {
        var _a = $k[--$j];
        var _b = $k[--$j];
        $k[$j++] = $f(_b + $cvi(_a));
      });
      var _c = $k[--$j];
      $1[$k[--$j]] = _c;
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _g = $k[--$j];
      $1[$k[--$j]] = _g;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      for (var _n = 0, _o = $f($1.ccpixx - 97); _n < _o; _n++) {
        $k[$j++] = 0;
      }
      $1.linpad = $a();
      $1.diff = $f($f($f($1.linwidth + $1.linpad.length) + 2) - $1.ccpixx);
      if ($1.diff > 0) {
        $k[$j++] = Infinity;
        for (var _v = 0, _w = $1.diff; _v < _w; _v++) {
          $k[$j++] = 0;
        }
        $1.ccrpad = $a();
        $1.pixx = $f($1.ccpixx + $1.diff);
      } else {
        $1.ccrpad = $a(0);
        $1.pixx = $1.ccpixx;
      }
      $k[$j++] = Infinity;
      for (var _15 = 0, _16 = $1.ccpixx, _14 = $1.ccpixs.length - 1; _16 < 0 ? _15 >= _14 : _15 <= _14; _15 += _16) {
        $1.i = _15;
        for (var _17 = 0, _18 = 2; _17 < _18; _17++) {
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $aload($1.ccrpad);
        }
      }
      for (var _1E = 0, _1F = 2; _1E < _1F; _1E++) {
        $aload($1.linpad);
        $k[$j++] = 0;
        $k[$j++] = 1;
        for (var _1H = 0, _1I = 93; _1H < _1I; _1H++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 1;
        $k[$j++] = 0;
        $aload($1.ccrpad);
      }
      for (var _1K = 0, _1L = 2; _1K < _1L; _1K++) {
        $aload($1.linpad);
        $k[$j++] = 1;
        $k[$j++] = 0;
        for (var _1N = 0, _1O = 93; _1N < _1O; _1N++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 0;
        $k[$j++] = 1;
        $aload($1.ccrpad);
      }
      for (var _1Q = 0, _1R = 2; _1Q < _1R; _1Q++) {
        $aload($1.linpad);
        $k[$j++] = 0;
        $k[$j++] = 1;
        for (var _1T = 0, _1U = 93; _1T < _1U; _1T++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 1;
        $k[$j++] = 0;
        $aload($1.ccrpad);
      }
      for (var _1W = 71; _1W >= 0; _1W -= 1) {
        $1.y = _1W;
        $aload($1.linpad);
        $k[$j++] = 0;
        for (var _1a = 0, _1Z = $1.sbs.length - 1; _1a <= _1Z; _1a += 1) {
          $1.i = _1a;
          if ($1.i % 2 == 0) {
            var _1f = $get($1.bbs, ~~($1.i / 2)) * 72;
            if (_1f > $1.y || $f(_1f + $get($1.bhs, ~~($1.i / 2)) * 72) < $1.y) {
              for (var _1o = 0, _1p = $cvi($get($1.sbs, $1.i)); _1o < _1p; _1o++) {
                $k[$j++] = 0;
              }
            } else {
              for (var _1t = 0, _1u = $cvi($get($1.sbs, $1.i)); _1t < _1u; _1t++) {
                $k[$j++] = 1;
              }
            }
          } else {
            for (var _1y = 0, _1z = $cvi($get($1.sbs, $1.i)); _1y < _1z; _1y++) {
              $k[$j++] = 0;
            }
          }
        }
        $k[$j++] = 0;
      }
      $1.pixs = $a();
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _29 = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _29;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_ean8composite() {
    var $1 = Object.create(bwipp_ean8composite.$ctx || (bwipp_ean8composite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#27993";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    $put($1.options, "lintype", "ean8");
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _C = $s($1.comp.length + 18);
    $puti(_C, 0, "(01)00000000000000");
    $puti(_C, 18, $1.comp);
    $k[$j++] = _C;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_ean8();
    if (!$1.usematrix) {
      $$.save();
      bwipp_renlinear();
      $$.rmoveto(-1, 72);
      $k[$j++] = Infinity;
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _H = 0, _I = 65; _H < _I; _H++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _J = 0, _K = 65; _J < _K; _J++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _L = 0, _M = 65; _L < _M; _L++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      var _N = $a();
      $k[$j++] = "ren";
      $k[$j++] = bwipp_renmatrix;
      $k[$j++] = "pixs";
      $k[$j++] = _N;
      $k[$j++] = "pixx";
      $k[$j++] = 69;
      $k[$j++] = "pixy";
      $k[$j++] = 3;
      $k[$j++] = "height";
      $k[$j++] = 6 / 72;
      $k[$j++] = "width";
      $k[$j++] = 69 / 72;
      $k[$j++] = "opt";
      $k[$j++] = $1.options;
      var _P = $d();
      $k[$j++] = _P;
      bwipp_renmatrix();
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _S = $k[--$j];
      $$.rmoveto($f(69 - $get(_S, "pixx")), 6);
      $k[$j++] = _S;
      bwipp_renmatrix();
      $$.restore();
    } else {
      $1.linsym = $k[--$j];
      $1.sbs = $get($1.linsym, "sbs");
      $1.bhs = $get($1.linsym, "bhs");
      $1.bbs = $get($1.linsym, "bbs");
      $k[$j++] = "linwidth";
      $k[$j++] = 0;
      $forall($1.sbs, function() {
        var _c = $k[--$j];
        var _d = $k[--$j];
        $k[$j++] = $f(_d + $cvi(_c));
      });
      var _e = $k[--$j];
      $1[$k[--$j]] = _e;
      var _g = $1.comp;
      $k[$j++] = "compsym";
      $k[$j++] = _g;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _i = $k[--$j];
      $1[$k[--$j]] = _i;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      for (var _p = 0, _q = $f($1.ccpixx - 69); _p < _q; _p++) {
        $k[$j++] = 0;
      }
      $1.linpad = $a();
      $1.diff = $f($f($f($1.linwidth + $1.linpad.length) + 2) - $1.ccpixx);
      if ($1.diff > 0) {
        $k[$j++] = Infinity;
        for (var _x = 0, _y = $1.diff; _x < _y; _x++) {
          $k[$j++] = 0;
        }
        $1.ccrpad = $a();
        $1.pixx = $f($1.ccpixx + $1.diff);
      } else {
        $1.ccrpad = $a(0);
        $1.pixx = $1.ccpixx;
      }
      $k[$j++] = Infinity;
      for (var _17 = 0, _18 = $1.ccpixx, _16 = $1.ccpixs.length - 1; _18 < 0 ? _17 >= _16 : _17 <= _16; _17 += _18) {
        $1.i = _17;
        for (var _19 = 0, _1A = 2; _19 < _1A; _19++) {
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $aload($1.ccrpad);
        }
      }
      for (var _1G = 0, _1H = 2; _1G < _1H; _1G++) {
        $aload($1.linpad);
        $k[$j++] = 0;
        $k[$j++] = 1;
        for (var _1J = 0, _1K = 65; _1J < _1K; _1J++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 1;
        $k[$j++] = 0;
        $aload($1.ccrpad);
      }
      for (var _1M = 0, _1N = 2; _1M < _1N; _1M++) {
        $aload($1.linpad);
        $k[$j++] = 1;
        $k[$j++] = 0;
        for (var _1P = 0, _1Q = 65; _1P < _1Q; _1P++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 0;
        $k[$j++] = 1;
        $aload($1.ccrpad);
      }
      for (var _1S = 0, _1T = 2; _1S < _1T; _1S++) {
        $aload($1.linpad);
        $k[$j++] = 0;
        $k[$j++] = 1;
        for (var _1V = 0, _1W = 65; _1V < _1W; _1V++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 1;
        $k[$j++] = 0;
        $aload($1.ccrpad);
      }
      for (var _1Y = 71; _1Y >= 0; _1Y -= 1) {
        $1.y = _1Y;
        $aload($1.linpad);
        $k[$j++] = 0;
        for (var _1c = 0, _1b = $1.sbs.length - 1; _1c <= _1b; _1c += 1) {
          $1.i = _1c;
          if ($1.i % 2 == 0) {
            var _1h = $get($1.bbs, ~~($1.i / 2)) * 72;
            if (_1h > $1.y || $f(_1h + $get($1.bhs, ~~($1.i / 2)) * 72) < $1.y) {
              for (var _1q = 0, _1r = $cvi($get($1.sbs, $1.i)); _1q < _1r; _1q++) {
                $k[$j++] = 0;
              }
            } else {
              for (var _1v = 0, _1w = $cvi($get($1.sbs, $1.i)); _1v < _1w; _1v++) {
                $k[$j++] = 1;
              }
            }
          } else {
            for (var _20 = 0, _21 = $cvi($get($1.sbs, $1.i)); _20 < _21; _20++) {
              $k[$j++] = 0;
            }
          }
        }
        $k[$j++] = 0;
      }
      $1.pixs = $a();
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _2B = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _2B;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_upcacomposite() {
    var $1 = Object.create(bwipp_upcacomposite.$ctx || (bwipp_upcacomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#28157";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    $put($1.options, "lintype", "ean13");
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _C = $s($1.comp.length + 18);
    $puti(_C, 0, "(01)00000000000000");
    $puti(_C, 18, $1.comp);
    $k[$j++] = _C;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_upca();
    if (!$1.usematrix) {
      $$.save();
      bwipp_renlinear();
      $$.rmoveto(-1, 72);
      $k[$j++] = Infinity;
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _H = 0, _I = 93; _H < _I; _H++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _J = 0, _K = 93; _J < _K; _J++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _L = 0, _M = 93; _L < _M; _L++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      var _N = $a();
      $k[$j++] = "ren";
      $k[$j++] = bwipp_renmatrix;
      $k[$j++] = "pixs";
      $k[$j++] = _N;
      $k[$j++] = "pixx";
      $k[$j++] = 97;
      $k[$j++] = "pixy";
      $k[$j++] = 3;
      $k[$j++] = "height";
      $k[$j++] = 6 / 72;
      $k[$j++] = "width";
      $k[$j++] = 97 / 72;
      $k[$j++] = "opt";
      $k[$j++] = $1.options;
      var _P = $d();
      $k[$j++] = _P;
      bwipp_renmatrix();
      $$.rmoveto(-2, 6);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $1.linsym = $k[--$j];
      $1.sbs = $get($1.linsym, "sbs");
      $1.bhs = $get($1.linsym, "bhs");
      $1.bbs = $get($1.linsym, "bbs");
      $k[$j++] = "linwidth";
      $k[$j++] = 0;
      $forall($1.sbs, function() {
        var _a = $k[--$j];
        var _b = $k[--$j];
        $k[$j++] = $f(_b + $cvi(_a));
      });
      var _c = $k[--$j];
      $1[$k[--$j]] = _c;
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _g = $k[--$j];
      $1[$k[--$j]] = _g;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      for (var _n = 0, _o = $f($1.ccpixx - 97); _n < _o; _n++) {
        $k[$j++] = 0;
      }
      $1.linpad = $a();
      $1.diff = $f($f($f($1.linwidth + $1.linpad.length) + 2) - $1.ccpixx);
      if ($1.diff > 0) {
        $k[$j++] = Infinity;
        for (var _v = 0, _w = $1.diff; _v < _w; _v++) {
          $k[$j++] = 0;
        }
        $1.ccrpad = $a();
        $1.pixx = $f($1.ccpixx + $1.diff);
      } else {
        $1.ccrpad = $a(0);
        $1.pixx = $1.ccpixx;
      }
      $k[$j++] = Infinity;
      for (var _15 = 0, _16 = $1.ccpixx, _14 = $1.ccpixs.length - 1; _16 < 0 ? _15 >= _14 : _15 <= _14; _15 += _16) {
        $1.i = _15;
        for (var _17 = 0, _18 = 2; _17 < _18; _17++) {
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $aload($1.ccrpad);
        }
      }
      for (var _1E = 0, _1F = 2; _1E < _1F; _1E++) {
        $aload($1.linpad);
        $k[$j++] = 0;
        $k[$j++] = 1;
        for (var _1H = 0, _1I = 93; _1H < _1I; _1H++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 1;
        $k[$j++] = 0;
        $aload($1.ccrpad);
      }
      for (var _1K = 0, _1L = 2; _1K < _1L; _1K++) {
        $aload($1.linpad);
        $k[$j++] = 1;
        $k[$j++] = 0;
        for (var _1N = 0, _1O = 93; _1N < _1O; _1N++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 0;
        $k[$j++] = 1;
        $aload($1.ccrpad);
      }
      for (var _1Q = 0, _1R = 2; _1Q < _1R; _1Q++) {
        $aload($1.linpad);
        $k[$j++] = 0;
        $k[$j++] = 1;
        for (var _1T = 0, _1U = 93; _1T < _1U; _1T++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 1;
        $k[$j++] = 0;
        $aload($1.ccrpad);
      }
      for (var _1W = 71; _1W >= 0; _1W -= 1) {
        $1.y = _1W;
        $aload($1.linpad);
        $k[$j++] = 0;
        for (var _1a = 0, _1Z = $1.sbs.length - 1; _1a <= _1Z; _1a += 1) {
          $1.i = _1a;
          if ($1.i % 2 == 0) {
            var _1f = $get($1.bbs, ~~($1.i / 2)) * 72;
            if (_1f > $1.y || $f(_1f + $get($1.bhs, ~~($1.i / 2)) * 72) < $1.y) {
              for (var _1o = 0, _1p = $cvi($get($1.sbs, $1.i)); _1o < _1p; _1o++) {
                $k[$j++] = 0;
              }
            } else {
              for (var _1t = 0, _1u = $cvi($get($1.sbs, $1.i)); _1t < _1u; _1t++) {
                $k[$j++] = 1;
              }
            }
          } else {
            for (var _1y = 0, _1z = $cvi($get($1.sbs, $1.i)); _1y < _1z; _1y++) {
              $k[$j++] = 0;
            }
          }
        }
        $k[$j++] = 0;
      }
      $1.pixs = $a();
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _29 = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _29;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_upcecomposite() {
    var $1 = Object.create(bwipp_upcecomposite.$ctx || (bwipp_upcecomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#28318";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    $put($1.options, "lintype", "upce");
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _C = $s($1.comp.length + 18);
    $puti(_C, 0, "(01)00000000000000");
    $puti(_C, 18, $1.comp);
    $k[$j++] = _C;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_upce();
    if (!$1.usematrix) {
      $$.save();
      bwipp_renlinear();
      $$.rmoveto(-1, 72);
      $k[$j++] = Infinity;
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _H = 0, _I = 49; _H < _I; _H++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _J = 0, _K = 49; _J < _K; _J++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _L = 0, _M = 49; _L < _M; _L++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      var _N = $a();
      $k[$j++] = "ren";
      $k[$j++] = bwipp_renmatrix;
      $k[$j++] = "pixs";
      $k[$j++] = _N;
      $k[$j++] = "pixx";
      $k[$j++] = 53;
      $k[$j++] = "pixy";
      $k[$j++] = 3;
      $k[$j++] = "height";
      $k[$j++] = 6 / 72;
      $k[$j++] = "width";
      $k[$j++] = 53 / 72;
      $k[$j++] = "opt";
      $k[$j++] = $1.options;
      var _P = $d();
      $k[$j++] = _P;
      bwipp_renmatrix();
      $$.rmoveto(-2, 6);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $1.linsym = $k[--$j];
      $1.sbs = $get($1.linsym, "sbs");
      $1.bhs = $get($1.linsym, "bhs");
      $1.bbs = $get($1.linsym, "bbs");
      $k[$j++] = "linwidth";
      $k[$j++] = 0;
      $forall($1.sbs, function() {
        var _a = $k[--$j];
        var _b = $k[--$j];
        $k[$j++] = $f(_b + $cvi(_a));
      });
      var _c = $k[--$j];
      $1[$k[--$j]] = _c;
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _g = $k[--$j];
      $1[$k[--$j]] = _g;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      for (var _n = 0, _o = $f($1.ccpixx - 53); _n < _o; _n++) {
        $k[$j++] = 0;
      }
      $1.linpad = $a();
      $1.diff = $f($f($f($1.linwidth + $1.linpad.length) + 2) - $1.ccpixx);
      if ($1.diff > 0) {
        $k[$j++] = Infinity;
        for (var _v = 0, _w = $1.diff; _v < _w; _v++) {
          $k[$j++] = 0;
        }
        $1.ccrpad = $a();
        $1.pixx = $f($1.ccpixx + $1.diff);
      } else {
        $1.ccrpad = $a(0);
        $1.pixx = $1.ccpixx;
      }
      $k[$j++] = Infinity;
      for (var _15 = 0, _16 = $1.ccpixx, _14 = $1.ccpixs.length - 1; _16 < 0 ? _15 >= _14 : _15 <= _14; _15 += _16) {
        $1.i = _15;
        for (var _17 = 0, _18 = 2; _17 < _18; _17++) {
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $aload($1.ccrpad);
        }
      }
      for (var _1E = 0, _1F = 2; _1E < _1F; _1E++) {
        $aload($1.linpad);
        $k[$j++] = 0;
        $k[$j++] = 1;
        for (var _1H = 0, _1I = 49; _1H < _1I; _1H++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 1;
        $k[$j++] = 0;
        $aload($1.ccrpad);
      }
      for (var _1K = 0, _1L = 2; _1K < _1L; _1K++) {
        $aload($1.linpad);
        $k[$j++] = 1;
        $k[$j++] = 0;
        for (var _1N = 0, _1O = 49; _1N < _1O; _1N++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 0;
        $k[$j++] = 1;
        $aload($1.ccrpad);
      }
      for (var _1Q = 0, _1R = 2; _1Q < _1R; _1Q++) {
        $aload($1.linpad);
        $k[$j++] = 0;
        $k[$j++] = 1;
        for (var _1T = 0, _1U = 49; _1T < _1U; _1T++) {
          $k[$j++] = 0;
        }
        $k[$j++] = 1;
        $k[$j++] = 0;
        $aload($1.ccrpad);
      }
      for (var _1W = 71; _1W >= 0; _1W -= 1) {
        $1.y = _1W;
        $aload($1.linpad);
        $k[$j++] = 0;
        for (var _1a = 0, _1Z = $1.sbs.length - 1; _1a <= _1Z; _1a += 1) {
          $1.i = _1a;
          if ($1.i % 2 == 0) {
            var _1f = $get($1.bbs, ~~($1.i / 2)) * 72;
            if (_1f > $1.y || $f(_1f + $get($1.bhs, ~~($1.i / 2)) * 72) < $1.y) {
              for (var _1o = 0, _1p = $cvi($get($1.sbs, $1.i)); _1o < _1p; _1o++) {
                $k[$j++] = 0;
              }
            } else {
              for (var _1t = 0, _1u = $cvi($get($1.sbs, $1.i)); _1t < _1u; _1t++) {
                $k[$j++] = 1;
              }
            }
          } else {
            for (var _1y = 0, _1z = $cvi($get($1.sbs, $1.i)); _1y < _1z; _1y++) {
              $k[$j++] = 0;
            }
          }
        }
        $k[$j++] = 0;
      }
      $1.pixs = $a();
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _29 = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _29;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_databaromnicomposite() {
    var $1 = Object.create(bwipp_databaromnicomposite.$ctx || (bwipp_databaromnicomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#28479";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    if (!$1.usematrix) {
      $$.save();
    }
    $put($1.options, "lintype", "databaromni");
    $put($1.options, "linkage", true);
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _F = $s($1.linear.length + $1.comp.length);
    $puti(_F, 0, $1.linear);
    $puti(_F, $1.linear.length, $1.comp);
    $k[$j++] = _F;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_databaromni();
    var _L = $k[--$j];
    $1.linsbs = $get(_L, "sbs");
    $1.linheight = $get($get(_L, "bhs"), 0) * 72;
    $k[$j++] = _L;
    if (!$1.usematrix) {
      bwipp_renlinear();
    } else {
      $j--;
    }
    $1.sepfinder = function() {
      $1.fp = $k[--$j];
      for (var _U = $1.fp, _T = $f($1.fp + 12); _U <= _T; _U += 1) {
        $1.i = _U;
        if ($get($1.bot, $1.i) == 0) {
          if ($get($1.bot, $1.i - 1) == 1) {
            $k[$j++] = 1;
          } else {
            var _e = $get($1.sep, $1.i - 1) == 0 ? 1 : 0;
            $k[$j++] = _e;
          }
        } else {
          $k[$j++] = 0;
        }
        $put($1.sep, $1.i, $k[--$j]);
      }
      $1.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
      $k[$j++] = true;
      for (var _j = 0; _j <= 12; _j += 1) {
        var _p = $k[--$j];
        $k[$j++] = _p && $eq($get($1.bot, $f(_j + $1.fp)), $get($1.f3, _j));
      }
      if ($k[--$j]) {
        $puti($1.sep, $1.fp, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $forall($1.linsbs, function() {
      var _v = $k[--$j];
      var _w = $k[--$j];
      var _x = _w == 1 ? 0 : 1;
      $k[$j++] = _w;
      for (var _y = 0, _z = _v; _y < _z; _y++) {
        $k[$j++] = _x;
      }
    });
    $astore($a($counttomark() - 1));
    $1.bot = $k[--$j];
    $j -= 2;
    $k[$j++] = Infinity;
    $forall($1.bot, function() {
      var _14 = $k[--$j];
      $k[$j++] = $f(1 - _14);
    });
    $1.sep = $a();
    $puti($1.sep, 0, $a([0, 0, 0]));
    $puti($1.sep, $1.sep.length - 4, $a([0, 0, 0, 0]));
    $k[$j++] = 18;
    $1.sepfinder();
    $k[$j++] = 64;
    $1.sepfinder();
    if (!$1.usematrix) {
      $$.rmoveto(0, $1.linheight);
      var _1H = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.sep],
        ["pixx", $1.sep.length],
        ["pixy", 1],
        ["height", 1 / 72],
        ["width", $1.sep.length / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1H;
      bwipp_renmatrix();
      $$.rmoveto(-5, 1);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _1M = $k[--$j];
      $1[$k[--$j]] = _1M;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $forall($1.linsbs, function() {
        var _1T = $k[--$j];
        var _1U = $k[--$j];
        var _1V = _1U == 0 ? 1 : 0;
        $k[$j++] = _1U;
        for (var _1W = 0, _1X = $cvi(_1T); _1W < _1X; _1W++) {
          $k[$j++] = _1V;
        }
      });
      $1.linpixs = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $aload($1.sep);
      $1.sep = $a();
      $1.linheight = ~~$1.linheight;
      $k[$j++] = Infinity;
      for (var _1f = 0, _1g = $1.ccpixx, _1e = $1.ccpixs.length - 1; _1g < 0 ? _1f >= _1e : _1f <= _1e; _1f += _1g) {
        $1.i = _1f;
        for (var _1h = 0, _1i = 2; _1h < _1i; _1h++) {
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $k[$j++] = 0;
        }
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($1.sep);
      for (var _1p = 0, _1q = $1.linheight; _1p < _1q; _1p++) {
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $aload($1.linpixs);
      }
      $1.pixs = $a();
      $1.pixx = $f($1.ccpixx + 1);
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _22 = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _22;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_databarstackedcomposite() {
    var $1 = Object.create(bwipp_databarstackedcomposite.$ctx || (bwipp_databarstackedcomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#28636";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    if (!$1.usematrix) {
      $$.save();
    }
    $put($1.options, "lintype", "databarstacked");
    $put($1.options, "linkage", true);
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _F = $s($1.linear.length + $1.comp.length);
    $puti(_F, 0, $1.linear);
    $puti(_F, $1.linear.length, $1.comp);
    $k[$j++] = _F;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_databarstacked();
    var _L = $k[--$j];
    $1.bot = $geti($get(_L, "pixs"), 0, $get(_L, "pixx"));
    $1.linheight = $get(_L, "pixy");
    $k[$j++] = _L;
    if (!$1.usematrix) {
      bwipp_renmatrix();
    } else {
      $1.linpixs = $get($k[--$j], "pixs");
    }
    $1.sepfinder = function() {
      $1.fp = $k[--$j];
      for (var _X = $1.fp, _W = $f($1.fp + 12); _X <= _W; _X += 1) {
        $1.i = _X;
        if ($get($1.bot, $1.i) == 0) {
          if ($get($1.bot, $1.i - 1) == 1) {
            $k[$j++] = 1;
          } else {
            var _h = $get($1.sep, $1.i - 1) == 0 ? 1 : 0;
            $k[$j++] = _h;
          }
        } else {
          $k[$j++] = 0;
        }
        $put($1.sep, $1.i, $k[--$j]);
      }
      $1.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
      $k[$j++] = true;
      for (var _m = 0; _m <= 12; _m += 1) {
        var _s = $k[--$j];
        $k[$j++] = _s && $eq($get($1.bot, $f(_m + $1.fp)), $get($1.f3, _m));
      }
      if ($k[--$j]) {
        $puti($1.sep, $1.fp, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
      }
    };
    $k[$j++] = Infinity;
    var _x = $1.bot;
    for (var _y = 0, _z = _x.length; _y < _z; _y++) {
      $k[$j++] = $f(1 - $get(_x, _y));
    }
    $1.sep = $a();
    $puti($1.sep, 0, $a([0, 0, 0, 0]));
    $puti($1.sep, $1.sep.length - 4, $a([0, 0, 0, 0]));
    $k[$j++] = 18;
    $1.sepfinder();
    if (!$1.usematrix) {
      $$.rmoveto(0, $1.linheight);
      var _1D = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.sep],
        ["pixx", $1.sep.length],
        ["pixy", 1],
        ["height", 1 / 72],
        ["width", $1.sep.length / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1D;
      bwipp_renmatrix();
      $$.rmoveto(1, 1);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _1I = $k[--$j];
      $1[$k[--$j]] = _1I;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $1.linwidth = $1.sep.length;
      $k[$j++] = Infinity;
      for (var _1S = 0, _1T = $1.ccpixx, _1R = $1.ccpixs.length - 1; _1T < 0 ? _1S >= _1R : _1S <= _1R; _1S += _1T) {
        $1.i = _1S;
        for (var _1U = 0, _1V = 2; _1U < _1V; _1U++) {
          $k[$j++] = 0;
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
        }
      }
      $aload($1.sep);
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _1e = 0, _1f = $1.linwidth, _1d = $1.linpixs.length - 1; _1f < 0 ? _1e >= _1d : _1e <= _1d; _1e += _1f) {
        $1.i = _1e;
        $aload($geti($1.linpixs, $1.i, $1.linwidth));
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
      }
      $1.pixs = $a();
      $1.pixx = $f($1.ccpixx + 1);
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _1u = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1u;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_databarstackedomnicomposite() {
    var $1 = Object.create(bwipp_databarstackedomnicomposite.$ctx || (bwipp_databarstackedomnicomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#28789";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    if (!$1.usematrix) {
      $$.save();
    }
    $put($1.options, "lintype", "databarstackedomni");
    $put($1.options, "linkage", true);
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _F = $s($1.linear.length + $1.comp.length);
    $puti(_F, 0, $1.linear);
    $puti(_F, $1.linear.length, $1.comp);
    $k[$j++] = _F;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_databarstackedomni();
    var _L = $k[--$j];
    $1.bot = $geti($get(_L, "pixs"), 0, $get(_L, "pixx"));
    $1.linheight = $get(_L, "pixy");
    $k[$j++] = _L;
    if (!$1.usematrix) {
      bwipp_renmatrix();
    } else {
      $1.linpixs = $get($k[--$j], "pixs");
    }
    $1.sepfinder = function() {
      $1.fp = $k[--$j];
      for (var _X = $1.fp, _W = $f($1.fp + 12); _X <= _W; _X += 1) {
        $1.i = _X;
        if ($get($1.bot, $1.i) == 0) {
          if ($get($1.bot, $1.i - 1) == 1) {
            $k[$j++] = 1;
          } else {
            var _h = $get($1.sep, $1.i - 1) == 0 ? 1 : 0;
            $k[$j++] = _h;
          }
        } else {
          $k[$j++] = 0;
        }
        $put($1.sep, $1.i, $k[--$j]);
      }
      $1.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
      $k[$j++] = true;
      for (var _m = 0; _m <= 12; _m += 1) {
        var _s = $k[--$j];
        $k[$j++] = _s && $eq($get($1.bot, $f(_m + $1.fp)), $get($1.f3, _m));
      }
      if ($k[--$j]) {
        $puti($1.sep, $1.fp, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
      }
    };
    $k[$j++] = Infinity;
    var _x = $1.bot;
    for (var _y = 0, _z = _x.length; _y < _z; _y++) {
      $k[$j++] = $f(1 - $get(_x, _y));
    }
    $1.sep = $a();
    $puti($1.sep, 0, $a([0, 0, 0, 0]));
    $puti($1.sep, $1.sep.length - 4, $a([0, 0, 0, 0]));
    $k[$j++] = 18;
    $1.sepfinder();
    if (!$1.usematrix) {
      $$.rmoveto(0, $1.linheight);
      var _1D = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.sep],
        ["pixx", $1.sep.length],
        ["pixy", 1],
        ["height", 1 / 72],
        ["width", $1.sep.length / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1D;
      bwipp_renmatrix();
      $$.rmoveto(1, 1);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _1I = $k[--$j];
      $1[$k[--$j]] = _1I;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $1.linwidth = $1.sep.length;
      $k[$j++] = Infinity;
      for (var _1S = 0, _1T = $1.ccpixx, _1R = $1.ccpixs.length - 1; _1T < 0 ? _1S >= _1R : _1S <= _1R; _1S += _1T) {
        $1.i = _1S;
        for (var _1U = 0, _1V = 2; _1U < _1V; _1U++) {
          $k[$j++] = 0;
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
        }
      }
      $aload($1.sep);
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _1e = 0, _1f = $1.linwidth, _1d = $1.linpixs.length - 1; _1f < 0 ? _1e >= _1d : _1e <= _1d; _1e += _1f) {
        $1.i = _1e;
        $aload($geti($1.linpixs, $1.i, $1.linwidth));
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
      }
      $1.pixs = $a();
      $1.pixx = $f($1.ccpixx + 1);
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _1u = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1u;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_databartruncatedcomposite() {
    var $1 = Object.create(bwipp_databartruncatedcomposite.$ctx || (bwipp_databartruncatedcomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#28943";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    if (!$1.usematrix) {
      $$.save();
    }
    $put($1.options, "lintype", "databartruncated");
    $put($1.options, "linkage", true);
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _F = $s($1.linear.length + $1.comp.length);
    $puti(_F, 0, $1.linear);
    $puti(_F, $1.linear.length, $1.comp);
    $k[$j++] = _F;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_databartruncated();
    var _L = $k[--$j];
    $1.linsbs = $get(_L, "sbs");
    $1.linheight = $get($get(_L, "bhs"), 0) * 72;
    $k[$j++] = _L;
    if (!$1.usematrix) {
      bwipp_renlinear();
    } else {
      $j--;
    }
    $1.sepfinder = function() {
      $1.fp = $k[--$j];
      for (var _U = $1.fp, _T = $f($1.fp + 12); _U <= _T; _U += 1) {
        $1.i = _U;
        if ($get($1.bot, $1.i) == 0) {
          if ($get($1.bot, $1.i - 1) == 1) {
            $k[$j++] = 1;
          } else {
            var _e = $get($1.sep, $1.i - 1) == 0 ? 1 : 0;
            $k[$j++] = _e;
          }
        } else {
          $k[$j++] = 0;
        }
        $put($1.sep, $1.i, $k[--$j]);
      }
      $1.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
      $k[$j++] = true;
      for (var _j = 0; _j <= 12; _j += 1) {
        var _p = $k[--$j];
        $k[$j++] = _p && $eq($get($1.bot, $f(_j + $1.fp)), $get($1.f3, _j));
      }
      if ($k[--$j]) {
        $puti($1.sep, $1.fp, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $forall($1.linsbs, function() {
      var _v = $k[--$j];
      var _w = $k[--$j];
      var _x = _w == 1 ? 0 : 1;
      $k[$j++] = _w;
      for (var _y = 0, _z = _v; _y < _z; _y++) {
        $k[$j++] = _x;
      }
    });
    $astore($a($counttomark() - 1));
    $1.bot = $k[--$j];
    $j -= 2;
    $k[$j++] = Infinity;
    $forall($1.bot, function() {
      var _14 = $k[--$j];
      $k[$j++] = $f(1 - _14);
    });
    $1.sep = $a();
    $puti($1.sep, 0, $a([0, 0, 0]));
    $puti($1.sep, $1.sep.length - 4, $a([0, 0, 0, 0]));
    $k[$j++] = 18;
    $1.sepfinder();
    $k[$j++] = 64;
    $1.sepfinder();
    if (!$1.usematrix) {
      $$.rmoveto(0, $1.linheight);
      var _1H = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.sep],
        ["pixx", $1.sep.length],
        ["pixy", 1],
        ["height", 1 / 72],
        ["width", $1.sep.length / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1H;
      bwipp_renmatrix();
      $$.rmoveto(-5, 1);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _1M = $k[--$j];
      $1[$k[--$j]] = _1M;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $forall($1.linsbs, function() {
        var _1T = $k[--$j];
        var _1U = $k[--$j];
        var _1V = _1U == 0 ? 1 : 0;
        $k[$j++] = _1U;
        for (var _1W = 0, _1X = $cvi(_1T); _1W < _1X; _1W++) {
          $k[$j++] = _1V;
        }
      });
      $1.linpixs = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $aload($1.sep);
      $1.sep = $a();
      $1.linheight = ~~$1.linheight;
      $k[$j++] = Infinity;
      for (var _1f = 0, _1g = $1.ccpixx, _1e = $1.ccpixs.length - 1; _1g < 0 ? _1f >= _1e : _1f <= _1e; _1f += _1g) {
        $1.i = _1f;
        for (var _1h = 0, _1i = 2; _1h < _1i; _1h++) {
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $k[$j++] = 0;
        }
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($1.sep);
      for (var _1p = 0, _1q = $1.linheight; _1p < _1q; _1p++) {
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $aload($1.linpixs);
      }
      $1.pixs = $a();
      $1.pixx = $f($1.ccpixx + 1);
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _22 = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _22;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_databarlimitedcomposite() {
    var $1 = Object.create(bwipp_databarlimitedcomposite.$ctx || (bwipp_databarlimitedcomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#29101";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    if (!$1.usematrix) {
      $$.save();
    }
    $put($1.options, "lintype", "databarlimited");
    $put($1.options, "linkage", true);
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _F = $s($1.linear.length + $1.comp.length);
    $puti(_F, 0, $1.linear);
    $puti(_F, $1.linear.length, $1.comp);
    $k[$j++] = _F;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_databarlimited();
    var _L = $k[--$j];
    $1.linsbs = $get(_L, "sbs");
    $1.linheight = $get($get(_L, "bhs"), 0) * 72;
    $k[$j++] = _L;
    if (!$1.usematrix) {
      bwipp_renlinear();
    } else {
      $j--;
    }
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    $forall($1.linsbs, function() {
      var _R = $k[--$j];
      var _S = $k[--$j];
      var _T = _S == 0 ? 1 : 0;
      $k[$j++] = _S;
      for (var _U = 0, _V = _R; _U < _V; _U++) {
        $k[$j++] = _T;
      }
    });
    $astore($a($counttomark() - 1));
    $1.sep = $k[--$j];
    $j -= 2;
    $puti($1.sep, 0, $a([0, 0, 0]));
    var _c = $1.sep;
    $puti($1.sep, _c.length - 9, $a([0, 0, 0, 0, 0, 0, 0, 0, 0]));
    if (!$1.usematrix) {
      $$.rmoveto(0, $1.linheight);
      var _g = $1.sep;
      var _k = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", _g],
        ["pixx", $1.sep.length],
        ["pixy", 1],
        ["height", 1 / 72],
        ["width", $1.sep.length / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _k;
      bwipp_renmatrix();
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _n = $k[--$j];
      $$.rmoveto($f(72 - $get(_n, "pixx")), 1);
      $k[$j++] = _n;
      bwipp_renmatrix();
      $$.restore();
    } else {
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _r = $k[--$j];
      $1[$k[--$j]] = _r;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $forall($1.linsbs, function() {
        var _y = $k[--$j];
        var _z = $k[--$j];
        var _10 = _z == 0 ? 1 : 0;
        $k[$j++] = _z;
        for (var _11 = 0, _12 = $cvi(_y); _11 < _12; _11++) {
          $k[$j++] = _10;
        }
      });
      $1.linpixs = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $aload($1.sep);
      $1.sep = $a();
      $1.linheight = ~~$1.linheight;
      if ($1.ccpixx == 72) {
        $k[$j++] = Infinity;
        for (var _1B = 0, _1C = $1.ccpixx, _1A = $1.ccpixs.length - 1; _1C < 0 ? _1B >= _1A : _1B <= _1A; _1B += _1C) {
          $1.i = _1B;
          for (var _1D = 0, _1E = 2; _1D < _1E; _1D++) {
            $k[$j++] = 0;
            $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
            $k[$j++] = 0;
            $k[$j++] = 0;
            $k[$j++] = 0;
            $k[$j++] = 0;
            $k[$j++] = 0;
            $k[$j++] = 0;
          }
        }
        $aload($1.sep);
        for (var _1L = 0, _1M = $1.linheight; _1L < _1M; _1L++) {
          $aload($1.linpixs);
        }
        $1.pixs = $a();
        $1.pixx = $1.linpixs.length;
      } else {
        $k[$j++] = Infinity;
        for (var _1T = 0, _1U = $1.ccpixx, _1S = $1.ccpixs.length - 1; _1U < 0 ? _1T >= _1S : _1T <= _1S; _1T += _1U) {
          $1.i = _1T;
          for (var _1V = 0, _1W = 2; _1V < _1W; _1V++) {
            $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
            $k[$j++] = 0;
            $k[$j++] = 0;
            $k[$j++] = 0;
            $k[$j++] = 0;
            $k[$j++] = 0;
            $k[$j++] = 0;
          }
        }
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $aload($1.sep);
        for (var _1d = 0, _1e = $1.linheight; _1d < _1e; _1d++) {
          $k[$j++] = 0;
          $k[$j++] = 0;
          $k[$j++] = 0;
          $k[$j++] = 0;
          $k[$j++] = 0;
          $k[$j++] = 0;
          $k[$j++] = 0;
          $k[$j++] = 0;
          $k[$j++] = 0;
          $aload($1.linpixs);
        }
        $1.pixs = $a();
        $1.pixx = $f($1.ccpixx + 6);
      }
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _1q = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1q;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_databarexpandedcomposite() {
    var $1 = Object.create(bwipp_databarexpandedcomposite.$ctx || (bwipp_databarexpandedcomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#29250";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    if (!$1.usematrix) {
      $$.save();
    }
    $put($1.options, "lintype", "databarexpanded");
    $put($1.options, "linkage", true);
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _F = $s($1.linear.length + $1.comp.length);
    $puti(_F, 0, $1.linear);
    $puti(_F, $1.linear.length, $1.comp);
    $k[$j++] = _F;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_databarexpanded();
    var _L = $k[--$j];
    $1.linsbs = $get(_L, "sbs");
    $1.linheight = $get($get(_L, "bhs"), 0) * 72;
    $k[$j++] = _L;
    if (!$1.usematrix) {
      bwipp_renlinear();
    } else {
      $j--;
    }
    $1.sepfinder = function() {
      $1.fp = $k[--$j];
      for (var _U = $1.fp, _T = $f($1.fp + 12); _U <= _T; _U += 1) {
        $1.i = _U;
        if ($get($1.bot, $1.i) == 0) {
          if ($get($1.bot, $1.i - 1) == 1) {
            $k[$j++] = 1;
          } else {
            var _e = $get($1.sep, $1.i - 1) == 0 ? 1 : 0;
            $k[$j++] = _e;
          }
        } else {
          $k[$j++] = 0;
        }
        $put($1.sep, $1.i, $k[--$j]);
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $forall($1.linsbs, function() {
      var _j = $k[--$j];
      var _k = $k[--$j];
      var _l = _k == 1 ? 0 : 1;
      $k[$j++] = _k;
      for (var _m = 0, _n = _j; _m < _n; _m++) {
        $k[$j++] = _l;
      }
    });
    $astore($a($counttomark() - 1));
    $1.bot = $k[--$j];
    $j -= 2;
    $k[$j++] = Infinity;
    $forall($1.bot, function() {
      var _s = $k[--$j];
      $k[$j++] = $f(1 - _s);
    });
    $1.sep = $a();
    $puti($1.sep, 0, $a([0, 0, 0]));
    $puti($1.sep, $1.sep.length - 4, $a([0, 0, 0, 0]));
    $k[$j++] = Infinity;
    for (var _11 = 18, _10 = $1.bot.length - 13; _11 <= _10; _11 += 98) {
      $k[$j++] = _11;
    }
    for (var _14 = 69, _13 = $1.bot.length - 13; _14 <= _13; _14 += 98) {
      $k[$j++] = _14;
    }
    var _15 = $a();
    for (var _16 = 0, _17 = _15.length; _16 < _17; _16++) {
      $k[$j++] = $get(_15, _16);
      $1.sepfinder();
    }
    if (!$1.usematrix) {
      $$.rmoveto(0, $1.linheight);
      var _1F = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.sep],
        ["pixx", $1.sep.length],
        ["pixy", 1],
        ["height", 1 / 72],
        ["width", $1.sep.length / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1F;
      bwipp_renmatrix();
      $$.rmoveto(1, 1);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _1K = $k[--$j];
      $1[$k[--$j]] = _1K;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $forall($1.linsbs, function() {
        var _1R = $k[--$j];
        var _1S = $k[--$j];
        var _1T = _1S == 0 ? 1 : 0;
        $k[$j++] = _1S;
        for (var _1U = 0, _1V = $cvi(_1R); _1U < _1V; _1U++) {
          $k[$j++] = _1T;
        }
      });
      $1.linpixs = $a();
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $aload($1.sep);
      $1.sep = $a();
      $1.linheight = ~~$1.linheight;
      $1.diff = $f($1.linpixs.length - $1.ccpixx);
      $k[$j++] = Infinity;
      for (var _1d = 0, _1e = $f($1.diff - 2); _1d < _1e; _1d++) {
        $k[$j++] = 0;
      }
      $1.ccrpad = $a();
      $k[$j++] = Infinity;
      for (var _1j = 0, _1k = $1.ccpixx, _1i = $1.ccpixs.length - 1; _1k < 0 ? _1j >= _1i : _1j <= _1i; _1j += _1k) {
        $1.i = _1j;
        for (var _1l = 0, _1m = 2; _1l < _1m; _1l++) {
          $k[$j++] = 0;
          $k[$j++] = 0;
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $aload($1.ccrpad);
        }
      }
      $aload($1.sep);
      for (var _1u = 0, _1v = $1.linheight; _1u < _1v; _1u++) {
        $aload($1.linpixs);
      }
      $1.pixs = $a();
      $1.pixx = $1.linpixs.length;
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _27 = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _27;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_databarexpandedstackedcomposite() {
    var $1 = Object.create(bwipp_databarexpandedstackedcomposite.$ctx || (bwipp_databarexpandedstackedcomposite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#29407";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    if (!$1.usematrix) {
      $$.save();
    }
    $put($1.options, "lintype", "databarexpandedstacked");
    $put($1.options, "linkage", true);
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _F = $s($1.linear.length + $1.comp.length);
    $puti(_F, 0, $1.linear);
    $puti(_F, $1.linear.length, $1.comp);
    $k[$j++] = _F;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $k[$j++] = $1.linear;
    $k[$j++] = $1.options;
    bwipp_databarexpandedstacked();
    var _L = $k[--$j];
    $1.bot = $geti($get(_L, "pixs"), 0, $get(_L, "pixx"));
    $1.linheight = $get(_L, "pixy");
    $k[$j++] = _L;
    if (!$1.usematrix) {
      bwipp_renmatrix();
    } else {
      $1.linpixs = $get($k[--$j], "pixs");
    }
    $1.sepfinder = function() {
      $1.fp = $k[--$j];
      for (var _X = $1.fp, _W = $f($1.fp + 12); _X <= _W; _X += 1) {
        $1.i = _X;
        if ($get($1.bot, $1.i) == 0) {
          if ($get($1.bot, $1.i - 1) == 1) {
            $k[$j++] = 1;
          } else {
            var _h = $get($1.sep, $1.i - 1) == 0 ? 1 : 0;
            $k[$j++] = _h;
          }
        } else {
          $k[$j++] = 0;
        }
        $put($1.sep, $1.i, $k[--$j]);
      }
    };
    $k[$j++] = Infinity;
    var _l = $1.bot;
    for (var _m = 0, _n = _l.length; _m < _n; _m++) {
      $k[$j++] = $f(1 - $get(_l, _m));
    }
    $1.sep = $a();
    $puti($1.sep, 0, $a([0, 0, 0, 0]));
    $puti($1.sep, $1.sep.length - 4, $a([0, 0, 0, 0]));
    $k[$j++] = Infinity;
    for (var _x = 19, _w = $1.bot.length - 13; _x <= _w; _x += 98) {
      $k[$j++] = _x;
    }
    for (var _10 = 70, _z = $1.bot.length - 13; _10 <= _z; _10 += 98) {
      $k[$j++] = _10;
    }
    var _11 = $a();
    for (var _12 = 0, _13 = _11.length; _12 < _13; _12++) {
      $k[$j++] = $get(_11, _12);
      $1.sepfinder();
    }
    if (!$1.usematrix) {
      $$.rmoveto(0, $1.linheight);
      var _1B = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.sep],
        ["pixx", $1.sep.length],
        ["pixy", 1],
        ["height", 1 / 72],
        ["width", $1.sep.length / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1B;
      bwipp_renmatrix();
      var _1E = $get($1.bot, 0) == 0 ? 2 : 0;
      $$.rmoveto(_1E, 1);
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      bwipp_renmatrix();
      $$.restore();
    } else {
      $k[$j++] = "compsym";
      $k[$j++] = $1.comp;
      $k[$j++] = $1.options;
      bwipp_gs1_cc();
      var _1J = $k[--$j];
      $1[$k[--$j]] = _1J;
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $1.pixx = $1.sep.length;
      $k[$j++] = Infinity;
      for (var _1S = 0, _1T = ~~($f($f($1.pixx - $1.ccpixx) + 1) / 2); _1S < _1T; _1S++) {
        $k[$j++] = 0;
      }
      $1.cclpad = $a();
      $k[$j++] = Infinity;
      for (var _1X = 0, _1Y = ~~($f($1.pixx - $1.ccpixx) / 2); _1X < _1Y; _1X++) {
        $k[$j++] = 0;
      }
      $1.ccrpad = $a();
      $k[$j++] = Infinity;
      for (var _1d = 0, _1e = $1.ccpixx, _1c = $1.ccpixs.length - 1; _1e < 0 ? _1d >= _1c : _1d <= _1c; _1d += _1e) {
        $1.i = _1d;
        for (var _1f = 0, _1g = 2; _1f < _1g; _1f++) {
          $aload($1.cclpad);
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $aload($1.ccrpad);
        }
      }
      $aload($1.sep);
      $aload($1.linpixs);
      $1.pixs = $a();
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _1y = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _1y;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_gs1_128composite() {
    var $1 = Object.create(bwipp_gs1_128composite.$ctx || (bwipp_gs1_128composite.$ctx = {}));
    $1.dontdraw = false;
    $1.usematrix = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if ($1.dontdraw) {
      $1.usematrix = true;
    }
    $search($1.barcode, "|");
    if ($k[--$j]) {
      $1.linear = $k[--$j];
      $j--;
      $1.comp = $k[--$j];
    } else {
      $j--;
      $k[$j++] = "bwipp.missingCompositeComponent#29556";
      $k[$j++] = "A Composite Component must be provided following a pipe character";
      bwipp_raiseerror();
    }
    if (!$1.usematrix) {
      $$.save();
    }
    $put($1.options, "inkspread", "0");
    $put($1.options, "dontdraw", true);
    $put($1.options, "dontlint", true);
    var _D = $s($1.linear.length + $1.comp.length);
    $puti(_D, 0, $1.linear);
    $puti(_D, $1.linear.length, $1.comp);
    $k[$j++] = _D;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $j -= 3;
    $put($1.options, "linkagea", true);
    $k[$j++] = $1.linear;
    $k[$j++] = Infinity;
    $forall($1.options);
    var _K = $d();
    $k[$j++] = _K;
    bwipp_gs1_128();
    var _M = $get($k[--$j], "sbs");
    $k[$j++] = 0;
    $forall(_M, function() {
      var _N = $k[--$j];
      var _O = $k[--$j];
      $k[$j++] = $f(_O + _N);
    });
    $1.linwidth = $k[--$j];
    $put($1.options, "lintype", "gs1-128");
    $put($1.options, "linwidth", $1.linwidth);
    $k[$j++] = $1.comp;
    $k[$j++] = $1.options;
    bwipp_gs1_cc();
    $1.compsym = $k[--$j];
    if ($get($1.compsym, "pixx") == 99) {
      $k[$j++] = "a";
    } else {
      $k[$j++] = "c";
    }
    $1.linktype = $k[--$j];
    if ($eq($1.linktype, "a")) {
      $put($1.options, "linkagea", true);
      $put($1.options, "linkagec", false);
    } else {
      $put($1.options, "linkagea", false);
      $put($1.options, "linkagec", true);
    }
    $k[$j++] = $1.linear;
    $k[$j++] = Infinity;
    $forall($1.options);
    var _g = $d();
    $k[$j++] = _g;
    bwipp_gs1_128();
    var _h = $k[--$j];
    $1.linsbs = $get(_h, "sbs");
    $1.linheight = $get($get(_h, "bhs"), 0) * 72;
    $k[$j++] = _h;
    if (!$1.usematrix) {
      bwipp_renlinear();
    } else {
      $j--;
    }
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    $forall($1.linsbs, function() {
      var _n = $k[--$j];
      var _o = $k[--$j];
      var _p = _o == 0 ? 1 : 0;
      $k[$j++] = _o;
      for (var _q = 0, _r = _n; _q < _r; _q++) {
        $k[$j++] = _p;
      }
    });
    $astore($a($counttomark() - 1));
    $1.sep = $k[--$j];
    $j -= 2;
    if (!$1.usematrix) {
      $$.rmoveto(0, $1.linheight);
      var _11 = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.sep],
        ["pixx", $1.sep.length],
        ["pixy", 1],
        ["height", 1 / 72],
        ["width", $1.sep.length / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _11;
      bwipp_renmatrix();
    }
    if ($eq($1.linktype, "a")) {
      $1.s = ~~($f($1.linwidth - 2) / 11);
      $1.p = ~~(($1.s - 9) / 2);
      $k[$j++] = "x";
      $k[$j++] = ($1.s - $1.p - 1) * 11 + 10;
      if ($1.p == 0) {
        var _18 = $k[--$j];
        $k[$j++] = $f(_18 + 2);
      }
      var _19 = $k[--$j];
      $1[$k[--$j]] = $f(_19 - 99);
    } else {
      $1.x = -7;
    }
    if (!$1.usematrix) {
      $$.rmoveto($1.x, 1);
      $k[$j++] = $1.compsym;
      bwipp_renmatrix();
      $$.restore();
    } else {
      $1.ccpixs = $get($1.compsym, "pixs");
      $1.ccpixx = $get($1.compsym, "pixx");
      $k[$j++] = Infinity;
      $forall($1.linsbs, function() {
        var _1J = $k[--$j];
        var _1K = $k[--$j];
        var _1L = _1K == 1 ? 0 : 1;
        $k[$j++] = _1K;
        for (var _1M = 0, _1N = _1J; _1M < _1N; _1M++) {
          $k[$j++] = _1L;
        }
      });
      $1.linpixs = $a();
      if ($1.x > 0) {
        $k[$j++] = Infinity;
        for (var _1R = 0, _1S = $1.x; _1R < _1S; _1R++) {
          $k[$j++] = 0;
        }
        $1.cclpad = $a();
        $1.linlpad = $a(0);
      } else {
        $1.cclpad = $a(0);
        $k[$j++] = Infinity;
        for (var _1X = 0, _1Y = -$1.x; _1X < _1Y; _1X++) {
          $k[$j++] = 0;
        }
        $1.linlpad = $a();
      }
      $1.diff = $f($1.linwidth - $f($1.ccpixx + $1.x));
      if ($1.diff > 0) {
        $k[$j++] = Infinity;
        for (var _1f = 0, _1g = $1.diff; _1f < _1g; _1f++) {
          $k[$j++] = 0;
        }
        $1.ccrpad = $a();
        $1.linrpad = $a(0);
      } else {
        $1.ccrpad = $a(0);
        $k[$j++] = Infinity;
        for (var _1l = 0, _1m = -$1.diff; _1l < _1m; _1l++) {
          $k[$j++] = 0;
        }
        $1.linrpad = $a();
      }
      $1.linheight = ~~$1.linheight;
      var _1q = $eq($1.linktype, "a") ? 2 : 3;
      $1.ccrepeat = _1q;
      $k[$j++] = Infinity;
      for (var _1u = 0, _1v = $1.ccpixx, _1t = $1.ccpixs.length - 1; _1v < 0 ? _1u >= _1t : _1u <= _1t; _1u += _1v) {
        $1.i = _1u;
        for (var _1x = 0, _1y = $1.ccrepeat; _1x < _1y; _1x++) {
          $aload($1.cclpad);
          $aload($geti($1.ccpixs, $1.i, $1.ccpixx));
          $aload($1.ccrpad);
        }
      }
      $aload($1.linlpad);
      $aload($1.sep);
      $aload($1.linrpad);
      for (var _29 = 0, _2A = $1.linheight; _29 < _2A; _29++) {
        $aload($1.linlpad);
        $aload($1.linpixs);
        $aload($1.linrpad);
      }
      $1.pixs = $a();
      $1.pixx = $f($f($1.cclpad.length + $1.ccpixx) + $1.ccrpad.length);
      $1.pixy = ~~($1.pixs.length / $1.pixx);
      var _2Q = /* @__PURE__ */ new Map([
        ["ren", bwipp_renmatrix],
        ["pixs", $1.pixs],
        ["pixx", $1.pixx],
        ["pixy", $1.pixy],
        ["height", $1.pixy / 72],
        ["width", $1.pixx / 72],
        ["opt", $1.options]
      ]);
      $k[$j++] = _2Q;
      if (!$1.dontdraw) {
        $$.save();
        bwipp_renmatrix();
        $$.restore();
      }
    }
  }
  function bwipp_gs1datamatrix() {
    var $1 = Object.create(bwipp_gs1datamatrix.$ctx || (bwipp_gs1datamatrix.$ctx = {}));
    $1.dontdraw = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $1.gssep = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $k[$j++] = $1.barcode;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $1.fncs = $k[--$j];
    $1.vals = $k[--$j];
    $1.ais = $k[--$j];
    $1.fnc1 = -1;
    $1.dmtx = $a([$1.fnc1]);
    for (var _A = 0, _9 = $1.ais.length - 1; _A <= _9; _A += 1) {
      $1.i = _A;
      $1.ai = $get($1.ais, $1.i);
      $1.val = $get($1.vals, $1.i);
      var _K = $a($1.dmtx.length + $1.ai.length + $1.val.length);
      $puti(_K, 0, $1.dmtx);
      $k[$j++] = _K;
      $k[$j++] = _K;
      $k[$j++] = $1.dmtx.length;
      $k[$j++] = $1.ai;
      $k[$j++] = Infinity;
      var _O = $k[--$j];
      var _P = $k[--$j];
      $k[$j++] = _O;
      $forall(_P);
      var _Q = $a();
      var _R = $k[--$j];
      $puti($k[--$j], _R, _Q);
      var _T = $k[--$j];
      $k[$j++] = _T;
      $k[$j++] = _T;
      $k[$j++] = $1.dmtx.length + $1.ai.length;
      $k[$j++] = $1.val;
      $k[$j++] = Infinity;
      var _X = $k[--$j];
      var _Y = $k[--$j];
      $k[$j++] = _X;
      $forall(_Y);
      var _Z = $a();
      var _a = $k[--$j];
      $puti($k[--$j], _a, _Z);
      $1.dmtx = $k[--$j];
      if ($1.i != $1.ais.length - 1 && $get($1.fncs, $1.i)) {
        var _j = $a($1.dmtx.length + 1);
        $puti(_j, 0, $1.dmtx);
        $k[$j++] = _j;
        $k[$j++] = _j;
        $k[$j++] = $1.dmtx.length;
        if ($1.gssep) {
          $k[$j++] = 29;
        } else {
          $k[$j++] = $1.fnc1;
        }
        var _o = $k[--$j];
        var _p = $k[--$j];
        $put($k[--$j], _p, _o);
        $1.dmtx = $k[--$j];
      }
    }
    $1.barcode = $s(($1.dmtx.length + 1) * 5);
    $1.i = 0;
    $1.j = 0;
    for (; ; ) {
      if ($1.i == $1.dmtx.length) {
        break;
      }
      var _y = $get($1.dmtx, $1.i);
      $k[$j++] = _y;
      if (_y == $1.fnc1) {
        $j--;
        $puti($1.barcode, $1.j, "^FNC1");
        $1.j = $1.j + 4;
      } else {
        $put($1.barcode, $1.j, $k[--$j]);
      }
      $1.i = $1.i + 1;
      $1.j = $1.j + 1;
    }
    $1.barcode = $geti($1.barcode, 0, $1.j);
    delete $1.options["parse"];
    $put($1.options, "dontdraw", true);
    $put($1.options, "parsefnc", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_datamatrix();
    var _1G = $k[--$j];
    $1[$k[--$j]] = _1G;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_gs1datamatrixrectangular() {
    var $1 = Object.create(bwipp_gs1datamatrixrectangular.$ctx || (bwipp_gs1datamatrixrectangular.$ctx = {}));
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $1.dontdraw = false;
    $1.gssep = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $k[$j++] = $1.barcode;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $1.fncs = $k[--$j];
    $1.vals = $k[--$j];
    $1.ais = $k[--$j];
    $1.fnc1 = -1;
    $1.dmtx = $a([$1.fnc1]);
    for (var _A = 0, _9 = $1.ais.length - 1; _A <= _9; _A += 1) {
      $1.i = _A;
      $1.ai = $get($1.ais, $1.i);
      $1.val = $get($1.vals, $1.i);
      var _K = $a($1.dmtx.length + $1.ai.length + $1.val.length);
      $puti(_K, 0, $1.dmtx);
      $k[$j++] = _K;
      $k[$j++] = _K;
      $k[$j++] = $1.dmtx.length;
      $k[$j++] = $1.ai;
      $k[$j++] = Infinity;
      var _O = $k[--$j];
      var _P = $k[--$j];
      $k[$j++] = _O;
      $forall(_P);
      var _Q = $a();
      var _R = $k[--$j];
      $puti($k[--$j], _R, _Q);
      var _T = $k[--$j];
      $k[$j++] = _T;
      $k[$j++] = _T;
      $k[$j++] = $1.dmtx.length + $1.ai.length;
      $k[$j++] = $1.val;
      $k[$j++] = Infinity;
      var _X = $k[--$j];
      var _Y = $k[--$j];
      $k[$j++] = _X;
      $forall(_Y);
      var _Z = $a();
      var _a = $k[--$j];
      $puti($k[--$j], _a, _Z);
      $1.dmtx = $k[--$j];
      if ($1.i != $1.ais.length - 1 && $get($1.fncs, $1.i)) {
        var _j = $a($1.dmtx.length + 1);
        $puti(_j, 0, $1.dmtx);
        $k[$j++] = _j;
        $k[$j++] = _j;
        $k[$j++] = $1.dmtx.length;
        if ($1.gssep) {
          $k[$j++] = 29;
        } else {
          $k[$j++] = $1.fnc1;
        }
        var _o = $k[--$j];
        var _p = $k[--$j];
        $put($k[--$j], _p, _o);
        $1.dmtx = $k[--$j];
      }
    }
    $1.barcode = $s(($1.dmtx.length + 1) * 5);
    $1.i = 0;
    $1.j = 0;
    for (; ; ) {
      if ($1.i == $1.dmtx.length) {
        break;
      }
      var _y = $get($1.dmtx, $1.i);
      $k[$j++] = _y;
      if (_y == $1.fnc1) {
        $j--;
        $puti($1.barcode, $1.j, "^FNC1");
        $1.j = $1.j + 4;
      } else {
        $put($1.barcode, $1.j, $k[--$j]);
      }
      $1.i = $1.i + 1;
      $1.j = $1.j + 1;
    }
    $1.barcode = $geti($1.barcode, 0, $1.j);
    delete $1.options["parse"];
    $put($1.options, "dontdraw", true);
    $put($1.options, "parsefnc", true);
    $put($1.options, "format", "rectangle");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_datamatrix();
    var _1H = $k[--$j];
    $1[$k[--$j]] = _1H;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_gs1dldatamatrix() {
    var $1 = Object.create(bwipp_gs1dldatamatrix.$ctx || (bwipp_gs1dldatamatrix.$ctx = {}));
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _3 = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parseonly", true],
      ["parsefnc", false]
    ]);
    $1.fncvals = _3;
    $k[$j++] = "barcode";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $k[$j++] = $1.barcode;
    $k[$j++] = "dl";
    bwipp_gs1process();
    $j -= 3;
    delete $1.options["parse"];
    $put($1.options, "dontdraw", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_datamatrix();
    var _D = $k[--$j];
    $1[$k[--$j]] = _D;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_gs1qrcode() {
    var $1 = Object.create(bwipp_gs1qrcode.$ctx || (bwipp_gs1qrcode.$ctx = {}));
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $k[$j++] = $1.barcode;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $1.fncs = $k[--$j];
    $1.vals = $k[--$j];
    $1.ais = $k[--$j];
    $1.fnc1 = -1;
    $1.qrc = $a([$1.fnc1]);
    for (var _A = 0, _9 = $1.ais.length - 1; _A <= _9; _A += 1) {
      $1.i = _A;
      $1.ai = $get($1.ais, $1.i);
      $1.val = $get($1.vals, $1.i);
      var _K = $a($1.qrc.length + $1.ai.length + $1.val.length);
      $puti(_K, 0, $1.qrc);
      $k[$j++] = _K;
      $k[$j++] = _K;
      $k[$j++] = $1.qrc.length;
      $k[$j++] = $1.ai;
      $k[$j++] = Infinity;
      var _O = $k[--$j];
      var _P = $k[--$j];
      $k[$j++] = _O;
      $forall(_P);
      var _Q = $a();
      var _R = $k[--$j];
      $puti($k[--$j], _R, _Q);
      var _T = $k[--$j];
      $k[$j++] = _T;
      $k[$j++] = _T;
      $k[$j++] = $1.qrc.length + $1.ai.length;
      $k[$j++] = $1.val;
      $k[$j++] = Infinity;
      var _X = $k[--$j];
      var _Y = $k[--$j];
      $k[$j++] = _X;
      $forall(_Y);
      var _Z = $a();
      var _a = $k[--$j];
      $puti($k[--$j], _a, _Z);
      $1.qrc = $k[--$j];
      if ($1.i != $1.ais.length - 1 && $get($1.fncs, $1.i)) {
        var _j = $a($1.qrc.length + 1);
        $puti(_j, 0, $1.qrc);
        $put(_j, $1.qrc.length, $1.fnc1);
        $1.qrc = _j;
      }
    }
    $1.barcode = $s(($1.qrc.length + 1) * 5);
    $1.i = 0;
    $1.j = 0;
    for (; ; ) {
      if ($1.i == $1.qrc.length) {
        break;
      }
      var _t = $get($1.qrc, $1.i);
      $k[$j++] = _t;
      if (_t == $1.fnc1) {
        $j--;
        $puti($1.barcode, $1.j, "^FNC1");
        $1.j = $1.j + 4;
      } else {
        $put($1.barcode, $1.j, $k[--$j]);
      }
      $1.i = $1.i + 1;
      $1.j = $1.j + 1;
    }
    $1.barcode = $geti($1.barcode, 0, $1.j);
    delete $1.options["parse"];
    $put($1.options, "dontdraw", true);
    $put($1.options, "parsefnc", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_qrcode();
    var _1B = $k[--$j];
    $1[$k[--$j]] = _1B;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_gs1dlqrcode() {
    var $1 = Object.create(bwipp_gs1dlqrcode.$ctx || (bwipp_gs1dlqrcode.$ctx = {}));
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $1.dontdraw = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    var _3 = /* @__PURE__ */ new Map([
      ["parse", $1.parse],
      ["parseonly", true],
      ["parsefnc", false]
    ]);
    $1.fncvals = _3;
    $k[$j++] = "barcode";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.fncvals;
    bwipp_parseinput();
    var _6 = $k[--$j];
    $1[$k[--$j]] = _6;
    $k[$j++] = $1.barcode;
    $k[$j++] = "dl";
    bwipp_gs1process();
    $j -= 3;
    delete $1.options["parse"];
    $put($1.options, "dontdraw", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_qrcode();
    var _D = $k[--$j];
    $1[$k[--$j]] = _D;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_gs1dotcode() {
    var $1 = Object.create(bwipp_gs1dotcode.$ctx || (bwipp_gs1dotcode.$ctx = {}));
    $1.dontdraw = false;
    $1.parse = false;
    $1.dontlint = false;
    $1.lintreqs = true;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $k[$j++] = $1.barcode;
    $k[$j++] = "ai";
    bwipp_gs1process();
    $1.fncs = $k[--$j];
    $1.vals = $k[--$j];
    $1.ais = $k[--$j];
    $1.fnc1 = -1;
    $1.dmtx = $a([$1.fnc1]);
    for (var _A = 0, _9 = $1.ais.length - 1; _A <= _9; _A += 1) {
      $1.i = _A;
      $1.ai = $get($1.ais, $1.i);
      $1.val = $get($1.vals, $1.i);
      var _K = $a($1.dmtx.length + $1.ai.length + $1.val.length);
      $puti(_K, 0, $1.dmtx);
      $k[$j++] = _K;
      $k[$j++] = _K;
      $k[$j++] = $1.dmtx.length;
      $k[$j++] = $1.ai;
      $k[$j++] = Infinity;
      var _O = $k[--$j];
      var _P = $k[--$j];
      $k[$j++] = _O;
      $forall(_P);
      var _Q = $a();
      var _R = $k[--$j];
      $puti($k[--$j], _R, _Q);
      var _T = $k[--$j];
      $k[$j++] = _T;
      $k[$j++] = _T;
      $k[$j++] = $1.dmtx.length + $1.ai.length;
      $k[$j++] = $1.val;
      $k[$j++] = Infinity;
      var _X = $k[--$j];
      var _Y = $k[--$j];
      $k[$j++] = _X;
      $forall(_Y);
      var _Z = $a();
      var _a = $k[--$j];
      $puti($k[--$j], _a, _Z);
      $1.dmtx = $k[--$j];
      if ($1.i != $1.ais.length - 1 && $get($1.fncs, $1.i)) {
        var _j = $a($1.dmtx.length + 1);
        $puti(_j, 0, $1.dmtx);
        $put(_j, $1.dmtx.length, $1.fnc1);
        $1.dmtx = _j;
      }
    }
    $1.barcode = $s(($1.dmtx.length + 1) * 5);
    $1.i = 0;
    $1.j = 0;
    for (; ; ) {
      if ($1.i == $1.dmtx.length) {
        break;
      }
      var _t = $get($1.dmtx, $1.i);
      $k[$j++] = _t;
      if (_t == $1.fnc1) {
        $j--;
        $puti($1.barcode, $1.j, "^FNC1");
        $1.j = $1.j + 4;
      } else {
        $put($1.barcode, $1.j, $k[--$j]);
      }
      $1.i = $1.i + 1;
      $1.j = $1.j + 1;
    }
    $1.barcode = $geti($1.barcode, 0, $1.j);
    delete $1.options["parse"];
    $put($1.options, "dontdraw", true);
    $put($1.options, "parsefnc", true);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_dotcode();
    var _1B = $k[--$j];
    $1[$k[--$j]] = _1B;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_hibccode39() {
    var $1 = Object.create(bwipp_hibccode39.$ctx || (bwipp_hibccode39.$ctx = {}));
    $1.dontdraw = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.textxoffset = 0;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibccode39.__30222__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibccode39.$ctx[id] = $ctx[id]);
        bwipp_hibccode39.__30222__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.hibccode39badCharacter#30227";
        $k[$j++] = "HIBC Code 39 must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibccode39badCheckDigit#30241";
        $k[$j++] = "Incorrect HIBC Code 39 check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _d = $s($f($1.barlen + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $1.text = $s($f($1.barlen + 4));
    $put($1.text, 0, 42);
    $puti($1.text, 1, $1.barcode);
    var _u = $get($1.barcode, $f($1.barlen + 1));
    $k[$j++] = $1.text;
    $k[$j++] = $f($1.barlen + 2);
    $k[$j++] = _u;
    if (_u == 32) {
      $j--;
      $k[$j++] = 95;
    }
    var _v = $k[--$j];
    var _w = $k[--$j];
    $put($k[--$j], _w, _v);
    $put($1.text, $f($1.barlen + 3), 42);
    $put($1.options, "dontdraw", true);
    $put($1.options, "includecheck", false);
    $put($1.options, "validatecheck", false);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code39();
    var _15 = $k[--$j];
    $1[$k[--$j]] = _15;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_hibccode128() {
    var $1 = Object.create(bwipp_hibccode128.$ctx || (bwipp_hibccode128.$ctx = {}));
    $1.dontdraw = false;
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textyoffset = -8;
    $1.textxoffset = 0;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibccode128.__30322__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibccode128.$ctx[id] = $ctx[id]);
        bwipp_hibccode128.__30322__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.hibccode128badCharacter#30327";
        $k[$j++] = "HIBC Code 128 must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibccode128badCheckDigit#30341";
        $k[$j++] = "Incorrect HIBC Code 128 check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _d = $s($f($1.barlen + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $1.text = $s($f($1.barlen + 4));
    $put($1.text, 0, 42);
    $puti($1.text, 1, $1.barcode);
    var _u = $get($1.barcode, $f($1.barlen + 1));
    $k[$j++] = $1.text;
    $k[$j++] = $f($1.barlen + 2);
    $k[$j++] = _u;
    if (_u == 32) {
      $j--;
      $k[$j++] = 95;
    }
    var _v = $k[--$j];
    var _w = $k[--$j];
    $put($k[--$j], _w, _v);
    $put($1.text, $f($1.barlen + 3), 42);
    $put($1.options, "dontdraw", true);
    $put($1.options, "validatecheck", false);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_code128();
    var _14 = $k[--$j];
    $1[$k[--$j]] = _14;
    $put($1.args, "txt", $a([$a([$1.text, $1.textxoffset, $1.textyoffset, $1.textfont, $1.textsize])]));
    $put($1.args, "textxalign", "center");
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_hibcdatamatrix() {
    var $1 = Object.create(bwipp_hibcdatamatrix.$ctx || (bwipp_hibcdatamatrix.$ctx = {}));
    $1.dontdraw = false;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibcdatamatrix.__30417__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibcdatamatrix.$ctx[id] = $ctx[id]);
        bwipp_hibcdatamatrix.__30417__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.hibcdatamatrixBadCharacter#30422";
        $k[$j++] = "HIBC Data Matrix must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibcdatamatrixBadCheckDigit#30436";
        $k[$j++] = "Incorrect HIBC Data Matrix check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _d = $s($f($1.barlen + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $put($1.options, "dontdraw", true);
    $put($1.options, "validatecheck", false);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_datamatrix();
    var _p = $k[--$j];
    $1[$k[--$j]] = _p;
    var _r = $1.args;
    $put(_r, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_hibcdatamatrixrectangular() {
    var $1 = Object.create(bwipp_hibcdatamatrixrectangular.$ctx || (bwipp_hibcdatamatrixrectangular.$ctx = {}));
    $1.dontdraw = false;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibcdatamatrixrectangular.__30504__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibcdatamatrixrectangular.$ctx[id] = $ctx[id]);
        bwipp_hibcdatamatrixrectangular.__30504__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.hibcdatamatrixrectangularBadCharacter#30509";
        $k[$j++] = "HIBC Data Matrix Rectangular must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibcdatamatrixrectangularBadCheckDigit#30523";
        $k[$j++] = "Incorrect HIBC Data Matrix Rectangular check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _d = $s($f($1.barlen + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $put($1.options, "dontdraw", true);
    $put($1.options, "validatecheck", false);
    $put($1.options, "format", "rectangle");
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_datamatrix();
    var _q = $k[--$j];
    var _r = $k[--$j];
    $1[_r] = _q;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_hibcpdf417() {
    var $1 = Object.create(bwipp_hibcpdf417.$ctx || (bwipp_hibcpdf417.$ctx = {}));
    $1.dontdraw = false;
    $1.columns = 2;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibcpdf417.__30593__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibcpdf417.$ctx[id] = $ctx[id]);
        bwipp_hibcpdf417.__30593__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.hibcpdf417BadCharacter#30598";
        $k[$j++] = "HIBC PDF417 must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibcpdf417BadCheckDigit#30612";
        $k[$j++] = "Incorrect HIBC PDF417 check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _d = $s($f($1.barlen + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $put($1.options, "dontdraw", true);
    $put($1.options, "columns", $1.columns);
    $put($1.options, "validatecheck", false);
    var _p = $1.barcode;
    $k[$j++] = "args";
    $k[$j++] = _p;
    $k[$j++] = $1.options;
    bwipp_pdf417();
    var _r = $k[--$j];
    $1[$k[--$j]] = _r;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_hibcmicropdf417() {
    var $1 = Object.create(bwipp_hibcmicropdf417.$ctx || (bwipp_hibcmicropdf417.$ctx = {}));
    $1.dontdraw = false;
    $1.columns = 2;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibcmicropdf417.__30682__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibcmicropdf417.$ctx[id] = $ctx[id]);
        bwipp_hibcmicropdf417.__30682__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.hibcmicropdf417BadCharacter#30687";
        $k[$j++] = "HIBC MicroPDF417 must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibcmicropdf417BadCheckDigit#30701";
        $k[$j++] = "Incorrect HIBC MicroPDF417 check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _d = $s($f($1.barlen + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $put($1.options, "dontdraw", true);
    var _m = $1.options;
    $put(_m, "columns", $1.columns);
    $put($1.options, "validatecheck", false);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_micropdf417();
    var _r = $k[--$j];
    $1[$k[--$j]] = _r;
    $put($1.args, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_hibcqrcode() {
    var $1 = Object.create(bwipp_hibcqrcode.$ctx || (bwipp_hibcqrcode.$ctx = {}));
    $1.dontdraw = false;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibcqrcode.__30770__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibcqrcode.$ctx[id] = $ctx[id]);
        bwipp_hibcqrcode.__30770__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.hibcqrcodeBadCharacter#30775";
        $k[$j++] = "HIBC QR Code must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibcqrcodeBadCheckDigit#30789";
        $k[$j++] = "Incorrect HIBC QR Code check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _d = $s($f($1.barlen + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $put($1.options, "dontdraw", true);
    $put($1.options, "validatecheck", false);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_qrcode();
    var _p = $k[--$j];
    $1[$k[--$j]] = _p;
    var _r = $1.args;
    $put(_r, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_hibccodablockf() {
    var $1 = Object.create(bwipp_hibccodablockf.$ctx || (bwipp_hibccodablockf.$ctx = {}));
    $1.dontdraw = false;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibccodablockf.__30857__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibccodablockf.$ctx[id] = $ctx[id]);
        bwipp_hibccodablockf.__30857__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.codablockfBadCharacter#30862";
        $k[$j++] = "HIBC Codablock F must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibccodablockfBadCheckDigit#30876";
        $k[$j++] = "Incorrect HIBC Codablock F check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _c = $1.barlen;
    var _d = $s($f(_c + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $put($1.options, "dontdraw", true);
    $put($1.options, "validatecheck", false);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_codablockf();
    var _p = $k[--$j];
    $1[$k[--$j]] = _p;
    var _r = $1.args;
    $put(_r, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_hibcazteccode() {
    var $1 = Object.create(bwipp_hibcazteccode.$ctx || (bwipp_hibcazteccode.$ctx = {}));
    $1.dontdraw = false;
    $1.validatecheck = false;
    $k[$j++] = $1;
    bwipp_processoptions();
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    if (!bwipp_hibcazteccode.__30944__) {
      (function() {
        var $ctx = Object.create($1);
        $ctx.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        $ctx.charvals = /* @__PURE__ */ new Map();
        for (var _2 = 0; _2 <= 42; _2 += 1) {
          $put($ctx.charvals, $geti($ctx.barchars, _2, 1), _2);
        }
        for (var id in $ctx)
          $ctx.hasOwnProperty(id) && (bwipp_hibcazteccode.$ctx[id] = $ctx[id]);
        bwipp_hibcazteccode.__30944__ = 1;
      })();
    }
    for (var _9 = 0, _8 = $1.barcode.length - 1; _9 <= _8; _9 += 1) {
      var _D = $get($1.charvals, $geti($1.barcode, _9, 1)) !== void 0;
      if (!_D) {
        $k[$j++] = "bwipp.hibcazteccodeBadCharacter#30949";
        $k[$j++] = "HIBC Aztec Code must contain only digits, capital letters, spaces and the symbols -.$/+%";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = "barlen";
    $k[$j++] = $1.barcode.length;
    if ($1.validatecheck) {
      var _G = $k[--$j];
      $k[$j++] = $f(_G - 1);
    }
    var _H = $k[--$j];
    $1[$k[--$j]] = _H;
    $1.checksum = 41;
    for (var _L = 0, _K = $f($1.barlen - 1); _L <= _K; _L += 1) {
      $1.checksum = $f($get($1.charvals, $geti($1.barcode, _L, 1)) + $1.checksum);
    }
    $1.checksum = $1.checksum % 43;
    if ($1.validatecheck) {
      if ($get($1.barcode, $1.barlen) != $get($1.barchars, $1.checksum)) {
        $k[$j++] = "bwipp.hibcazteccodeBadCheckDigit#30963";
        $k[$j++] = "Incorrect HIBC Aztec Code check digit provided";
        bwipp_raiseerror();
      }
      $1.barcode = $geti($1.barcode, 0, $1.barlen);
    }
    var _d = $s($f($1.barlen + 2));
    $puti(_d, 1, $1.barcode);
    $1.barcode = _d;
    $put($1.barcode, 0, 43);
    $put($1.barcode, $f($1.barlen + 1), $get($1.barchars, $1.checksum));
    $put($1.options, "dontdraw", true);
    $put($1.options, "validatecheck", false);
    $k[$j++] = "args";
    $k[$j++] = $1.barcode;
    $k[$j++] = $1.options;
    bwipp_azteccode();
    var _p = $k[--$j];
    $1[$k[--$j]] = _p;
    var _r = $1.args;
    $put(_r, "opt", $1.options);
    $k[$j++] = $1.args;
    if (!$1.dontdraw) {
      bwipp_renmatrix();
    }
  }
  function bwipp_channelcode() {
    var $1 = Object.create(bwipp_channelcode.$ctx || (bwipp_channelcode.$ctx = {}));
    $1.options = $k[--$j];
    $1.barcode = $k[--$j];
    $1.dontdraw = false;
    $1.shortfinder = false;
    $1.includetext = false;
    $1.includecheck = false;
    $1.height = 1;
    $forall($1.options, function() {
      var _3 = $k[--$j];
      $1[$k[--$j]] = _3;
    });
    $1.height = +$1.height;
    if ($1.barcode.length < 2 || $1.barcode.length > 7) {
      $k[$j++] = "bwipp.channelcodeBadLength#31038";
      $k[$j++] = "Channel Code must be 2 to 7 digits";
      bwipp_raiseerror();
    }
    $forall($1.barcode, function() {
      var _9 = $k[--$j];
      if (_9 < 48 || _9 > 57) {
        $k[$j++] = "bwipp.channelcodeBadCharacter#31042";
        $k[$j++] = "Channel Code must contain only digits";
        bwipp_raiseerror();
      }
    });
    if ($cvi($1.barcode) > $get($a([26, 292, 3493, 44072, 576688, 7742862]), $1.barcode.length - 2)) {
      $k[$j++] = "bwipp.channelcodeTooBig#31046";
      $k[$j++] = "The Channel Code value is too big for the number of channels";
      bwipp_raiseerror();
    }
    $1.nextb = function() {
      var _E = $k[--$j];
      var _N = $f($get($1.s, _E) + $f($get($1.b, $f(_E - 1)) + $f($get($1.b, $f(_E - 2)) + $get($1.s, $f(_E - 1))))) > 4 ? 1 : 2;
      $k[$j++] = _E;
      $k[$j++] = _N;
      if (_E < $f($1.chan + 2)) {
        var _P = $k[--$j];
        var _Q = $k[--$j];
        var _R = $k[--$j];
        $k[$j++] = _R;
        $k[$j++] = _Q;
        $k[$j++] = _P;
        for (var _T = _P, _S = _R; _T <= _S; _T += 1) {
          var _V = $k[--$j];
          var _W = $k[--$j];
          $put($1.b, _W, _T);
          var _X = $k[--$j];
          var _Y = $k[--$j];
          $k[$j++] = _Y;
          $k[$j++] = _X;
          $k[$j++] = _W;
          $k[$j++] = _V;
          $k[$j++] = $f($f(_X - _T) + 1);
          $k[$j++] = _Y;
          $k[$j++] = $f(_W + 1);
          $1.nexts();
        }
      } else {
        var _Z = $k[--$j];
        var _a = $k[--$j];
        var _b = $k[--$j];
        $k[$j++] = _b;
        $k[$j++] = _a;
        $k[$j++] = _Z;
        if ($le(_Z, _b)) {
          var _d = $k[--$j];
          var _e = $k[--$j];
          var _f = $k[--$j];
          $put($1.b, _e, _f);
          $k[$j++] = _f;
          $k[$j++] = _e;
          $k[$j++] = _d;
          if ($1.value == $1.target) {
            $k[$j++] = Infinity;
            for (var _i = 3; _i <= 10; _i += 1) {
              $k[$j++] = $get($1.s, _i);
              $k[$j++] = $get($1.b, _i);
            }
            $1.out = $geti($a(), 0, $1.chan * 2);
          }
          $1.value = $1.value + 1;
        }
      }
      $j -= 4;
    };
    $1.nexts = function() {
      var _r = $k[--$j];
      $k[$j++] = _r;
      if (_r < $f($1.chan + 2)) {
        $k[$j++] = 1;
      } else {
        var _t = $k[--$j];
        var _u = $k[--$j];
        $k[$j++] = _u;
        $k[$j++] = _t;
        $k[$j++] = _u;
      }
      var _v = $k[--$j];
      var _w = $k[--$j];
      var _x = $k[--$j];
      $k[$j++] = _x;
      $k[$j++] = _w;
      for (var _z = _v, _y = _x; _z <= _y; _z += 1) {
        var _11 = $k[--$j];
        $put($1.s, _11, _z);
        var _12 = $k[--$j];
        var _13 = $k[--$j];
        $k[$j++] = _13;
        $k[$j++] = _12;
        $k[$j++] = _11;
        $k[$j++] = $f($f(_12 - _z) + 1);
        $k[$j++] = _13;
        $k[$j++] = _11;
        $1.nextb();
      }
      $j -= 3;
    };
    $1.encode = function() {
      $1.chan = $k[--$j];
      $1.target = $k[--$j];
      $1.value = 0;
      $1.out = -1;
      $1.b = $a([1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]);
      $1.s = $a([0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]);
      var _18 = $1.chan;
      $k[$j++] = _18;
      $k[$j++] = _18;
      $k[$j++] = 3;
      $1.nexts();
      $k[$j++] = $1.out;
    };
    $1.barlen = $1.barcode.length;
    $k[$j++] = "finder";
    if ($1.shortfinder) {
      $k[$j++] = $a([1, 1, 1, 1, 1]);
    } else {
      $k[$j++] = $a([1, 1, 1, 1, 1, 1, 1, 1, 1]);
    }
    var _1E = $k[--$j];
    $1[$k[--$j]] = _1E;
    $k[$j++] = "data";
    $k[$j++] = $cvi($1.barcode);
    $k[$j++] = $1.barlen + 1;
    $1.encode();
    var _1I = $k[--$j];
    $1[$k[--$j]] = _1I;
    $1.check = $a([]);
    if ($1.includecheck) {
      $1.mod23 = $get($a([$a([]), $a([]), $a([13, 12, 4, 9, 3, 1]), $a([13, 2, 12, 3, 18, 16, 4, 1]), $a([11, 16, 17, 8, 20, 4, 10, 2, 5, 1]), $a([1, 4, 16, 18, 3, 12, 2, 8, 9, 13, 6, 1]), $a([20, 16, 22, 13, 15, 12, 5, 4, 8, 9, 21, 3, 7, 1]), $a([2, 6, 18, 8, 1, 3, 9, 4, 12, 13, 16, 2, 6, 18, 8, 1])]), $1.barlen);
      $k[$j++] = 0;
      for (var _1Z = 0, _1Y = $1.data.length - 1; _1Z <= _1Y; _1Z += 1) {
        var _1e = $k[--$j];
        $k[$j++] = $f(_1e + $f($get($1.data, _1Z) - 1) * $get($1.mod23, _1Z));
      }
      var _1f = $k[--$j];
      $k[$j++] = _1f % 23;
      $k[$j++] = 3;
      $1.encode();
      $1.check = $k[--$j];
    }
    $k[$j++] = Infinity;
    $aload($1.finder);
    $aload($1.data);
    $aload($1.check);
    $1.sbs = $a();
    $1.txt = $a($1.barlen);
    for (var _1p = 0, _1o = $1.barlen - 1; _1p <= _1o; _1p += 1) {
      $1.i = _1p;
      $put($1.txt, $1.i, $a([$geti($1.barcode, $1.i, 1), 0, 0, "", 0]));
    }
    $k[$j++] = Infinity;
    var _1w = $1.sbs;
    $k[$j++] = Infinity;
    for (var _1y = 0, _1z = ~~(($1.sbs.length + 1) / 2); _1y < _1z; _1y++) {
      $k[$j++] = $1.height;
    }
    var _21 = $a();
    $k[$j++] = Infinity;
    for (var _23 = 0, _24 = ~~(($1.sbs.length + 1) / 2); _23 < _24; _23++) {
      $k[$j++] = 0;
    }
    var _25 = $a();
    $k[$j++] = "ren";
    $k[$j++] = bwipp_renlinear;
    $k[$j++] = "sbs";
    $k[$j++] = _1w;
    $k[$j++] = "bhs";
    $k[$j++] = _21;
    $k[$j++] = "bbs";
    $k[$j++] = _25;
    $k[$j++] = "txt";
    $k[$j++] = $1.txt;
    $k[$j++] = "textxalign";
    $k[$j++] = "center";
    $k[$j++] = "opt";
    $k[$j++] = $1.options;
    var _28 = $d();
    $k[$j++] = _28;
    if (!$1.dontdraw) {
      bwipp_renlinear();
    }
  }
  function bwipp_renlinear() {
    if ($0.bwipjs_dontdraw) {
      return;
    }
    var $1 = Object.create(bwipp_renlinear.$ctx || (bwipp_renlinear.$ctx = {}));
    $1.args = $k[--$j];
    $1.sbs = $a([]);
    $1.bhs = $a([]);
    $1.bbs = $a([]);
    $1.txt = $a([]);
    $1.barcolor = "unset";
    $1.includetext = false;
    $1.textcolor = "unset";
    $1.textxalign = "unset";
    $1.textyalign = "unset";
    $1.textfont = "OCR-B";
    $1.textsize = 10;
    $1.textxoffset = 0;
    $1.textyoffset = 0;
    $1.textgaps = 0;
    $1.alttext = "";
    $1.bordercolor = "unset";
    $1.backgroundcolor = "unset";
    $1.inkspread = 0;
    $1.width = 0;
    $1.barratio = 1;
    $1.spaceratio = 1;
    $1.showborder = false;
    $1.borderleft = 10;
    $1.borderright = 10;
    $1.bordertop = 1;
    $1.borderbottom = 1;
    $1.borderwidth = 0.5;
    $1.guardwhitespace = false;
    $1.guardleftpos = 0;
    $1.guardleftypos = 0;
    $1.guardrightpos = 0;
    $1.guardrightypos = 0;
    $1.guardwidth = 7;
    $1.guardheight = 7;
    $forall($1.args, function() {
      var _7 = $k[--$j];
      $1[$k[--$j]] = _7;
    });
    var _9 = $1.opt;
    for (var _E = _9.size, _D = _9.keys(), _C = 0; _C < _E; _C++) {
      var _A = _D.next().value;
      $1[_A] = _9.get(_A);
    }
    $1.barcolor = "" + $1.barcolor;
    $1.textcolor = "" + $1.textcolor;
    $1.textxalign = "" + $1.textxalign;
    $1.textyalign = "" + $1.textyalign;
    $1.textfont = "" + $1.textfont;
    $1.textsize = +$1.textsize;
    $1.textxoffset = +$1.textxoffset;
    $1.textyoffset = +$1.textyoffset;
    $1.textgaps = +$1.textgaps;
    $1.alttext = "" + $1.alttext;
    $1.bordercolor = "" + $1.bordercolor;
    $1.backgroundcolor = "" + $1.backgroundcolor;
    $1.inkspread = +$1.inkspread;
    $1.width = +$1.width;
    $1.barratio = +$1.barratio;
    $1.spaceratio = +$1.spaceratio;
    $1.borderleft = +$1.borderleft;
    $1.borderright = +$1.borderright;
    $1.bordertop = +$1.bordertop;
    $1.borderbottom = +$1.borderbottom;
    $1.borderwidth = +$1.borderwidth;
    $1.guardleftpos = +$1.guardleftpos;
    $1.guardleftypos = +$1.guardleftypos;
    $1.guardrightpos = +$1.guardrightpos;
    $1.guardrightypos = +$1.guardrightypos;
    $1.guardwidth = +$1.guardwidth;
    $1.guardheight = +$1.guardheight;
    $1.bars = $a(~~(($1.sbs.length + 1) / 2));
    $1.x = 0;
    $1.maxh = 0;
    for (var _k = 0, _j = ~~(($1.sbs.length + 1) / 2) * 2 - 2; _k <= _j; _k += 1) {
      $1.i = _k;
      if ($1.i % 2 == 0) {
        $1.d = $f($f($get($1.sbs, $1.i) * $1.barratio - $1.barratio) + 1);
        if ($get($1.sbs, $1.i) != 0) {
          $1.h = $get($1.bhs, ~~($1.i / 2)) * 72;
          $1.c = $f($1.d / 2 + $1.x);
          $1.y = $get($1.bbs, ~~($1.i / 2)) * 72;
          $1.w = $f($1.d - $1.inkspread);
          $put($1.bars, ~~($1.i / 2), $a([$1.h, $1.c, $1.y, $1.w]));
          if ($f($1.h + $1.y) > $1.maxh) {
            $1.maxh = $f($1.h + $1.y);
          }
        } else {
          $put($1.bars, ~~($1.i / 2), -1);
        }
      } else {
        $1.d = $f($f($get($1.sbs, $1.i) * $1.spaceratio - $1.spaceratio) + 1);
      }
      $1.x = $f($1.x + $1.d);
    }
    $$.save();
    var _1P = $$.currpos();
    $$.translate(_1P.x, _1P.y);
    if ($1.width != 0) {
      $$.scale($1.width * 72 / $1.x, 1);
    }
    $$.newpath();
    $$.moveto(-$1.borderleft, -$1.borderbottom);
    $$.rlineto($f($f($1.x + $1.borderleft) + $1.borderright), 0);
    $$.rlineto(0, $f($f($1.maxh + $1.borderbottom) + $1.bordertop));
    $$.rlineto(-$f($f($1.x + $1.borderleft) + $1.borderright), 0);
    $$.rlineto(0, -$f($f($1.maxh + $1.borderbottom) + $1.bordertop));
    $$.closepath();
    if ($1.showborder) {
      $$.save();
      if ($ne($1.bordercolor, "unset")) {
        $$.setcolor($1.bordercolor);
      }
      $$.setlinewidth($1.borderwidth);
      $$.stroke();
      $$.restore();
    }
    $$.save();
    if ($ne($1.barcolor, "unset")) {
      $$.setcolor($1.barcolor);
    }
    var _1n = $1.bars;
    for (var _1o = 0, _1p = _1n.length; _1o < _1p; _1o++) {
      var _1q = $get(_1n, _1o);
      $k[$j++] = _1q;
      if (_1q != -1) {
        $aload($k[--$j]);
        $$.newpath();
        $$.setlinewidth($k[--$j]);
        var _1t = $k[--$j];
        $$.moveto($k[--$j], _1t);
        $$.rlineto(0, $k[--$j]);
        $$.stroke();
      } else {
        $j--;
      }
    }
    $$.restore();
    if ($ne($1.textcolor, "unset")) {
      $$.setcolor($1.textcolor);
    }
    if ($1.includetext) {
      if ($eq($1.textxalign, "unset") && $eq($1.textyalign, "unset") && $eq($1.alttext, "")) {
        $1.s = 0;
        $1.fn = "";
        var _22 = $1.txt;
        for (var _23 = 0, _24 = _22.length; _23 < _24; _23++) {
          $forall($get(_22, _23));
          var _26 = $k[--$j];
          var _27 = $k[--$j];
          $k[$j++] = _27;
          $k[$j++] = _26;
          if (_26 != $1.s || $ne(_27, $1.fn)) {
            var _2A = $k[--$j];
            var _2B = $k[--$j];
            $1.s = _2A;
            $1.fn = _2B;
            $$.selectfont(_2B, _2A);
          } else {
            $j -= 2;
          }
          var _2C = $k[--$j];
          $$.moveto($k[--$j], _2C);
          $$.show($k[--$j], 0, 0);
        }
      } else {
        $$.selectfont($1.textfont, $1.textsize);
        if ($eq($1.alttext, "")) {
          $k[$j++] = Infinity;
          var _2I = $1.txt;
          for (var _2J = 0, _2K = _2I.length; _2J < _2K; _2J++) {
            $forall($get($get(_2I, _2J), 0));
          }
          $1.txt = $a();
          $1.tstr = $s($1.txt.length);
          for (var _2S = 0, _2R = $1.txt.length - 1; _2S <= _2R; _2S += 1) {
            $put($1.tstr, _2S, $get($1.txt, _2S));
          }
        } else {
          $1.tstr = $1.alttext;
        }
        if ($1.tstr.length == 0) {
          $k[$j++] = 0;
        } else {
          $$.save();
          $$.newpath();
          $$.moveto(0, 0);
          $$.charpath("0", false);
          var _2Y = $$.pathbbox();
          $$.restore();
          $k[$j++] = _2Y.ury;
        }
        $1.textascent = $k[--$j];
        var _2b = $$.stringwidth($1.tstr);
        $1.textwidth = $f(_2b.w + ($1.tstr.length - 1) * $1.textgaps);
        $1.textxpos = $f($1.textxoffset + $f($1.x - $1.textwidth) / 2);
        if ($eq($1.textxalign, "left")) {
          $1.textxpos = $1.textxoffset;
        }
        if ($eq($1.textxalign, "right")) {
          $1.textxpos = $f($f($1.x - $1.textxoffset) - $1.textwidth);
        }
        if ($eq($1.textxalign, "offleft")) {
          $1.textxpos = -$f($1.textwidth + $1.textxoffset);
        }
        if ($eq($1.textxalign, "offright")) {
          $1.textxpos = $f($1.x + $1.textxoffset);
        }
        if ($eq($1.textxalign, "justify") && $1.textwidth < $1.x) {
          $1.textxpos = 0;
          $1.textgaps = $f($1.x - $1.textwidth) / ($1.tstr.length - 1);
        }
        $1.textypos = -$f($f($1.textyoffset + $1.textascent) + 1);
        if ($eq($1.textyalign, "above")) {
          $1.textypos = $f($f($1.textyoffset + $1.maxh) + 1);
        }
        if ($eq($1.textyalign, "center")) {
          $1.textypos = $f($1.textyoffset + $f($1.maxh - $1.textascent) / 2);
        }
        $$.moveto($1.textxpos, $1.textypos);
        $$.show($1.tstr, $1.textgaps, 0);
      }
    }
    if ($1.guardwhitespace) {
      $$.selectfont("OCR-B", $1.guardheight * 2);
      if ($1.guardleftpos != 0) {
        $$.moveto($f(-$1.guardleftpos - 1), $f($f($1.guardleftypos - $1.guardheight / 2) - 1.5));
        $$.show("<", 0, 0);
      }
      if ($1.guardrightpos != 0) {
        $$.moveto($f($f($f($1.guardrightpos + $1.x) - $1.guardwidth) + 1), $f($f($1.guardrightypos - $1.guardheight / 2) - 1.5));
        $$.show(">", 0, 0);
      }
    }
    $$.restore();
  }
  function bwipp_renmaximatrix() {
    if ($0.bwipjs_dontdraw) {
      return;
    }
    var $1 = Object.create(bwipp_renmaximatrix.$ctx || (bwipp_renmaximatrix.$ctx = {}));
    $1.args = $k[--$j];
    $1.barcolor = "unset";
    $1.backgroundcolor = "unset";
    $forall($1.args, function() {
      var _3 = $k[--$j];
      $1[$k[--$j]] = _3;
    });
    var _5 = $1.opt;
    for (var _A = _5.size, _9 = _5.keys(), _8 = 0; _8 < _A; _8++) {
      var _6 = _9.next().value;
      $1[_6] = _5.get(_6);
    }
    $1.barcolor = "" + $1.barcolor;
    $1.backgroundcolor = "" + $1.backgroundcolor;
    $$.save();
    if ($ne($1.barcolor, "unset")) {
      $$.setcolor($1.barcolor);
    }
    $$.maxicode($1.pixs);
    $$.restore();
  }
  function bwipp_encode(bwipjs, encoder, text, opts, dontdraw) {
    if (typeof text !== "string") {
      throw new Error("bwipp.typeError: barcode text not a string (" + text + ")");
    }
    opts = opts || {};
    if (typeof opts === "string") {
      var tmp = opts.split(" ");
      opts = {};
      for (var i = 0; i < tmp.length; i++) {
        if (!tmp[i]) {
          continue;
        }
        var eq = tmp[i].indexOf("=");
        if (eq == -1) {
          opts[tmp[i]] = true;
        } else {
          opts[tmp[i].substr(0, eq)] = tmp[i].substr(eq + 1);
        }
      }
    } else if (typeof opts !== "object" || opts.constructor !== Object) {
      throw new Error("bwipp.typeError: options not an object");
    }
    if (/[\u0080-\uffff]/.test(text)) {
      text = unescape(encodeURIComponent(text));
    }
    $0.bwipjs_dontdraw = opts.dontdraw || dontdraw || false;
    var map = /* @__PURE__ */ new Map();
    for (var id in opts) {
      if (opts.hasOwnProperty(id)) {
        map.set(id, opts[id]);
      }
    }
    $$ = bwipjs;
    $k = [text, map];
    $j = 2;
    encoder();
    if ($j) {
      return $k.splice(0, $j);
    }
    return true;
  }
  function bwipp_lookup(symbol2) {
    if (!symbol2) {
      throw new Error("bwipp.undefinedEncoder: bcid is not defined");
    }
    switch (symbol2.replace(/-/g, "_")) {
      case "auspost":
        return bwipp_auspost;
      case "azteccode":
        return bwipp_azteccode;
      case "azteccodecompact":
        return bwipp_azteccodecompact;
      case "aztecrune":
        return bwipp_aztecrune;
      case "bc412":
        return bwipp_bc412;
      case "channelcode":
        return bwipp_channelcode;
      case "codablockf":
        return bwipp_codablockf;
      case "code11":
        return bwipp_code11;
      case "code128":
        return bwipp_code128;
      case "code16k":
        return bwipp_code16k;
      case "code2of5":
        return bwipp_code2of5;
      case "code32":
        return bwipp_code32;
      case "code39":
        return bwipp_code39;
      case "code39ext":
        return bwipp_code39ext;
      case "code49":
        return bwipp_code49;
      case "code93":
        return bwipp_code93;
      case "code93ext":
        return bwipp_code93ext;
      case "codeone":
        return bwipp_codeone;
      case "coop2of5":
        return bwipp_coop2of5;
      case "daft":
        return bwipp_daft;
      case "databarexpanded":
        return bwipp_databarexpanded;
      case "databarexpandedcomposite":
        return bwipp_databarexpandedcomposite;
      case "databarexpandedstacked":
        return bwipp_databarexpandedstacked;
      case "databarexpandedstackedcomposite":
        return bwipp_databarexpandedstackedcomposite;
      case "databarlimited":
        return bwipp_databarlimited;
      case "databarlimitedcomposite":
        return bwipp_databarlimitedcomposite;
      case "databaromni":
        return bwipp_databaromni;
      case "databaromnicomposite":
        return bwipp_databaromnicomposite;
      case "databarstacked":
        return bwipp_databarstacked;
      case "databarstackedcomposite":
        return bwipp_databarstackedcomposite;
      case "databarstackedomni":
        return bwipp_databarstackedomni;
      case "databarstackedomnicomposite":
        return bwipp_databarstackedomnicomposite;
      case "databartruncated":
        return bwipp_databartruncated;
      case "databartruncatedcomposite":
        return bwipp_databartruncatedcomposite;
      case "datalogic2of5":
        return bwipp_datalogic2of5;
      case "datamatrix":
        return bwipp_datamatrix;
      case "datamatrixrectangular":
        return bwipp_datamatrixrectangular;
      case "datamatrixrectangularextension":
        return bwipp_datamatrixrectangularextension;
      case "dotcode":
        return bwipp_dotcode;
      case "ean13":
        return bwipp_ean13;
      case "ean13composite":
        return bwipp_ean13composite;
      case "ean14":
        return bwipp_ean14;
      case "ean2":
        return bwipp_ean2;
      case "ean5":
        return bwipp_ean5;
      case "ean8":
        return bwipp_ean8;
      case "ean8composite":
        return bwipp_ean8composite;
      case "flattermarken":
        return bwipp_flattermarken;
      case "gs1_128":
        return bwipp_gs1_128;
      case "gs1_128composite":
        return bwipp_gs1_128composite;
      case "gs1_cc":
        return bwipp_gs1_cc;
      case "gs1datamatrix":
        return bwipp_gs1datamatrix;
      case "gs1datamatrixrectangular":
        return bwipp_gs1datamatrixrectangular;
      case "gs1dldatamatrix":
        return bwipp_gs1dldatamatrix;
      case "gs1dlqrcode":
        return bwipp_gs1dlqrcode;
      case "gs1dotcode":
        return bwipp_gs1dotcode;
      case "gs1northamericancoupon":
        return bwipp_gs1northamericancoupon;
      case "gs1qrcode":
        return bwipp_gs1qrcode;
      case "hanxin":
        return bwipp_hanxin;
      case "hibcazteccode":
        return bwipp_hibcazteccode;
      case "hibccodablockf":
        return bwipp_hibccodablockf;
      case "hibccode128":
        return bwipp_hibccode128;
      case "hibccode39":
        return bwipp_hibccode39;
      case "hibcdatamatrix":
        return bwipp_hibcdatamatrix;
      case "hibcdatamatrixrectangular":
        return bwipp_hibcdatamatrixrectangular;
      case "hibcmicropdf417":
        return bwipp_hibcmicropdf417;
      case "hibcpdf417":
        return bwipp_hibcpdf417;
      case "hibcqrcode":
        return bwipp_hibcqrcode;
      case "iata2of5":
        return bwipp_iata2of5;
      case "identcode":
        return bwipp_identcode;
      case "industrial2of5":
        return bwipp_industrial2of5;
      case "interleaved2of5":
        return bwipp_interleaved2of5;
      case "isbn":
        return bwipp_isbn;
      case "ismn":
        return bwipp_ismn;
      case "issn":
        return bwipp_issn;
      case "itf14":
        return bwipp_itf14;
      case "jabcode":
        return bwipp_jabcode;
      case "japanpost":
        return bwipp_japanpost;
      case "kix":
        return bwipp_kix;
      case "leitcode":
        return bwipp_leitcode;
      case "mailmark":
        return bwipp_mailmark;
      case "mands":
        return bwipp_mands;
      case "matrix2of5":
        return bwipp_matrix2of5;
      case "maxicode":
        return bwipp_maxicode;
      case "micropdf417":
        return bwipp_micropdf417;
      case "microqrcode":
        return bwipp_microqrcode;
      case "msi":
        return bwipp_msi;
      case "onecode":
        return bwipp_onecode;
      case "pdf417":
        return bwipp_pdf417;
      case "pdf417compact":
        return bwipp_pdf417compact;
      case "pharmacode":
        return bwipp_pharmacode;
      case "pharmacode2":
        return bwipp_pharmacode2;
      case "planet":
        return bwipp_planet;
      case "plessey":
        return bwipp_plessey;
      case "posicode":
        return bwipp_posicode;
      case "postnet":
        return bwipp_postnet;
      case "pzn":
        return bwipp_pzn;
      case "qrcode":
        return bwipp_qrcode;
      case "rationalizedCodabar":
        return bwipp_rationalizedCodabar;
      case "raw":
        return bwipp_raw;
      case "rectangularmicroqrcode":
        return bwipp_rectangularmicroqrcode;
      case "royalmail":
        return bwipp_royalmail;
      case "sscc18":
        return bwipp_sscc18;
      case "swissqrcode":
        return bwipp_swissqrcode;
      case "symbol":
        return bwipp_symbol;
      case "telepen":
        return bwipp_telepen;
      case "telepennumeric":
        return bwipp_telepennumeric;
      case "ultracode":
        return bwipp_ultracode;
      case "upca":
        return bwipp_upca;
      case "upcacomposite":
        return bwipp_upcacomposite;
      case "upce":
        return bwipp_upce;
      case "upcecomposite":
        return bwipp_upcecomposite;
    }
    throw new Error("bwipp.unknownEncoder: unknown encoder name: " + symbol2);
  }
  var BWIPP_VERSION = "2023-04-03";

  // node_modules/bwip-js/dist/bwip-js.mjs
  function ToCanvas(opts, canvas) {
    if (typeof canvas == "string") {
      canvas = document.getElementById(canvas) || document.querySelector(canvas);
    } else if (typeof opts == "string") {
      opts = document.getElementById(opts) || document.querySelector(opts);
    }
    if (opts instanceof HTMLCanvasElement) {
      var tmp = opts;
      opts = canvas;
      canvas = tmp;
    } else if (!(canvas instanceof HTMLCanvasElement)) {
      throw "bwipjs: Not a canvas";
    }
    _Render(bwipp_lookup(opts.bcid), opts, DrawingCanvas(opts, canvas));
    return canvas;
  }
  function _ToCanvas(encoder, opts, canvas) {
    if (typeof canvas == "string") {
      canvas = document.getElementById(canvas) || document.querySelector(canvas);
    } else if (typeof opts == "string") {
      opts = document.getElementById(opts) || document.querySelector(opts);
    }
    if (opts instanceof HTMLCanvasElement) {
      var tmp = opts;
      opts = canvas;
      canvas = tmp;
    } else if (!(canvas instanceof HTMLCanvasElement)) {
      throw "bwipjs: Not a canvas";
    }
    _Render(encoder, opts, DrawingCanvas(opts, canvas));
    return canvas;
  }
  function FixupOptions(opts) {
    var scale2 = opts.scale || 2;
    var scaleX = +opts.scaleX || scale2;
    var scaleY = +opts.scaleY || scaleX;
    opts.paddingleft = padding(opts.paddingleft, opts.paddingwidth, opts.padding, scaleX);
    opts.paddingright = padding(opts.paddingright, opts.paddingwidth, opts.padding, scaleX);
    opts.paddingtop = padding(opts.paddingtop, opts.paddingheight, opts.padding, scaleY);
    opts.paddingbottom = padding(opts.paddingbottom, opts.paddingheight, opts.padding, scaleY);
    if (/^[0-9a-fA-F]{8}$/.test("" + opts.backgroundcolor)) {
      var cmyk2 = opts.backgroundcolor;
      var c = parseInt(cmyk2.substr(0, 2), 16) / 255;
      var m = parseInt(cmyk2.substr(2, 2), 16) / 255;
      var y = parseInt(cmyk2.substr(4, 2), 16) / 255;
      var k = parseInt(cmyk2.substr(6, 2), 16) / 255;
      var r = Math.floor((1 - c) * (1 - k) * 255).toString(16);
      var g = Math.floor((1 - m) * (1 - k) * 255).toString(16);
      var b = Math.floor((1 - y) * (1 - k) * 255).toString(16);
      opts.backgroundcolor = (r.length == 1 ? "0" : "") + r + (g.length == 1 ? "0" : "") + g + (b.length == 1 ? "0" : "") + b;
    }
    return opts;
    function padding(a, b2, c2, s) {
      if (a != null) {
        return a * s;
      }
      if (b2 != null) {
        return b2 * s;
      }
      return c2 * s || 0;
    }
  }
  var BWIPJS_OPTIONS = {
    bcid: 1,
    text: 1,
    scale: 1,
    scaleX: 1,
    scaleY: 1,
    rotate: 1,
    padding: 1,
    paddingwidth: 1,
    paddingheight: 1,
    paddingtop: 1,
    paddingleft: 1,
    paddingright: 1,
    paddingbottom: 1,
    backgroundcolor: 1
  };
  function Render(params, drawing) {
    return _Render(bwipp_lookup(params.bcid), params, drawing);
  }
  function _Render(encoder, params, drawing) {
    var text = params.text;
    if (!text) {
      throw new ReferenceError("bwip-js: bar code text not specified.");
    }
    FixupOptions(params);
    var scale2 = params.scale || 2;
    var scaleX = +params.scaleX || scale2;
    var scaleY = +params.scaleY || scaleX;
    var rotate = params.rotate || "N";
    var bw = new BWIPJS(drawing);
    var opts = {};
    for (var id in params) {
      if (!BWIPJS_OPTIONS[id]) {
        opts[id] = params[id];
      }
    }
    if (opts.alttext) {
      opts.includetext = true;
    }
    if (+opts.height && encoder != bwipp_pharmacode2) {
      opts.height = opts.height / 25.4 || 0.5;
    }
    if (+opts.width) {
      opts.width = opts.width / 25.4 || 0;
    }
    bw.scale(scaleX, scaleY);
    bwipp_encode(bw, encoder, text, opts);
    return bw.render();
  }
  function ToRaw(bcid, text, options) {
    if (arguments.length == 1) {
      options = bcid;
      bcid = options.bcid;
      text = options.text;
    }
    var bw = new BWIPJS(DrawingBuiltin({}));
    var stack = bwipp_encode(bw, bwipp_lookup(bcid), text, options, true);
    var ids = { pixs: 1, pixx: 1, pixy: 1, sbs: 1, bbs: 1, bhs: 1, width: 1, height: 1 };
    for (var i = 0; i < stack.length; i++) {
      var elt = stack[i];
      if (elt instanceof Map) {
        var obj = {};
        for (var keys = elt.keys(), size = elt.size, k = 0; k < size; k++) {
          var id = keys.next().value;
          if (ids[id]) {
            var val = elt.get(id);
            if (val instanceof Array) {
              obj[id] = val.b.slice(val.o, val.o + val.length);
            } else {
              obj[id] = val;
            }
          }
        }
        stack[i] = obj;
      } else {
        stack.splice(i--, 1);
      }
    }
    return stack;
  }
  var BWIPJS = function() {
    var floor = Math.floor;
    var round = Math.round;
    var ceil = Math.ceil;
    var min = Math.min;
    var max = Math.max;
    function BWIPJS2(drawing) {
      if (this.constructor !== BWIPJS2) {
        return new BWIPJS2(drawing);
      }
      this.gstk = [];
      this.cmds = [];
      this.drawing = drawing;
      this.reset();
      this.minx = this.miny = Infinity;
      this.maxx = this.maxy = -Infinity;
    }
    ;
    BWIPJS2.prototype.reset = function() {
      this.g_tdx = 0;
      this.g_tdy = 0;
      this.g_tsx = 1;
      this.g_tsy = 1;
      this.g_posx = 0;
      this.g_posy = 0;
      this.g_penw = 1;
      this.g_path = [];
      this.g_font = null;
      this.g_rgb = [0, 0, 0];
      this.g_clip = false;
    };
    BWIPJS2.prototype.save = function() {
      var ctx = {};
      for (var id in this) {
        if (id.indexOf("g_") == 0) {
          ctx[id] = clone(this[id]);
        }
      }
      this.gstk.push(ctx);
      function clone(v) {
        if (v instanceof Array) {
          var t = [];
          for (var i = 0; i < v.length; i++)
            t[i] = clone(v[i]);
          return t;
        }
        if (v instanceof Object) {
          var t = {};
          for (var id2 in v)
            t[id2] = clone(v[id2]);
          return t;
        }
        return v;
      }
    };
    BWIPJS2.prototype.restore = function() {
      if (!this.gstk.length) {
        throw new Error("grestore: stack underflow");
      }
      var ctx = this.gstk.pop();
      var self = this;
      if (this.g_clip && !ctx.g_clip) {
        this.cmds.push(function() {
          self.drawing.unclip();
        });
      }
      for (var id in ctx) {
        this[id] = ctx[id];
      }
    };
    BWIPJS2.prototype.currpos = function() {
      return {
        x: (this.g_posx - this.g_tdx) / this.g_tsx,
        y: (this.g_posy - this.g_tdy) / this.g_tsy
      };
    };
    BWIPJS2.prototype.currfont = function() {
      return this.g_font;
    };
    BWIPJS2.prototype.translate = function(x, y) {
      this.g_tdx = this.g_tsx * x;
      this.g_tdy = this.g_tsy * y;
    };
    BWIPJS2.prototype.scale = function(x, y) {
      this.g_tsx *= x;
      this.g_tsy *= y;
      var sxy = this.drawing.scale(this.g_tsx, this.g_tsy);
      if (sxy && sxy[0] && sxy[1]) {
        this.g_tsx = sxy[0];
        this.g_tsy = sxy[1];
      }
    };
    BWIPJS2.prototype.setlinewidth = function(w) {
      this.g_penw = w;
    };
    BWIPJS2.prototype.selectfont = function(f, z2) {
      this.g_font = { FontName: this.jsstring(f), FontSize: +z2 };
    };
    BWIPJS2.prototype.getfont = function() {
      return this.g_font.FontName;
    };
    BWIPJS2.prototype.jsstring = function(s) {
      if (s instanceof Uint8Array) {
        return String.fromCharCode.apply(null, s);
      }
      return "" + s;
    };
    BWIPJS2.prototype.setcolor = function(s) {
      if (s instanceof Uint8Array) {
        s = this.jsstring(s);
      }
      if (s.length == 6) {
        var r = parseInt(s.substr(0, 2), 16);
        var g = parseInt(s.substr(2, 2), 16);
        var b = parseInt(s.substr(4, 2), 16);
        this.g_rgb = [r, g, b];
      } else if (s.length == 8) {
        var c = parseInt(s.substr(0, 2), 16) / 255;
        var m = parseInt(s.substr(2, 2), 16) / 255;
        var y = parseInt(s.substr(4, 2), 16) / 255;
        var k = parseInt(s.substr(6, 2), 16) / 255;
        var r = round((1 - c) * (1 - k) * 255);
        var g = round((1 - m) * (1 - k) * 255);
        var b = round((1 - y) * (1 - k) * 255);
        this.g_rgb = [r, g, b];
      }
    };
    BWIPJS2.prototype.setrgbcolor = function(r, g, b) {
      this.g_rgb = [r, g, b];
    };
    BWIPJS2.prototype.getRGB = function() {
      var r = this.g_rgb[0].toString(16);
      var g = this.g_rgb[1].toString(16);
      var b = this.g_rgb[2].toString(16);
      return "00".substr(r.length) + r + "00".substr(g.length) + g + "00".substr(b.length) + b;
    };
    BWIPJS2.prototype.newpath = function() {
      this.g_path = [];
    };
    BWIPJS2.prototype.closepath = function() {
      var path = this.g_path;
      var plen = path.length;
      if (!plen)
        return;
      var f = plen - 1;
      for (; f >= 0 && path[f].op == "l"; f--)
        ;
      f++;
      if (f < plen - 1) {
        var poly = [];
        var xmin = Infinity;
        var ymin = Infinity;
        var xmax = -Infinity;
        var ymax = -Infinity;
        for (var i = f; i < plen; i++) {
          var a = path[i];
          poly.push([a.x0, a.y0]);
          if (xmin > a.x0)
            xmin = a.x0;
          if (xmax < a.x0)
            xmax = a.x0;
          if (ymin > a.y0)
            ymin = a.y0;
          if (ymax < a.y0)
            ymax = a.y0;
        }
        var a = path[plen - 1];
        var b = path[f];
        if (a.x1 != b.x0 || a.y1 != b.y0) {
          poly.push([a.x1, a.y1]);
          if (xmin > a.x1)
            xmin = a.x1;
          if (xmax < a.x1)
            xmax = a.x1;
          if (ymin > a.y1)
            ymin = a.y1;
          if (ymax < a.y1)
            ymax = a.y1;
        }
        path.splice(
          f,
          plen - f,
          { op: "p", x0: xmin, y0: ymin, x1: xmax, y1: ymax, poly }
        );
      } else {
        path.push({ op: "c" });
      }
    };
    BWIPJS2.prototype.moveto = function(x, y) {
      this.g_posx = this.g_tdx + this.g_tsx * x;
      this.g_posy = this.g_tdy + this.g_tsy * y;
    };
    BWIPJS2.prototype.rmoveto = function(x, y) {
      this.g_posx += this.g_tsx * x;
      this.g_posy += this.g_tsy * y;
    };
    BWIPJS2.prototype.lineto = function(x, y) {
      var x0 = round(this.g_posx);
      var y0 = round(this.g_posy);
      this.g_posx = this.g_tdx + this.g_tsx * x;
      this.g_posy = this.g_tdy + this.g_tsy * y;
      var x1 = round(this.g_posx);
      var y1 = round(this.g_posy);
      this.g_path.push({ op: "l", x0, y0, x1, y1 });
    };
    BWIPJS2.prototype.rlineto = function(x, y) {
      var x0 = round(this.g_posx);
      var y0 = round(this.g_posy);
      this.g_posx += this.g_tsx * x;
      this.g_posy += this.g_tsy * y;
      var x1 = round(this.g_posx);
      var y1 = round(this.g_posy);
      this.g_path.push({ op: "l", x0, y0, x1, y1 });
    };
    BWIPJS2.prototype.arc = function(x, y, r, sa, ea, ccw) {
      if (sa == ea) {
        return;
      }
      if (sa != 0 && sa != 360 || ea != 0 && ea != 360) {
        throw new Error("arc: not a full circle (" + sa + "," + ea + ")");
      }
      x = this.g_tdx + this.g_tsx * x;
      y = this.g_tdy + this.g_tsy * y;
      var rx = r * this.g_tsx;
      var ry = r * this.g_tsy;
      this.g_path.push({
        op: "e",
        x0: x - rx,
        y0: y - ry,
        x1: x + rx,
        y1: y + ry,
        x,
        y,
        rx,
        ry,
        sa,
        ea,
        ccw
      });
    };
    BWIPJS2.prototype.stringwidth = function(str) {
      var tsx = this.g_tsx;
      var tsy = this.g_tsy;
      var size = +this.g_font.FontSize || 10;
      str = this.toUCS2(this.jsstring(str));
      var bbox = this.drawing.measure(str, this.g_font.FontName, size * tsx, size * tsy);
      return {
        w: bbox.width / tsx,
        h: (bbox.ascent + bbox.descent) / tsy,
        a: bbox.ascent / tsy,
        d: bbox.descent / tsy
      };
    };
    BWIPJS2.prototype.charpath = function(str, b) {
      var sw = this.stringwidth(str);
      this.rlineto(0, sw.a);
      this.rlineto(sw.w, 0);
      this.rlineto(0, -sw.h);
    };
    BWIPJS2.prototype.pathbbox = function() {
      if (!this.g_path.length)
        throw new Error("pathbbox: --nocurrentpoint--");
      var path = this.g_path;
      var llx = Infinity;
      var lly = Infinity;
      var urx = -Infinity;
      var ury = -Infinity;
      for (var i = 0; i < path.length; i++) {
        var a = path[i];
        if (a.op == "c") {
          continue;
        }
        if (a.x0 < a.x1) {
          if (llx > a.x0)
            llx = a.x0;
          if (urx < a.x1)
            urx = a.x1;
        } else {
          if (llx > a.x1)
            llx = a.x1;
          if (urx < a.x0)
            urx = a.x0;
        }
        if (a.y0 < a.y1) {
          if (lly > a.y0)
            lly = a.y0;
          if (ury < a.y1)
            ury = a.y1;
        } else {
          if (lly > a.y1)
            lly = a.y1;
          if (ury < a.y0)
            ury = a.y0;
        }
      }
      var rv = {
        llx: (llx - this.g_tdx) / this.g_tsx,
        lly: (lly - this.g_tdy) / this.g_tsy,
        urx: (urx - this.g_tdx) / this.g_tsx,
        ury: (ury - this.g_tdy) / this.g_tsy
      };
      return rv;
    };
    BWIPJS2.prototype.transform = function(pts) {
      var minx = this.minx;
      var maxy = this.maxy;
      for (var i = 0; i < pts.length; i++) {
        var pt = pts[i];
        pt[0] = pt[0] - minx;
        pt[1] = maxy - pt[1];
      }
    };
    BWIPJS2.prototype.stroke = function() {
      var tsx = this.g_tsx;
      var tsy = this.g_tsy;
      var path = this.g_path;
      var rgb2 = this.getRGB();
      this.g_path = [];
      var penw = floor(this.g_penw * tsx + 0.66);
      var penh = floor(this.g_penw * tsy + 0.66);
      var nlines = 0, npolys = 0;
      for (var i = 0; i < path.length; i++) {
        var a = path[i];
        if (a.op == "l") {
          if (a.x0 != a.x1 && a.y0 != a.y1) {
            throw new Error("stroke: --not-orthogonal--");
          }
          var x0 = a.x0;
          var y0 = a.y0;
          var x1 = a.x1;
          var y1 = a.y1;
          var penw2 = penw / 2;
          var penh2 = penh / 2;
          if (x0 > x1) {
            var t = x0;
            x0 = x1;
            x1 = t;
          }
          if (y0 > y1) {
            var t = y0;
            y0 = y1;
            y1 = t;
          }
          if (x0 == x1) {
            this.bbox(x0 - penw2, y0, x0 + penw - penw2 - 1, y1);
          } else {
            this.bbox(x0, y0 - penh + penh2 + 1, x1, y1 + penh2);
          }
          nlines++;
        } else if (a.op == "p") {
          var minx = Infinity;
          var miny = Infinity;
          var maxx = -Infinity;
          var maxy = -Infinity;
          var pts = a.poly;
          if (pts.length != 4) {
            throw new Error("stroke: --not-a-rect--");
          }
          for (var i = 0, j = pts.length - 1; i < pts.length; j = i++) {
            var xj = pts[j][0];
            var yj = pts[j][1];
            var xi = pts[i][0];
            var yi = pts[i][1];
            if (xi != xj && yi != yj) {
              throw new Error("stroke: --not-orthogonal--");
            }
            if (xi < minx)
              minx = xi;
            if (xi > maxx)
              maxx = xi;
            if (yi < miny)
              miny = yi;
            if (yi > maxy)
              maxy = yi;
          }
          var penw2 = ceil(penw / 2);
          var penh2 = ceil(penh / 2);
          this.bbox(minx - penw2, miny - penh2, maxx + penw2, maxy + penh2);
          npolys++;
        } else {
          throw new Error("stroke: --not-a-line--");
        }
      }
      var self = this;
      this.cmds.push(function() {
        var bigw2 = ceil(penw / 2);
        var bigh2 = ceil(penh / 2);
        var remw2 = penw - bigw2;
        var remh2 = penh - bigh2;
        for (var i2 = 0; i2 < path.length; i2++) {
          var a2 = path[i2];
          if (a2.op == "l") {
            var pts2 = [[a2.x0, a2.y0], [a2.x1, a2.y1]];
            self.transform(pts2);
            self.drawing.line(
              pts2[0][0],
              pts2[0][1],
              pts2[1][0],
              pts2[1][1],
              a2.x0 == a2.x1 ? penw : penh,
              rgb2
            );
            self.fill(rgb2);
          } else {
            var pts2 = a2.poly;
            self.transform(pts2);
            var x02 = min(pts2[0][0], pts2[2][0]);
            var x12 = max(pts2[0][0], pts2[2][0]);
            var y02 = min(pts2[0][1], pts2[2][1]);
            var y12 = max(pts2[0][1], pts2[2][1]);
            self.drawing.polygon([
              [x02 - bigw2, y02 - bigh2],
              [x02 - bigw2, y12 + bigh2 + 1],
              [x12 + bigw2 + 1, y12 + bigh2 + 1],
              [x12 + bigw2 + 1, y02 - bigh2]
            ]);
            self.drawing.polygon([
              [x02 + remw2, y02 + remh2],
              [x02 + remw2, y12 - remh2 + 1],
              [x12 - remw2 + 1, y12 - remh2 + 1],
              [x12 - remw2 + 1, y02 + remh2]
            ]);
            self.drawing.fill(rgb2);
          }
        }
      });
    };
    BWIPJS2.prototype.fill = function() {
      var path = this.g_path;
      var rgb2 = this.getRGB();
      this.g_path = [];
      for (var p = 0; p < path.length; p++) {
        var a = path[p];
        if (a.op == "p") {
          var minx = Infinity;
          var miny = Infinity;
          var maxx = -Infinity;
          var maxy = -Infinity;
          var pts = a.poly;
          for (var i = 0; i < pts.length; i++) {
            var xi = pts[i][0];
            var yi = pts[i][1];
            if (xi < minx)
              minx = xi;
            if (xi > maxx)
              maxx = xi;
            if (yi < miny)
              miny = yi;
            if (yi > maxy)
              maxy = yi;
          }
          this.bbox(minx, miny + 1, maxx - 1, maxy);
        } else if (a.op == "e") {
          this.bbox(a.x - a.rx, a.y - a.ry, a.x + a.rx, a.y + a.ry);
        } else {
          throw new Error("fill: --not-a-polygon--");
        }
      }
      var self = this;
      this.cmds.push(function() {
        for (var i2 = 0; i2 < path.length; i2++) {
          var a2 = path[i2];
          if (a2.op == "p") {
            var pts2 = a2.poly;
            self.transform(pts2);
            self.drawing.polygon(pts2);
          } else if (a2.op == "e") {
            var pts2 = [[a2.x, a2.y]];
            self.transform(pts2);
            self.drawing.ellipse(pts2[0][0], pts2[0][1], a2.rx, a2.ry, a2.ccw);
          }
        }
        self.drawing.fill(rgb2);
      });
    };
    BWIPJS2.prototype.clip = function() {
      var path = this.g_path;
      this.g_path = [];
      this.g_clip = true;
      var self = this;
      this.cmds.push(function() {
        var polys = [];
        for (var i = 0; i < path.length; i++) {
          var a = path[i];
          if (a.op == "p") {
            var pts = a.poly;
            self.transform(pts);
            polys.push(pts);
          } else {
            throw new Error("clip: only polygon regions supported");
          }
        }
        self.drawing.clip(polys);
      });
    };
    BWIPJS2.prototype.maxicode = function(pix) {
      var tsx = this.g_tsx;
      var tsy = this.g_tsy;
      var rgb2 = this.getRGB();
      var twidth = 1.04 * tsx * 100;
      var mwidth = twidth / 30 | 0;
      if (twidth - (mwidth * 30 - 1) > 9) {
        mwidth++;
      }
      var w, h, wgap, hgap;
      wgap = tsx / 2 | 0;
      hgap = tsy / 2 | 0;
      w = mwidth - wgap;
      if (w & 1) {
        w--;
      }
      h = (4 * tsy | 0) - hgap;
      var w2 = w / 2 - 1;
      var qh = (w2 + 1) / 2 | 0;
      var vh = h - 2 - 2 * qh;
      this.bbox(0, 0, mwidth * 30 - wgap, tsy * 3 * 32 + tsy * 4 - hgap);
      var self = this;
      this.cmds.push(function() {
        for (var i = 0; i < pix.length; i++) {
          var c = pix[i];
          var x = c % 30;
          var y = c / 30 | 0;
          x *= mwidth;
          x += y & 1 ? mwidth : mwidth / 2;
          x = x | 0;
          y = 33 - y;
          y *= tsy * 3;
          y += tsy * 2 - h / 2;
          y = y | 0;
          var pts = [[x - 0.5, y--]];
          y -= qh - 1;
          pts.push([x - 1 - w2, y--]);
          y -= vh;
          pts.push([x - 1 - w2, y--]);
          y -= qh - 1;
          pts.push([x - 0.5, y++]);
          y += qh - 1;
          pts.push([x + w2, y++]);
          y += vh;
          pts.push([x + w2, y++]);
          self.transform(pts);
          self.drawing.hexagon(pts, rgb2);
        }
        self.drawing.fill(rgb2);
        var x = 14 * mwidth + mwidth / 2 + 0.01 | 0;
        var y = (12 * 4 + 3) * tsy - qh / 2 + 0.01 | 0;
        self.drawing.ellipse(x, y, 0.5774 * 3.5 * tsx + 0.01 | 0, 0.5774 * 3.5 * tsy + 0.01 | 0, true);
        self.drawing.ellipse(x, y, 1.3359 * 3.5 * tsx + 0.01 | 0, 1.3359 * 3.5 * tsy + 0.01 | 0, false);
        self.drawing.fill(rgb2);
        self.drawing.ellipse(x, y, 2.1058 * 3.5 * tsx + 0.01 | 0, 2.1058 * 3.5 * tsy + 0.01 | 0, true);
        self.drawing.ellipse(x, y, 2.8644 * 3.5 * tsx + 0.01 | 0, 2.8644 * 3.5 * tsy + 0.01 | 0, false);
        self.drawing.fill(rgb2);
        self.drawing.ellipse(x, y, 3.6229 * 3.5 * tsx + 0.01 | 0, 3.6229 * 3.5 * tsy + 0.01 | 0, true);
        self.drawing.ellipse(x, y, 4.3814 * 3.5 * tsx + 0.01 | 0, 4.3814 * 3.5 * tsy + 0.01 | 0, false);
        self.drawing.fill(rgb2);
      });
    };
    BWIPJS2.prototype.toUCS2 = function(str) {
      return str.replace(
        /[\xc0-\xdf][\x80-\xbf]|[\xe0-\xff][\x80-\xbf]{2}/g,
        function(s) {
          var code;
          if (s.length == 2) {
            code = (s.charCodeAt(0) & 31) << 6 | s.charCodeAt(1) & 63;
          } else {
            code = (s.charCodeAt(0) & 15) << 12 | (s.charCodeAt(1) & 63) << 6 | s.charCodeAt(2) & 63;
          }
          return String.fromCharCode(code);
        }
      );
    };
    BWIPJS2.prototype.show = function(str, dx, dy) {
      if (!str.length) {
        return;
      }
      var tsx = this.g_tsx;
      var tsy = this.g_tsy;
      var name = this.g_font.FontName || "OCR-B";
      var size = this.g_font.FontSize || 10;
      var szx = size * tsx;
      var szy = size * tsy;
      var posx = this.g_posx;
      var posy = this.g_posy;
      var rgb2 = this.getRGB();
      str = this.toUCS2(this.jsstring(str));
      dx = tsx * dx || 0;
      dy = tsy * dy || 0;
      var base = posy + dy;
      var bbox = this.drawing.measure(str, name, szx, szy);
      var width = bbox.width + (str.length - 1) * dx;
      this.bbox(posx, base - bbox.descent + 1, posx + width - 1, base + bbox.ascent);
      this.g_posx += width;
      var self = this;
      self.cmds.push(function() {
        var x = posx - self.minx;
        var y = self.maxy - posy;
        self.drawing.text(x, y, str, rgb2, { name, width: szx, height: szy, dx });
      });
    };
    BWIPJS2.prototype.bbox = function(x0, y0, x1, y1) {
      if (x0 > x1) {
        var t = x0;
        x0 = x1;
        x1 = t;
      }
      if (y0 > y1) {
        var t = y0;
        y0 = y1;
        y1 = t;
      }
      x0 = floor(x0);
      y0 = floor(y0);
      x1 = ceil(x1);
      y1 = ceil(y1);
      if (this.minx > x0)
        this.minx = x0;
      if (this.maxx < x1)
        this.maxx = x1;
      if (this.miny > y0)
        this.miny = y0;
      if (this.maxy < y1)
        this.maxy = y1;
    };
    BWIPJS2.prototype.render = function() {
      if (this.minx === Infinity) {
        return new Promise(function(resolve, reject) {
          resolve(null);
        });
      }
      this.drawing.init(
        this.maxx - this.minx + 1,
        this.maxy - this.miny + 1,
        this.g_tsx,
        this.g_tsy
      );
      for (var i = 0, l = this.cmds.length; i < l; i++) {
        this.cmds[i]();
      }
      return this.drawing.end();
    };
    return BWIPJS2;
  }();
  function DrawingBuiltin(opts) {
    var floor = Math.floor;
    var tx0 = 0, tx1 = 0, tx2 = 0, tx3 = 0;
    var ty0 = 0, ty1 = 0, ty2 = 0, ty3 = 0;
    var gs_image, gs_rowbyte;
    var gs_width, gs_height;
    var gs_dx, gs_dy;
    var gs_r, gs_g, gs_b;
    var gs_xymap;
    var gs_xyclip;
    return {
      // Ensure compliant bar codes by always using integer scaling factors.
      scale: function(sx2, sy2) {
        if (opts.bcid == "swissqrcode") {
          return [sx2, sy2];
        } else {
          return [sx2 | 0 || 1, sy2 | 0 || 1];
        }
      },
      // Measure text.  This and scale() are the only drawing primitives that
      // are called before init().
      //
      // `font` is the font name typically OCR-A or OCR-B.
      // `fwidth` and `fheight` are the requested font cell size.  They will
      // usually be the same, except when the scaling is not symetric.
      measure: function(str, font, fwidth, fheight) {
        fwidth = fwidth | 0;
        fheight = fheight | 0;
        var fontid = FontLib.lookup(font);
        var width = 0;
        var ascent = 0;
        var descent = 0;
        for (var i = 0, l = str.length; i < l; i++) {
          var ch = str.charCodeAt(i);
          var glyph = FontLib.getglyph(fontid, ch, fwidth, fheight);
          ascent = Math.max(ascent, glyph.top);
          descent = Math.max(descent, glyph.height - glyph.top);
          if (i == l - 1) {
            width += glyph.left + glyph.width;
          } else {
            width += glyph.advance;
          }
        }
        return { width, ascent, descent };
      },
      // width and height represent the maximum bounding box the graphics will occupy.
      // The dimensions are for an unrotated rendering.  Adjust as necessary.
      init: function(width, height) {
        var padl = opts.paddingleft;
        var padr = opts.paddingright;
        var padt = opts.paddingtop;
        var padb = opts.paddingbottom;
        var rot = opts.rotate || "N";
        width += padl + padr;
        height += padt + padb;
        if (+opts.sizelimit && +opts.sizelimit < width * height) {
          throw new Error("Image size over limit");
        }
        switch (rot) {
          case "R":
            tx1 = -1;
            tx2 = 1;
            ty0 = 1;
            break;
          case "I":
            tx0 = -1;
            tx2 = 1;
            ty1 = -1;
            ty3 = 1;
            break;
          case "L":
            tx1 = 1;
            ty0 = -1;
            ty3 = 1;
            break;
          default:
            tx0 = ty1 = 1;
            break;
        }
        var swap = rot == "L" || rot == "R";
        gs_width = swap ? height : width;
        gs_height = swap ? width : height;
        gs_dx = padl;
        gs_dy = padt;
        gs_xymap = [];
        gs_xymap.min = Infinity;
        gs_xyclip = null;
        gs_r = gs_g = gs_b = 0;
        var res = this.image(gs_width, gs_height);
        gs_image = res.buffer;
        gs_rowbyte = res.ispng ? 1 : 0;
      },
      // Unconnected stroked lines are used to draw the bars in linear barcodes;
      // and the border around a linear barcode (e.g. ITF-14)
      // No line cap should be applied.  These lines are always orthogonal.
      line: function(x0, y0, x1, y1, lw, rgb2) {
        x0 = x0 | 0;
        y0 = y0 | 0;
        x1 = x1 | 0;
        y1 = y1 | 0;
        lw = Math.round(lw) || 1;
        if (y1 < y0) {
          var t = y0;
          y0 = y1;
          y1 = t;
        }
        if (x1 < x0) {
          var t = x0;
          x0 = x1;
          x1 = t;
        }
        gs_r = parseInt(rgb2.substr(0, 2), 16);
        gs_g = parseInt(rgb2.substr(2, 2), 16);
        gs_b = parseInt(rgb2.substr(4, 2), 16);
        var w2 = lw / 2 | 0;
        if (x0 == x1) {
          x0 = x0 - lw + w2;
          x1 = x1 + w2 - 1;
        } else {
          y0 = y0 - w2;
          y1 = y1 + lw - w2 - 1;
        }
        for (var y = y0; y <= y1; y++) {
          for (var x = x0; x <= x1; x++) {
            set(x, y, 255);
          }
        }
      },
      // Polygons are used to draw the connected regions in a 2d barcode.
      // These will always be unstroked, filled, orthogonal shapes.
      // 
      // You will see a series of polygon() calls, followed by a fill().
      polygon: function(pts) {
        var npts = pts.length;
        for (var j = npts - 1, i = 0; i < npts; j = i++) {
          if (pts[j][0] == pts[i][0]) {
            var xj = pts[j][0] | 0;
            var yj = pts[j][1] | 0;
            var yi = pts[i][1] | 0;
            if (yj > yi) {
              for (var y = yi + 1; y < yj; y++) {
                addPoint(xj, y);
              }
            } else {
              for (var y = yj + 1; y < yi; y++) {
                addPoint(xj, y);
              }
            }
          } else {
            var xj = pts[j][0] | 0;
            var xi = pts[i][0] | 0;
            var yj = pts[j][1] | 0;
            if (xj < xi) {
              var yl = pts[j == 0 ? npts - 1 : j - 1][1];
              var yr = pts[i == npts - 1 ? 0 : i + 1][1];
              if (yl > yj) {
                addPoint(xj, yj);
              }
              if (yr > yj) {
                addPoint(xi, yj);
              }
            } else {
              var yl = pts[i == npts - 1 ? 0 : i + 1][1];
              var yr = pts[j == 0 ? npts - 1 : j - 1][1];
              if (yl > yj) {
                addPoint(xi, yj);
              }
              if (yr > yj) {
                addPoint(xj, yj);
              }
            }
          }
        }
      },
      // An unstroked, filled hexagon used by maxicode.  You can choose to fill
      // each individually, or wait for the final fill().
      //
      // The hexagon is drawn from the top, counter-clockwise.
      //
      // The X-coordinate for the top and bottom points on the hexagon is always
      // .5 pixels.  We draw our hexagons with a 2 pixel flat top.
      //
      // All other points of the polygon/hexagon are guaranteed to be integer values.
      hexagon: function(pts, rgb2) {
        var x = pts[0][0] | 0;
        var y = pts[0][1] | 0;
        var qh = pts[1][1] - pts[0][1] | 0;
        var vh = pts[2][1] - pts[1][1] - 1 | 0;
        var xl = pts[2][0] | 0;
        var xr = pts[4][0] | 0;
        gs_r = parseInt(rgb2.substr(0, 2), 16);
        gs_g = parseInt(rgb2.substr(2, 2), 16);
        gs_b = parseInt(rgb2.substr(4, 2), 16);
        fillSegment(x, x + 1, y++);
        for (var k = 1; k < qh; k++) {
          fillSegment(x - 2 * k, x + 1 + 2 * k, y++);
        }
        for (var k = 0; k <= vh; k++) {
          fillSegment(xl, xr, y++);
        }
        for (var k = qh - 1; k >= 1; k--) {
          fillSegment(x - 2 * k, x + 1 + 2 * k, y++);
        }
        fillSegment(x, x + 1, y);
      },
      // An unstroked, filled ellipse.  Used by dotcode and maxicode at present.
      // maxicode issues pairs of ellipse calls (one cw, one ccw) followed by a fill()
      // to create the bullseye rings.  dotcode issues all of its ellipses then a
      // fill().
      ellipse: function(x, y, rx, ry, ccw) {
        drawEllipse2(x - rx | 0, y - ry | 0, x + rx | 0, y + ry | 0, ccw);
      },
      // PostScript's default fill rule is non-zero but since there are never
      // intersecting regions, we use the easier to implement even-odd.
      fill: function(rgb2) {
        gs_r = parseInt(rgb2.substr(0, 2), 16);
        gs_g = parseInt(rgb2.substr(2, 2), 16);
        gs_b = parseInt(rgb2.substr(4, 2), 16);
        evenodd();
        gs_xymap = [];
        gs_xymap.min = Infinity;
      },
      // Currently only used by swissqrcode.  The `polys` area is an array of
      // arrays of points.  Each array of points is identical to the `pts`
      // parameter passed to polygon().  The postscript default clipping rule,
      // like the fill rule, is even-odd winding.
      clip: function(polys) {
        if (!gs_xyclip) {
          gs_xyclip = [];
          gs_xyclip.min = Infinity;
        }
        var xymap = gs_xymap;
        gs_xymap = gs_xyclip;
        for (var i = 0, l = polys.length; i < l; i++) {
          this.polygon(polys[i]);
        }
        gs_xymap = xymap;
      },
      unclip: function() {
        gs_xyclip = null;
      },
      // Draw text with optional inter-character spacing.  `y` is the baseline.
      // font is an object with properties { name, width, height, dx }
      // width and height are the font cell size.
      // dx is extra space requested between characters (usually zero).
      text: function(x, y, str, rgb2, font) {
        x = x | 0;
        y = y | 0;
        gs_r = parseInt(rgb2.substr(0, 2), 16);
        gs_g = parseInt(rgb2.substr(2, 2), 16);
        gs_b = parseInt(rgb2.substr(4, 2), 16);
        var fontid = FontLib.lookup(font.name);
        var fwidth = font.width | 0;
        var fheight = font.height | 0;
        var dx = font.dx | 0;
        for (var k = 0; k < str.length; k++) {
          var ch = str.charCodeAt(k);
          var glyph = FontLib.getglyph(fontid, ch, fwidth, fheight);
          var gt = y - glyph.top;
          var gl = glyph.left;
          var gw = glyph.width;
          var gh = glyph.height;
          var gb = glyph.bytes;
          var go = glyph.offset;
          for (var i = 0; i < gw; i++) {
            for (var j = 0; j < gh; j++) {
              var a = gb[go + j * gw + i];
              if (a) {
                set(x + gl + i, gt + j, a);
              }
            }
          }
          x += glyph.advance + dx;
        }
      },
      // Called after all drawing is complete.
      end: function() {
      }
    };
    function set(x, y, a) {
      if (gs_xyclip && clipped(x, y)) {
        return;
      }
      x += gs_dx;
      y += gs_dy;
      var tx = tx0 * x + tx1 * y + tx2 * (gs_width - 1) + tx3 * (gs_height - 1);
      var ty = ty0 * x + ty1 * y + ty2 * (gs_width - 1) + ty3 * (gs_height - 1);
      var offs = (ty * gs_width + tx) * 4 + (ty + 1) * gs_rowbyte;
      var dsta = gs_image[offs + 3] / 255;
      var srca = a / 255;
      var inva = (1 - srca) * dsta;
      var outa = srca + inva;
      gs_image[offs + 0] = (gs_r * srca + gs_image[offs + 0] * inva) / outa | 0;
      gs_image[offs + 1] = (gs_g * srca + gs_image[offs + 1] * inva) / outa | 0;
      gs_image[offs + 2] = (gs_b * srca + gs_image[offs + 2] * inva) / outa | 0;
      gs_image[offs + 3] = 255 * outa | 0;
    }
    function addPoint(x, y) {
      if (gs_xymap.min > y)
        gs_xymap.min = y;
      if (!gs_xymap[y]) {
        gs_xymap[y] = [x];
      } else {
        gs_xymap[y].push(x);
      }
    }
    function fillSegment(x0, x1, y) {
      while (x0 <= x1) {
        set(x0++, y, 255);
      }
    }
    function evenodd() {
      var ymin = gs_xymap.min;
      var ymax = gs_xymap.length - 1;
      for (var y = ymin; y <= ymax; y++) {
        var pts = gs_xymap[y];
        if (!pts) {
          continue;
        }
        pts.sort(function(a, b) {
          return a - b;
        });
        var wn = false;
        var xl = 0;
        for (var n = 0, npts = pts.length; n < npts; n++) {
          var x = pts[n];
          if (wn) {
            fillSegment(xl, x - 1, y);
          } else {
            xl = x;
          }
          wn = !wn;
        }
      }
    }
    function drawEllipse2(x0, y0, x1, y1, dir) {
      x0 = x0 | 0;
      y0 = y0 | 0;
      x1 = x1 | 0;
      y1 = y1 | 0;
      var a = Math.abs(x1 - x0);
      var b = Math.abs(y1 - y0);
      var b1 = b & 1;
      var dx = 4 * (1 - a) * b * b;
      var dy = 4 * (b1 + 1) * a * a;
      var err = dx + dy + b1 * a * a;
      var e2;
      var left = [], right = [];
      left.min = right.min = Infinity;
      if (x0 > x1) {
        x0 = x1;
        x1 += a;
      }
      if (y0 > y1)
        y0 = y1;
      y0 += (b + 1) / 2 | 0;
      y1 = y0 - b1;
      a *= 8 * a;
      b1 = 8 * b * b;
      do {
        maxedge(right, x1, y0);
        minedge(left, x0, y0);
        minedge(left, x0, y1);
        maxedge(right, x1, y1);
        e2 = 2 * err;
        if (e2 >= dx) {
          x0++;
          x1--;
          dx += b1;
          err += dx;
        }
        if (e2 <= dy) {
          y0++;
          y1--;
          dy += a;
          err += dy;
        }
      } while (x0 <= x1);
      while (y0 - y1 < b) {
        maxedge(right, x1 + 1, y0);
        minedge(left, x0 - 1, y0++);
        minedge(left, x0 - 1, y1);
        maxedge(right, x1 + 1, y1--);
      }
      for (var y = left.min, max = left.length - 1; y <= max; y++) {
        addPoint(left[y], y);
      }
      for (var y = right.min, max = right.length - 1; y <= max; y++) {
        addPoint(right[y] + 1, y);
      }
      function minedge(e, x, y2) {
        if (e.min > y2)
          e.min = y2;
        var ey = e[y2];
        if (ey == null || ey > x) {
          e[y2] = x;
        }
      }
      function maxedge(e, x, y2) {
        if (e.min > y2)
          e.min = y2;
        var ey = e[y2];
        if (ey == null || ey < x) {
          e[y2] = x;
        }
      }
    }
    function clipped(x, y) {
      var pts = gs_xyclip[y];
      if (!pts) {
        return true;
      }
      if (!pts.sorted) {
        pts.sort(function(a, b) {
          return a - b;
        });
        pts.sorted = true;
      }
      var wn = false;
      for (var n = 0, npts = pts.length; n < npts; n++) {
        var xn = pts[n];
        if (xn > x) {
          return !wn;
        } else if (xn == x) {
          return wn;
        }
        wn = !wn;
      }
      return true;
    }
    function polydir(pts) {
      var xp = 0;
      for (var i = 0, l = pts.length, j = l - 1; i < l; j = i++) {
        xp += pts[j][0] * pts[i][1] - pts[i][0] * pts[j][1];
      }
      return xp > 0 ? 1 : -1;
    }
  }
  function DrawingCanvas(opts, canvas) {
    if (typeof window == null) {
      throw new Error("DrawingCanvas: not a browser");
    }
    var img;
    var ctx = canvas.getContext("2d", { willReadFrequently: true });
    var drawing = DrawingBuiltin(opts);
    drawing.image = image;
    drawing.end = end;
    return drawing;
    function image(width, height) {
      canvas.width = width;
      canvas.height = height;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      if (/^[0-9a-fA-F]{6}$/.test("" + opts.backgroundcolor)) {
        ctx.fillStyle = "#" + opts.backgroundcolor;
        ctx.fillRect(0, 0, width, height);
      } else {
        ctx.clearRect(0, 0, width, height);
      }
      img = ctx.getImageData(0, 0, width, height);
      return { buffer: img.data, ispng: false };
    }
    function end() {
      ctx.putImageData(img, 0, 0);
    }
  }
  var FontLib = function() {
    var fonts = [];
    var names = {};
    var glyphcache = {};
    var glyphmru = {};
    var glyphcount = 0;
    glyphmru.next = glyphmru;
    glyphmru.prev = glyphmru;
    return {
      lookup: lookup4,
      monochrome,
      getglyph,
      getpaths,
      loadFont
    };
    function loadFont(name) {
      var multx = 100;
      var multy = 100;
      var data = null;
      if (arguments.length == 2) {
        data = arguments[1];
      } else if (arguments.length == 3) {
        multx = multy = +arguments[1] || 100;
        data = arguments[2];
      } else if (arguments.length == 4) {
        multy = +arguments[1] || 100;
        multx = +arguments[2] || 100;
        data = arguments[3];
      } else {
        throw new Error("loadFont(): invalid number of arguments");
      }
      var font = STBTT.InitFont(toUint8Array2(data));
      font.bwipjs_name = name;
      font.bwipjs_multx = multx;
      font.bwipjs_multy = multy;
      var fontid = fonts.push(font) - 1;
      names[name.toUpperCase()] = fontid;
      return fontid;
    }
    function lookup4(name) {
      var fontid = names[name.toUpperCase()];
      return fontid === void 0 ? 1 : fontid;
    }
    function monochrome(mono) {
      if (mono) {
        throw new Error("fontlib: monochrome not implemented");
      }
    }
    function getglyph(fontid, charcode, width, height) {
      fontid = fontid | 0;
      charcode = charcode | 0;
      width = +width;
      height = +height;
      if (!width || width < 8) {
        width = 8;
      }
      if (!height || height < 8) {
        height = width;
      }
      if (fontid < 0 || fontid >= fonts.length) {
        fontid = 1;
      }
      if (!charcode || charcode < 32) {
        charcode = 32;
      }
      var cachekey = "" + fontid + "c" + charcode + "w" + width + "h" + height;
      var glyph = glyphcache[cachekey];
      if (glyph) {
        glyph.prev.next = glyph.next;
        glyph.next.prev = glyph.prev;
        var sntl = glyphmru;
        sntl.next.prev = glyph;
        glyph.next = sntl.next;
        glyph.prev = sntl;
        sntl.next = glyph;
        return glyph;
      }
      var font = fonts[fontid];
      var glyph = STBTT.GetGlyph(
        font,
        charcode,
        width * font.bwipjs_multx / 100,
        height * font.bwipjs_multy / 100
      ) || STBTT.GetGlyph(
        font,
        0,
        width * font.bwipjs_multx / 100,
        height * font.bwipjs_multy / 100
      );
      glyph.bytes = glyph.pixels;
      glyph.cachekey = cachekey;
      glyph.offset = 0;
      if (glyphcount > 250) {
        var sntl = glyphmru;
        var temp = sntl.prev;
        temp.prev.next = sntl;
        sntl.prev = temp.prev;
        temp.next = temp.prev = null;
        delete glyphcache[temp.cachekey];
      } else {
        glyphcount++;
      }
      glyphcache[cachekey] = glyph;
      var sntl = glyphmru;
      sntl.next.prev = glyph;
      glyph.next = sntl.next;
      glyph.prev = sntl;
      sntl.next = glyph;
      return glyph;
    }
    function getpaths(fontid, charcode, width, height) {
      fontid = fontid | 0;
      charcode = charcode | 0;
      width = +width;
      height = +height;
      if (!width || width < 8) {
        width = 8;
      }
      if (!height || height < 8) {
        height = width;
      }
      if (fontid < 0 || fontid >= fonts.length) {
        fontid = 1;
      }
      if (!charcode || charcode < 32) {
        charcode = 32;
      }
      var font = fonts[fontid];
      return STBTT.GetPaths(
        font,
        charcode,
        width * font.bwipjs_multx / 100,
        height * font.bwipjs_multy / 100
      );
    }
  }();
  var STBTT = function() {
    var STBTT_vmove = 1, STBTT_vline = 2, STBTT_vcurve = 3, STBTT_vcubic = 4, STBTT_PLATFORM_ID_UNICODE = 0, STBTT_PLATFORM_ID_MAC = 1, STBTT_PLATFORM_ID_ISO = 2, STBTT_PLATFORM_ID_MICROSOFT = 3, STBTT_UNICODE_EID_UNICODE_1_0 = 0, STBTT_UNICODE_EID_UNICODE_1_1 = 1, STBTT_UNICODE_EID_ISO_10646 = 2, STBTT_UNICODE_EID_UNICODE_2_0_BMP = 3, STBTT_UNICODE_EID_UNICODE_2_0_FULL = 4, STBTT_MS_EID_SYMBOL = 0, STBTT_MS_EID_UNICODE_BMP = 1, STBTT_MS_EID_SHIFTJIS = 2, STBTT_MS_EID_UNICODE_FULL = 10;
    var floor = Math.floor;
    var ceil = Math.ceil;
    var sqrt = Math.sqrt;
    var abs = Math.abs;
    function oalloc(n) {
      var o = [];
      for (var i = 0; i < n; i++) {
        o.push({});
      }
      return o;
    }
    function stbtt__buf_get8(b) {
      return b[b.cursor++] || 0;
    }
    function stbtt__buf_peek8(b) {
      return b[b.cursor];
    }
    function stbtt__buf_seek(b, o) {
      b.cursor = o > b.length || o < 0 ? b.length : o;
    }
    function stbtt__buf_skip(b, o) {
      stbtt__buf_seek(b, b.cursor + o);
    }
    function stbtt__buf_get(b, n) {
      var v = 0;
      for (var i = 0; i < n; i++) {
        v = v << 8 | stbtt__buf_get8(b);
      }
      return v;
    }
    function stbtt__null_buf() {
      return { length: 0 };
    }
    function stbtt__buf_range(b, o, s) {
      if (o < 0 || s < 0 || o > b.length || s > b.length - o) {
        return stbtt__null_buf();
      }
      var r = b.subarray(o, o + s);
      r.cursor = 0;
      return r;
    }
    function stbtt__cff_get_index(b) {
      var start = b.cursor;
      var count = stbtt__buf_get(b, 2);
      if (count) {
        var offsize = stbtt__buf_get8(b);
        stbtt__buf_skip(b, offsize * count);
        stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
      }
      return stbtt__buf_range(b, start, b.cursor - start);
    }
    function stbtt__cff_int(b) {
      var b0 = stbtt__buf_get8(b);
      if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
      } else if (b0 >= 247 && b0 <= 250) {
        return (b0 - 247) * 256 + stbtt__buf_get8(b) + 108;
      } else if (b0 >= 251 && b0 <= 254) {
        return -(b0 - 251) * 256 - stbtt__buf_get8(b) - 108;
      } else if (b0 == 28) {
        return stbtt__buf_get(b, 2);
      } else if (b0 == 29) {
        return stbtt__buf_get(b, 4);
      }
      return 0;
    }
    function stbtt__cff_skip_operand(b) {
      var b0 = stbtt__buf_peek8(b);
      if (b0 == 30) {
        stbtt__buf_skip(b, 1);
        while (b.cursor < b.length) {
          var v = stbtt__buf_get8(b);
          if ((v & 15) == 15 || v >> 4 == 15) {
            break;
          }
        }
      } else {
        stbtt__cff_int(b);
      }
    }
    function stbtt__dict_get(b, key) {
      stbtt__buf_seek(b, 0);
      while (b.cursor < b.length) {
        var start = b.cursor, end, op;
        while (stbtt__buf_peek8(b) >= 28) {
          stbtt__cff_skip_operand(b);
        }
        end = b.cursor;
        op = stbtt__buf_get8(b);
        if (op == 12) {
          op = stbtt__buf_get8(b) | 256;
        }
        if (op == key) {
          return stbtt__buf_range(b, start, end - start);
        }
      }
      return stbtt__buf_range(b, 0, 0);
    }
    function stbtt__dict_get_ints(b, key, outcount, out) {
      var operands = stbtt__dict_get(b, key);
      for (var i = 0; i < outcount && operands.cursor < operands.length; i++) {
        out[i] = stbtt__cff_int(operands);
      }
    }
    function stbtt__dict_get_int(b, key, out) {
      var operands = stbtt__dict_get(b, key);
      if (operands.cursor < operands.length) {
        out = stbtt__cff_int(operands);
      }
      return out;
    }
    function stbtt__cff_index_count(b) {
      stbtt__buf_seek(b, 0);
      return stbtt__buf_get(b, 2);
    }
    function stbtt__cff_index_get(b, i) {
      var count, offsize, start, end;
      stbtt__buf_seek(b, 0);
      count = stbtt__buf_get(b, 2);
      offsize = stbtt__buf_get8(b);
      stbtt__buf_skip(b, i * offsize);
      start = stbtt__buf_get(b, offsize);
      end = stbtt__buf_get(b, offsize);
      return stbtt__buf_range(b, 2 + (count + 1) * offsize + start, end - start);
    }
    function INT16(n) {
      return n & 32768 ? (4294901760 | n) >> 0 : n;
    }
    function ttUSHORT(b, o) {
      return b[o] * 256 + b[o + 1];
    }
    function ttSHORT(b, o) {
      var n = b[o] * 256 + b[o + 1];
      return n & 32768 ? (4294901760 | n) >> 0 : n;
    }
    function ttULONG(b, o) {
      return (b[o] << 24) + (b[o + 1] << 16) + (b[o + 2] << 8) + b[o + 3];
    }
    function stbtt__find_table(data, fontstart, tag) {
      var num_tables = ttUSHORT(data, fontstart + 4);
      var tabledir = fontstart + 12;
      for (var i = 0; i < num_tables; ++i) {
        var loc = tabledir + 16 * i;
        if (data[loc] == tag[0] && data[loc + 1] == tag[1] && data[loc + 2] == tag[2] && data[loc + 3] == tag[3]) {
          return ttULONG(data, loc + 8);
        }
      }
      return 0;
    }
    function stbtt__get_subrs(cff, fontdict) {
      var private_loc = [0, 0];
      stbtt__dict_get_ints(fontdict, 18, 2, private_loc);
      if (!private_loc[1] || !private_loc[0]) {
        return stbtt__null_buf();
      }
      var pdict = stbtt__buf_range(cff, private_loc[1], private_loc[0]);
      var subrsoff = stbtt__dict_get_int(pdict, 19, 0);
      if (!subrsoff) {
        return stbtt__null_buf();
      }
      stbtt__buf_seek(cff, private_loc[1] + subrsoff);
      return stbtt__cff_get_index(cff);
    }
    function stbtt_InitFont_internal(info, data, fontstart) {
      var cmap, t, i, numTables;
      info.data = data;
      info.fontstart = fontstart;
      info.cff = stbtt__null_buf();
      cmap = stbtt__find_table(data, fontstart, [99, 109, 97, 112]);
      info.loca = stbtt__find_table(data, fontstart, [108, 111, 99, 97]);
      info.head = stbtt__find_table(data, fontstart, [104, 101, 97, 100]);
      info.glyf = stbtt__find_table(data, fontstart, [103, 108, 121, 102]);
      info.hhea = stbtt__find_table(data, fontstart, [104, 104, 101, 97]);
      info.hmtx = stbtt__find_table(data, fontstart, [104, 109, 116, 120]);
      info.kern = stbtt__find_table(data, fontstart, [107, 101, 114, 110]);
      if (!cmap || !info.head || !info.hhea || !info.hmtx) {
        return 0;
      }
      if (info.glyf) {
        if (!info.loca) {
          return 0;
        }
      } else {
        var b, topdict, topdictidx, cff, cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
        cff = stbtt__find_table(data, fontstart, [67, 70, 70, 32]);
        if (!cff) {
          return 0;
        }
        info.fontdicts = stbtt__null_buf();
        info.fdselect = stbtt__null_buf();
        info.cff = data.subarray(cff);
        info.cff.cursor = 0;
        b = info.cff;
        stbtt__buf_skip(b, 2);
        stbtt__buf_seek(b, stbtt__buf_get8(b));
        stbtt__cff_get_index(b);
        topdictidx = stbtt__cff_get_index(b);
        topdict = stbtt__cff_index_get(topdictidx, 0);
        stbtt__cff_get_index(b);
        info.gsubrs = stbtt__cff_get_index(b);
        charstrings = stbtt__dict_get_int(topdict, 17, charstrings);
        cstype = stbtt__dict_get_int(topdict, 256 | 6, cstype);
        fdarrayoff = stbtt__dict_get_int(topdict, 256 | 36, fdarrayoff);
        fdselectoff = stbtt__dict_get_int(topdict, 256 | 37, fdselectoff);
        info.subrs = stbtt__get_subrs(b, topdict);
        if (cstype != 2) {
          return 0;
        }
        if (charstrings == 0) {
          return 0;
        }
        if (fdarrayoff) {
          if (!fdselectoff) {
            return 0;
          }
          stbtt__buf_seek(b, fdarrayoff);
          info.fontdicts = stbtt__cff_get_index(b);
          info.fdselect = stbtt__buf_range(b, fdselectoff, b.length - fdselectoff);
        }
        stbtt__buf_seek(b, charstrings);
        info.charstrings = stbtt__cff_get_index(b);
      }
      t = stbtt__find_table(data, fontstart, [109, 97, 120, 112]);
      if (t) {
        info.numGlyphs = ttUSHORT(data, t + 4);
      } else {
        info.numGlyphs = 65535;
      }
      numTables = ttUSHORT(data, cmap + 2);
      info.index_map = 0;
      for (i = 0; i < numTables; ++i) {
        var encoding_record = cmap + 4 + 8 * i;
        switch (ttUSHORT(data, encoding_record)) {
          case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data, encoding_record + 2)) {
              case STBTT_MS_EID_UNICODE_BMP:
              case STBTT_MS_EID_UNICODE_FULL:
                info.index_map = cmap + ttULONG(data, encoding_record + 4);
                break;
            }
            break;
          case STBTT_PLATFORM_ID_UNICODE:
            info.index_map = cmap + ttULONG(data, encoding_record + 4);
            break;
        }
      }
      if (info.index_map == 0) {
        return 0;
      }
      info.indexToLocFormat = ttUSHORT(data, info.head + 50);
      return 1;
    }
    function stbtt_FindGlyphIndex(info, unicode_codepoint) {
      var data = info.data, index_map = info.index_map;
      var format = ttUSHORT(data, index_map + 0);
      if (format == 0) {
        var bytes = ttUSHORT(data, index_map + 2);
        if (unicode_codepoint < bytes - 6) {
          return data[index_map + 6 + unicode_codepoint];
        }
        return 0;
      } else if (format == 6) {
        var first = ttUSHORT(data, index_map + 6), count = ttUSHORT(data, index_map + 8);
        if (unicode_codepoint >= first && unicode_codepoint < first + count) {
          return ttUSHORT(data, index_map + 10 + (unicode_codepoint - first) * 2);
        }
        return 0;
      } else if (format == 2) {
        return 0;
      } else if (format == 4) {
        var segcount = ttUSHORT(data, index_map + 6) >> 1, searchRange = ttUSHORT(data, index_map + 8) >> 1, entrySelector = ttUSHORT(data, index_map + 10), rangeShift = ttUSHORT(data, index_map + 12) >> 1, endCount = index_map + 14, search = endCount;
        if (unicode_codepoint > 65535) {
          return 0;
        }
        if (unicode_codepoint >= ttUSHORT(data, search + rangeShift * 2)) {
          search += rangeShift * 2;
        }
        search -= 2;
        while (entrySelector) {
          searchRange >>= 1;
          var end = ttUSHORT(data, search + searchRange * 2);
          if (unicode_codepoint > end) {
            search += searchRange * 2;
          }
          --entrySelector;
        }
        search += 2;
        var offset, start, item = search - endCount >>> 1;
        start = ttUSHORT(data, index_map + 14 + segcount * 2 + 2 + 2 * item);
        if (unicode_codepoint < start) {
          return 0;
        }
        offset = ttUSHORT(data, index_map + 14 + segcount * 6 + 2 + 2 * item);
        if (offset == 0) {
          return unicode_codepoint + ttSHORT(data, index_map + 14 + segcount * 4 + 2 + 2 * item);
        }
        return ttUSHORT(data, offset + (unicode_codepoint - start) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item);
      } else if (format == 12 || format == 13) {
        var ngroups = ttULONG(data, index_map + 12), low = 0, high = ngroups;
        while (low < high) {
          var mid = low + (high - low >> 1);
          var start_char = ttULONG(data, index_map + 16 + mid * 12);
          var end_char = ttULONG(data, index_map + 16 + mid * 12 + 4);
          if (unicode_codepoint < start_char) {
            high = mid;
          } else if (unicode_codepoint > end_char) {
            low = mid + 1;
          } else {
            var start_glyph = ttULONG(data, index_map + 16 + mid * 12 + 8);
            if (format == 12) {
              return start_glyph + unicode_codepoint - start_char;
            } else {
              return start_glyph;
            }
          }
        }
        return 0;
      }
      return 0;
    }
    function stbtt_setvertex(v, type, x, y, cx2, cy2) {
      v.type = type;
      v.x = x;
      v.y = y;
      v.cx = cx2;
      v.cy = cy2;
    }
    function stbtt__GetGlyfOffset(info, glyph_index) {
      var g1, g2;
      if (glyph_index >= info.numGlyphs) {
        return -1;
      }
      if (info.indexToLocFormat >= 2) {
        return -1;
      }
      if (info.indexToLocFormat == 0) {
        g1 = info.glyf + ttUSHORT(info.data, info.loca + glyph_index * 2) * 2;
        g2 = info.glyf + ttUSHORT(info.data, info.loca + glyph_index * 2 + 2) * 2;
      } else {
        g1 = info.glyf + ttULONG(info.data, info.loca + glyph_index * 4);
        g2 = info.glyf + ttULONG(info.data, info.loca + glyph_index * 4 + 4);
      }
      return g1 == g2 ? -1 : g1;
    }
    function stbtt_GetGlyphBox(info, glyph_index, out) {
      if (info.cff.length) {
        stbtt__GetGlyphInfoT2(info, glyph_index, out);
      } else {
        var g = stbtt__GetGlyfOffset(info, glyph_index);
        if (g < 0) {
          return 0;
        }
        out.x0 = ttSHORT(info.data, g + 2);
        out.y0 = ttSHORT(info.data, g + 4);
        out.x1 = ttSHORT(info.data, g + 6);
        out.y1 = ttSHORT(info.data, g + 8);
      }
      return 1;
    }
    function stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx2, sy2, scx, scy, cx2, cy2) {
      if (start_off) {
        if (was_off) {
          stbtt_setvertex(
            vertices[num_vertices++],
            STBTT_vcurve,
            cx2 + scx >> 1,
            cy2 + scy >> 1,
            cx2,
            cy2
          );
        }
        stbtt_setvertex(vertices[num_vertices++], STBTT_vcurve, sx2, sy2, scx, scy);
      } else {
        if (was_off) {
          stbtt_setvertex(vertices[num_vertices++], STBTT_vcurve, sx2, sy2, cx2, cy2);
        } else {
          stbtt_setvertex(vertices[num_vertices++], STBTT_vline, sx2, sy2, 0, 0);
        }
      }
      return num_vertices;
    }
    function stbtt__GetGlyphShapeTT(info, glyph_index) {
      var data = info.data, g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) {
        return null;
      }
      var vertices = [];
      var numberOfContours = ttSHORT(data, g);
      if (numberOfContours > 0) {
        var flags = 0, flagcount, i, j = 0, m, n, next_move, was_off = 0, off, start_off = 0, x, y, cx2, cy2, sx2, sy2, scx, scy;
        var endPtsOfContours = g + 10;
        var ins = ttUSHORT(data, g + 10 + numberOfContours * 2);
        var points = data.subarray(g + 10 + numberOfContours * 2 + 2 + ins);
        var ptsoff = 0;
        n = 1 + ttUSHORT(data, endPtsOfContours + numberOfContours * 2 - 2);
        m = n + 2 * numberOfContours;
        vertices = oalloc(m);
        next_move = 0;
        flagcount = 0;
        off = m - n;
        for (i = 0; i < n; ++i) {
          if (flagcount == 0) {
            flags = points[ptsoff++];
            if (flags & 8) {
              flagcount = points[ptsoff++];
            }
          } else {
            --flagcount;
          }
          vertices[off + i].type = flags;
        }
        x = 0;
        for (i = 0; i < n; ++i) {
          flags = vertices[off + i].type;
          if (flags & 2) {
            var dx = points[ptsoff++];
            x += flags & 16 ? dx : -dx;
          } else {
            if (!(flags & 16)) {
              x = x + INT16(points[ptsoff] * 256 + points[ptsoff + 1]);
              ptsoff += 2;
            }
          }
          vertices[off + i].x = x;
        }
        y = 0;
        for (i = 0; i < n; ++i) {
          flags = vertices[off + i].type;
          if (flags & 4) {
            var dy = points[ptsoff++];
            y += flags & 32 ? dy : -dy;
          } else {
            if (!(flags & 32)) {
              y = y + INT16(points[ptsoff] * 256 + points[ptsoff + 1]);
              ptsoff += 2;
            }
          }
          vertices[off + i].y = y;
        }
        var num_vertices = 0;
        sx2 = sy2 = cx2 = cy2 = scx = scy = 0;
        for (i = 0; i < n; ++i) {
          flags = vertices[off + i].type;
          x = vertices[off + i].x;
          y = vertices[off + i].y;
          if (next_move == i) {
            if (i != 0) {
              num_vertices = stbtt__close_shape(
                vertices,
                num_vertices,
                was_off,
                start_off,
                sx2,
                sy2,
                scx,
                scy,
                cx2,
                cy2
              );
            }
            start_off = !(flags & 1);
            if (start_off) {
              scx = x;
              scy = y;
              if (!(vertices[off + i + 1].type & 1)) {
                sx2 = x + vertices[off + i + 1].x >> 1;
                sy2 = y + vertices[off + i + 1].y >> 1;
              } else {
                sx2 = vertices[off + i + 1].x;
                sy2 = vertices[off + i + 1].y;
                ++i;
              }
            } else {
              sx2 = x;
              sy2 = y;
            }
            stbtt_setvertex(vertices[num_vertices++], STBTT_vmove, sx2, sy2, 0, 0);
            was_off = 0;
            next_move = 1 + ttUSHORT(data, endPtsOfContours + j * 2);
            ++j;
          } else {
            if (!(flags & 1)) {
              if (was_off) {
                stbtt_setvertex(
                  vertices[num_vertices++],
                  STBTT_vcurve,
                  cx2 + x >> 1,
                  cy2 + y >> 1,
                  cx2,
                  cy2
                );
              }
              cx2 = x;
              cy2 = y;
              was_off = 1;
            } else {
              if (was_off) {
                stbtt_setvertex(vertices[num_vertices++], STBTT_vcurve, x, y, cx2, cy2);
              } else {
                stbtt_setvertex(vertices[num_vertices++], STBTT_vline, x, y, 0, 0);
              }
              was_off = 0;
            }
          }
        }
        vertices.length = stbtt__close_shape(
          vertices,
          num_vertices,
          was_off,
          start_off,
          sx2,
          sy2,
          scx,
          scy,
          cx2,
          cy2
        );
      } else if (numberOfContours == -1) {
        var more = 1;
        var comp = g + 10;
        while (more) {
          var flags, gidx, mtx = [1, 0, 0, 1, 0, 0];
          flags = ttSHORT(data, comp);
          comp += 2;
          gidx = ttSHORT(data, comp);
          comp += 2;
          if (flags & 2) {
            if (flags & 1) {
              mtx[4] = ttSHORT(data, comp);
              comp += 2;
              mtx[5] = ttSHORT(data, comp);
              comp += 2;
            } else {
              mtx[4] = stbtt__buf_get8(data, comp);
              comp += 1;
              mtx[5] = stbtt__buf_get8(data, comp);
              comp += 1;
            }
          }
          if (flags & 1 << 3) {
            mtx[0] = mtx[3] = ttSHORT(data, comp) / 16384;
            comp += 2;
            mtx[1] = mtx[2] = 0;
          } else if (flags & 1 << 6) {
            mtx[0] = ttSHORT(data, comp) / 16384;
            comp += 2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(data, comp) / 16384;
            comp += 2;
          } else if (flags & 1 << 7) {
            mtx[0] = ttSHORT(data, comp) / 16384;
            comp += 2;
            mtx[1] = ttSHORT(data, comp) / 16384;
            comp += 2;
            mtx[2] = ttSHORT(data, comp) / 16384;
            comp += 2;
            mtx[3] = ttSHORT(data, comp) / 16384;
            comp += 2;
          }
          var m = sqrt(mtx[0] * mtx[0] + mtx[1] * mtx[1]);
          var n = sqrt(mtx[2] * mtx[2] + mtx[3] * mtx[3]);
          var comp_verts = stbtt_GetGlyphShape(info, gidx);
          if (comp_verts.length > 0) {
            for (var i = 0, l = comp_verts.length; i < l; ++i) {
              var v = comp_verts[i], x, y;
              x = v.x;
              y = v.y;
              v.x = floor(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
              v.y = floor(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
              x = v.cx;
              y = v.cy;
              v.cx = floor(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
              v.cy = floor(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
            }
            vertices = vertices.concat(comp_verts);
          }
          more = flags & 1 << 5;
        }
      }
      return vertices;
    }
    function stbtt__track_vertex(c, x, y) {
      if (x > c.max_x || !c.started) {
        c.max_x = x;
      }
      if (y > c.max_y || !c.started) {
        c.max_y = y;
      }
      if (x < c.min_x || !c.started) {
        c.min_x = x;
      }
      if (y < c.min_y || !c.started) {
        c.min_y = y;
      }
      c.started = 1;
    }
    function stbtt__csctx_v(c, type, x, y, cx2, cy2, cx1, cy1) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
        stbtt__track_vertex(c, cx2, cy2);
        stbtt__track_vertex(c, cx1, cy1);
      }
      var v = {};
      stbtt_setvertex(v, type, x, y, cx2, cy2);
      v.cx1 = cx1;
      v.cy1 = cy1;
      c.vertices.push(v);
    }
    function stbtt__csctx_close_shape(ctx) {
      if (ctx.first_x != ctx.x || ctx.first_y != ctx.y) {
        stbtt__csctx_v(ctx, STBTT_vline, ctx.first_x, ctx.first_y, 0, 0, 0, 0);
      }
    }
    function stbtt__csctx_rmove_to(ctx, dx, dy) {
      stbtt__csctx_close_shape(ctx);
      ctx.first_x = ctx.x = ctx.x + dx;
      ctx.first_y = ctx.y = ctx.y + dy;
      stbtt__csctx_v(ctx, STBTT_vmove, ctx.x, ctx.y, 0, 0, 0, 0);
    }
    function stbtt__csctx_rline_to(ctx, dx, dy) {
      ctx.x += dx;
      ctx.y += dy;
      stbtt__csctx_v(ctx, STBTT_vline, ctx.x, ctx.y, 0, 0, 0, 0);
    }
    function stbtt__csctx_rccurve_to(ctx, dx1, dy1, dx2, dy2, dx3, dy3) {
      var cx1 = ctx.x + dx1, cy1 = ctx.y + dy1, cx2 = cx1 + dx2, cy2 = cy1 + dy2;
      ctx.x = cx2 + dx3;
      ctx.y = cy2 + dy3;
      stbtt__csctx_v(ctx, STBTT_vcubic, ctx.x, ctx.y, cx1, cy1, cx2, cy2);
    }
    function stbtt__get_subr(b, n) {
      var count = stbtt__cff_index_count(b);
      var bias = 107;
      if (count >= 33900) {
        bias = 32768;
      } else if (count >= 1240) {
        bias = 1131;
      }
      n += bias;
      if (n < 0 || n >= count) {
        return stbtt__null_buf();
      }
      return stbtt__cff_index_get(b, n);
    }
    function stbtt__cid_get_glyph_subrs(info, glyph_index) {
      var fdselect = info.fdselect;
      var nranges, start, end, v, fmt, fdselector = -1, i;
      stbtt__buf_seek(fdselect, 0);
      fmt = stbtt__buf_get8(fdselect);
      if (fmt == 0) {
        stbtt__buf_skip(fdselect, glyph_index);
        fdselector = stbtt__buf_get8(fdselect);
      } else if (fmt == 3) {
        nranges = stbtt__buf_get(fdselect, 2);
        start = stbtt__buf_get(fdselect, 2);
        for (i = 0; i < nranges; i++) {
          v = stbtt__buf_get8(fdselect);
          end = stbtt__buf_get(fdselect, 2);
          if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
          }
          start = end;
        }
      }
      if (fdselector == -1) {
        stbtt__null_buf();
      }
      return stbtt__get_subrs(info.cff, stbtt__cff_index_get(info.fontdicts, fdselector));
    }
    function stbtt__run_charstring(info, glyph_index, c) {
      var in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0, has_subrs = 0, clear_stack, s = [], subr_stack = [], subrs = info.subrs, b, f;
      b = stbtt__cff_index_get(info.charstrings, glyph_index);
      while (b.cursor < b.length) {
        i = 0;
        clear_stack = 1;
        b0 = stbtt__buf_get8(b);
        switch (b0) {
          case 19:
          case 20:
            if (in_header) {
              maskbits += sp / 2 | 0;
            }
            in_header = 0;
            stbtt__buf_skip(b, (maskbits + 7) / 8 | 0);
            break;
          case 1:
          case 3:
          case 18:
          case 23:
            maskbits += sp / 2 | 0;
            break;
          case 21:
            in_header = 0;
            if (sp < 2) {
              return 0;
            }
            stbtt__csctx_rmove_to(c, s[sp - 2], s[sp - 1]);
            break;
          case 4:
            in_header = 0;
            if (sp < 1) {
              return 0;
            }
            stbtt__csctx_rmove_to(c, 0, s[sp - 1]);
            break;
          case 22:
            in_header = 0;
            if (sp < 1) {
              return 0;
            }
            stbtt__csctx_rmove_to(c, s[sp - 1], 0);
            break;
          case 5:
            if (sp < 2) {
              return 0;
            }
            for (; i + 1 < sp; i += 2) {
              stbtt__csctx_rline_to(c, s[i], s[i + 1]);
            }
            break;
          case 7:
            if (sp < 1) {
              return 0;
            }
            for (; ; ) {
              if (i >= sp) {
                break;
              }
              stbtt__csctx_rline_to(c, 0, s[i]);
              i++;
              if (i >= sp) {
                break;
              }
              stbtt__csctx_rline_to(c, s[i], 0);
              i++;
            }
            break;
          case 6:
            if (sp < 1) {
              return 0;
            }
            for (; ; ) {
              if (i >= sp) {
                break;
              }
              stbtt__csctx_rline_to(c, s[i], 0);
              i++;
              if (i >= sp) {
                break;
              }
              stbtt__csctx_rline_to(c, 0, s[i]);
              i++;
            }
            break;
          case 31:
            if (sp < 4) {
              return 0;
            }
            for (; ; ) {
              if (i + 3 >= sp) {
                break;
              }
              stbtt__csctx_rccurve_to(
                c,
                s[i],
                0,
                s[i + 1],
                s[i + 2],
                sp - i == 5 ? s[i + 4] : 0,
                s[i + 3]
              );
              i += 4;
              if (i + 3 >= sp) {
                break;
              }
              stbtt__csctx_rccurve_to(
                c,
                0,
                s[i],
                s[i + 1],
                s[i + 2],
                s[i + 3],
                sp - i == 5 ? s[i + 4] : 0
              );
              i += 4;
            }
            break;
          case 30:
            if (sp < 4) {
              return 0;
            }
            for (; ; ) {
              if (i + 3 >= sp) {
                break;
              }
              stbtt__csctx_rccurve_to(
                c,
                0,
                s[i],
                s[i + 1],
                s[i + 2],
                s[i + 3],
                sp - i == 5 ? s[i + 4] : 0
              );
              i += 4;
              if (i + 3 >= sp) {
                break;
              }
              stbtt__csctx_rccurve_to(
                c,
                s[i],
                0,
                s[i + 1],
                s[i + 2],
                sp - i == 5 ? s[i + 4] : 0,
                s[i + 3]
              );
              i += 4;
            }
            break;
          case 8:
            if (sp < 6) {
              return 0;
            }
            for (; i + 5 < sp; i += 6) {
              stbtt__csctx_rccurve_to(
                c,
                s[i],
                s[i + 1],
                s[i + 2],
                s[i + 3],
                s[i + 4],
                s[i + 5]
              );
            }
            break;
          case 24:
            if (sp < 8) {
              return 0;
            }
            for (; i + 5 < sp - 2; i += 6) {
              stbtt__csctx_rccurve_to(
                c,
                s[i],
                s[i + 1],
                s[i + 2],
                s[i + 3],
                s[i + 4],
                s[i + 5]
              );
            }
            if (i + 1 >= sp) {
              return 0;
            }
            stbtt__csctx_rline_to(c, s[i], s[i + 1]);
            break;
          case 25:
            if (sp < 8) {
              return 0;
            }
            for (; i + 1 < sp - 6; i += 2) {
              stbtt__csctx_rline_to(c, s[i], s[i + 1]);
            }
            if (i + 5 >= sp) {
              return 0;
            }
            stbtt__csctx_rccurve_to(
              c,
              s[i],
              s[i + 1],
              s[i + 2],
              s[i + 3],
              s[i + 4],
              s[i + 5]
            );
            break;
          case 26:
          case 27:
            if (sp < 4) {
              return 0;
            }
            f = 0;
            if (sp & 1) {
              f = s[i];
              i++;
            }
            for (; i + 3 < sp; i += 4) {
              if (b0 == 27) {
                stbtt__csctx_rccurve_to(
                  c,
                  s[i],
                  f,
                  s[i + 1],
                  s[i + 2],
                  s[i + 3],
                  0
                );
              } else {
                stbtt__csctx_rccurve_to(
                  c,
                  f,
                  s[i],
                  s[i + 1],
                  s[i + 2],
                  0,
                  s[i + 3]
                );
              }
              f = 0;
            }
            break;
          case 10:
            if (!has_subrs) {
              if (info.fdselect.length) {
                subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
              }
              has_subrs = 1;
            }
          case 29:
            if (sp < 1) {
              return 0;
            }
            v = s[--sp] | 0;
            if (subr_stack_height >= 10) {
              return 0;
            }
            subr_stack[subr_stack_height++] = b;
            b = stbtt__get_subr(b0 == 10 ? subrs : info.gsubrs, v);
            if (b.length == 0) {
              return 0;
            }
            b.cursor = 0;
            clear_stack = 0;
            break;
          case 11:
            if (subr_stack_height <= 0) {
              return 0;
            }
            b = subr_stack[--subr_stack_height];
            clear_stack = 0;
            break;
          case 14:
            stbtt__csctx_close_shape(c);
            return 1;
          case 12:
            var dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6, dx, dy, b1 = stbtt__buf_get8(b);
            switch (b1) {
              case 34:
                if (sp < 7) {
                  return 0;
                }
                dx1 = s[0];
                dx2 = s[1];
                dy2 = s[2];
                dx3 = s[3];
                dx4 = s[4];
                dx5 = s[5];
                dx6 = s[6];
                stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
                stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
                break;
              case 35:
                if (sp < 13) {
                  return 0;
                }
                dx1 = s[0];
                dy1 = s[1];
                dx2 = s[2];
                dy2 = s[3];
                dx3 = s[4];
                dy3 = s[5];
                dx4 = s[6];
                dy4 = s[7];
                dx5 = s[8];
                dy5 = s[9];
                dx6 = s[10];
                dy6 = s[11];
                stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
                stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
                break;
              case 36:
                if (sp < 9) {
                  return 0;
                }
                dx1 = s[0];
                dy1 = s[1];
                dx2 = s[2];
                dy2 = s[3];
                dx3 = s[4];
                dx4 = s[5];
                dx5 = s[6];
                dy5 = s[7];
                dx6 = s[8];
                stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
                stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1 + dy2 + dy5));
                break;
              case 37:
                if (sp < 11) {
                  return 0;
                }
                dx1 = s[0];
                dy1 = s[1];
                dx2 = s[2];
                dy2 = s[3];
                dx3 = s[4];
                dy3 = s[5];
                dx4 = s[6];
                dy4 = s[7];
                dx5 = s[8];
                dy5 = s[9];
                dx6 = dy6 = s[10];
                dx = dx1 + dx2 + dx3 + dx4 + dx5;
                dy = dy1 + dy2 + dy3 + dy4 + dy5;
                if (abs(dx) > abs(dy)) {
                  dy6 = -dy;
                } else {
                  dx6 = -dx;
                }
                stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
                stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
                break;
              default:
                return 0;
            }
            break;
          default:
            if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254)) {
              return 0;
            }
            if (b0 == 255) {
              f = (stbtt__buf_get(b, 4) | 0) / 65536;
            } else {
              stbtt__buf_skip(b, -1);
              f = (stbtt__cff_int(b) << 16 | 0) >> 16;
            }
            if (sp >= 48) {
              return 0;
            }
            s[sp++] = f;
            clear_stack = 0;
            break;
        }
        if (clear_stack) {
          sp = 0;
        }
      }
      return 0;
    }
    function stbtt__csctx_init() {
      return {
        started: 0,
        first_x: 0,
        first_y: 0,
        x: 0,
        y: 0,
        min_x: 0,
        max_x: 0,
        min_y: 0,
        max_y: 0,
        vertices: []
      };
    }
    function stbtt__GetGlyphShapeT2(info, glyph_index) {
      var output_ctx = stbtt__csctx_init();
      if (stbtt__run_charstring(info, glyph_index, output_ctx)) {
        return output_ctx.vertices;
      }
      return null;
    }
    function stbtt__GetGlyphInfoT2(info, glyph_index, out) {
      var c = stbtt__csctx_init();
      var r = stbtt__run_charstring(info, glyph_index, c);
      out.x0 = r ? c.min_x : 0;
      out.y0 = r ? c.min_y : 0;
      out.x1 = r ? c.max_x : 0;
      out.y1 = r ? c.max_y : 0;
      return r && c.vertices ? c.vertices.length : 0;
    }
    function stbtt_GetGlyphShape(info, glyph_index) {
      if (!info.cff.length) {
        return stbtt__GetGlyphShapeTT(info, glyph_index);
      } else {
        return stbtt__GetGlyphShapeT2(info, glyph_index);
      }
    }
    function stbtt_GetGlyphHMetrics(info, glyph_index) {
      var numOfLongHorMetrics = ttUSHORT(info.data, info.hhea + 34);
      if (glyph_index < numOfLongHorMetrics) {
        return {
          advanceWidth: ttSHORT(info.data, info.hmtx + 4 * glyph_index),
          leftSideBearing: ttSHORT(info.data, info.hmtx + 4 * glyph_index + 2)
        };
      } else {
        return {
          advanceWidth: ttSHORT(info.data, info.hmtx + 4 * (numOfLongHorMetrics - 1)),
          leftSideBearing: ttSHORT(info.data, info.hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics))
        };
      }
    }
    function stbtt_GetCodepointHMetrics(info, codepoint) {
      return stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info, codepoint));
    }
    function stbtt_GetFontVMetrics(info) {
      return {
        ascent: ttSHORT(info.data, info.hhea + 4),
        descent: ttSHORT(info.data, info.hhea + 6),
        linegap: ttSHORT(info.data, info.hhea + 8)
      };
    }
    function stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, shift_x, shift_y) {
      var tmp = {};
      if (!stbtt_GetGlyphBox(font, glyph, tmp)) {
        return { x0: 0, y0: 0, x1: 0, y1: 0 };
      }
      return {
        x0: floor(tmp.x0 * scale_x + shift_x),
        y0: floor(-tmp.y1 * scale_y + shift_y),
        x1: ceil(tmp.x1 * scale_x + shift_x),
        y1: ceil(-tmp.y0 * scale_y + shift_y)
      };
    }
    function stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y, shift_x, shift_y) {
      return stbtt_GetGlyphBitmapBoxSubpixel(
        font,
        stbtt_FindGlyphIndex(font, codepoint),
        scale_x,
        scale_y,
        shift_x,
        shift_y
      );
    }
    function stbtt_GetCodepointBitmapBox(font, codepoint, scale_x, scale_y) {
      return stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y, 0, 0);
    }
    function stbtt__new_active(e, off_x, start_point) {
      var dxdy = (e.x1 - e.x0) / (e.y1 - e.y0);
      return {
        fdx: dxdy,
        fdy: dxdy != 0 ? 1 / dxdy : 0,
        fx: e.x0 + dxdy * (start_point - e.y0) - (off_x | 0),
        direction: e.invert ? 1 : -1,
        sy: e.y0,
        ey: e.y1,
        next: 0
      };
    }
    function stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1) {
      x = x | 0;
      if (y0 == y1) {
        return;
      }
      if (y0 > e.ey) {
        return;
      }
      if (y1 < e.sy) {
        return;
      }
      if (y0 < e.sy) {
        x0 += (x1 - x0) * (e.sy - y0) / (y1 - y0);
        y0 = e.sy;
      }
      if (y1 > e.ey) {
        x1 += (x1 - x0) * (e.ey - y1) / (y1 - y0);
        y1 = e.ey;
      }
      if (x0 <= x && x1 <= x) {
        scanline[x] += e.direction * (y1 - y0);
      } else if (x0 >= x + 1 && x1 >= x + 1) {
      } else {
        scanline[x] += e.direction * (y1 - y0) * (1 - (x0 - x + (x1 - x)) / 2);
      }
    }
    function stbtt__fill_active_edges_new(scanline, scanline_fill, len, e, y_top) {
      var y_bottom = y_top + 1;
      while (e) {
        if (e.fdx == 0) {
          var x0 = e.fx;
          if (x0 < len) {
            if (x0 >= 0) {
              stbtt__handle_clipped_edge(scanline, x0, e, x0, y_top, x0, y_bottom);
              stbtt__handle_clipped_edge(scanline_fill, x0 + 1, e, x0, y_top, x0, y_bottom);
            } else {
              stbtt__handle_clipped_edge(scanline_fill, 0, e, x0, y_top, x0, y_bottom);
            }
          }
        } else {
          var x0 = e.fx, dx = e.fdx, xb = x0 + dx, x_top, x_bottom, sy0, sy1, dy = e.fdy;
          if (e.sy > y_top) {
            x_top = x0 + dx * (e.sy - y_top);
            sy0 = e.sy;
          } else {
            x_top = x0;
            sy0 = y_top;
          }
          if (e.ey < y_bottom) {
            x_bottom = x0 + dx * (e.ey - y_top);
            sy1 = e.ey;
          } else {
            x_bottom = xb;
            sy1 = y_bottom;
          }
          if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            if ((x_top | 0) == (x_bottom | 0)) {
              var height = sy1 - sy0, x = x_top | 0;
              scanline[x] += e.direction * (1 - (x_top - x + (x_bottom - x)) / 2) * height;
              scanline_fill[x + 1] += e.direction * height;
            } else {
              var t, x, x1, x2, y_crossing, step, sign, area;
              if (x_top > x_bottom) {
                sy0 = y_bottom - (sy0 - y_top);
                sy1 = y_bottom - (sy1 - y_top);
                t = sy0, sy0 = sy1, sy1 = t;
                t = x_bottom, x_bottom = x_top, x_top = t;
                dx = -dx;
                dy = -dy;
                t = x0, x0 = xb, xb = t;
              }
              x1 = x_top | 0;
              x2 = x_bottom | 0;
              y_crossing = (x1 + 1 - x0) * dy + y_top;
              sign = e.direction;
              area = sign * (y_crossing - sy0);
              scanline[x1] += area * (1 - (x_top - x1 + (x1 + 1 - x1)) / 2);
              step = sign * dy;
              for (x = x1 + 1; x < x2; ++x) {
                scanline[x] += area + step / 2;
                area += step;
              }
              y_crossing += dy * (x2 - (x1 + 1));
              scanline[x2] += area + sign * (1 - (x2 - x2 + (x_bottom - x2)) / 2) * (sy1 - y_crossing);
              scanline_fill[x2 + 1] += sign * (sy1 - sy0);
            }
          } else {
            for (var x = 0; x < len; ++x) {
              var y0 = y_top, x1 = x, x2 = x + 1, x3 = xb, y3 = y_bottom, y1 = (x - x0) / dx + y_top, y2 = (x + 1 - x0) / dx + y_top;
              if (x0 < x1 && x3 > x2) {
                stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
                stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x2, y2);
                stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
              } else if (x3 < x1 && x0 > x2) {
                stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
                stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x1, y1);
                stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
              } else if (x0 < x1 && x3 > x1) {
                stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
                stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
              } else if (x3 < x1 && x0 > x1) {
                stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
                stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
              } else if (x0 < x2 && x3 > x2) {
                stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
                stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
              } else if (x3 < x2 && x0 > x2) {
                stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
                stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
              } else {
                stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x3, y3);
              }
            }
          }
        }
        e = e.next;
      }
    }
    function stbtt__rasterize_sorted_edges(result, edges, nedges, vsubsample, off_x, off_y) {
      vsubsample |= 0, off_x |= 0, off_y |= 0;
      var active = null, z2;
      var y = off_y, j = 0, i;
      var scanline = new Float32Array(result.w * 2 + 1);
      var scanline2 = scanline.subarray(result.w);
      var eoff = 0;
      edges[nedges].y0 = off_y + result.h + 1;
      while (j < result.h) {
        var scan_y_top = y + 0, scan_y_bottom = y + 1, step = active;
        if (scanline.fill) {
          scanline.fill(0);
        } else {
          for (var $i = 0, $l = scanline.length; $i < $l; $i++)
            scanline[$i] = 0;
        }
        while (step) {
          z2 = step;
          step = z2.next;
          if (z2.ey <= scan_y_top) {
            z2.direction = 0;
          } else {
          }
        }
        while (edges[eoff].y0 <= scan_y_bottom) {
          if (edges[eoff].y0 != edges[eoff].y1) {
            z2 = stbtt__new_active(edges[eoff], off_x, scan_y_top);
            z2.next = active;
            active = z2;
          }
          ++eoff;
        }
        if (active) {
          stbtt__fill_active_edges_new(scanline, scanline2, result.w, active, scan_y_top);
        }
        for (var i = 0, sum2 = 0; i < result.w; ++i) {
          var k, m;
          sum2 += scanline2[i];
          k = scanline[i] + sum2;
          k = abs(k) * 255 + 0.5;
          m = k >>> 0;
          if (m > 255) {
            m = 255;
          }
          result.pixels[j * result.stride + i] = m;
        }
        step = active;
        while (step) {
          z2 = step;
          z2.fx += z2.fdx;
          step = z2.next;
        }
        ++y;
        ++j;
      }
    }
    function stbtt__sort_edges_ins_sort(p, n) {
      for (var i = 1; i < n; ++i) {
        var t = p[i], j = i;
        while (j > 0 && t.y0 < p[j - 1].y0) {
          p[j] = p[j - 1];
          --j;
        }
        if (i != j) {
          p[j] = t;
        }
      }
    }
    function stbtt__sort_edges_quicksort(p, o, n) {
      while (n > 12) {
        var t, c, i, j, z2, m = n >> 1, c01 = p[o].y0 < p[o + m].y0, c12 = p[o + m].y0 < p[o + n - 1].y0;
        if (c01 != c12) {
          c = p[o].y0 < p[o + n - 11].y0;
          z2 = c == c12 ? 0 : n - 1;
          t = p[o + z2];
          p[o + z2] = p[o + m];
          p[o + m] = t;
        }
        t = p[o];
        p[o] = p[o + m];
        p[o + m] = t;
        i = 1;
        j = n - 1;
        for (; ; ) {
          for (; p[o + i].y0 < p[o].y0; ++i) {
          }
          for (; p[o].y0 < p[o + j].y0; --j) {
          }
          if (i >= j) {
            break;
          }
          t = p[o + i];
          p[o + i] = p[o + j];
          p[o + j] = t;
          ++i;
          --j;
        }
        if (j < n - i) {
          stbtt__sort_edges_quicksort(p, o, j);
          o += i;
          n -= i;
        } else {
          stbtt__sort_edges_quicksort(p, o + i, n - i);
          n = j;
        }
      }
    }
    function stbtt__sort_edges(p, n) {
      stbtt__sort_edges_quicksort(p, 0, n);
      stbtt__sort_edges_ins_sort(p, n);
    }
    function stbtt__rasterize(result, pts, wcount, scale_x, scale_y, shift_x, shift_y, off_x, off_y, invert) {
      var y_scale_inv = invert ? -scale_y : scale_y, e, n, i, j, k, m, vsubsample = 1;
      n = 0;
      for (i = 0; i < wcount.length; ++i) {
        n += wcount[i];
      }
      e = oalloc(n + 1);
      n = 0;
      m = 0;
      for (i = 0; i < wcount.length; ++i) {
        var p = m;
        m += wcount[i];
        j = wcount[i] - 1;
        for (k = 0; k < wcount[i]; j = k++) {
          var a = k, b = j;
          if (pts[p + j].y == pts[p + k].y) {
            continue;
          }
          e[n].invert = 0;
          if (invert ? pts[p + j].y > pts[p + k].y : pts[p + j].y < pts[p + k].y) {
            e[n].invert = 1;
            a = j, b = k;
          }
          e[n].x0 = pts[p + a].x * scale_x + shift_x;
          e[n].y0 = (pts[p + a].y * y_scale_inv + shift_y) * vsubsample;
          e[n].x1 = pts[p + b].x * scale_x + shift_x;
          e[n].y1 = (pts[p + b].y * y_scale_inv + shift_y) * vsubsample;
          ++n;
        }
      }
      stbtt__sort_edges(e, n);
      stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y);
    }
    function stbtt__tesselate_curve(points, x0, y0, x1, y1, x2, y2, objspace_flatness_squared, n) {
      var mx = (x0 + 2 * x1 + x2) / 4, my = (y0 + 2 * y1 + y2) / 4, dx = (x0 + x2) / 2 - mx, dy = (y0 + y2) / 2 - my;
      if (n > 16) {
        return 1;
      }
      if (dx * dx + dy * dy > objspace_flatness_squared) {
        stbtt__tesselate_curve(
          points,
          x0,
          y0,
          (x0 + x1) / 2,
          (y0 + y1) / 2,
          mx,
          my,
          objspace_flatness_squared,
          n + 1
        );
        stbtt__tesselate_curve(
          points,
          mx,
          my,
          (x1 + x2) / 2,
          (y1 + y2) / 2,
          x2,
          y2,
          objspace_flatness_squared,
          n + 1
        );
      } else {
        points.push({ x: x2, y: y2 });
      }
      return 1;
    }
    function stbtt__tesselate_cubic(points, x0, y0, x1, y1, x2, y2, x3, y3, objspace_flatness_squared, n) {
      var dx0 = x1 - x0, dy0 = y1 - y0, dx1 = x2 - x1, dy1 = y2 - y1, dx2 = x3 - x2, dy2 = y3 - y2, dx = x3 - x0, dy = y3 - y0, longlen = sqrt(dx0 * dx0 + dy0 * dy0) + sqrt(dx1 * dx1 + dy1 * dy1) + sqrt(dx2 * dx2 + dy2 * dy2), shortlen = sqrt(dx * dx + dy * dy), flatness_squared = longlen * longlen - shortlen * shortlen;
      if (n > 16) {
        return;
      }
      if (flatness_squared > objspace_flatness_squared) {
        var x01 = (x0 + x1) / 2, y01 = (y0 + y1) / 2, x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, xa = (x01 + x12) / 2, ya = (y01 + y12) / 2, xb = (x12 + x23) / 2, yb = (y12 + y23) / 2, mx = (xa + xb) / 2, my = (ya + yb) / 2;
        stbtt__tesselate_cubic(
          points,
          x0,
          y0,
          x01,
          y01,
          xa,
          ya,
          mx,
          my,
          objspace_flatness_squared,
          n + 1
        );
        stbtt__tesselate_cubic(
          points,
          mx,
          my,
          xb,
          yb,
          x23,
          y23,
          x3,
          y3,
          objspace_flatness_squared,
          n + 1
        );
      } else {
        points.push({ x: x3, y: y3 });
      }
    }
    function stbtt_FlattenCurves(vertices, objspace_flatness, contour_lengths) {
      var points = [], objspace_flatness_squared = objspace_flatness * objspace_flatness, n = -1, start = 0, x = 0, y = 0;
      for (var i = 0, nverts = vertices.length; i < nverts; ++i) {
        switch (vertices[i].type) {
          case STBTT_vmove:
            if (n >= 0) {
              contour_lengths[n] = points.length - start;
            }
            ++n;
            start = points.length;
            x = vertices[i].x, y = vertices[i].y;
            points.push({ x, y });
            break;
          case STBTT_vline:
            x = vertices[i].x, y = vertices[i].y;
            points.push({ x, y });
            break;
          case STBTT_vcurve:
            stbtt__tesselate_curve(
              points,
              x,
              y,
              vertices[i].cx,
              vertices[i].cy,
              vertices[i].x,
              vertices[i].y,
              objspace_flatness_squared,
              0
            );
            x = vertices[i].x, y = vertices[i].y;
            break;
          case STBTT_vcubic:
            stbtt__tesselate_cubic(
              points,
              x,
              y,
              vertices[i].cx,
              vertices[i].cy,
              vertices[i].cx1,
              vertices[i].cy1,
              vertices[i].x,
              vertices[i].y,
              objspace_flatness_squared,
              0
            );
            x = vertices[i].x, y = vertices[i].y;
            break;
        }
      }
      contour_lengths[n] = points.length - start;
      return points;
    }
    function stbtt_Rasterize(result, flatness_in_pixels, vertices, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert) {
      x_off |= 0, y_off |= 0;
      var scale2 = scale_x > scale_y ? scale_y : scale_x, wcount = [], windings = stbtt_FlattenCurves(vertices, flatness_in_pixels / scale2, wcount);
      if (windings) {
        stbtt__rasterize(
          result,
          windings,
          wcount,
          scale_x,
          scale_y,
          shift_x,
          shift_y,
          x_off,
          y_off,
          invert
        );
      }
    }
    function stbtt_MakeGlyphBitmapSubpixel(info, buffer, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, glyph) {
      var vertices = stbtt_GetGlyphShape(info, glyph);
      var gbm = {};
      var rect = stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y);
      gbm.pixels = buffer;
      gbm.w = out_w | 0;
      gbm.h = out_h | 0;
      gbm.stride = out_stride | 0;
      if (gbm.w && gbm.h) {
        stbtt_Rasterize(gbm, 0.35, vertices, scale_x, scale_y, shift_x, shift_y, rect.x0, rect.y0, 1);
      }
    }
    function stbtt_MakeCodepointBitmapSubpixel(info, buffer, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, codepoint) {
      stbtt_MakeGlyphBitmapSubpixel(
        info,
        buffer,
        out_w,
        out_h,
        out_stride,
        scale_x,
        scale_y,
        shift_x,
        shift_y,
        stbtt_FindGlyphIndex(info, codepoint)
      );
    }
    function stbtt_InitFont(font, data, offset) {
      return stbtt_InitFont_internal(font, data, offset);
    }
    function InitFont(data) {
      var font = {};
      if (!stbtt_InitFont_internal(font, data, 0)) {
        return null;
      }
      var vm = stbtt_GetFontVMetrics(font);
      font.ascent = vm.ascent;
      font.descent = vm.descent;
      font.linegap = vm.linegap;
      return font;
    }
    function GetGlyph(font, codepoint, size_x, size_y) {
      size_y = size_y || size_x;
      var scale_x = size_x / font.ascent;
      var scale_y = size_y / font.ascent;
      var glyph = stbtt_FindGlyphIndex(font, codepoint);
      if (!glyph && codepoint) {
        return null;
      }
      var vertices = stbtt_GetGlyphShape(font, glyph);
      var rect = stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0, 0);
      var width = rect.x1 - rect.x0;
      var height = rect.y1 - rect.y0;
      var pixels = null;
      if (width && height) {
        var gbm = {
          pixels: pixels = new Uint8Array(width * height),
          w: width,
          h: height,
          stride: width
        };
        stbtt_Rasterize(gbm, 0.35, vertices, scale_x, scale_y, 0, 0, rect.x0, rect.y0, 1);
      }
      var hmetrics = stbtt_GetGlyphHMetrics(font, glyph);
      return {
        glyph,
        pixels,
        width,
        height,
        top: -rect.y0,
        left: rect.x0,
        advance: floor(hmetrics.advanceWidth * scale_x)
      };
    }
    function GetPaths(font, codepoint, size_x, size_y) {
      size_y = size_y || size_x;
      var scale_x = size_x / font.ascent;
      var scale_y = size_y / font.ascent;
      var glyph = stbtt_FindGlyphIndex(font, codepoint);
      if (!glyph && codepoint) {
        return null;
      }
      var vertices = stbtt_GetGlyphShape(font, glyph);
      var hmetrics = stbtt_GetGlyphHMetrics(font, glyph);
      var ascent = 0;
      var descent = 0;
      var paths = [];
      if (vertices) {
        for (var i = 0, l = vertices.length; i < l; i++) {
          var v = vertices[i];
          var path;
          if (v.type == STBTT_vmove) {
            path = { type: "M", x: v.x * scale_x, y: v.y * scale_y };
          } else if (v.type == STBTT_vline) {
            path = { type: "L", x: v.x * scale_x, y: v.y * scale_y };
          } else if (v.type == STBTT_vcurve) {
            path = {
              type: "Q",
              x: v.x * scale_x,
              y: v.y * scale_y,
              cx: v.cx * scale_x,
              cy: v.cy * scale_y
            };
          } else if (v.type == STBTT_vcubic) {
            path = {
              type: "C",
              x: v.x * scale_x,
              y: v.y * scale_y,
              cx1: v.cx * scale_x,
              cy1: v.cy * scale_y,
              cx2: v.cx1 * scale_x,
              cy2: v.cy1 * scale_y
            };
          } else {
            continue;
          }
          if (path.y > ascent)
            ascent = path.y;
          if (path.y < descent)
            descent = path.y;
          paths.push(path);
        }
      }
      paths.advance = hmetrics.advanceWidth * scale_x;
      paths.ascent = ascent;
      paths.descent = descent;
      return paths;
    }
    return {
      InitFont,
      GetGlyph,
      GetPaths
    };
  }();
  function toUint8Array2(data) {
    if (typeof data == "string") {
      var binary = /[^A-Za-z0-9+\/=\s]/.test(data);
      var bstr = binary ? data : atob(data), len = bstr.length, bytes = new Uint8Array(len);
      for (var i = 0; i < len; i++) {
        bytes[i] = bstr.charCodeAt(i);
      }
      return bytes;
    } else if (data instanceof Uint8Array) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return new Uint8Array(data);
    }
    throw new ReferenceError("data must be a binary or base64 encoded string or Uint8Array");
  }
  FontLib.loadFont("OCR-A", 100, 100, "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");
  FontLib.loadFont("OCR-B", 96, 100, "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");
  function auspost(opts, cvs) {
    return _ToCanvas(bwipp_auspost, opts, cvs);
  }
  ;
  function azteccode(opts, cvs) {
    return _ToCanvas(bwipp_azteccode, opts, cvs);
  }
  ;
  function azteccodecompact(opts, cvs) {
    return _ToCanvas(bwipp_azteccodecompact, opts, cvs);
  }
  ;
  function aztecrune(opts, cvs) {
    return _ToCanvas(bwipp_aztecrune, opts, cvs);
  }
  ;
  function bc412(opts, cvs) {
    return _ToCanvas(bwipp_bc412, opts, cvs);
  }
  ;
  function channelcode(opts, cvs) {
    return _ToCanvas(bwipp_channelcode, opts, cvs);
  }
  ;
  function codablockf(opts, cvs) {
    return _ToCanvas(bwipp_codablockf, opts, cvs);
  }
  ;
  function code11(opts, cvs) {
    return _ToCanvas(bwipp_code11, opts, cvs);
  }
  ;
  function code128(opts, cvs) {
    return _ToCanvas(bwipp_code128, opts, cvs);
  }
  ;
  function code16k(opts, cvs) {
    return _ToCanvas(bwipp_code16k, opts, cvs);
  }
  ;
  function code2of5(opts, cvs) {
    return _ToCanvas(bwipp_code2of5, opts, cvs);
  }
  ;
  function code32(opts, cvs) {
    return _ToCanvas(bwipp_code32, opts, cvs);
  }
  ;
  function code39(opts, cvs) {
    return _ToCanvas(bwipp_code39, opts, cvs);
  }
  ;
  function code39ext(opts, cvs) {
    return _ToCanvas(bwipp_code39ext, opts, cvs);
  }
  ;
  function code49(opts, cvs) {
    return _ToCanvas(bwipp_code49, opts, cvs);
  }
  ;
  function code93(opts, cvs) {
    return _ToCanvas(bwipp_code93, opts, cvs);
  }
  ;
  function code93ext(opts, cvs) {
    return _ToCanvas(bwipp_code93ext, opts, cvs);
  }
  ;
  function codeone(opts, cvs) {
    return _ToCanvas(bwipp_codeone, opts, cvs);
  }
  ;
  function coop2of5(opts, cvs) {
    return _ToCanvas(bwipp_coop2of5, opts, cvs);
  }
  ;
  function daft(opts, cvs) {
    return _ToCanvas(bwipp_daft, opts, cvs);
  }
  ;
  function databarexpanded(opts, cvs) {
    return _ToCanvas(bwipp_databarexpanded, opts, cvs);
  }
  ;
  function databarexpandedcomposite(opts, cvs) {
    return _ToCanvas(bwipp_databarexpandedcomposite, opts, cvs);
  }
  ;
  function databarexpandedstacked(opts, cvs) {
    return _ToCanvas(bwipp_databarexpandedstacked, opts, cvs);
  }
  ;
  function databarexpandedstackedcomposite(opts, cvs) {
    return _ToCanvas(bwipp_databarexpandedstackedcomposite, opts, cvs);
  }
  ;
  function databarlimited(opts, cvs) {
    return _ToCanvas(bwipp_databarlimited, opts, cvs);
  }
  ;
  function databarlimitedcomposite(opts, cvs) {
    return _ToCanvas(bwipp_databarlimitedcomposite, opts, cvs);
  }
  ;
  function databaromni(opts, cvs) {
    return _ToCanvas(bwipp_databaromni, opts, cvs);
  }
  ;
  function databaromnicomposite(opts, cvs) {
    return _ToCanvas(bwipp_databaromnicomposite, opts, cvs);
  }
  ;
  function databarstacked(opts, cvs) {
    return _ToCanvas(bwipp_databarstacked, opts, cvs);
  }
  ;
  function databarstackedcomposite(opts, cvs) {
    return _ToCanvas(bwipp_databarstackedcomposite, opts, cvs);
  }
  ;
  function databarstackedomni(opts, cvs) {
    return _ToCanvas(bwipp_databarstackedomni, opts, cvs);
  }
  ;
  function databarstackedomnicomposite(opts, cvs) {
    return _ToCanvas(bwipp_databarstackedomnicomposite, opts, cvs);
  }
  ;
  function databartruncated(opts, cvs) {
    return _ToCanvas(bwipp_databartruncated, opts, cvs);
  }
  ;
  function databartruncatedcomposite(opts, cvs) {
    return _ToCanvas(bwipp_databartruncatedcomposite, opts, cvs);
  }
  ;
  function datalogic2of5(opts, cvs) {
    return _ToCanvas(bwipp_datalogic2of5, opts, cvs);
  }
  ;
  function datamatrix(opts, cvs) {
    return _ToCanvas(bwipp_datamatrix, opts, cvs);
  }
  ;
  function datamatrixrectangular(opts, cvs) {
    return _ToCanvas(bwipp_datamatrixrectangular, opts, cvs);
  }
  ;
  function datamatrixrectangularextension(opts, cvs) {
    return _ToCanvas(bwipp_datamatrixrectangularextension, opts, cvs);
  }
  ;
  function dotcode(opts, cvs) {
    return _ToCanvas(bwipp_dotcode, opts, cvs);
  }
  ;
  function ean13(opts, cvs) {
    return _ToCanvas(bwipp_ean13, opts, cvs);
  }
  ;
  function ean13composite(opts, cvs) {
    return _ToCanvas(bwipp_ean13composite, opts, cvs);
  }
  ;
  function ean14(opts, cvs) {
    return _ToCanvas(bwipp_ean14, opts, cvs);
  }
  ;
  function ean2(opts, cvs) {
    return _ToCanvas(bwipp_ean2, opts, cvs);
  }
  ;
  function ean5(opts, cvs) {
    return _ToCanvas(bwipp_ean5, opts, cvs);
  }
  ;
  function ean8(opts, cvs) {
    return _ToCanvas(bwipp_ean8, opts, cvs);
  }
  ;
  function ean8composite(opts, cvs) {
    return _ToCanvas(bwipp_ean8composite, opts, cvs);
  }
  ;
  function flattermarken(opts, cvs) {
    return _ToCanvas(bwipp_flattermarken, opts, cvs);
  }
  ;
  function gs1_128(opts, cvs) {
    return _ToCanvas(bwipp_gs1_128, opts, cvs);
  }
  ;
  function gs1_128composite(opts, cvs) {
    return _ToCanvas(bwipp_gs1_128composite, opts, cvs);
  }
  ;
  function gs1_cc(opts, cvs) {
    return _ToCanvas(bwipp_gs1_cc, opts, cvs);
  }
  ;
  function gs1datamatrix(opts, cvs) {
    return _ToCanvas(bwipp_gs1datamatrix, opts, cvs);
  }
  ;
  function gs1datamatrixrectangular(opts, cvs) {
    return _ToCanvas(bwipp_gs1datamatrixrectangular, opts, cvs);
  }
  ;
  function gs1dldatamatrix(opts, cvs) {
    return _ToCanvas(bwipp_gs1dldatamatrix, opts, cvs);
  }
  ;
  function gs1dlqrcode(opts, cvs) {
    return _ToCanvas(bwipp_gs1dlqrcode, opts, cvs);
  }
  ;
  function gs1dotcode(opts, cvs) {
    return _ToCanvas(bwipp_gs1dotcode, opts, cvs);
  }
  ;
  function gs1northamericancoupon(opts, cvs) {
    return _ToCanvas(bwipp_gs1northamericancoupon, opts, cvs);
  }
  ;
  function gs1qrcode(opts, cvs) {
    return _ToCanvas(bwipp_gs1qrcode, opts, cvs);
  }
  ;
  function hanxin(opts, cvs) {
    return _ToCanvas(bwipp_hanxin, opts, cvs);
  }
  ;
  function hibcazteccode(opts, cvs) {
    return _ToCanvas(bwipp_hibcazteccode, opts, cvs);
  }
  ;
  function hibccodablockf(opts, cvs) {
    return _ToCanvas(bwipp_hibccodablockf, opts, cvs);
  }
  ;
  function hibccode128(opts, cvs) {
    return _ToCanvas(bwipp_hibccode128, opts, cvs);
  }
  ;
  function hibccode39(opts, cvs) {
    return _ToCanvas(bwipp_hibccode39, opts, cvs);
  }
  ;
  function hibcdatamatrix(opts, cvs) {
    return _ToCanvas(bwipp_hibcdatamatrix, opts, cvs);
  }
  ;
  function hibcdatamatrixrectangular(opts, cvs) {
    return _ToCanvas(bwipp_hibcdatamatrixrectangular, opts, cvs);
  }
  ;
  function hibcmicropdf417(opts, cvs) {
    return _ToCanvas(bwipp_hibcmicropdf417, opts, cvs);
  }
  ;
  function hibcpdf417(opts, cvs) {
    return _ToCanvas(bwipp_hibcpdf417, opts, cvs);
  }
  ;
  function hibcqrcode(opts, cvs) {
    return _ToCanvas(bwipp_hibcqrcode, opts, cvs);
  }
  ;
  function iata2of5(opts, cvs) {
    return _ToCanvas(bwipp_iata2of5, opts, cvs);
  }
  ;
  function identcode(opts, cvs) {
    return _ToCanvas(bwipp_identcode, opts, cvs);
  }
  ;
  function industrial2of5(opts, cvs) {
    return _ToCanvas(bwipp_industrial2of5, opts, cvs);
  }
  ;
  function interleaved2of5(opts, cvs) {
    return _ToCanvas(bwipp_interleaved2of5, opts, cvs);
  }
  ;
  function isbn(opts, cvs) {
    return _ToCanvas(bwipp_isbn, opts, cvs);
  }
  ;
  function ismn(opts, cvs) {
    return _ToCanvas(bwipp_ismn, opts, cvs);
  }
  ;
  function issn(opts, cvs) {
    return _ToCanvas(bwipp_issn, opts, cvs);
  }
  ;
  function itf14(opts, cvs) {
    return _ToCanvas(bwipp_itf14, opts, cvs);
  }
  ;
  function jabcode(opts, cvs) {
    return _ToCanvas(bwipp_jabcode, opts, cvs);
  }
  ;
  function japanpost(opts, cvs) {
    return _ToCanvas(bwipp_japanpost, opts, cvs);
  }
  ;
  function kix(opts, cvs) {
    return _ToCanvas(bwipp_kix, opts, cvs);
  }
  ;
  function leitcode(opts, cvs) {
    return _ToCanvas(bwipp_leitcode, opts, cvs);
  }
  ;
  function mailmark(opts, cvs) {
    return _ToCanvas(bwipp_mailmark, opts, cvs);
  }
  ;
  function mands(opts, cvs) {
    return _ToCanvas(bwipp_mands, opts, cvs);
  }
  ;
  function matrix2of5(opts, cvs) {
    return _ToCanvas(bwipp_matrix2of5, opts, cvs);
  }
  ;
  function maxicode(opts, cvs) {
    return _ToCanvas(bwipp_maxicode, opts, cvs);
  }
  ;
  function micropdf417(opts, cvs) {
    return _ToCanvas(bwipp_micropdf417, opts, cvs);
  }
  ;
  function microqrcode(opts, cvs) {
    return _ToCanvas(bwipp_microqrcode, opts, cvs);
  }
  ;
  function msi(opts, cvs) {
    return _ToCanvas(bwipp_msi, opts, cvs);
  }
  ;
  function onecode(opts, cvs) {
    return _ToCanvas(bwipp_onecode, opts, cvs);
  }
  ;
  function pdf417(opts, cvs) {
    return _ToCanvas(bwipp_pdf417, opts, cvs);
  }
  ;
  function pdf417compact(opts, cvs) {
    return _ToCanvas(bwipp_pdf417compact, opts, cvs);
  }
  ;
  function pharmacode(opts, cvs) {
    return _ToCanvas(bwipp_pharmacode, opts, cvs);
  }
  ;
  function pharmacode2(opts, cvs) {
    return _ToCanvas(bwipp_pharmacode2, opts, cvs);
  }
  ;
  function planet(opts, cvs) {
    return _ToCanvas(bwipp_planet, opts, cvs);
  }
  ;
  function plessey(opts, cvs) {
    return _ToCanvas(bwipp_plessey, opts, cvs);
  }
  ;
  function posicode(opts, cvs) {
    return _ToCanvas(bwipp_posicode, opts, cvs);
  }
  ;
  function postnet(opts, cvs) {
    return _ToCanvas(bwipp_postnet, opts, cvs);
  }
  ;
  function pzn(opts, cvs) {
    return _ToCanvas(bwipp_pzn, opts, cvs);
  }
  ;
  function qrcode(opts, cvs) {
    return _ToCanvas(bwipp_qrcode, opts, cvs);
  }
  ;
  function rationalizedCodabar(opts, cvs) {
    return _ToCanvas(bwipp_rationalizedCodabar, opts, cvs);
  }
  ;
  function raw(opts, cvs) {
    return _ToCanvas(bwipp_raw, opts, cvs);
  }
  ;
  function rectangularmicroqrcode(opts, cvs) {
    return _ToCanvas(bwipp_rectangularmicroqrcode, opts, cvs);
  }
  ;
  function royalmail(opts, cvs) {
    return _ToCanvas(bwipp_royalmail, opts, cvs);
  }
  ;
  function sscc18(opts, cvs) {
    return _ToCanvas(bwipp_sscc18, opts, cvs);
  }
  ;
  function swissqrcode(opts, cvs) {
    return _ToCanvas(bwipp_swissqrcode, opts, cvs);
  }
  ;
  function symbol(opts, cvs) {
    return _ToCanvas(bwipp_symbol, opts, cvs);
  }
  ;
  function telepen(opts, cvs) {
    return _ToCanvas(bwipp_telepen, opts, cvs);
  }
  ;
  function telepennumeric(opts, cvs) {
    return _ToCanvas(bwipp_telepennumeric, opts, cvs);
  }
  ;
  function ultracode(opts, cvs) {
    return _ToCanvas(bwipp_ultracode, opts, cvs);
  }
  ;
  function upca(opts, cvs) {
    return _ToCanvas(bwipp_upca, opts, cvs);
  }
  ;
  function upcacomposite(opts, cvs) {
    return _ToCanvas(bwipp_upcacomposite, opts, cvs);
  }
  ;
  function upce(opts, cvs) {
    return _ToCanvas(bwipp_upce, opts, cvs);
  }
  ;
  function upcecomposite(opts, cvs) {
    return _ToCanvas(bwipp_upcecomposite, opts, cvs);
  }
  ;
  var bwip_js_default = {
    // The public interface
    toCanvas: ToCanvas,
    render: Render,
    raw: ToRaw,
    fixupOptions: FixupOptions,
    loadFont: FontLib.loadFont,
    BWIPJS_VERSION: "3.4.3",
    BWIPP_VERSION,
    // Internals
    BWIPJS,
    STBTT,
    FontLib,
    DrawingBuiltin,
    DrawingCanvas
  };

  // node_modules/@pdfme/generator/dist/esm/src/helper.js
  var __awaiter4 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var barCodeType2Bcid = (type) => type === "nw7" ? "rationalizedCodabar" : type;
  var createBarCode = (arg) => __awaiter4(void 0, void 0, void 0, function* () {
    const { type, input, width, height, backgroundColor } = arg;
    const bcid = barCodeType2Bcid(type);
    const includetext = true;
    const scale2 = 5;
    const bwipjsArg = { bcid, text: input, width, height, scale: scale2, includetext };
    if (backgroundColor) {
      bwipjsArg.backgroundcolor = backgroundColor;
    }
    let res;
    if (typeof window !== "undefined") {
      const canvas = document.createElement("canvas");
      bwip_js_default.toCanvas(canvas, bwipjsArg);
      const dataUrl = canvas.toDataURL("image/png");
      res = b64toUint8Array(dataUrl).buffer;
    } else {
      res = yield bwip_js_default.toBuffer(bwipjsArg);
    }
    return res;
  });
  var embedAndGetFontObj = (arg) => __awaiter4(void 0, void 0, void 0, function* () {
    const { pdfDoc, font } = arg;
    const fontValues = yield Promise.all(Object.values(font).map((v) => __awaiter4(void 0, void 0, void 0, function* () {
      let fontData = v.data;
      if (typeof fontData === "string" && fontData.startsWith("http")) {
        fontData = yield fetch(fontData).then((res) => res.arrayBuffer());
      }
      return pdfDoc.embedFont(fontData, {
        subset: typeof v.subset === "undefined" ? true : v.subset
      });
    })));
    return Object.keys(font).reduce((acc, cur, i) => Object.assign(acc, { [cur]: fontValues[i] }), {});
  });
  var getEmbeddedPagesAndEmbedPdfBoxes = (arg) => __awaiter4(void 0, void 0, void 0, function* () {
    const { pdfDoc, basePdf } = arg;
    let embeddedPages = [];
    let embedPdfBoxes = [];
    const willLoadPdf = typeof basePdf === "string" ? yield getB64BasePdf(basePdf) : basePdf;
    const embedPdf = yield PDFDocument_default.load(willLoadPdf);
    const embedPdfPages = embedPdf.getPages();
    embedPdfBoxes = embedPdfPages.map((p) => ({
      mediaBox: p.getMediaBox(),
      bleedBox: p.getBleedBox(),
      trimBox: p.getTrimBox()
    }));
    const boundingBoxes = embedPdfPages.map((p) => {
      const { x, y, width, height } = p.getMediaBox();
      return { left: x, bottom: y, right: width, top: height + y };
    });
    const transformationMatrices = embedPdfPages.map(() => [1, 0, 0, 1, 0, 0]);
    embeddedPages = yield pdfDoc.embedPages(embedPdfPages, boundingBoxes, transformationMatrices);
    return { embeddedPages, embedPdfBoxes };
  });
  var mm2pt = (mm) => {
    const ptRatio = 2.8346;
    return parseFloat(String(mm)) * ptRatio;
  };
  var getSchemaSizeAndRotate = (schema) => {
    const width = mm2pt(schema.width);
    const height = mm2pt(schema.height);
    const rotate = degrees(schema.rotate ? schema.rotate : 0);
    return { width, height, rotate };
  };
  var hex2rgb = (hex) => {
    if (hex.slice(0, 1) === "#")
      hex = hex.slice(1);
    if (hex.length === 3)
      hex = hex.slice(0, 1) + hex.slice(0, 1) + hex.slice(1, 2) + hex.slice(1, 2) + hex.slice(2, 3) + hex.slice(2, 3);
    return [hex.slice(0, 2), hex.slice(2, 4), hex.slice(4, 6)].map((str) => parseInt(str, 16));
  };
  var hex2RgbColor = (hexString) => {
    if (hexString) {
      const [r, g, b] = hex2rgb(hexString);
      return rgb(r / 255, g / 255, b / 255);
    }
    return void 0;
  };
  var getFontProp = ({ input, font, schema }) => __awaiter4(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e;
    const size = schema.dynamicFontSize ? yield calculateDynamicFontSize({ textSchema: schema, font, input }) : (_a = schema.fontSize) !== null && _a !== void 0 ? _a : DEFAULT_FONT_SIZE;
    const color = hex2RgbColor((_b = schema.fontColor) !== null && _b !== void 0 ? _b : DEFAULT_FONT_COLOR);
    const alignment = (_c = schema.alignment) !== null && _c !== void 0 ? _c : DEFAULT_ALIGNMENT;
    const lineHeight = (_d = schema.lineHeight) !== null && _d !== void 0 ? _d : DEFAULT_LINE_HEIGHT;
    const characterSpacing = (_e = schema.characterSpacing) !== null && _e !== void 0 ? _e : DEFAULT_CHARACTER_SPACING;
    return { size, color, alignment, lineHeight, characterSpacing };
  });
  var calcX = (x, alignment, boxWidth, textWidth) => {
    let addition = 0;
    if (alignment === "center") {
      addition = (boxWidth - textWidth) / 2;
    } else if (alignment === "right") {
      addition = boxWidth - textWidth;
    }
    return mm2pt(x) + addition;
  };
  var calcY = (y, height, itemHeight) => height - mm2pt(y) - itemHeight;
  var drawBackgroundColor = (arg) => {
    const { templateSchema, page, pageHeight } = arg;
    if (!templateSchema.backgroundColor)
      return;
    const { width, height } = getSchemaSizeAndRotate(templateSchema);
    const color = hex2RgbColor(templateSchema.backgroundColor);
    page.drawRectangle({
      x: calcX(templateSchema.position.x, "left", width, width),
      y: calcY(templateSchema.position.y, pageHeight, height),
      width,
      height,
      color
    });
  };
  var getOverPosition = (inputLine, isOverEval) => {
    for (let i = 0; i <= inputLine.length; i++) {
      if (isOverEval(inputLine.slice(0, i))) {
        return i;
      }
    }
    return null;
  };
  var getSplitPosition = (inputLine, isOverEval) => {
    const overPos = getOverPosition(inputLine, isOverEval);
    if (overPos === null)
      return inputLine.length;
    let overPosTmp = overPos;
    while (inputLine[overPosTmp] !== " " && overPosTmp >= 0) {
      overPosTmp--;
    }
    return overPosTmp > 0 ? overPosTmp : overPos - 1;
  };
  var getSplittedLines = (inputLine, isOverEval) => {
    const splitPos = getSplitPosition(inputLine, isOverEval);
    const splittedLine = inputLine.substring(0, splitPos);
    const rest = inputLine.substring(splitPos).trimStart();
    if (rest.length === 0) {
      return [splittedLine];
    }
    return [splittedLine, ...getSplittedLines(rest, isOverEval)];
  };
  var drawInputByTextSchema = (arg) => __awaiter4(void 0, void 0, void 0, function* () {
    const { input, templateSchema, page, pageHeight, fontSetting } = arg;
    const { font, pdfFontObj, fallbackFontName } = fontSetting;
    const pdfFontValue = pdfFontObj[templateSchema.fontName ? templateSchema.fontName : fallbackFontName];
    drawBackgroundColor({ templateSchema, page, pageHeight });
    const { width, rotate } = getSchemaSizeAndRotate(templateSchema);
    const { size, color, alignment, lineHeight, characterSpacing } = yield getFontProp({ input, font, schema: templateSchema });
    page.pushOperators(setCharacterSpacing(characterSpacing));
    let beforeLineOver = 0;
    input.split(/\r|\n|\r\n/g).forEach((inputLine, inputLineIndex) => {
      const isOverEval = (testString) => {
        const testStringWidth = pdfFontValue.widthOfTextAtSize(testString, size) + (testString.length - 1) * characterSpacing;
        return width <= testStringWidth;
      };
      const splitedLines = getSplittedLines(inputLine, isOverEval);
      const drawLine2 = (splitedLine, splitedLineIndex) => {
        const textWidth = pdfFontValue.widthOfTextAtSize(splitedLine, size) + (splitedLine.length - 1) * characterSpacing;
        page.drawText(splitedLine, {
          x: calcX(templateSchema.position.x, alignment, width, textWidth),
          y: calcY(templateSchema.position.y, pageHeight, size) - lineHeight * size * (inputLineIndex + splitedLineIndex + beforeLineOver) - (lineHeight === 0 ? 0 : (lineHeight - 1) * size / 2),
          rotate,
          size,
          color,
          lineHeight: lineHeight * size,
          maxWidth: width,
          font: pdfFontValue,
          wordBreaks: [""]
        });
        if (splitedLines.length === splitedLineIndex + 1)
          beforeLineOver += splitedLineIndex;
      };
      splitedLines.forEach(drawLine2);
    });
  });
  var getCacheKey = (templateSchema, input) => `${templateSchema.type}${input}`;
  var drawInputByImageSchema = (arg) => __awaiter4(void 0, void 0, void 0, function* () {
    const { input, templateSchema, pageHeight, pdfDoc, page, inputImageCache } = arg;
    const { width, height, rotate } = getSchemaSizeAndRotate(templateSchema);
    const opt = {
      x: calcX(templateSchema.position.x, "left", width, width),
      y: calcY(templateSchema.position.y, pageHeight, height),
      rotate,
      width,
      height
    };
    const inputImageCacheKey = getCacheKey(templateSchema, input);
    let image = inputImageCache[inputImageCacheKey];
    if (!image) {
      const isPng = input.startsWith("data:image/png;");
      image = yield isPng ? pdfDoc.embedPng(input) : pdfDoc.embedJpg(input);
    }
    inputImageCache[inputImageCacheKey] = image;
    page.drawImage(image, opt);
  });
  var drawInputByBarcodeSchema = (arg) => __awaiter4(void 0, void 0, void 0, function* () {
    const { input, templateSchema, pageHeight, pdfDoc, page, inputImageCache } = arg;
    if (!validateBarcodeInput(templateSchema.type, input))
      return;
    const { width, height, rotate } = getSchemaSizeAndRotate(templateSchema);
    const opt = {
      x: calcX(templateSchema.position.x, "left", width, width),
      y: calcY(templateSchema.position.y, pageHeight, height),
      rotate,
      width,
      height
    };
    const inputBarcodeCacheKey = getCacheKey(templateSchema, input);
    let image = inputImageCache[inputBarcodeCacheKey];
    if (!image) {
      const imageBuf = yield createBarCode(Object.assign(templateSchema, { type: templateSchema.type, input }));
      image = yield pdfDoc.embedPng(imageBuf);
    }
    inputImageCache[inputBarcodeCacheKey] = image;
    page.drawImage(image, opt);
  });
  var drawInputByTemplateSchema = (arg) => __awaiter4(void 0, void 0, void 0, function* () {
    if (!arg.input || !arg.templateSchema)
      return;
    if (isTextSchema(arg.templateSchema)) {
      const templateSchema = arg.templateSchema;
      yield drawInputByTextSchema(Object.assign(Object.assign({}, arg), { templateSchema }));
    } else if (isImageSchema(arg.templateSchema)) {
      const templateSchema = arg.templateSchema;
      yield drawInputByImageSchema(Object.assign(Object.assign({}, arg), { templateSchema }));
    } else if (isBarcodeSchema(arg.templateSchema)) {
      const templateSchema = arg.templateSchema;
      yield drawInputByBarcodeSchema(Object.assign(Object.assign({}, arg), { templateSchema }));
    }
  });
  var drawEmbeddedPage = (arg) => {
    const { page, embeddedPage, embedPdfBox } = arg;
    page.drawPage(embeddedPage);
    const { mediaBox: mb, bleedBox: bb, trimBox: tb } = embedPdfBox;
    page.setMediaBox(mb.x, mb.y, mb.width, mb.height);
    page.setBleedBox(bb.x, bb.y, bb.width, bb.height);
    page.setTrimBox(tb.x, tb.y, tb.width, tb.height);
  };

  // node_modules/@pdfme/generator/dist/esm/src/constants.js
  var TOOL_NAME = "pdfme (https://github.com/hand-dot/pdfme)";

  // node_modules/@pdfme/generator/dist/esm/src/generate.js
  var __awaiter5 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var preprocessing = (arg) => __awaiter5(void 0, void 0, void 0, function* () {
    const { template: template2, font } = arg;
    const { basePdf } = template2;
    const fallbackFontName = getFallbackFontName(font);
    const pdfDoc = yield PDFDocument_default.create();
    pdfDoc.registerFontkit(browser_module_exports);
    const pdfFontObj = yield embedAndGetFontObj({ pdfDoc, font });
    const pagesAndBoxes = yield getEmbeddedPagesAndEmbedPdfBoxes({ pdfDoc, basePdf });
    const { embeddedPages, embedPdfBoxes } = pagesAndBoxes;
    return { pdfDoc, pdfFontObj, fallbackFontName, embeddedPages, embedPdfBoxes };
  });
  var postProcessing = (pdfDoc) => {
    pdfDoc.setProducer(TOOL_NAME);
    pdfDoc.setCreator(TOOL_NAME);
  };
  var generate = (props) => __awaiter5(void 0, void 0, void 0, function* () {
    checkGenerateProps(props);
    const { inputs, template: template2, options = {} } = props;
    const { font = getDefaultFont() } = options;
    const { schemas } = template2;
    const preRes = yield preprocessing({ inputs, template: template2, font });
    const { pdfDoc, pdfFontObj, fallbackFontName, embeddedPages, embedPdfBoxes } = preRes;
    const inputImageCache = {};
    for (let i = 0; i < inputs.length; i += 1) {
      const inputObj = inputs[i];
      const keys = Object.keys(inputObj);
      for (let j = 0; j < embeddedPages.length; j += 1) {
        const embeddedPage = embeddedPages[j];
        const { width: pageWidth, height: pageHeight } = embeddedPage;
        const embedPdfBox = embedPdfBoxes[j];
        const page = pdfDoc.addPage([pageWidth, pageHeight]);
        drawEmbeddedPage({ page, embeddedPage, embedPdfBox });
        for (let l = 0; l < keys.length; l += 1) {
          const key = keys[l];
          const schema = schemas[j];
          const templateSchema = schema[key];
          const input = inputObj[key];
          const fontSetting = { font, pdfFontObj, fallbackFontName };
          yield drawInputByTemplateSchema({
            input,
            templateSchema,
            pdfDoc,
            page,
            pageHeight,
            fontSetting,
            inputImageCache
          });
        }
      }
    }
    postProcessing(pdfDoc);
    return pdfDoc.save();
  });
  var generate_default = generate;

  // src/scripts/jsx/pdfgen.jsx
  var _tmpl$ = /* @__PURE__ */ template(`<div class="pdfme-generator"><button>Generate PDF`);
  var BLANK_PDF2 = "data:application/pdf;base64,JVBERi0xLjcKJeLjz9MKNSAwIG9iago8PAovRmlsdGVyIC9GbGF0ZURlY29kZQovTGVuZ3RoIDM4Cj4+CnN0cmVhbQp4nCvkMlAwUDC1NNUzMVGwMDHUszRSKErlCtfiyuMK5AIAXQ8GCgplbmRzdHJlYW0KZW5kb2JqCjQgMCBvYmoKPDwKL1R5cGUgL1BhZ2UKL01lZGlhQm94IFswIDAgNTk1LjQ0IDg0MS45Ml0KL1Jlc291cmNlcyA8PAo+PgovQ29udGVudHMgNSAwIFIKL1BhcmVudCAyIDAgUgo+PgplbmRvYmoKMiAwIG9iago8PAovVHlwZSAvUGFnZXMKL0tpZHMgWzQgMCBSXQovQ291bnQgMQo+PgplbmRvYmoKMSAwIG9iago8PAovVHlwZSAvQ2F0YWxvZwovUGFnZXMgMiAwIFIKPj4KZW5kb2JqCjMgMCBvYmoKPDwKL3RyYXBwZWQgKGZhbHNlKQovQ3JlYXRvciAoU2VyaWYgQWZmaW5pdHkgRGVzaWduZXIgMS4xMC40KQovVGl0bGUgKFVudGl0bGVkLnBkZikKL0NyZWF0aW9uRGF0ZSAoRDoyMDIyMDEwNjE0MDg1OCswOScwMCcpCi9Qcm9kdWNlciAoaUxvdmVQREYpCi9Nb2REYXRlIChEOjIwMjIwMTA2MDUwOTA5WikKPj4KZW5kb2JqCjYgMCBvYmoKPDwKL1NpemUgNwovUm9vdCAxIDAgUgovSW5mbyAzIDAgUgovSUQgWzwyODhCM0VENTAyOEU0MDcyNERBNzNCOUE0Nzk4OUEwQT4gPEY1RkJGNjg4NkVERDZBQUNBNDRCNEZDRjBBRDUxRDlDPl0KL1R5cGUgL1hSZWYKL1cgWzEgMiAyXQovRmlsdGVyIC9GbGF0ZURlY29kZQovSW5kZXggWzAgN10KL0xlbmd0aCAzNgo+PgpzdHJlYW0KeJxjYGD4/5+RUZmBgZHhFZBgDAGxakAEP5BgEmFgAABlRwQJCmVuZHN0cmVhbQplbmRvYmoKc3RhcnR4cmVmCjUzMgolJUVPRgo=";
  function PdfmeGenerator() {
    const [template2, setTemplate] = createSignal({
      basePdf: BLANK_PDF2,
      schemas: [{
        a: {
          type: "text",
          position: {
            x: 0,
            y: 0
          },
          width: 10,
          height: 10
        },
        b: {
          type: "text",
          position: {
            x: 10,
            y: 10
          },
          width: 10,
          height: 10
        },
        c: {
          type: "text",
          position: {
            x: 20,
            y: 20
          },
          width: 10,
          height: 10
        }
      }]
    });
    const [inputs, setInputs] = createSignal([{
      a: "a1",
      b: "c1",
      c: "f1"
    }]);
    async function generatePdf() {
      console.log(template2());
      console.log(inputs());
      const pdf = await generate_default({
        template: template2(),
        inputs: inputs()
      });
      const blob = new Blob([pdf.buffer], {
        type: "application/pdf"
      });
      window.open(URL.createObjectURL(blob));
    }
    return (() => {
      const _el$ = _tmpl$(), _el$2 = _el$.firstChild;
      _el$2.$$click = generatePdf;
      return _el$;
    })();
  }
  var pdfgen_default = PdfmeGenerator;
  delegateEvents(["click"]);

  // src/scripts/jsx/render.jsx
  render(() => createComponent(pdfgen_default, {}), document.getElementById("pdfapp"));
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=render.js.map
