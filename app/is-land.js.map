{
  "version": 3,
  "sources": ["../../node_modules/@11ty/is-land/is-land.js"],
  "sourcesContent": ["class Island extends HTMLElement {\n  static tagName = \"is-land\";\n  static prefix = \"is-land--\";\n  static attr = {\n    template: \"data-island\",\n    ready: \"ready\",\n    defer: \"defer-hydration\",\n  };\n\n  static onceCache = new Map();\n  static onReady = new Map();\n\n  static fallback = {\n    \":not(is-land,:defined,[defer-hydration])\": (readyPromise, node, prefix) => {\n      // remove from document to prevent web component init\n      let cloned = document.createElement(prefix + node.localName);\n      for(let attr of node.getAttributeNames()) {\n        cloned.setAttribute(attr, node.getAttribute(attr));\n      }\n    \n      // Declarative Shadow DOM (with polyfill)\n      let shadowroot = node.shadowRoot;\n      if(!shadowroot) {\n        let tmpl = node.querySelector(\":scope > template:is([shadowrootmode], [shadowroot])\");\n        if(tmpl) {\n          let mode = tmpl.getAttribute(\"shadowrootmode\") || tmpl.getAttribute(\"shadowroot\") || \"closed\";\n          shadowroot = node.attachShadow({ mode }); // default is closed\n          shadowroot.appendChild(tmpl.content.cloneNode(true));\n        }\n      }\n    \n      // Cheers to https://gist.github.com/developit/45c85e9be01e8c3f1a0ec073d600d01e\n      if(shadowroot) {\n        cloned.attachShadow({ mode: shadowroot.mode }).append(...shadowroot.childNodes);\n      }\n    \n      // Keep *same* child nodes to preserve state of children (e.g. details->summary)\n      cloned.append(...node.childNodes);\n      node.replaceWith(cloned);\n    \n      return readyPromise.then(() => {\n        // Restore original children and shadow DOM\n        if(cloned.shadowRoot) {\n          node.shadowRoot.append(...cloned.shadowRoot.childNodes);\n        }\n        node.append(...cloned.childNodes);\n        cloned.replaceWith(node);\n      });\n    }\n  }\n\n  constructor() {\n    super();\n\n    // Internal promises\n    this.ready = new Promise(resolve => {\n      this.readyResolve = resolve;\n    });\n  }\n\n  // any parents of `el` that are <is-land> (with conditions)\n  static getParents(el, stopAt = false) {\n    let nodes = [];\n    while(el) {\n      if(el.matches && el.matches(Island.tagName)) {\n        if(stopAt && el === stopAt) {\n          break;\n        }\n\n        if(Conditions.hasConditions(el)) {\n          nodes.push(el);\n        }\n      }\n      el = el.parentNode;\n    }\n    return nodes;\n  }\n\n  static async ready(el, parents) {\n    if(!parents) {\n      parents = Island.getParents(el);\n    }\n    if(parents.length === 0) {\n      return;\n    }\n    let imports = await Promise.all(parents.map(p => p.wait()));\n    // return innermost module import\n    if(imports.length) {\n      return imports[0];\n    }\n  }\n\n  forceFallback() {\n    if(window.Island) {\n      Object.assign(Island.fallback, window.Island.fallback);\n    }\n\n    for(let selector in Island.fallback) {\n      // Reverse here as a cheap way to get the deepest nodes first\n      let components = Array.from(this.querySelectorAll(selector)).reverse();\n\n      // with thanks to https://gist.github.com/cowboy/938767\n      for(let node of components) {\n        if(!node.isConnected) {\n          continue;\n        }\n\n        let parents = Island.getParents(node);\n        // must be in a leaf island (not nested deep)\n        if(parents.length === 1) {\n          let p = Island.ready(node, parents);\n          Island.fallback[selector](p, node, Island.prefix);\n        }\n      }\n    }\n  }\n\n  wait() {\n    return this.ready;\n  }\n\n  async connectedCallback() {\n    // Only use fallback content with loading conditions\n    if(Conditions.hasConditions(this)) {\n      // Keep fallback content without initializing the components\n      this.forceFallback();\n    }\n\n    await this.hydrate();\n  }\n\n  getTemplates() {\n    return this.querySelectorAll(`template[${Island.attr.template}]`);\n  }\n\n  replaceTemplates(templates) {\n    // replace <template> with the live content\n    for(let node of templates) {\n      // if the template is nested inside another child <is-land> inside, skip\n      if(Island.getParents(node, this).length > 0) {\n        continue;\n      }\n\n      let value = node.getAttribute(Island.attr.template);\n      // get rid of the rest of the content on the island\n      if(value === \"replace\") {\n        let children = Array.from(this.childNodes);\n        for(let child of children) {\n          this.removeChild(child);\n        }\n        this.appendChild(node.content);\n        break;\n      } else {\n        let html = node.innerHTML;\n        if(value === \"once\" && html) {\n          if(Island.onceCache.has(html)) {\n            node.remove();\n            return;\n          }\n\n          Island.onceCache.set(html, true);\n        }\n\n        node.replaceWith(node.content);\n      }\n    }\n  }\n\n  async hydrate() {\n    let conditions = [];\n    if(this.parentNode) {\n      // wait for all parents before hydrating\n      conditions.push(Island.ready(this.parentNode));\n    }\n\n    let attrs = Conditions.getConditions(this);\n    for(let condition in attrs) {\n      if(Conditions.map[condition]) {\n        conditions.push(Conditions.map[condition](attrs[condition], this));\n      }\n    }\n\n    // Loading conditions must finish before dependencies are loaded\n    await Promise.all(conditions);\n\n    this.replaceTemplates(this.getTemplates());\n\n    for(let fn of Island.onReady.values()) {\n      await fn.call(this, Island);\n    }\n\n    this.readyResolve();\n\n    this.setAttribute(Island.attr.ready, \"\");\n\n    // Remove [defer-hydration]\n    this.querySelectorAll(`[${Island.attr.defer}]`).forEach(node => node.removeAttribute(Island.attr.defer));\n  }\n}\n\nclass Conditions {\n  static map = {\n    visible: Conditions.visible,\n    idle: Conditions.idle,\n    interaction: Conditions.interaction,\n    media: Conditions.media,\n    \"save-data\": Conditions.saveData,\n  };\n\n  static hasConditions(node) {\n    return Object.keys(Conditions.getConditions(node)).length > 0;\n  }\n\n  static getConditions(node) {\n    let map = {};\n    for(let key of Object.keys(Conditions.map)) {\n      if(node.hasAttribute(`on:${key}`)) {\n        map[key] = node.getAttribute(`on:${key}`);\n      }\n    }\n\n    return map;\n  }\n\n  static visible(noop, el) {\n    if(!('IntersectionObserver' in window)) {\n      // runs immediately\n      return;\n    }\n\n    return new Promise(resolve => {\n      let observer = new IntersectionObserver(entries => {\n        let [entry] = entries;\n        if(entry.isIntersecting) {\n          observer.unobserve(entry.target);\n          resolve();\n        }\n      });\n\n      observer.observe(el);\n    });\n  }\n\n  // Warning: on:idle is not very useful with other conditions as it may resolve long before.\n  static idle() {\n    let onload = new Promise(resolve => {\n      if(document.readyState !== \"complete\") {\n        window.addEventListener(\"load\", () => resolve(), { once: true });\n      } else {\n        resolve();\n      }\n    });\n\n    if(!(\"requestIdleCallback\" in window)) {\n      // run immediately\n      return onload;\n    }\n\n    // both idle and onload\n    return Promise.all([\n      new Promise(resolve => {\n        requestIdleCallback(() => {\n          resolve();\n        });\n      }),\n      onload,\n    ]);\n  }\n\n  static interaction(eventOverrides, el) {\n    let events = [\"click\", \"touchstart\"];\n    // event overrides e.g. on:interaction=\"mouseenter\"\n    if(eventOverrides) {\n      events = (eventOverrides || \"\").split(\",\").map(entry => entry.trim());\n    }\n\n    return new Promise(resolve => {\n      function resolveFn(e) {\n        resolve();\n\n        // cleanup the other event handlers\n        for(let name of events) {\n          el.removeEventListener(name, resolveFn);\n        }\n      }\n\n      for(let name of events) {\n        el.addEventListener(name, resolveFn, { once: true });\n      }\n    });\n  }\n\n  static media(query) {\n    let mm = {\n      matches: true\n    };\n\n    if(query && (\"matchMedia\" in window)) {\n      mm = window.matchMedia(query);\n    }\n\n    if(mm.matches) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      mm.addListener(e => {\n        if(e.matches) {\n          resolve();\n        }\n      });\n    });\n  }\n\n  static saveData(expects) {\n    // return early if API does not exist\n    if(!(\"connection\" in navigator) || navigator.connection.saveData === (expects !== \"false\")) {\n      return;\n    }\n\n    // dangly promise\n    return new Promise(() => {});\n  }\n}\n\n// Should this auto define? Folks can redefine later using { component } export\nif(\"customElements\" in window) {\n  window.customElements.define(Island.tagName, Island);\n  window.Island = Island;\n}\n\nexport {\n  Island,\n  Island as component, // Backwards compat only: recommend `Island` export\n};\n\n// TODO remove in 4.0\nexport const ready = Island.ready; // Backwards compat only: recommend `Island` export\n"],
  "mappings": "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",
  "names": []
}
