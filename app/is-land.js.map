{
  "version": 3,
  "sources": ["../../node_modules/@11ty/is-land/is-land.js"],
  "sourcesContent": ["class Island extends HTMLElement {\n  static tagName = \"is-land\";\n  static prefix = \"is-land--\";\n  static attr = {\n    autoInitType: \"autoinit\",\n    import: \"import\",\n    template: \"data-island\",\n    ready: \"ready\",\n    defer: \"defer-hydration\",\n  };\n\n  static onceCache = new Map();\n\n  static fallback = {\n    \":not(:defined):not([defer-hydration])\": (readyPromise, node, prefix) => {\n      // remove from document to prevent web component init\n      let cloned = document.createElement(prefix + node.localName);\n      for(let attr of node.getAttributeNames()) {\n        cloned.setAttribute(attr, node.getAttribute(attr));\n      }\n\n      // Declarative Shadow DOM\n      let shadowroot = node.shadowRoot;\n      if(!shadowroot) {\n        // polyfill\n        let tmpl = node.querySelector(\":scope > template:is([shadowrootmode], [shadowroot])\");\n        if(tmpl) {\n          shadowroot = node.attachShadow({ mode: \"open\" });\n          shadowroot.appendChild(tmpl.content.cloneNode(true));\n        }\n      }\n\n      // cheers to https://gist.github.com/developit/45c85e9be01e8c3f1a0ec073d600d01e\n      if(shadowroot) {\n        cloned.attachShadow({ mode: shadowroot.mode }).append(...shadowroot.childNodes);\n      }\n\n      // Keep the *same* child nodes, clicking on a details->summary child should keep the state of that child\n      cloned.append(...node.childNodes);\n      node.replaceWith(cloned);\n\n      return readyPromise.then(() => {\n        // restore children (not cloned), including declarative shadow dom nodes\n        if(cloned.shadowRoot) {\n          node.shadowRoot.append(...cloned.shadowRoot.childNodes);\n        }\n        node.append(...cloned.childNodes);\n        cloned.replaceWith(node);\n      });\n    }\n  };\n\n  static autoinit = {\n    \"petite-vue\": function(library) {\n      library.createApp().mount(this);\n    },\n    \"vue\": function(library) {\n      library.createApp().mount(this);\n    },\n    \"svelte\": function(mod) {\n      new mod.default({ target: this });\n    },\n    \"svelte-ssr\": function(mod) {\n      new mod.default({ target: this, hydrate: true });\n    },\n    \"preact\": function(mod) {\n      mod.default(this);\n    }\n  }\n\n  constructor() {\n    super();\n\n    // Internal promises\n    this.ready = new Promise(resolve => {\n      this.readyResolve = resolve;\n    });\n  }\n\n  // <is-land> parent nodes (that *have* island conditions)\n  static getParents(el, stopAt = false) {\n    let nodes = [];\n    while(el) {\n      if(el.matches && el.matches(Island.tagName)) {\n        if(stopAt && el === stopAt) {\n          break;\n        }\n\n        if(Conditions.hasConditions(el)) {\n          nodes.push(el);\n        }\n      }\n      el = el.parentNode;\n    }\n    return nodes;\n  }\n\n  static async ready(el) {\n    let parents = Island.getParents(el);\n    if(parents.length === 0) {\n      return;\n    }\n\n    let imports = await Promise.all(parents.map(el => el.wait()));\n    // return innermost module import\n    if(imports.length) {\n      return imports[0];\n    }\n  }\n\n  forceFallback() {\n    if(window.Island) {\n      Object.assign(Island.fallback, window.Island.fallback);\n    }\n\n    for(let selector in Island.fallback) {\n      // Reverse here as a cheap way to get the deepest nodes first\n      let components = Array.from(this.querySelectorAll(selector)).reverse();\n\n      // with thanks to https://gist.github.com/cowboy/938767\n      for(let node of components) {\n        // must be connected, must not be an island\n        if(!node.isConnected || node.localName === Island.tagName) {\n          continue;\n        }\n\n        let p = Island.ready(node);\n        Island.fallback[selector](p, node, Island.prefix);\n      }\n    }\n  }\n\n  wait() {\n    return this.ready;\n  }\n\n  async connectedCallback() {\n    // Only use fallback content with loading conditions\n    if(Conditions.hasConditions(this)) {\n      // Keep fallback content without initializing the components\n      this.forceFallback();\n    }\n\n    await this.hydrate();\n  }\n\n  getTemplates() {\n    return this.querySelectorAll(`template[${Island.attr.template}]`);\n  }\n\n  replaceTemplates(templates) {\n    // replace <template> with the live content\n    for(let node of templates) {\n      // if the template is nested inside another child <is-land> inside, skip\n      if(Island.getParents(node, this).length > 0) {\n        continue;\n      }\n\n      let value = node.getAttribute(Island.attr.template);\n      // get rid of the rest of the content on the island\n      if(value === \"replace\") {\n        let children = Array.from(this.childNodes);\n        for(let child of children) {\n          this.removeChild(child);\n        }\n        this.appendChild(node.content);\n        break;\n      } else {\n        let html = node.innerHTML;\n        if(value === \"once\" && html) {\n          if(Island.onceCache.has(html)) {\n            node.remove();\n            return;\n          }\n\n          Island.onceCache.set(html, true);\n        }\n\n        node.replaceWith(node.content);\n      }\n    }\n  }\n\n  async hydrate() {\n    let conditions = [];\n    if(this.parentNode) {\n      // wait for all parents before hydrating\n      conditions.push(Island.ready(this.parentNode));\n    }\n\n    let attrs = Conditions.getConditions(this);\n    for(let condition in attrs) {\n      if(Conditions.map[condition]) {\n        conditions.push(Conditions.map[condition](attrs[condition], this));\n      }\n    }\n\n    // Loading conditions must finish before dependencies are loaded\n    await Promise.all(conditions);\n\n    this.replaceTemplates(this.getTemplates());\n\n    let mod;\n    // [dependency=\"my-component-code.js\"]\n    let importScript = this.getAttribute(Island.attr.import);\n    if(importScript) {\n      // we could resolve import maps here manually but you\u2019d still have to use the full URL in your script\u2019s import anyway\n      mod = await import(importScript);\n    }\n\n    if(mod) {\n      // Use `import=\"\"` for when import maps are available e.g. `import=\"petite-vue\"`\n      let fn = Island.autoinit[this.getAttribute(Island.attr.autoInitType) || importScript];\n\n      if(fn) {\n        await fn.call(this, mod);\n      }\n    }\n\n    this.readyResolve();\n\n    this.setAttribute(Island.attr.ready, \"\");\n\n    // Remove [defer-hydration]\n    this.querySelectorAll(`[${Island.attr.defer}]`).forEach(node => node.removeAttribute(Island.attr.defer));\n  }\n}\n\nclass Conditions {\n  static map = {\n    visible: Conditions.visible,\n    idle: Conditions.idle,\n    interaction: Conditions.interaction,\n    media: Conditions.media,\n    \"save-data\": Conditions.saveData,\n  };\n\n  static hasConditions(node) {\n    return Object.keys(Conditions.getConditions(node)).length > 0;\n  }\n\n  static getConditions(node) {\n    let map = {};\n    for(let key of Object.keys(Conditions.map)) {\n      if(node.hasAttribute(`on:${key}`)) {\n        map[key] = node.getAttribute(`on:${key}`);\n      }\n    }\n\n    return map;\n  }\n\n  static visible(noop, el) {\n    if(!('IntersectionObserver' in window)) {\n      // runs immediately\n      return;\n    }\n\n    return new Promise(resolve => {\n      let observer = new IntersectionObserver(entries => {\n        let [entry] = entries;\n        if(entry.isIntersecting) {\n          observer.unobserve(entry.target);\n          resolve();\n        }\n      });\n\n      observer.observe(el);\n    });\n  }\n\n  // This isn\u2019t very useful with other conditions as periods of idle may\n  // happen before other conditions are satisfied. Would be more useful if waited\n  // for all other conditions to finish.\n  static idle() {\n    let onload = new Promise(resolve => {\n      if(document.readyState !== \"complete\") {\n        window.addEventListener(\"load\", () => resolve(), { once: true });\n      } else {\n        resolve();\n      }\n    });\n\n    if(!(\"requestIdleCallback\" in window)) {\n      // run immediately\n      return onload;\n    }\n\n    // both idle and onload\n    return Promise.all([\n      new Promise(resolve => {\n        requestIdleCallback(() => {\n          resolve();\n        });\n      }),\n      onload,\n    ]);\n  }\n\n  static interaction(eventOverrides, el) {\n    let events = [\"click\", \"touchstart\"];\n    // event overrides e.g. on:interaction=\"mouseenter\"\n    if(eventOverrides) {\n      events = (eventOverrides || \"\").split(\",\").map(entry => entry.trim());\n    }\n\n    return new Promise(resolve => {\n      function resolveFn(e) {\n        resolve();\n\n        // cleanup the other event handlers\n        for(let name of events) {\n          el.removeEventListener(name, resolveFn);\n        }\n      }\n\n      for(let name of events) {\n        el.addEventListener(name, resolveFn, { once: true });\n      }\n    });\n  }\n\n  static media(query) {\n    let mm = {\n      matches: true\n    };\n\n    if(query && (\"matchMedia\" in window)) {\n      mm = window.matchMedia(query);\n    }\n\n    if(mm.matches) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      mm.addListener(e => {\n        if(e.matches) {\n          resolve();\n        }\n      });\n    });\n  }\n\n  static saveData(expects) {\n    // return early if API does not exist\n    if(!(\"connection\" in navigator) || navigator.connection.saveData === (expects !== \"false\")) {\n      return Promise.resolve();\n    }\n\n    // dangly promise\n    return new Promise(() => {});\n  }\n}\n\n// Should this auto define? Folks can redefine later using { component } export\nif(\"customElements\" in window) {\n  window.customElements.define(Island.tagName, Island);\n  window.Island = Island;\n}\n\nexport {\n  Island,\n  Island as component, // Backwards compat only: recommend `Island` export\n};\n\nexport const ready = Island.ready; // Backwards compat only: recommend `Island` export\n"],
  "mappings": "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",
  "names": ["el"]
}
