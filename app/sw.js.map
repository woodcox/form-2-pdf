{
  "version": 3,
  "sources": ["../../src/scripts/js/sw.js"],
  "sourcesContent": ["/**\r\n * @define {Object}\r\n */\r\nvar caches;\r\n\r\n/**\r\n * @define {Object}\r\n */\r\nvar self;\r\n\r\n// Activate event: Clean up old caches\r\n// Define the cache name\r\nconst cacheName = 'your-app-cache-v1';\r\n\r\n// List of assets to cache\r\nconst assetsToCache = [\r\n  '/',\r\n  '/index.html',\r\n  \"{{ '/app/style.css' | hash }}\",\r\n  '/path/to/your/css/styles.css',\r\n  '/path/to/your/js/script.js',\r\n  'https://via.placeholder.com/128x128?text=App+Icon',\r\n  'https://via.placeholder.com/192x192?text=App+Icon',\r\n  'https://via.placeholder.com/512x512?text=App+Icon',\r\n  // Add a wildcard to match all pages (*)\r\n  '/*'\r\n];\r\n\r\n// Install event: Cache the essential assets\r\nself.addEventListener('install', (event) => {\r\n  event.waitUntil(\r\n    caches.open(cacheName)\r\n      .then(cache => cache.addAll(assetsToCache))\r\n      .then(() => self.skipWaiting())\r\n  );\r\n});\r\n\r\n// Activate event: Clean up old caches\r\nself.addEventListener('activate', (event) => {\r\n  event.waitUntil(\r\n    caches.keys()\r\n      .then(cacheNames => {\r\n        return Promise.all(\r\n          cacheNames.filter(name => name !== cacheName)\r\n            .map(name => caches.delete(name))\r\n        );\r\n      })\r\n      .then(() => self.clients.claim())\r\n  );\r\n});\r\n\r\n// Fetch event: Serve assets from cache, and update cache if necessary\r\nself.addEventListener('fetch', (event) => {\r\n  event.respondWith(\r\n    caches.match(event.request)\r\n      .then(response => {\r\n        if (response) {\r\n          return response;\r\n        }\r\n\r\n        // Clone the request because it can only be consumed once\r\n        const fetchRequest = event.request.clone();\r\n\r\n        return fetch(fetchRequest)\r\n          .then(response => {\r\n            if (!response || response.status !== 200 || response.type !== 'basic') {\r\n              return response;\r\n            }\r\n\r\n            // Clone the response because it can only be consumed once\r\n            const responseToCache = response.clone();\r\n\r\n            caches.open(cacheName)\r\n              .then(cache => cache.put(event.request, responseToCache));\r\n\r\n            return response;\r\n          });\r\n      })\r\n  );\r\n});\r\n"],
  "mappings": ";;AAGA,MAAI;AAKJ,MAAI;AAIJ,MAAM,YAAY;AAGlB,MAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,EACF;AAGA,OAAK,iBAAiB,WAAW,CAAC,UAAU;AAC1C,UAAM;AAAA,MACJ,OAAO,KAAK,SAAS,EAClB,KAAK,WAAS,MAAM,OAAO,aAAa,CAAC,EACzC,KAAK,MAAM,KAAK,YAAY,CAAC;AAAA,IAClC;AAAA,EACF,CAAC;AAGD,OAAK,iBAAiB,YAAY,CAAC,UAAU;AAC3C,UAAM;AAAA,MACJ,OAAO,KAAK,EACT,KAAK,gBAAc;AAClB,eAAO,QAAQ;AAAA,UACb,WAAW,OAAO,UAAQ,SAAS,SAAS,EACzC,IAAI,UAAQ,OAAO,OAAO,IAAI,CAAC;AAAA,QACpC;AAAA,MACF,CAAC,EACA,KAAK,MAAM,KAAK,QAAQ,MAAM,CAAC;AAAA,IACpC;AAAA,EACF,CAAC;AAGD,OAAK,iBAAiB,SAAS,CAAC,UAAU;AACxC,UAAM;AAAA,MACJ,OAAO,MAAM,MAAM,OAAO,EACvB,KAAK,cAAY;AAChB,YAAI,UAAU;AACZ,iBAAO;AAAA,QACT;AAGA,cAAM,eAAe,MAAM,QAAQ,MAAM;AAEzC,eAAO,MAAM,YAAY,EACtB,KAAK,CAAAA,cAAY;AAChB,cAAI,CAACA,aAAYA,UAAS,WAAW,OAAOA,UAAS,SAAS,SAAS;AACrE,mBAAOA;AAAA,UACT;AAGA,gBAAM,kBAAkBA,UAAS,MAAM;AAEvC,iBAAO,KAAK,SAAS,EAClB,KAAK,WAAS,MAAM,IAAI,MAAM,SAAS,eAAe,CAAC;AAE1D,iBAAOA;AAAA,QACT,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AAAA,EACF,CAAC;",
  "names": ["response"]
}
